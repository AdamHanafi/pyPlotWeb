/*! globalize - v0.1.1 - 2013-12-13
* https://github.com/jquery/globalize
* Copyright 2013 ; Licensed MIT */
!function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z;c=function(a){return new c.prototype.init(a)},"undefined"!=typeof require&&"undefined"!=typeof exports&&"undefined"!=typeof module?module.exports=c:a.Globalize=c,c.cultures={},c.prototype={constructor:c,init:function(a){return this.cultures=c.cultures,this.cultureSelector=a,this}},c.prototype.init.prototype=c.prototype,c.cultures["default"]={name:"en",englishName:"English",nativeName:"English",isRTL:!1,language:"en",numberFormat:{pattern:["-n"],decimals:2,",":",",".":".",groupSizes:[3],"+":"+","-":"-",NaN:"NaN",negativeInfinity:"-Infinity",positiveInfinity:"Infinity",percent:{pattern:["-n %","n %"],decimals:2,groupSizes:[3],",":",",".":".",symbol:"%"},currency:{pattern:["($n)","$n"],decimals:2,groupSizes:[3],",":",",".":".",symbol:"$"}},calendars:{standard:{name:"Gregorian_USEnglish","/":"/",":":":",firstDay:0,days:{names:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],namesAbbr:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],namesShort:["Su","Mo","Tu","We","Th","Fr","Sa"]},months:{names:["January","February","March","April","May","June","July","August","September","October","November","December",""],namesAbbr:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec",""]},AM:["AM","am","AM"],PM:["PM","pm","PM"],eras:[{name:"A.D.",start:null,offset:0}],twoDigitYearMax:2029,patterns:{d:"M/d/yyyy",D:"dddd, MMMM dd, yyyy",t:"h:mm tt",T:"h:mm:ss tt",f:"dddd, MMMM dd, yyyy h:mm tt",F:"dddd, MMMM dd, yyyy h:mm:ss tt",M:"MMMM dd",Y:"yyyy MMMM",S:"yyyy'-'MM'-'dd'T'HH':'mm':'ss"}}},messages:{}},c.cultures["default"].calendar=c.cultures["default"].calendars.standard,c.cultures.en=c.cultures["default"],c.cultureSelector="en",d=/^0x[a-f0-9]+$/i,e=/^[+\-]?infinity$/i,f=/^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/,g=/^\s+|\s+$/g,h=function(a,b){if(a.indexOf)return a.indexOf(b);for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},i=function(a,b){return a.substr(a.length-b.length)===b},j=function(){var a,c,d,e,f,g,h=arguments[0]||{},i=1,n=arguments.length,o=!1;for("boolean"==typeof h&&(o=h,h=arguments[1]||{},i=2),"object"==typeof h||l(h)||(h={});n>i;i++)if(null!=(a=arguments[i]))for(c in a)d=h[c],e=a[c],h!==e&&(o&&e&&(m(e)||(f=k(e)))?(f?(f=!1,g=d&&k(d)?d:[]):g=d&&m(d)?d:{},h[c]=j(o,g,e)):e!==b&&(h[c]=e));return h},k=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},l=function(a){return"[object Function]"===Object.prototype.toString.call(a)},m=function(a){return"[object Object]"===Object.prototype.toString.call(a)},n=function(a,b){return 0===a.indexOf(b)},o=function(a){return(a+"").replace(g,"")},p=function(a){return isNaN(a)?0/0:Math[0>a?"ceil":"floor"](a)},q=function(a,b,c){var d;for(d=a.length;b>d;d+=1)a=c?"0"+a:a+"0";return a},r=function(a,b){for(var c=0,d=!1,e=0,f=a.length;f>e;e++){var g=a.charAt(e);switch(g){case"'":d?b.push("'"):c++,d=!1;break;case"\\":d&&b.push("\\"),d=!d;break;default:b.push(g),d=!1}}return c},s=function(a,b){b=b||"F";var c,d=a.patterns,e=b.length;if(1===e){if(c=d[b],!c)throw"Invalid date format string '"+b+"'.";b=c}else 2===e&&"%"===b.charAt(0)&&(b=b.charAt(1));return b},t=function(a,b,c){function d(a,b){var c,d=a+"";return b>1&&d.length<b?(c=u[b-2]+d,c.substr(c.length-b,b)):c=d}function e(){return o||p?o:(o=y.test(b),p=!0,o)}function f(a,b){if(q)return q[b];switch(b){case 0:return a.getFullYear();case 1:return a.getMonth();case 2:return a.getDate();default:throw"Invalid part value "+b}}var g,h=c.calendar,i=h.convert;if(!b||!b.length||"i"===b){if(c&&c.name.length)if(i)g=t(a,h.patterns.F,c);else{var j=new Date(a.getTime()),k=w(a,h.eras);j.setFullYear(x(a,h,k)),g=j.toLocaleString()}else g=a.toString();return g}var l=h.eras,m="s"===b;b=s(h,b),g=[];var n,o,p,q,u=["0","00","000"],y=/([^d]|^)(d|dd)([^d]|$)/g,z=0,A=v();for(!m&&i&&(q=i.fromGregorian(a));;){var B=A.lastIndex,C=A.exec(b),D=b.slice(B,C?C.index:b.length);if(z+=r(D,g),!C)break;if(z%2)g.push(C[0]);else{var E=C[0],F=E.length;switch(E){case"ddd":case"dddd":var G=3===F?h.days.namesAbbr:h.days.names;g.push(G[a.getDay()]);break;case"d":case"dd":o=!0,g.push(d(f(a,2),F));break;case"MMM":case"MMMM":var H=f(a,1);g.push(h.monthsGenitive&&e()?h.monthsGenitive[3===F?"namesAbbr":"names"][H]:h.months[3===F?"namesAbbr":"names"][H]);break;case"M":case"MM":g.push(d(f(a,1)+1,F));break;case"y":case"yy":case"yyyy":H=q?q[0]:x(a,h,w(a,l),m),4>F&&(H%=100),g.push(d(H,F));break;case"h":case"hh":n=a.getHours()%12,0===n&&(n=12),g.push(d(n,F));break;case"H":case"HH":g.push(d(a.getHours(),F));break;case"m":case"mm":g.push(d(a.getMinutes(),F));break;case"s":case"ss":g.push(d(a.getSeconds(),F));break;case"t":case"tt":H=a.getHours()<12?h.AM?h.AM[0]:" ":h.PM?h.PM[0]:" ",g.push(1===F?H.charAt(0):H);break;case"f":case"ff":case"fff":g.push(d(a.getMilliseconds(),3).substr(0,F));break;case"z":case"zz":n=a.getTimezoneOffset()/60,g.push((0>=n?"+":"-")+d(Math.floor(Math.abs(n)),F));break;case"zzz":n=a.getTimezoneOffset()/60,g.push((0>=n?"+":"-")+d(Math.floor(Math.abs(n)),2)+":"+d(Math.abs(a.getTimezoneOffset()%60),2));break;case"g":case"gg":h.eras&&g.push(h.eras[w(a,l)].name);break;case"/":g.push(h["/"]);break;default:throw"Invalid date format pattern '"+E+"'."}}}return g.join("")},function(){var a;a=function(a,b,c){var d=c.groupSizes,e=d[0],f=1,g=Math.pow(10,b),h=Math.round(a*g)/g;isFinite(h)||(h=a),a=h;var i=a+"",j="",k=i.split(/e/i),l=k.length>1?parseInt(k[1],10):0;i=k[0],k=i.split("."),i=k[0],j=k.length>1?k[1]:"",l>0?(j=q(j,l,!1),i+=j.slice(0,l),j=j.substr(l)):0>l&&(l=-l,i=q(i,l+1,!0),j=i.slice(-l,i.length)+j,i=i.slice(0,-l)),j=b>0?c["."]+(j.length>b?j.slice(0,b):q(j,b)):"";for(var m=i.length-1,n=c[","],o="";m>=0;){if(0===e||e>m)return i.slice(0,m+1)+(o.length?n+o+j:j);o=i.slice(m-e+1,m+1)+(o.length?n+o:""),m-=e,f<d.length&&(e=d[f],f++)}return i.slice(0,m+1)+n+o+j},u=function(b,c,d){if(!isFinite(b))return 1/0===b?d.numberFormat.positiveInfinity:b===-1/0?d.numberFormat.negativeInfinity:d.numberFormat.NaN;if(!c||"i"===c)return d.name.length?b.toLocaleString():b.toString();c=c||"D";var e,f=d.numberFormat,g=Math.abs(b),h=-1;c.length>1&&(h=parseInt(c.slice(1),10));var i,j=c.charAt(0).toUpperCase();switch(j){case"D":e="n",g=p(g),-1!==h&&(g=q(""+g,h,!0)),0>b&&(g="-"+g);break;case"N":i=f;case"C":i=i||f.currency;case"P":i=i||f.percent,e=0>b?i.pattern[0]:i.pattern[1]||"n",-1===h&&(h=i.decimals),g=a(g*("P"===j?100:1),h,i);break;default:throw"Bad number format specifier: "+j}for(var k=/n|\$|-|%/g,l="";;){var m=k.lastIndex,n=k.exec(e);if(l+=e.slice(m,n?n.index:e.length),!n)break;switch(n[0]){case"n":l+=g;break;case"$":l+=f.currency.symbol;break;case"-":/[1-9]/.test(g)&&(l+=f["-"]);break;case"%":l+=f.percent.symbol}}return l}}(),v=function(){return/\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g},w=function(a,b){if(!b)return 0;for(var c,d=a.getTime(),e=0,f=b.length;f>e;e++)if(c=b[e].start,null===c||d>=c)return e;return 0},x=function(a,b,c,d){var e=a.getFullYear();return!d&&b.eras&&(e-=b.eras[c].offset),e},function(){var a,b,c,d,e,f,g;a=function(a,b){if(100>b){var c=new Date,d=w(c),e=x(c,a,d),f=a.twoDigitYearMax;f="string"==typeof f?(new Date).getFullYear()%100+parseInt(f,10):f,b+=e-e%100,b>f&&(b-=100)}return b},b=function(a,b,c){var d,e=a.days,i=a._upperDays;return i||(a._upperDays=i=[g(e.names),g(e.namesAbbr),g(e.namesShort)]),b=f(b),c?(d=h(i[1],b),-1===d&&(d=h(i[2],b))):d=h(i[0],b),d},c=function(a,b,c){var d=a.months,e=a.monthsGenitive||a.months,i=a._upperMonths,j=a._upperMonthsGen;i||(a._upperMonths=i=[g(d.names),g(d.namesAbbr)],a._upperMonthsGen=j=[g(e.names),g(e.namesAbbr)]),b=f(b);var k=h(c?i[1]:i[0],b);return 0>k&&(k=h(c?j[1]:j[0],b)),k},d=function(a,b){var c=a._parseRegExp;if(c){var d=c[b];if(d)return d}else a._parseRegExp=c={};for(var e,f=s(a,b).replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g,"\\\\$1"),g=["^"],h=[],i=0,j=0,k=v();null!==(e=k.exec(f));){var l=f.slice(i,e.index);if(i=k.lastIndex,j+=r(l,g),j%2)g.push(e[0]);else{var m,n=e[0],o=n.length;switch(n){case"dddd":case"ddd":case"MMMM":case"MMM":case"gg":case"g":m="(\\D+)";break;case"tt":case"t":m="(\\D*)";break;case"yyyy":case"fff":case"ff":case"f":m="(\\d{"+o+"})";break;case"dd":case"d":case"MM":case"M":case"yy":case"y":case"HH":case"H":case"hh":case"h":case"mm":case"m":case"ss":case"s":m="(\\d\\d?)";break;case"zzz":m="([+-]?\\d\\d?:\\d{2})";break;case"zz":case"z":m="([+-]?\\d\\d?)";break;case"/":m="(\\/)";break;default:throw"Invalid date format pattern '"+n+"'."}m&&g.push(m),h.push(e[0])}}r(f.slice(i),g),g.push("$");var p=g.join("").replace(/\s+/g,"\\s+"),q={regExp:p,groups:h};return c[b]=q},e=function(a,b,c){return b>a||a>c},f=function(a){return a.split("\xa0").join(" ").toUpperCase()},g=function(a){for(var b=[],c=0,d=a.length;d>c;c++)b[c]=f(a[c]);return b},y=function(f,g,h){f=o(f);var i=h.calendar,j=d(i,g),k=new RegExp(j.regExp).exec(f);if(null===k)return null;for(var l,m=j.groups,p=null,q=null,r=null,s=null,t=null,u=0,v=0,w=0,x=0,y=null,z=!1,A=0,B=m.length;B>A;A++){var C=k[A+1];if(C){var D=m[A],E=D.length,F=parseInt(C,10);switch(D){case"dd":case"d":if(s=F,e(s,1,31))return null;break;case"MMM":case"MMMM":if(r=c(i,C,3===E),e(r,0,11))return null;break;case"M":case"MM":if(r=F-1,e(r,0,11))return null;break;case"y":case"yy":case"yyyy":if(q=4>E?a(i,F):F,e(q,0,9999))return null;break;case"h":case"hh":if(u=F,12===u&&(u=0),e(u,0,11))return null;break;case"H":case"HH":if(u=F,e(u,0,23))return null;break;case"m":case"mm":if(v=F,e(v,0,59))return null;break;case"s":case"ss":if(w=F,e(w,0,59))return null;break;case"tt":case"t":if(z=i.PM&&(C===i.PM[0]||C===i.PM[1]||C===i.PM[2]),!z&&(!i.AM||C!==i.AM[0]&&C!==i.AM[1]&&C!==i.AM[2]))return null;break;case"f":case"ff":case"fff":if(x=F*Math.pow(10,3-E),e(x,0,999))return null;break;case"ddd":case"dddd":if(t=b(i,C,3===E),e(t,0,6))return null;break;case"zzz":var G=C.split(/:/);if(2!==G.length)return null;if(l=parseInt(G[0],10),e(l,-12,13))return null;var H=parseInt(G[1],10);if(e(H,0,59))return null;y=60*l+(n(C,"-")?-H:H);break;case"z":case"zz":if(l=F,e(l,-12,13))return null;y=60*l;break;case"g":case"gg":var I=C;if(!I||!i.eras)return null;I=o(I.toLowerCase());for(var J=0,K=i.eras.length;K>J;J++)if(I===i.eras[J].name.toLowerCase()){p=J;break}if(null===p)return null}}}var L,M=new Date,N=i.convert;if(L=N?N.fromGregorian(M)[0]:M.getFullYear(),null===q?q=L:i.eras&&(q+=i.eras[p||0].offset),null===r&&(r=0),null===s&&(s=1),N){if(M=N.toGregorian(q,r,s),null===M)return null}else{if(M.setFullYear(q,r,s),M.getDate()!==s)return null;if(null!==t&&M.getDay()!==t)return null}if(z&&12>u&&(u+=12),M.setHours(u,v,w,x),null!==y){var O=M.getMinutes()-(y+M.getTimezoneOffset());M.setHours(M.getHours()+parseInt(O/60,10),O%60)}return M}}(),z=function(a,b,c){var d,e=b["-"],f=b["+"];switch(c){case"n -":e=" "+e,f=" "+f;case"n-":i(a,e)?d=["-",a.substr(0,a.length-e.length)]:i(a,f)&&(d=["+",a.substr(0,a.length-f.length)]);break;case"- n":e+=" ",f+=" ";case"-n":n(a,e)?d=["-",a.substr(e.length)]:n(a,f)&&(d=["+",a.substr(f.length)]);break;case"(n)":n(a,"(")&&i(a,")")&&(d=["-",a.substr(1,a.length-2)])}return d||["",a]},c.prototype.findClosestCulture=function(a){return c.findClosestCulture.call(this,a)},c.prototype.format=function(a,b,d){return c.format.call(this,a,b,d)},c.prototype.localize=function(a,b){return c.localize.call(this,a,b)},c.prototype.parseInt=function(a,b,d){return c.parseInt.call(this,a,b,d)},c.prototype.parseFloat=function(a,b,d){return c.parseFloat.call(this,a,b,d)},c.prototype.culture=function(a){return c.culture.call(this,a)},c.addCultureInfo=function(a,b,c){var d={},e=!1;"string"!=typeof a?(c=a,a=this.culture().name,d=this.cultures[a]):"string"!=typeof b?(c=b,e=null==this.cultures[a],d=this.cultures[a]||this.cultures["default"]):(e=!0,d=this.cultures[b]),this.cultures[a]=j(!0,{},d,c),e&&(this.cultures[a].calendar=this.cultures[a].calendars.standard)},c.findClosestCulture=function(a){var b;if(!a)return this.findClosestCulture(this.cultureSelector)||this.cultures["default"];if("string"==typeof a&&(a=a.split(",")),k(a)){var c,d,e=this.cultures,f=a,g=f.length,h=[];for(d=0;g>d;d++){a=o(f[d]);var i,j=a.split(";");c=o(j[0]),1===j.length?i=1:(a=o(j[1]),0===a.indexOf("q=")?(a=a.substr(2),i=parseFloat(a),i=isNaN(i)?0:i):i=1),h.push({lang:c,pri:i})}for(h.sort(function(a,b){return a.pri<b.pri?1:a.pri>b.pri?-1:0}),d=0;g>d;d++)if(c=h[d].lang,b=e[c])return b;for(d=0;g>d;d++)for(c=h[d].lang;;){var l=c.lastIndexOf("-");if(-1===l)break;if(c=c.substr(0,l),b=e[c])return b}for(d=0;g>d;d++){c=h[d].lang;for(var m in e){var n=e[m];if(n.language===c)return n}}}else if("object"==typeof a)return a;return b||null},c.format=function(a,b,c){var d=this.findClosestCulture(c);return a instanceof Date?a=t(a,b,d):"number"==typeof a&&(a=u(a,b,d)),a},c.localize=function(a,b){return this.findClosestCulture(b).messages[a]||this.cultures["default"].messages[a]},c.parseDate=function(a,b,c){c=this.findClosestCulture(c);var d,e,f;if(b){if("string"==typeof b&&(b=[b]),b.length)for(var g=0,h=b.length;h>g;g++){var i=b[g];if(i&&(d=y(a,i,c)))break}}else{f=c.calendar.patterns;for(e in f)if(d=y(a,f[e],c))break}return d||null},c.parseInt=function(a,b,d){return p(c.parseFloat(a,b,d))},c.parseFloat=function(a,b,c){"number"!=typeof b&&(c=b,b=10);var g=this.findClosestCulture(c),h=0/0,i=g.numberFormat;if(a.indexOf(g.numberFormat.currency.symbol)>-1&&(a=a.replace(g.numberFormat.currency.symbol,""),a=a.replace(g.numberFormat.currency["."],g.numberFormat["."])),a.indexOf(g.numberFormat.percent.symbol)>-1&&(a=a.replace(g.numberFormat.percent.symbol,"")),a=a.replace(/ /g,""),e.test(a))h=parseFloat(a);else if(!b&&d.test(a))h=parseInt(a,16);else{var j=z(a,i,i.pattern[0]),k=j[0],l=j[1];""===k&&"(n)"!==i.pattern[0]&&(j=z(a,i,"(n)"),k=j[0],l=j[1]),""===k&&"-n"!==i.pattern[0]&&(j=z(a,i,"-n"),k=j[0],l=j[1]),k=k||"+";var m,n,o=l.indexOf("e");0>o&&(o=l.indexOf("E")),0>o?(n=l,m=null):(n=l.substr(0,o),m=l.substr(o+1));var p,q,r=i["."],s=n.indexOf(r);0>s?(p=n,q=null):(p=n.substr(0,s),q=n.substr(s+r.length));var t=i[","];p=p.split(t).join("");var u=t.replace(/\u00A0/g," ");t!==u&&(p=p.split(u).join(""));var v=k+p;if(null!==q&&(v+="."+q),null!==m){var w=z(m,i,"-n");v+="e"+(w[0]||"+")+w[1]}f.test(v)&&(h=parseFloat(v))}return h},c.culture=function(a){return"undefined"!=typeof a&&(this.cultureSelector=a),this.findClosestCulture(a)||this.cultures["default"]}}(this); 

 
 var __extends=this.__extends||function(e,t){function n(){this.constructor=e}n.prototype=t.prototype,e.prototype=new n},wijmo;(function(e){var t=jQuery,n=function(){function e(){}return e.autoMobilize=!0,e.wijCSS={widget:"ui-widget",overlay:"ui-widget-overlay",content:"ui-widget-content",header:"ui-widget-header",stateDisabled:"ui-state-disabled",stateFocus:"ui-state-focus",stateActive:"ui-state-active",stateDefault:"ui-state-default",stateHighlight:"ui-state-highlight",stateHover:"ui-state-hover",stateChecked:"ui-state-checked",stateError:"ui-state-error",getState:function(e){return e=e.charAt(0).toUpperCase()+e.substr(1),t.wijmo.wijCSS["state"+e]},icon:"ui-icon",iconCheck:"ui-icon-check",iconRadioOn:"ui-icon-radio-on",iconRadioOff:"ui-icon-radio-off",iconClose:"ui-icon-close",iconArrow4Diag:"ui-icon-arrow-4-diag",iconNewWin:"ui-icon-newwin",iconVGripSolid:"ui-icon-grip-solid-vertical",iconHGripSolid:"ui-icon-grip-solid-horizontal",iconPlay:"ui-icon-play",iconPause:"ui-icon-pause",iconStop:"ui-icon-stop",iconArrowUp:"ui-icon-triangle-1-n",iconArrowRight:"ui-icon-triangle-1-e",iconArrowDown:"ui-icon-triangle-1-s",iconArrowLeft:"ui-icon-triangle-1-w",iconArrowRightDown:"ui-icon-triangle-1-se",iconArrowThickDown:"ui-icon-arrowthick-1-s glyphicon glyphicon-arrow-down",iconArrowThickUp:"ui-icon-arrowthick-1-n glyphicon glyphicon-arrow-up",iconCaratUp:"ui-icon-carat-1-n",iconCaratRight:"ui-icon-carat-1-e",iconCaratDown:"ui-icon-carat-1-s",iconCaratLeft:"ui-icon-carat-1-w",iconClock:"ui-icon-clock glyphicon glyphicon-time",iconPencil:"ui-icon-pencil glyphicon glyphicon-pencil",iconSeekFirst:"ui-icon-seek-first",iconSeekEnd:"ui-icon-seek-end",iconSeekNext:"ui-icon-seek-next",iconSeekPrev:"ui-icon-seek-prev",iconPrint:"ui-icon-print",iconDisk:"ui-icon-disk",iconSeekStart:"ui-icon-seek-start",iconFullScreen:"ui-icon-newwin",iconContinousView:"ui-icon-carat-2-n-s",iconZoomIn:"ui-icon-zoomin",iconZoomOut:"ui-icon-zoomout",iconBookmark:"ui-icon-bookmark",iconSearch:"ui-icon-search",iconImage:"ui-icon-image",inputSpinnerLeft:"ui-input-spinner-left",inputSpinnerRight:"ui-input-spinner-right",inputTriggerLeft:"ui-input-trigger-left",inputTriggerRight:"ui-input-trigger-right",inputSpinnerTriggerLeft:"ui-input-spinner-trigger-left",inputSpinnerTriggerRight:"ui-input-spinner-trigger-right",cornerAll:"ui-corner-all",cornerLeft:"ui-corner-left",cornerRight:"ui-corner-right",cornerBottom:"ui-corner-bottom",cornerBL:"ui-corner-bl",cornerBR:"ui-corner-br",cornerTop:"ui-corner-top",cornerTL:"ui-corner-tl",cornerTR:"ui-corner-tr",helperClearFix:"ui-helper-clearfix",helperReset:"ui-helper-reset",helperHidden:"ui-helper-hidden",priorityPrimary:"ui-priority-primary",prioritySecondary:"ui-priority-secondary",button:"ui-button",buttonText:"ui-button-text",buttonTextOnly:"ui-button-text-only",tabs:"ui-tabs",tabsTop:"ui-tabs-top",tabsBottom:"ui-tabs-bottom",tabsLeft:"ui-tabs-left",tabsRight:"ui-tabs-right",tabsLoading:"ui-tabs-loading",tabsActive:"ui-tabs-active",tabsPanel:"ui-tabs-panel",tabsNav:"ui-tabs-nav",tabsHide:"ui-tabs-hide",tabsCollapsible:"ui-tabs-collapsible",activeMenuitem:"ui-active-menuitem"},e.wijMobileCSS={content:"ui-content",header:"ui-header",overlay:"ui-overlay",stateDisabled:"ui-state-disabled",stateFocus:"ui-focus",stateActive:"ui-btn-active",stateDefault:"ui-btn ui-btn-a",icon:"ui-icon ui-btn-icon-notext",iconArrowUp:"ui-icon-carat-u",iconArrowRight:"ui-icon-carat-r",iconArrowDown:"ui-icon-carat-d",iconArrowLeft:"ui-icon-carat-l",iconArrowRightDown:"ui-icon-carat-d",iconSeekFirst:"ui-icon-carat-l",iconSeekEnd:"ui-icon-carat-r",iconSeekNext:"ui-icon-carat-r",iconSeekPrev:"ui-icon-carat-l",iconClose:"ui-icon-delete",iconStop:"ui-icon-grid",iconCheck:"ui-icon-check"},e.wijMobileThemePrefix=["ui-bar","ui-body","ui-overlay","ui-btn"],e.registerWidget=function(n,r,i,s){var o="wijmo."+n,u;typeof i=="function"&&(u=i,i=null);if(i===null||i===undefined)i=t.extend(!0,{},r),r=t.wijmo.widget;i.options=i.options||{},i.options.initSelector=i.options.initSelector||":jqmData(role='"+n+"')",i.initSelector=i.initSelector==null?i.options.initSelector:i.initSelector+i.options.initSelector,t.mobile&&i.options&&i.options.wijMobileCSS&&(i.options.wijCSS=i.options.wijCSS||{},t.extend(i.options.wijCSS,i.options.wijMobileCSS)),t.widget(o,r,i),u&&u.call()},e.addThemeToMobileCSS=function(r,i){t.each(i,function(n,s){typeof s=="string"?t.each(e.wijMobileThemePrefix,function(e,t){var o=new RegExp("\\b"+t);o.test(s)&&(i[n]=s+" "+t+"-"+r)}):e.addThemeToMobileCSS(r,s)})},e}();t.wijmo=n;var r=function(){function e(){}return e.prototype.destroy=function(){},e.prototype._setOption=function(e,t){},e.prototype._create=function(){},e.prototype._init=function(){},e.prototype.widget=function(){return this.element},e}();e.JQueryUIWidget=r,r.prototype.options={wijCSS:t.wijmo.wijCSS},r.prototype.destroy=function(){t.Widget.prototype.destroy.apply(this,arguments)},r.prototype._setOption=function(e,n){t.Widget.prototype._setOption.apply(this,arguments)},r.prototype._create=function(){t.Widget.prototype._create.apply(this,arguments)},r.prototype._init=function(){t.Widget.prototype._init.apply(this,arguments)};var i=function(e){function t(){e.apply(this,arguments)}return __extends(t,e),t}(r);e.JQueryMobileWidget=i,t(window.document).trigger("wijmoinit");var s=function(e){function n(){e.apply(this,arguments),this._widgetCreated=!1}return __extends(n,e),n.prototype._baseWidget=function(){return this._isMobile?t.mobile.widget:t.Widget},n.prototype._createWidget=function(e,n){this._widgetCreated=!0,this._syncEventPrefix&&(this.widgetEventPrefix=this.widgetName),window.wijmoApplyWijTouchUtilEvents&&(t=window.wijmoApplyWijTouchUtilEvents(t)),this._baseWidget().prototype._createWidget.apply(this,arguments)},n.prototype._create=function(){this._baseWidget().prototype._create.apply(this,arguments)},n.prototype._init=function(){this._baseWidget().prototype._init.apply(this,arguments)},n.prototype.destroy=function(){this._baseWidget().prototype.destroy.apply(this,arguments)},n.prototype._setOption=function(e,t){this._baseWidget().prototype._setOption.apply(this,arguments),e==="disabled"&&t&&this._isMobile&&this.element.removeClass("ui-state-disabled").addClass(this.options.wijCSS.stateDisabled)},n}(i);e.wijmoWidget=s,s.prototype._syncEventPrefix=!0,s.prototype._isMobile=!1,t.mobile!=null&&t.wijmo.autoMobilize===!0?(t.extend(!0,s.prototype.options.wijCSS,t.wijmo.wijMobileCSS),s.prototype._isMobile=!0,s.prototype.options=t.extend(!0,{},s.prototype.options,s.prototype._baseWidget().prototype.options),s.prototype._getCreateOptions=function(){var e=this.element,n,r=r=function(e){if(typeof e=="undefined")return{};if(e===null)return{};var n=/(?:(?:\{[\n\r\t\s]*(.+?)\s*\:[\n\r\t\s]*)|(?:,[\n\r\t\s]*(.+?)\s*\:[\n\r\t\s]*))('(.*?[^\\])')?/gi,r=/\[.*?(?=[\]\[])|[\]\[].*?(?=[\]])/gi,i=e.replace(n,function(e,t,n,r){var i,s=/[\n\r\t\s]*['"]?([^\{,\s]+?)['"]?\s*:[\n\r\t\s]*/i,o=/\:[\n\r\t\s]*(?:'(.*)')?/i;return i=e.replace(s,'"$1":'),r?i.replace(o,':"$1"'):i}).replace(r,function(e){var t=/'(.*?[^\\])'/g;return e.replace(t,'"$1"')});return t.parseJSON(i)},i=r(e.attr("data-"+t.mobile.nsNormalize("options"))),s;return n=t.mobile.widget.prototype._getCreateOptions.apply(this,arguments),s=t.extend(!0,{},this.options.wijCSS),this.theme=this.options.theme!==undefined?this.options.theme:this.element.jqmData("theme"),this.theme&&t.wijmo.addThemeToMobileCSS(this.theme,s),t.extend(n,{wijCSS:s},i)},t.widget("wijmo.widget",t.mobile.widget,s.prototype),t(document).on("pageshow",function(e,n){if(e.target==null)return;var r=t(e.target);r.wijTriggerVisibility&&r.wijTriggerVisibility()})):(s.prototype.options=t.extend(!0,{},s.prototype.options,s.prototype._baseWidget().prototype.options),t.widget("wijmo.widget",s.prototype))})(wijmo||(wijmo={})); 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 * ----
 * Credits: Wijmo includes some MIT-licensed software, see copyright notices below.
 */
/// <reference path="../External/declarations/jquery.d.ts"/>
/// <reference path="../External/declarations/jquery.ui.d.ts"/>
/// <reference path="../External/declarations/jquerymobile.d.ts"/>
/// <reference path="../Base/wijmo.d.ts"/>
/*
*
* Depends:
*  jquery.ui.core.js
*
*/
var wijmo;
(function (wijmo) {
    $.fn.extend({
        wijtextselection: function () {
            /// <summary>jQuery plugins to get/set text selection for input element</summary>
                        var start, end, t = this[0];
            var val = this.val();
            if(arguments.length === 0) {
                var range, stored_range, s, e;
                if(typeof t.selectionStart !== "undefined") {
                    s = t.selectionStart;
                    e = t.selectionEnd;
                } else {
                    try  {
                        var selection = document.selection;
                        if(t.tagName.toLowerCase() != "textarea") {
                            //$(this).focus();
                            range = selection.createRange().duplicate();
                            range.moveEnd("character", val.length);
                            s = (range.text === "" ? val.length : val.lastIndexOf(range.text));
                            range = selection.createRange().duplicate();
                            range.moveStart("character", -val.length);
                            e = range.text.length;
                        } else {
                            range = selection.createRange();
                            stored_range = range.duplicate();
                            stored_range.moveToElementText(t);
                            stored_range.setEndPoint('EndToEnd', range);
                            s = stored_range.text.length - range.text.length;
                            e = s + range.text.length;
                        }
                    } catch (e) {
                    }//fixed bug 26153
                    
                }
                var te = val.substring(s, e);
                return {
                    start: s,
                    end: e,
                    text: te,
                    replace: function (st) {
                        return val.substring(0, s) + st + val.substring(e, val.length);
                    }
                };
            } else if(arguments.length === 1) {
                if(typeof arguments[0] === "object" && typeof arguments[0].start === "number" && typeof arguments[0].end === "number") {
                    start = arguments[0].start;
                    end = arguments[0].end;
                } else if(typeof arguments[0] === "string") {
                    if((start = val.indexOf(arguments[0])) > -1) {
                        end = start + arguments[0].length;
                    }
                } else if(Object.prototype.toString.call(arguments[0]) === "[object RegExp]") {
                    var re = arguments[0].exec(val);
                    if(re != null) {
                        start = re.index;
                        end = start + re[0].length;
                    }
                }
            } else if(arguments.length === 2) {
                if(typeof arguments[0] === "number" && typeof arguments[1] === "number") {
                    start = arguments[0];
                    end = arguments[1];
                }
            }
            if(typeof start === "undefined") {
                start = 0;
                end = val.length;
            }
            if(typeof t.createTextRange !== "undefined") {
                var selRange = t.createTextRange();
                selRange.collapse(true);
                selRange.moveStart('character', start);
                selRange.moveEnd('character', end - start);
                selRange.select();
            } else {
                t.selectionStart = start;
                t.selectionEnd = end;
            }
        },
        wijContent: function (url) {
            return this.each(function () {
                this.innerHTML = '<iframe frameborder="0" style="width: 100%; height: 100%;" src="' + url + '">"';
            });
        },
        wijAddVisibilityObserver: /* Visibility observer */
        function (h, namespace) {
            return this.each(function () {
                var _this = this;
                $(this).addClass("wijmo-wijobserver-visibility");
                $(this).bind("wijmovisibilitychanged" + (namespace ? ("." + namespace) : ""), function (e) {
                    //fixed an issue that if an visiblity Objerver element inside another visiblity Objerver element,
                    // when trigger inside the element's event, it will propagate. It's not we wanted, So stop the propagation.
                    h.apply(_this, arguments);
                    e.stopPropagation();
                });
            });
        },
        wijRemoveVisibilityObserver: function (h) {
            return this.each(function () {
                $(this).removeClass("wijmo-wijobserver-visibility");
                if(!h) {
                    $(this).unbind("wijmovisibilitychanged");
                } else if(jQuery.isFunction(h)) {
                    $(this).unbind("wijmovisibilitychanged", h);
                } else {
                    $(this).unbind("wijmovisibilitychanged." + h);
                }
            });
        },
        wijTriggerVisibility: function () {
            return this.each(function () {
                var $el = $(this);
                if($el.hasClass("wijmo-wijobserver-visibility")) {
                    $el.trigger("wijmovisibilitychanged");
                }
                $el.find(".wijmo-wijobserver-visibility").trigger("wijmovisibilitychanged");
            });
        },
        leftBorderWidth: function () {
            var blw = parseFloat($(this).css("borderLeftWidth"));
            var pl = parseFloat($(this).css("padding-left"));
            var ml = 0;
            if($(this).css("margin-left") !== "auto") {
                ml = parseFloat($(this).css("margin-left"));
            }
            return naNTest(blw) + naNTest(pl) + naNTest(ml);
        },
        rightBorderWidth: function () {
            var brw = parseFloat($(this).css("borderRightWidth"));
            var pr = parseFloat($(this).css("padding-right"));
            var mr = 0;
            if($(this).css("margin-right") !== "auto") {
                mr = parseFloat($(this).css("margin-right"));
            }
            return naNTest(brw) + naNTest(pr) + naNTest(mr);
        },
        topBorderWidth: function () {
            var blw = parseFloat($(this).css("borderTopWidth"));
            var pl = parseFloat($(this).css("padding-top"));
            var ml = 0;
            if($(this).css("margin-top") !== "auto") {
                ml = parseFloat($(this).css("margin-top"));
            }
            return naNTest(blw) + naNTest(pl) + naNTest(ml);
        },
        bottomBorderWidth: function () {
            var brw = parseFloat($(this).css("borderBottomWidth"));
            var pr = parseFloat($(this).css("padding-bottom"));
            var mr = 0;
            if($(this).css("margin-bottom") !== "auto") {
                mr = parseFloat($(this).css("margin-bottom"));
            }
            return naNTest(brw) + naNTest(pr) + naNTest(mr);
        },
        borderSize: function () {
            var bw = $(this).leftBorderWidth() + $(this).rightBorderWidth();
            var bh = $(this).topBorderWidth() + $(this).bottomBorderWidth();
            var b = {
                width: bw,
                height: bh
            };
            return b;
        },
        setOutWidth: function (width) {
            var bw = $(this).leftBorderWidth() + $(this).rightBorderWidth();
            $(this).width(width - bw);
            return this;
        },
        setOutHeight: function (height) {
            var bh = $(this).topBorderWidth() + $(this).bottomBorderWidth();
            $(this).height(height - bh);
            return this;
        },
        getWidget: function () {
            var widgetName = this.data("widgetName");
            if(widgetName && widgetName !== "") {
                return this.data(widgetName);
            }
            return null;
        },
        wijshow: function (animation, customAnimations, customAnimationOptions, showing, shown) {
            var animated = animation.animated || false, duration = animation.duration || 400, easing = animation.easing, option = animation.option || {
            };
            if(showing && $.isFunction(showing)) {
                showing.call(this);
            }
            if(animated) {
                if(customAnimations && customAnimations[animated]) {
                    customAnimations[animated](animation, $.extend(customAnimationOptions, {
                        complete: shown
                    }));
                    return;
                }
                //individual effects in jqueryui 1.9 are now defined on $.effects.effect
                //rather than directly on $.effects.
                if($.effects) {
                    if($.effects[animated] || ($.effects.effect && $.effects.effect[animated])) {
                        this.show(animated, $.extend(option, {
                            easing: easing
                        }), duration, shown);
                        return;
                    }
                }
            }
            this.show();
            if(shown && $.isFunction(shown)) {
                shown.call(this);
            }
        },
        wijhide: function (animation, customAnimations, customAnimationOptions, hiding, hidden) {
            var animated = animation.animated || false, duration = animation.duration || 400, easing = animation.easing, option = animation.option || {
            };
            if(hiding && $.isFunction(hiding)) {
                hiding.call(this);
            }
            if(animated) {
                if(customAnimations && customAnimations[animated]) {
                    customAnimations[animated](animation, $.extend(customAnimationOptions, {
                        complete: hidden
                    }));
                    return;
                }
                //individual effects in jqueryui 1.9 are now defined on $.effects.effect
                //rather than directly on $.effects.
                if($.effects) {
                    if($.effects[animated] || ($.effects.effect && $.effects.effect[animated])) {
                        this.stop().hide(animated, $.extend(option, {
                            easing: easing
                        }), duration, hidden);
                        return;
                    }
                }
            }
            this.hide();
            if(hidden && $.isFunction(hidden)) {
                hidden.call(this);
            }
        }
    });
    function naNTest(num) {
        return isNaN(num) ? 0 : num;
    }
    //Saves a set of properties in a data storage
    $.save = function (element, set) {
        if($.effects) {
            return $.effects.save(element, set);
        }
        for(var i = 0; i < set.length; i++) {
            if(set[i] !== null) {
                element.data("ec.storage." + set[i], element[0].style[set[i]]);
            }
        }
    };
    // Restores a set of previously saved properties from a data storage
    $.restore = function (element, set) {
        if($.effects) {
            return $.effects.restore(element, set);
        }
        for(var i = 0; i < set.length; i++) {
            if(set[i] !== null) {
                element.css(set[i], element.data("ec.storage." + set[i]));
            }
        }
    };
    // Wraps the element around a wrapper that copies position properties
    $.createWrapper = function (element) {
        if($.effects) {
            return $.effects.createWrapper(element);
        }
        // if the element is already wrapped, return it
        if(element.parent().is('.ui-effects-wrapper')) {
            return element.parent();
        }
        // wrap the element
                var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            'float': element.css('float')
        }, wrapper = $('<div></div>').addClass('ui-effects-wrapper').css({
            fontSize: '100%',
            background: 'transparent',
            border: 'none',
            margin: 0,
            padding: 0
        }), active = document.activeElement;
        element.wrap(wrapper);
        // Fixes #7595 - Elements lose focus when wrapped.
        if(element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
        }
        wrapper = element.parent()//Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element
        ;
        // transfer positioning properties to the wrapper
        if(element.css('position') == 'static') {
            wrapper.css({
                position: 'relative'
            });
            element.css({
                position: 'relative'
            });
        } else {
            $.extend(props, {
                position: element.css('position'),
                zIndex: element.css('z-index')
            });
            $.each([
                'top', 
                'left', 
                'bottom', 
                'right'
            ], function (i, pos) {
                props[pos] = element.css(pos);
                if(isNaN(parseInt(props[pos], 10))) {
                    props[pos] = 'auto';
                }
            });
            element.css({
                position: 'relative',
                top: 0,
                left: 0,
                right: 'auto',
                bottom: 'auto'
            });
        }
        return wrapper.css(props).show();
    };
    $.removeWrapper = function (element) {
        if($.effects) {
            return $.effects.removeWrapper(element);
        }
        var parent, active = document.activeElement;
        if(element.parent().is('.ui-effects-wrapper')) {
            parent = element.parent().replaceWith(element);
            // Fixes #7595 - Elements lose focus when wrapped.
            if(element[0] === active || $.contains(element[0], active)) {
                $(active).focus();
            }
            return parent;
        }
        return element;
    };
    //Add the hasAllClasses method for supporting multiple classes selector
    $.fn.hasAllClasses = function (classesString) {
        var i, classes = (classesString || '').match(/\S+/g) || [];
        //if classesString is "" or null or undefined, return false
        if(classes.length === 0) {
            return false;
        }
        for(i = 0; i < classes.length; i++) {
            if(!this.hasClass(classes[i])) {
                return false;
            }
        }
        ;
        return true;
    };
    /**TODO: Override the hasClass method for supporting multiple classes selector
    $.fn.hasClass = function (selector) {
    var className = " " + selector + " ",
    i = 0, j = 0,
    eleClassName = "",
    classes = (className || '').match(/\S+/g) || [],
    l = this.length;
    for (; i < l; i++) {
    if (this[i].nodeType === 1) {
    eleClassName = (" " + this[i].className + " ").replace(/[\t\r\n]/g, " ");
    for (j = 0; j < classes.length; j++) {
    if (eleClassName.indexOf(classes[j]) <= 0) {
    return false;
    }
    }
    }
    }
    return true;
    };*/
    $.setMode = function (el, mode) {
        if($.effects) {
            return $.effects.setMode(el, mode);
        }
        if(mode === "toggle") {
            mode = el.is(":hidden") ? "show" : "hide";
        }
        return mode;
    };
    var wijCharValidator = function () {
    };
    $.extend(wijCharValidator.prototype, {
        _UTFPunctuationsString: ' ! \" # % & \' ( ) * , - . / : ; ? @ [ \\ ] { } \u00a1 \u00ab \u00ad \u00b7 \u00bb \u00bf \u037e \u0387 \u055a \u055b \u055c \u055d \u055e \u055f \u0589 \u058a \u05be \u05c0 \u05c3 \u05f3 \u05f4 \u060c \u061b \u061f \u066a \u066b \u066c \u066d \u06d4 \u0700 \u0701 \u0702 \u0703 \u0704 \u0705 \u0706 \u0707 \u0708 \u0709 \u070a \u070b \u070c \u070d \u0964 \u0965 \u0970 \u0df4 \u0e4f \u0e5a \u0e5b \u0f04 \u0f05 \u0f06 \u0f07 \u0f08 \u0f09 \u0f0a \u0f0b \u0f0c \u0f0d \u0f0e \u0f0f \u0f10 \u0f11 \u0f12 \u0f3a \u0f3b \u0f3c \u0f3d \u0f85 \u104a \u104b \u104c \u104d \u104e \u104f \u10fb \u1361 \u1362 \u1363 \u1364 \u1365 \u1366 \u1367 \u1368 \u166d \u166e \u169b \u169c \u16eb \u16ec \u16ed \u17d4 \u17d5 \u17d6 \u17d7 \u17d8 \u17d9 \u17da \u17dc \u1800 \u1801 \u1802 \u1803 \u1804 \u1805 \u1806 \u1807 \u1808 \u1809 \u180a \u2010 \u2011 \u2012 \u2013 \u2014 \u2015 \u2016 \u2017 \u2018 \u2019 \u201a \u201b \u201c \u201d \u201e \u201f \u2020 \u2021 \u2022 \u2023 \u2024 \u2025 \u2026 \u2027 \u2030 \u2031 \u2032 \u2033 \u2034 \u2035 \u2036 \u2037 \u2038 \u2039 \u203a \u203b \u203c \u203d \u203e \u2041 \u2042 \u2043 \u2045 \u2046 \u2048 \u2049 \u204a \u204b \u204c \u204d \u207d \u207e \u208d \u208e \u2329 \u232a \u3001 \u3002 \u3003 \u3008 \u3009 \u300a \u300b \u300c \u300d \u300e \u300f \u3010 \u3011 \u3014 \u3015 \u3016 \u3017 \u3018 \u3019 \u301a \u301b \u301c \u301d \u301e \u301f \u3030 \ufd3e \ufd3f \ufe30 \ufe31 \ufe32 \ufe35 \ufe36 \ufe37 \ufe38 \ufe39 \ufe3a \ufe3b \ufe3c \ufe3d \ufe3e \ufe3f \ufe40 \ufe41 \ufe42 \ufe43 \ufe44 \ufe49 \ufe4a \ufe4b \ufe4c \ufe50 \ufe51 \ufe52 \ufe54 \ufe55 \ufe56 \ufe57 \ufe58 \ufe59 \ufe5a \ufe5b \ufe5c \ufe5d \ufe5e \ufe5f \ufe60 \ufe61 \ufe63 \ufe68 \ufe6a \ufe6b \uff01 \uff02 \uff03 \uff05 \uff06 \uff07 \uff08 \uff09 \uff0a \uff0c \uff0d \uff0e \uff0f \uff1a \uff1b \uff1f \uff20 \uff3b \uff3c \uff3d \uff5b \uff5d \uff61 \uff62 \uff63 \uff64\';this.UTFWhitespacesString_=\'\t \u000b \u000c \u001f   \u00a0 \u1680 \u2000 \u2001 \u2002 \u2003 \u2004 \u2005 \u2006 \u2007 \u2008 \u2009 \u200a \u200b \u2028 \u202f \u3000',
        isDigit: function (c) {
            var code = c.charCodeAt(0);
            return (code >= 48 && code < 58);
        },
        isLetter: function (c) {
            return !!((c + '').match(new RegExp('[A-Za-z\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u021f\u0222-\u0233\u0250-\u02ad\u02b0-\u02b8\u02bb-\u02c1\u02d0\u02d1\u02e0-\u02e4\u02ee\u037a\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03ce\u03d0-\u03d7\u03da-\u03f3\u0400-\u0481\u048c-\u04c4\u04c7\u04c8\u04cb\u04cc\u04d0-\u04f5\u04f8\u04f9\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u063a\u0640-\u064a\u0671-\u06d3\u06d5\u06e5\u06e6\u06fa-\u06fc\u0710\u0712-\u072c\u0780-\u07a5\u0905-\u0939\u093d\u0950\u0958-\u0961\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8b\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b36-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb5\u0bb7-\u0bb9\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cde\u0ce0\u0ce1\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d60\u0d61\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc\u0edd\u0f00\u0f40-\u0f47\u0f49-\u0f6a\u0f88-\u0f8b\u1000-\u1021\u1023-\u1027\u1029\u102a\u1050-\u1055\u10a0-\u10c5\u10d0-\u10f6\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1206\u1208-\u1246\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1286\u1288\u128a-\u128d\u1290-\u12ae\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12ce\u12d0-\u12d6\u12d8-\u12ee\u12f0-\u130e\u1310\u1312-\u1315\u1318-\u131e\u1320-\u1346\u1348-\u135a\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1780-\u17b3\u1820-\u1877\u1880-\u18a8\u1e00-\u1e9b\u1ea0-\u1ef9\u1f00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u207f\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2131\u2133-\u2139\u3005\u3006\u3031-\u3035\u3041-\u3094\u309d\u309e\u30a1-\u30fa\u30fc-\u30fe\u3105-\u312c\u3131-\u318e\u31a0-\u31b7\u3400-\u4db5\u4e00-\u9fa5\ua000-\ua48c\uac00-\ud7a3\uf900-\ufa2d\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe72\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')));
        },
        isLetterOrDigit: function (c) {
            return this.isLetter(c) || this.isDigit(c);
        },
        isDoubleByteNumber: function (c) {
            var code = c.charCodeAt(0);
            return code >= 65296 && code < 65306;
        },
        isSymbol: function (c) {
            var re = new RegExp('[$+<->^`|~\u00a2-\u00a9\u00ac\u00ae-\u00b1\u00b4\u00b6\u00b8\u00d7\u00f7\u02b9\u02ba\u02c2-\u02cf\u02d2-\u02df\u02e5-\u02ed\u0374\u0375\u0384\u0385\u0482\u06e9\u06fd\u06fe\u09f2\u09f3\u09fa\u0b70\u0e3f\u0f01-\u0f03\u0f13-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fcf\u17db\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u207a-\u207c\u208a-\u208c\u20a0-\u20af\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u2132\u213a\u2190-\u21f3\u2200-\u22f1\u2300-\u2328\u232b-\u237b\u237d-\u239a\u2400-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2595\u25a0-\u25f7\u2600-\u2613\u2619-\u2671\u2701-\u2704\u2706-\u2709\u270c-\u2727\u2729-\u274b\u274d\u274f-\u2752\u2756\u2758-\u275e\u2761-\u2767\u2794\u2798-\u27af\u27b1-\u27be\u2800-\u28ff\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u3200-\u321c\u322a-\u3243\u3260-\u327b\u327f\u328a-\u32b0\u32c0-\u32cb\u32d0-\u32fe\u3300-\u3376\u337b-\u33dd\u33e0-\u33fe\ua490-\ua4a1\ua4a4-\ua4b3\ua4b5-\ua4c0\ua4c2-\ua4c4\ua4c6\ufb29\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]');
            return re.test(c + '');
        },
        isPunctuation: function (c) {
            return this._UTFPunctuationsString.indexOf(c) >= 0;
        },
        isPrintableChar: function (c) {
            if((!this.isLetterOrDigit(c) && !this.isPunctuation(c)) && !this.isSymbol(c) && !this.isDoubleByteNumber(c)) {
                return (c === ' ');
            }
            return true;
        },
        isAscii: function (c) {
            return (c >= '!') && (c <= '~');
        },
        isAsciiLetter: function (c) {
            return ((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'));
        },
        isUpper: function (c) {
            return c.toUpperCase() === c;
        },
        isLower: function (c) {
            return c.toLowerCase() === c;
        },
        isAlphanumeric: function (c) {
            return !this.isLetter(c) ? this.isDigit(c) : true;
        },
        isAciiAlphanumeric: function (c) {
            if(((c < '0') || (c > '9')) && ((c < 'A') || (c > 'Z'))) {
                if(c >= 'a') {
                    return (c <= 'z');
                }
                return false;
            }
            return true;
        },
        setChar: function (input, ch, pos) {
            if(pos >= input.length || pos < 0) {
                return input;
            }
            return '' || input.substr(0, pos) + ch + input.substr(pos + 1);
        }
    });
    // add the zIndex method to util if using in mobile.
    if(!$.fn.zIndex) {
        $.fn.zIndex = function (zIndex) {
            if(zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }
            if(this.length) {
                var elem = $(this[0]), position, value;
                while(elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if(position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if(!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }
            return 0;
        };
    }
    var c__escapeArr1 = [
        '\n', 
        '\r', 
        '"', 
        '@', 
        '+', 
        '\'', 
        '<', 
        '>', 
        '%', 
        '{', 
        '}'
    ], c__escapeArr2 = [
        "!ESC!NN!", 
        "!ESC!RR!", 
        "!ESC!01!", 
        "!ESC!02!", 
        "!ESC!03!", 
        "!ESC!04!", 
        "!ESC!05!", 
        "!ESC!06!", 
        "!ESC!07!", 
        "!ESC!08!", 
        "!ESC!09!"
    ], c__escapeArr3 = [
        "(\n)", 
        "(\r)", 
        "(\")", 
        "(@)", 
        "(\\+)", 
        "(')", 
        "(\\<)", 
        "(\\>)", 
        "(%)", 
        "(\\{)", 
        "(\\})"
    ];
    if(!$.wij) {
        $.extend({
            wij: {
                charValidator: new wijCharValidator(),
                encodeString: function (s) {
                    for(var i = 0; i < c__escapeArr1.length; i++) {
                        //var r = /c__escapeArr3[i]/g;
                        var r = new RegExp(c__escapeArr3[i], "g");
                        s = s.replace(r, c__escapeArr2[i]);
                    }
                    return s;
                },
                decodeString: function (s) {
                    if(s === "") {
                        return;
                    }
                    for(var i = 0; i < c__escapeArr2.length; i++) {
                        //var r = /c__escapeArr2[i]/g;
                        var r = new RegExp(c__escapeArr2[i], "g");
                        s = s.replace(r, c__escapeArr1[i]);
                    }
                    return s;
                }
            }
        });
    }
    ;
    //copy from jQuery-migrate.js in case of jQuery 1.9 removing $.browser api.
    if(!jQuery.uaMatch) {
        jQuery.uaMatch = function (ua) {
            ua = ua.toLowerCase();
            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };
    }
    // Don't clobber any existing jQuery.browser in case it's different
    if(!jQuery.browser) {
        var matched = jQuery.uaMatch(navigator.userAgent), browser = {
            version: "0",
            msie: false,
            opera: false,
            safari: false,
            mozilla: false,
            webkit: false,
            chrome: false
        };
        if(matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }
        //check whether the browser is ie11.
        if(browser.mozilla && !!navigator.userAgent.match(/Trident\/\d+?\./)) {
            browser.msie = true;
            browser.mozilla = false;
        }
        // Chrome is Webkit, but Webkit is also Safari.
        if(browser.chrome) {
            browser.webkit = true;
        } else if(browser.webkit) {
            browser.safari = true;
        }
        jQuery.browser = browser;
    }
    //Fix a known jQuery issue #8710, fix tfs issue #34746
    //http://bugs.jqueryui.com/ticket/8710
    if($.ui && $.ui.position && $.ui.position.flipfit) {
        $.ui.position.flip.top = function (position, data) {
            var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
            if(overTop < 0) {
                newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                if((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < Math.abs(overTop))) {
                    position.top += myOffset + atOffset + offset;
                }
            } else if(overBottom > 0) {
                newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                if((position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - offsetTop) < overBottom && (newOverTop > 0 || Math.abs(newOverTop) < overBottom)) {
                    //if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
                    position.top += myOffset + atOffset + offset;
                }
            }
        };
    }
    // for upgrade jQuery UI 1.10, it remove the offset option from option arguments.
    var $position = $.fn.position;
    $.fn.position = function (options) {
        //$position.call(this, options);
        if(options && $.isPlainObject(options) && options.offset) {
            var my = (options.my || "").split(" "), rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, offset = (options.offset || "").split(" ");
            if(my.length === 1) {
                rhorizontal.test(my[0]) ? my.concat([
                    "center"
                ]) : rvertical.test(my[0]) ? [
                    "center"
                ].concat(my) : [
                    "center", 
                    "center"
                ];
            }
            if(offset.length === 1) {
                offset.concat(offset[0]);
            }
            $.each(my, function (i, m) {
                if(/\+|-/.test(offset[i])) {
                    my[i] = my[i] + offset[i];
                } else {
                    my[i] = my[i] + "+" + offset[i];
                }
            });
            options.my = my.join(" ");
        }
        return $position.apply(this, arguments);
    };
    function getKeyCodeEnum() {
        if($.ui && $.ui.keyCode) {
            return $.ui.keyCode;
        }
        if($.mobile && $.mobile.keyCode) {
            return $.mobile.keyCode;
        }
        throw "keyCode object is not found";
    }
    wijmo.getKeyCodeEnum = getKeyCodeEnum;
    function getCSSSelector(classNames) {
        var classNameArr, resultArr = new Array();
        if(classNames == null || classNames.length == 0 || typeof classNames != "string") {
            return "";
        }
        classNameArr = classNames.split(" ");
        for(var index = 0; index < classNameArr.length; index++) {
            if(classNameArr[index].length != 0) {
                resultArr.push(classNameArr[index]);
            }
        }
        if(resultArr.length == 0) {
            return "";
        }
        return resultArr.join(".");
    }
    wijmo.getCSSSelector = getCSSSelector;
    function htmlEncode(val) {
        return $('<div/>').text(val).html();
    }
    wijmo.htmlEncode = htmlEncode;
    function htmlDecode(val) {
        return $('<div/>').html(val).text();
    }
    wijmo.htmlDecode = htmlDecode;
})(wijmo || (wijmo = {}));
function __wijReadOptionEvents(eventsArr, widgetInstance) {
    // handle option events
    for(var k = 0; k < eventsArr.length; k++) {
        if(widgetInstance.options[eventsArr[k]] !== null) {
            widgetInstance.element.bind(eventsArr[k], widgetInstance.options[eventsArr[k]]);
        }
    }
    //handle option event names separated by space, like: "afterexpand aftercollapse"
    for(var k in widgetInstance.options) {
        if(k.indexOf(" ") !== -1) {
            // possible multiple events separated by space:
            var arr = k.split(" ");
            for(var j = 0; j < arr.length; j++) {
                if(arr[j].length > 0) {
                    widgetInstance.element.bind(arr[j], widgetInstance.options[k]);
                }
            }
        }
    }
}
;
function wijmoASPNetParseOptionsReviewer(o, k) {
    var a, v = o[k], d;
    if(v) {
        switch(typeof v) {
            case "string":
                a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?):(\d{3})Z$/.exec(v);
                if(a) {
                    d = new Date(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6], +a[7]);
                    d.setFullYear(+a[1]);
                    o[k] = d;
                }
                break;
            case "object":
                if(v.needQuotes !== undefined && v.valueString !== undefined) {
                    if(!v.needQuotes) {
                        o[k] = eval(v.valueString);
                    } else {
                        o[k] = v.valueString;
                    }
                } else {
                    for(k in v) {
                        wijmoASPNetParseOptionsReviewer(v, k);
                    }
                }
                break;
        }
    }
}
function wijmoASPNetParseOptions(o) {
    var k;
    if(!o) {
        return o;
    }
    for(k in o) {
        wijmoASPNetParseOptionsReviewer(o, k);
    }
    return o;
}
var wijmo;
(function (wijmo) {
    (function (input) {
        /** @ignore */
        var wijInputResult = (function () {
            function wijInputResult() {
                this.characterEscaped = 1;
                this.noEffect = 2;
                this.sideEffect = 3;
                this.success = 4;
                this.unknown = 0;
                this.hint = 0;
                this.asciiCharacterExpected = -1;
                this.alphanumericCharacterExpected = -2;
                this.digitExpected = -3;
                this.invalidInput = -51;
                this.letterExpected = -4;
                this.nonEditPosition = -54;
                this.positionOutOfRange = -55;
                this.promptCharNotAllowed = -52;
                this.unavailableEditPosition = -53;
                this.testPosition = -1;
            }
            return wijInputResult;
        })();
        input.wijInputResult = wijInputResult;        
    })(wijmo.input || (wijmo.input = {}));
    var input = wijmo.input;
})(wijmo || (wijmo = {}));
$.wijinputcore = $.wijinputcore || {
};
$.wijinputcore.format = $.wijinputcore.format || function (value, formatOrType, options) {
    if(typeof value === 'number' || value instanceof Number) {
        return $.wijinputcore.formatnumber(value, formatOrType, options);
    } else if(value instanceof Date) {
        return $.wijinputcore.formatdate(value, formatOrType, options);
    } else {
        return $.wijinputcore.formatmask(value, formatOrType, options);
    }
};
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
/// <reference path="../../External/declarations/jquery.d.ts"/>
var wijmo;
(function (wijmo) {
    wijmo.expando = ".wijmo";
    /** @ignore */
    var WijmoError = (function () {
        function WijmoError(message) {
            this.message = message;
            this.stack = "Wijmo" + (new Error()).stack;
            this.name = "WijmoError";
        }
        return WijmoError;
    })();
    wijmo.WijmoError = WijmoError;    
    var wijerr = WijmoError;
    wijerr.prototype = new Error();
    wijerr.prototype["constructor"] = wijerr;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    (function (data) {
        /** @ignore */
        var Expando = (function () {
            function Expando(object) {
                this.object = object;
            }
            Expando.getFrom = function getFrom(obj, create) {
                if (typeof create === "undefined") { create = true; }
                var propertyName = wijmo.expando, ext;
                if(Object(obj) !== obj) {
                    return null;
                }
                ext = obj[propertyName];
                if(ext && ext.object !== obj) {
                    ext = null;
                }
                if(create && !(ext instanceof Expando && Object.prototype.hasOwnProperty.call(obj, propertyName))) {
                    ext = new Expando(obj);
                    try  {
                        Object.defineProperty(obj, propertyName, {
                            value: ext,
                            configurable: false,
                            enumerable: false,
                            writable: false
                        });
                    } catch (e) {
                        obj[propertyName] = ext;
                    }
                }
                return ext;
            };
            return Expando;
        })();
        data.Expando = Expando;        
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    (function (data) {
        /** @ignore */
        (function (util) {
            function funcClass(ctor) {
                return function () {
                    var result = function () {
                        return ctor.prototype._call.apply(result, arguments);
                    };
                    $.extend(result, ctor.prototype);
                    ctor.apply(result, arguments);
                    return result;
                };
            }
            util.funcClass = funcClass;
        })(data.util || (data.util = {}));
        var util = data.util;
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="./core.ts"/>
    /// <reference path="./util.ts"/>
    (function (data) {
        var $ = jQuery;
        /** @ignore */
        var SubscriberEntry = (function () {
            function SubscriberEntry(handler, context) {
                this.handler = handler;
                this.context = context;
            }
            SubscriberEntry.prototype.trigger = function (args) {
                return this.handler.apply(this.context, args);
            };
            return SubscriberEntry;
        })();
        data.SubscriberEntry = SubscriberEntry;        
        /** @ignore */
        var Subscribable = (function () {
            function Subscribable(defaultContext) {
                this.defaultContext = defaultContext;
                this._entries = [];
            }
            Subscribable.prototype.subscribe = function (handler, context) {
                if (typeof context === "undefined") { context = this.defaultContext; }
                var _this = this;
                var entry = new SubscriberEntry(handler, context);
                this._entries.push(entry);
                return {
                    dispose: function () {
                        return data.util.remove(_this._entries, entry);
                    }
                };
            };
            Subscribable.prototype.trigger = function () {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    args[_i] = arguments[_i + 0];
                }
                data.util.each(this._entries, function (_, e) {
                    return e.trigger(args);
                });
            };
            Subscribable.makeSubscribable = function makeSubscribable(obj) {
                var subscribable = new Subscribable(obj);
                obj.subscribe = $.proxy(subscribable.subscribe, subscribable);
                return subscribable;
            };
            return Subscribable;
        })();
        data.Subscribable = Subscribable;        
        function isSubscriptable(subscribable) {
            return $.isFunction(subscribable.subscribe);
        }
        data.isSubscriptable = isSubscriptable;
        /** @ignore */
        var BaseObservable = (function () {
            function BaseObservable() { }
            BaseObservable.prototype.subscribe = function (handler, context) {
                this._subscribable = this._subscribable || new Subscribable(this);
                return this._subscribable.subscribe(handler, context);
            };
            BaseObservable.prototype._trigger = function () {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    args[_i] = arguments[_i + 0];
                }
                if(this._subscribable) {
                    this._subscribable.trigger.apply(this._subscribable, arguments);
                }
            };
            return BaseObservable;
        })();
        data.BaseObservable = BaseObservable;        
        /** @ignore */
        var _ReadOnlyObservable = (function (_super) {
            __extends(_ReadOnlyObservable, _super);
            function _ReadOnlyObservable(mutable) {
                        _super.call(this);
                this.mutable = mutable;
            }
            _ReadOnlyObservable.prototype._call = function () {
                return this.mutable.value;
            };
            return _ReadOnlyObservable;
        })(BaseObservable);
        data._ReadOnlyObservable = _ReadOnlyObservable;        
        var ReadOnlyObservable = data.util.funcClass(_ReadOnlyObservable);
        /** @ignore */
        var _MutableObservable = (function (_super) {
            __extends(_MutableObservable, _super);
            function _MutableObservable(value, checkNewValue) {
                if (typeof checkNewValue === "undefined") { checkNewValue = false; }
                        _super.call(this);
                this.value = value;
                this.checkNewValue = checkNewValue;
            }
            _MutableObservable.prototype._call = function (newValue) {
                if(arguments.length > 0 && (!this.checkNewValue || newValue !== this.value)) {
                    this.value = newValue;
                    this._trigger(newValue);
                    if(this._readOnly) {
                        this._readOnly._trigger(newValue);
                    }
                }
                return this.value;
            };
            _MutableObservable.prototype.read = function () {
                this._readOnly = this._readOnly || new ReadOnlyObservable(this);
                return this._readOnly;
            };
            return _MutableObservable;
        })(BaseObservable);
        data._MutableObservable = _MutableObservable;        
        var MutableObservable = data.util.funcClass(_MutableObservable);
        /** @ignore */
        var _NumericMutableObservable = (function (_super) {
            __extends(_NumericMutableObservable, _super);
            function _NumericMutableObservable(value) {
                        _super.call(this, value, false);
                this.value = value;
            }
            _NumericMutableObservable.prototype.change = function (delta) {
                return this._call(this._call() + delta);
            };
            _NumericMutableObservable.prototype.inc = function () {
                return this.change(1);
            };
            _NumericMutableObservable.prototype.dec = function () {
                return this.change(-1);
            };
            return _NumericMutableObservable;
        })(_MutableObservable);
        data._NumericMutableObservable = _NumericMutableObservable;        
        var NumericMutableObservable = data.util.funcClass(_NumericMutableObservable);
        function observable(value) {
            if (typeof value === "undefined") { value = null; }
            return new MutableObservable(value);
        }
        data.observable = observable;
        /** @ignore */
        function numericObservable(value) {
            if (typeof value === "undefined") { value = 0; }
            return new NumericMutableObservable(value);
        }
        data.numericObservable = numericObservable;
        /** @ignore */
        function observableWithNewValueCheck(value) {
            if (typeof value === "undefined") { value = null; }
            return new MutableObservable(value, true);
        }
        data.observableWithNewValueCheck = observableWithNewValueCheck;
        function isObservable(observable) {
            return $.isFunction(observable) && isSubscriptable(observable);
        }
        data.isObservable = isObservable;
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    (function (data) {
        /// <reference path="./core.ts"/>
        /// <reference path="./observable.ts"/>
        /** @ignore */
        (function (util) {
            var $ = jQuery;
            function clone(obj, deep) {
                if (typeof deep === "undefined") { deep = false; }
                if($.isArray(obj)) {
                    obj = obj.slice(0);
                } else if($.isPlainObject(obj)) {
                    obj = $.extend(!!deep, {
                    }, obj);
                }
                return obj;
            }
            util.clone = clone;
            function isString(str) {
                return typeof str === "string" || str instanceof String;
            }
            util.isString = isString;
            function isNumeric(value) {
                return typeof value === "number";
            }
            util.isNumeric = isNumeric;
            function isInternalProperty(p) {
                return p === wijmo.expando || p === $.expando;
            }
            util.isInternalProperty = isInternalProperty;
            function each(obj, fn) {
                var _this = this;
                $.each(obj, function (key, value) {
                    if(!isInternalProperty(key)) {
                        return fn.call(_this, key, value);
                    }
                });
            }
            util.each = each;
            function map(obj, fn) {
                var result = $.map(obj, fn);
                delete result[wijmo.expando];
                return result;
            }
            util.map = map;
            function toStr(obj) {
                var text;
                if(obj && $.isFunction(obj.toString) && obj.toString !== Object.prototype.toString) {
                    text = obj.toString();
                } else {
                    text = JSON.stringify(obj);
                }
                if(text != null && text.length > 2 && text[0] === '"' && text[text.length - 1] === '"') {
                    text = text.substr(1, text.length - 2);
                }
                return text;
            }
            util.toStr = toStr;
            function format(format) {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 1); _i++) {
                    args[_i] = arguments[_i + 1];
                }
                return format.replace(/{(\d+)}/g, function (m, index) {
                    return toStr(args[parseInt(index, 10)]);
                });
            }
            util.format = format;
            function every(obj, predicate) {
                var res = true;
                each(obj, function (key, value) {
                    res = value;
                    if(predicate) {
                        res = predicate.call(res, res, key);
                    }
                    if(!res) {
                        return false;
                    }
                });
                return res;
            }
            util.every = every;
            function some(obj, predicate) {
                var res = false;
                each(obj, function (key, value) {
                    res = value;
                    if(predicate) {
                        res = predicate.call(res, res, key);
                    }
                    if(res) {
                        return false;
                    }
                });
                return res;
            }
            util.some = some;
            function compare(a, b) {
                var i, len, cmp;
                if(a == null) {
                    return b == null ? 0 : -1;
                } else if(b == null) {
                    return 1;
                }
                if($.isArray(a) && $.isArray(b)) {
                    len = Math.min(a.length, b.length);
                    for(i = 0; i < len; i++) {
                        cmp = compare(a[i], b[i]);
                        if(cmp !== 0) {
                            return cmp;
                        }
                    }
                    return a.length - b.length;
                } else if(isString(a) && isString(b)) {
                    a = a.toLowerCase();
                    b = b.toLowerCase();
                    return a < b ? -1 : a > b ? 1 : 0;
                }
                cmp = a - b;
                return isNaN(cmp) ? 0 : cmp;
            }
            util.compare = compare;
            function contains(array, elem) {
                return $.inArray(elem, array) >= 0;
            }
            util.contains = contains;
            function remove(array, elem) {
                var removed = 0, i;
                for(i = 0; i < array.length; ) {
                    if(array[i] !== elem) {
                        i++;
                    } else {
                        array.splice(i, 1);
                        removed++;
                    }
                }
                return removed;
            }
            util.remove = remove;
            function pageCount(totalCount, pageSize) {
                if(totalCount == -1) {
                    return -1;
                } else if(totalCount == 0) {
                    return 0;
                } else if(!pageSize) {
                    return 1;
                } else {
                    return Math.ceil(totalCount / pageSize);
                }
            }
            util.pageCount = pageCount;
            ;
            function executeDelayed(fn, context) {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 2); _i++) {
                    args[_i] = arguments[_i + 2];
                }
                function callback() {
                    return fn.apply(context, args);
                }
                if(typeof setTimeout === typeof undefined) {
                    return callback();
                } else {
                    setTimeout(callback, 10);
                }
            }
            util.executeDelayed = executeDelayed;
            function logError(message) {
                if(typeof console == "undefined") {
                    return;
                }
                if(console.error) {
                    console.error(message);
                } else if(console.log) {
                    console.log(message);
                }
            }
            util.logError = logError;
            function getProperty(obj, property) {
                var start = 0, value = obj, key;
                while(true) {
                    var point = property.indexOf('.', start);
                    if(point >= 0) {
                        key = property.substring(start, point);
                        start = point + 1;
                    } else if(start > 0) {
                        key = property.substring(start);
                    } else {
                        key = property;
                    }
                    value = value[key];
                    if(data.isObservable(value)) {
                        value = value();
                    }
                    if(point < 0) {
                        break;
                    }
                }
                return value;
            }
            util.getProperty = getProperty;
            function setProperty(obj, property, newValue) {
                var start = 0, key;
                while(true) {
                    var point = property.indexOf('.', start);
                    if(point >= 0) {
                        key = property.substring(start, point);
                        start = point + 1;
                    } else if(start > 0) {
                        key = property.substring(start);
                    } else {
                        key = property;
                    }
                    var value = obj[key];
                    if(point >= 0) {
                        if(data.isObservable(value)) {
                            value = value();
                        }
                        obj = value;
                    } else {
                        if(data.isObservable(value)) {
                            value(newValue);
                        } else {
                            obj[key] = newValue;
                        }
                        break;
                    }
                }
            }
            util.setProperty = setProperty;
            function isClassInstance(instance) {
                return typeof instance === "object" && !$.isArray(instance) && !$.isPlainObject(instance) && instance.constructor !== (Object.prototype).constructor;
            }
            util.isClassInstance = isClassInstance;
            function convertDateProperties(entities) {
                data.util.each(entities, function (_, entity) {
                    if(!entity || typeof entity !== "object") {
                        return;
                    }
                    data.util.each(entity, function (key, value) {
                        var match;
                        if(!data.util.isString(value)) {
                            return;
                        }
                        match = /\/Date\((-?\d+)\)\//.exec(value);
                        if(!match) {
                            return;
                        }
                        entity[key] = new Date(parseInt(match[1], 10));
                    });
                });
            }
            util.convertDateProperties = convertDateProperties;
            var HashMapEntry = (function () {
                function HashMapEntry(key) {
                    this.key = key;
                }
                return HashMapEntry;
            })();
            util.HashMapEntry = HashMapEntry;            
            var HashMap = (function () {
                function HashMap() {
                    this.hash = {
                    };
                }
                HashMap.prototype.getEntry = function (key, create) {
                    if (typeof create === "undefined") { create = false; }
                    if(key === null) {
                        if(!this.nullEntry && create) {
                            this.nullEntry = new HashMapEntry(key);
                        }
                        return this.nullEntry;
                    }
                    var strKey = String(key);
                    var list = this.hash[strKey];
                    var entry;
                    if(list == null) {
                        if(!create) {
                            return null;
                        }
                        list = [];
                        this.hash[strKey] = list;
                    }
                    for(var i = 0; i < list.length; i++) {
                        if(list[i].key === key) {
                            return list[i];
                        }
                    }
                    if(create) {
                        entry = new HashMapEntry(key);
                        list.push(entry);
                    }
                    return null;
                };
                HashMap.prototype.containsKey = function (key) {
                    return !!this.getEntry(key);
                };
                HashMap.prototype.get = function (key, defaultValue) {
                    if (typeof defaultValue === "undefined") { defaultValue = null; }
                    var entry = this.getEntry(key);
                    return entry ? entry.value : defaultValue;
                };
                HashMap.prototype.put = function (key, value) {
                    this.getEntry(key, true).value = value;
                };
                return HashMap;
            })();
            util.HashMap = HashMap;            
        })(data.util || (data.util = {}));
        var util = data.util;
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    /// <reference path="./util.ts"/>
    /** @ignore */
    (function (data) {
        data.errors = {
        };
        data.errors._register = function (messages) {
            data.util.each(messages, function (name, msg) {
                function create() {
                    var fmtArgs = [];
                    for (var _i = 0; _i < (arguments.length - 0); _i++) {
                        fmtArgs[_i] = arguments[_i + 0];
                    }
                    var lastChar;
                    if($.isFunction(msg)) {
                        msg = msg.apply(this, arguments);
                    } else if(arguments.length > 0) {
                        fmtArgs.unshift(msg);
                        msg = data.util.format.apply(this, fmtArgs);
                    }
                    msg = $.trim(msg);
                    lastChar = msg[msg.length - 1];
                    if(lastChar !== '.' && lastChar !== '!' && lastChar !== '?') {
                        msg += '.';
                    }
                    return new wijmo.WijmoError(msg);
                }
                data.errors[name] = function () {
                    throw create.apply(this, arguments);
                };
                data.errors[name].create = create;
            });
        };
        data.errors._register({
            indexOutOfBounds: "Index is outside the bounds of the array.",
            notImplemented: "The operation is not implemented",
            unsupportedOperation: "Unsupported operation",
            unsupportedFilterOperator: "Unsupported filter operator: {0}",
            unsupportedDataSource: "Unsupported data source",
            argument: function (paramName) {
                var message = "Unexpected argument value.";
                if(paramName) {
                    message += "\nParameter name: " + paramName;
                }
                return message;
            },
            argumentNull: "Argument '{0}' is null/undefined",
            noParser: "There is no parser for type '{0}'",
            noUrl: "Url is not specified",
            cantConvert: "Value can't be converted to type '{0}': '{1}'",
            noGlobalize: "Globalize is not defined. Make sure you include globalize.js",
            itemNotInView: "Item {0} is not in the data view",
            unsupportedFilterFormat: "The filter format is not supported",
            multiPropertyKeysNotSupported: "Entities with multiple properties in the primary key are not supported. Entity type: {0}",
            keyPropertyNotFound: "Key property not found in {0} entity type"
        });
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    (function (data) {
        /// <reference path="dataView.ts"/>
        /** @ignore */
        (function (filtering) {
            var $ = jQuery;
            filtering.opMap = {
                "==": "equals",
                doesnotcontain: "notcontain",
                "!=": "notequal",
                ">": "greater",
                "<": "less",
                ">=": "greaterorequal",
                "<=": "lessorequal",
                isnotempty: "notisempty",
                isnotnull: "notisnull"
            };
            function findOperator(name, throwIfNotFound) {
                if (typeof throwIfNotFound === "undefined") { throwIfNotFound = false; }
                name = name.toLowerCase();
                var op = filtering.ops[name];
                if(!op) {
                    var mappedName = filtering.opMap[name];
                    if(mappedName) {
                        op = filtering.ops[mappedName];
                    }
                }
                if(!op && throwIfNotFound) {
                    data.errors.unsupportedFilterOperator(name);
                }
                return op;
            }
            function normalizeCondition(cond) {
                var filter;
                if(!$.isPlainObject(cond)) {
                    return {
                        operator: "==",
                        op: filtering.ops.equals,
                        value: cond
                    };
                }
                var op = cond.operator || filtering.ops.equals;
                if(data.util.isString(cond.operator)) {
                    if(cond.operator.toLowerCase() === "nofilter") {
                        return null;
                    }
                    op = findOperator(cond.operator, true);
                } else if(!$.isFunction(op.apply)) {
                    data.errors.unsupportedFilterOperator(op);
                }
                return {
                    operator: cond.operator,
                    op: op,
                    value: cond.value
                };
            }
            filtering.normalizeCondition = normalizeCondition;
            function compile(filter) {
                var result = {
                    isEmpty: false,
                    original: filter,
                    func: null,
                    normalized: null
                };
                if($.isFunction(filter)) {
                    result.func = filter;
                } else if($.isArray(filter)) {
                    data.errors.unsupportedFilterFormat(filter);
                } else if(filter) {
                    result.normalized = {
                    };
                    var hasConditions = false;
                    data.util.each(filter, function (prop, cond) {
                        if($.isArray(cond)) {
                            data.errors.unsupportedFilterFormat();
                        }
                        cond = normalizeCondition(cond);
                        if(cond) {
                            result.normalized[prop] = cond;
                            hasConditions = true;
                        }
                    });
                    if(!hasConditions) {
                        result.normalized = null;
                    } else {
                        result.func = function (x) {
                            return data.util.every(result.normalized, function (cond, prop) {
                                var propValue = data.util.getProperty(x, prop);
                                return cond.op.apply(propValue, cond.value);
                            });
                        };
                    }
                }
                if(!result.normalized && !result.func) {
                    result.isEmpty = true;
                    result.func = function (x) {
                        return true;
                    };
                }
                return result;
            }
            filtering.compile = compile;
            //#region operators
            filtering.ops = (function () {
                var ops = {
                }, types = {
                    str: [
                        "string"
                    ],
                    prim: [
                        "string", 
                        "number", 
                        "datetime", 
                        "currency", 
                        "boolean"
                    ]
                };
                function op(name, displayName, arity, types, apply) {
                    return ops[name.toLowerCase()] = {
                        name: name,
                        displayName: displayName,
                        arity: arity,
                        applicableTo: types,
                        apply: apply
                    };
                }
                function preprocessOperand(value) {
                    if(value instanceof Date) {
                        value = value.getTime();
                    }
                    if(data.util.isString(value)) {
                        value = value.toLowerCase();
                    }
                    return value;
                }
                function bin(name, displayName, types, apply) {
                    op(name, displayName, 2, types, function (left, right) {
                        return apply(preprocessOperand(left), preprocessOperand(right));
                    });
                }
                function unary(name, displayName, types, apply) {
                    op(name, displayName, 1, types, apply);
                }
                function binprim(name, displayName, apply) {
                    bin(name, displayName, types.prim, apply);
                }
                function binstr(name, displayName, apply) {
                    bin(name, displayName, types.str, apply);
                }
                // Primitive binary operators
                binprim("Equals", "Equals", function (l, r) {
                    return l == r;
                });
                binprim("NotEqual", "Not equal", function (l, r) {
                    return l != r;
                });
                binprim("Greater", "Greater than", function (l, r) {
                    return l > r;
                });
                binprim("Less", "Less than", function (l, r) {
                    return l < r;
                });
                binprim("GreaterOrEqual", "Greater or equal", function (l, r) {
                    return l >= r;
                });
                binprim("LessOrEqual", "Less or equal", function (l, r) {
                    return l <= r;
                });
                // String operators
                binstr("Contains", "Contains", function (left, right) {
                    return left == right || left && left.indexOf && left.indexOf(right) >= 0;
                });
                binstr("NotContain", "Does not contain", function (left, right) {
                    return left != right && (!left || !left.indexOf || left.indexOf(right) < 0);
                });
                binstr("BeginsWith", "Begins with", function (left, right) {
                    return left == right || left && left.indexOf && left.indexOf(right) == 0;
                });
                binstr("EndsWith", "Ends with", function (left, right) {
                    var idx;
                    if(!data.util.isString(left) || !data.util.isString(right)) {
                        return false;
                    }
                    idx = left.lastIndexOf(right);
                    return idx >= 0 && left.length - idx === right.length;
                });
                // Unary operators
                unary("IsEmpty", "Is empty", types.str, function (x) {
                    return !x && x !== 0 && x !== false;
                })// null, undefined, or empty string
                ;
                unary("NotIsEmpty", "Is not empty", types.str, function (x) {
                    return !!x || x === 0 || x === false;
                });
                unary("IsNull", "Is null", types.prim, function (x) {
                    return x == null;
                });
                unary("NotIsNull", "Is not null", types.prim, function (x) {
                    return x != null;
                });
                return ops;
            })();
            //#endregion operators
                    })(data.filtering || (data.filtering = {}));
        var filtering = data.filtering;
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    (function (data) {
        /// <reference path="dataView.ts"/>
        /** @ignore */
        (function (sorting) {
            function normalize(sort) {
                var result = [];
                sort = data.util.isString(sort) ? sort.split(/,\s*/) : !$.isArray(sort) ? [
                    sort
                ] : sort.slice(0);
                sort = $.isArray(sort) ? sort.slice(0) : [
                    sort
                ];
                data.util.each(sort, function (_, prop) {
                    var asc = true, i;
                    if(prop == null) {
                        return;
                    }
                    if(!data.util.isString(prop)) {
                        if(prop.property != null) {
                            result.push(prop);
                        }
                        return;
                    }
                    if(prop[0] === "-") {
                        asc = false;
                        prop = prop.substr(1);
                    } else {
                        var match = /\s(asc|desc)\s*$/.exec(prop);
                        if(match) {
                            prop = prop.substr(0, match.index);
                            asc = !(match[1] === "desc");
                        }
                    }
                    result.push({
                        property: prop,
                        asc: asc
                    });
                });
                return result.length > 0 ? result : null;
            }
            function compile(sort, compareTo) {
                if (typeof compareTo === "undefined") { compareTo = data.util.compare; }
                var normalized = normalize(sort);
                var result = {
                    isEmpty: true,
                    original: sort,
                    propertyCompareTo: compareTo,
                    compare: null,
                    normalized: normalized
                };
                if(normalized != null) {
                    result.isEmpty = false;
                    result.compare = function (a, b) {
                        var i = 0, cmp, descr;
                        for(i = 0; i < normalized.length; i++) {
                            descr = normalized[i];
                            cmp = compareTo(data.util.getProperty(a, descr.property), data.util.getProperty(b, descr.property));
                            if(cmp !== 0) {
                                if(!descr.asc) {
                                    cmp = -cmp;
                                }
                                return cmp;
                            }
                        }
                        return 0;
                    };
                }
                return result;
            }
            sorting.compile = compile;
        })(data.sorting || (data.sorting = {}));
        var sorting = data.sorting;
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    /// <reference path="./core.ts"/>
    /// <reference path="./filtering.ts"/>
    /// <reference path="./sorting.ts"/>
    /// <reference path="./arrayDataView.ts"/>
    (function (data) {
        var $ = jQuery;
        var dataViewFactories = [];
        /** Registers a new IDataView provider.
        * @param {IDataViewFactory} factory A function that creates a IDataView for a data source if possible. Otherwise returns null.
        * @returns An IDisposable that can be used to remove the registration.
        * @remarks
        * Use this method to provide your own IDataView implementation for a specific data source. See wijmo.data.breeze.ts for an example.
        */
        function registerDataViewFactory(factory) {
            if(!$.isFunction(factory)) {
                data.errors.argument("factory");
            }
            dataViewFactories.push(factory);
            return {
                dispose: function () {
                    data.util.remove(dataViewFactories, factory);
                }
            };
        }
        data.registerDataViewFactory = registerDataViewFactory;
        registerDataViewFactory(function (view) {
            return isDataView(view) && view;
        });
        registerDataViewFactory(function (array) {
            return $.isArray(array) && new data.ArrayDataView(array);
        });
        //#endregion Data view factories
        /** Creates an IDataView for a data source.
        * @param src A data source, can be anything that is supported by the registered IDataView providers
        * @returns An IDataView instance for the data source.
        */
        function asDataView(src) {
            if(isDataView(src)) {
                return src;
            }
            var view = data.util.some(dataViewFactories, function (p) {
                return p(src);
            });
            return view || data.errors.unsupportedDataSource();
        }
        data.asDataView = asDataView;
        /** Returns true if the view parameter is a IDataView */
        function isDataView(view) {
            return view && $.isFunction(view.count) && $.isFunction(view.item) && $.isFunction(view.getProperty);
        }
        data.isDataView = isDataView;
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    /// <reference path="./core.ts"/>
    /// <reference path="./arrayDataView.ts"/>
    /** @ignore */
    (function (data) {
        var $ = jQuery;
        var CurrencyManager = (function () {
            function CurrencyManager(array) {
                this.array = array;
                this.currentItem = data.observableWithNewValueCheck(null);
                this.currentPosition = data.observableWithNewValueCheck(-1);
                var syncing = false;
function synced(fn) {
                    return function () {
                        if(syncing) {
                            return;
                        }
                        syncing = true;
                        try  {
                            fn.apply(this, arguments);
                        }finally {
                            syncing = false;
                        }
                    };
                }
                this.currentItem.subscribe(synced(function (value) {
                    this.currentPosition(value == null ? -1 : $.inArray(value, this.array));
                }), this);
                this.currentPosition.subscribe(synced(function (value) {
                    if(!data.util.isNumeric(value)) {
                        data.errors.argument("value");
                    }
                    if(value < -1 || value >= this.array.length) {
                        data.errors.indexOutOfBounds();
                    }
                    this.currentItem(value < 0 ? null : this.array[value]);
                }), this);
            }
            CurrencyManager.prototype.update = function () {
                var item = this.currentItem(), pos = this.currentPosition(), newIndex = $.inArray(item, this.array);
                if(newIndex < 0 && item == null && this._recentlyRemovedItem != null) {
                    newIndex = $.inArray(this._recentlyRemovedItem, this.array);
                }
                if(newIndex >= 0) {
                    if(item) {
                        this._recentlyRemovedItem = item;
                    }
                    this.currentPosition(newIndex);
                } else if(pos >= 0 && pos < this.array.length) {
                    this.currentItem(this.array[pos]);
                } else if(pos >= this.array.length && this.array.length > 0) {
                    pos = this.array.length - 1;
                    this.currentPosition(pos);
                    this.currentItem(this.array[pos]);
                } else {
                    this.currentPosition(-1);
                    this.currentItem(null);
                }
            };
            CurrencyManager.prototype.updateDelayed = function () {
                data.util.executeDelayed(this.update, this);
            };
            return CurrencyManager;
        })();
        data.CurrencyManager = CurrencyManager;        
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    (function (data) {
        var $ = jQuery;
        /** @ignore */
        var Shape = (function () {
            function Shape(onChanged) {
                this.onChanged = onChanged;
                this.filter = data.observable();
                this._compiledFilter = data.filtering.compile(null);
                this.sort = data.observable();
                this._compiledSort = data.sorting.compile(null);
                this.pageIndex = data.observable(0);
                this.pageSize = data.observable(0);
                this._skip = 0;
                this._take = -1;
                this.filter.subscribe(function (newValue) {
                    this.onFilterChanged(newValue);
                    onChanged();
                }, this);
                this.sort.subscribe(function () {
                    this._compiledSort = data.sorting.compile(this.sort());
                    onChanged();
                }, this);
function updatePaging() {
                    if(this.pageSize() > 0 && this.pageIndex() >= 0) {
                        this._skip = this.pageSize() * this.pageIndex();
                        this._take = this.pageSize();
                    } else {
                        this._skip = 0;
                        this._take = -1;
                    }
                    onChanged(true);
                }
                this.pageIndex.subscribe(updatePaging, this);
                this.pageSize.subscribe(updatePaging, this);
            }
            Shape.prototype.onFilterChanged = function (newValue) {
                this._compiledFilter = data.filtering.compile(newValue);
            };
            Shape.prototype.setFilter = function (filter) {
                this.filter(filter);
            };
            Shape.prototype.update = function (shape) {
                if("filter" in shape) {
                    this.setFilter(shape.filter);
                }
                if("sort" in shape) {
                    this.sort(shape.sort);
                }
                if("pageSize" in shape) {
                    this.pageSize(shape.pageSize);
                }
                if("pageIndex" in shape) {
                    this.pageIndex(shape.pageIndex);
                }
            };
            Shape.prototype.apply = function (array, applyPaging, destination) {
                if (typeof applyPaging === "undefined") { applyPaging = true; }
                if (typeof destination === "undefined") { destination = null; }
                var i;
                // filter
                if(!this._compiledFilter.isEmpty) {
                    if(destination) {
                        destination.length = 0;
                    } else {
                        destination = [];
                    }
                    for(i = 0; i < array.length; i++) {
                        var item = array[i];
                        if(this._compiledFilter.func(item)) {
                            destination.push(item);
                        }
                    }
                } else {
                    // just clone it
                    if(!destination) {
                        destination = array.slice(0);
                    } else {
                        destination.length = array.length;
                        for(i = 0; i < array.length; i++) {
                            destination[i] = array[i];
                        }
                    }
                }
                // sort
                if(!this._compiledSort.isEmpty) {
                    this._stableSort(destination, this._compiledSort.compare);
                }
                // page
                var totalCount = destination.length;
                if(applyPaging && this._take > 0) {
                    if(this._skip > 0) {
                        destination.splice(0, Math.min(this._skip, destination.length));
                    }
                    if(this._take < destination.length) {
                        destination.length = this._take;
                    }
                }
                return {
                    results: destination,
                    totalCount: totalCount
                };
            };
            Shape.prototype._stableSort = function (arr, fn) {
                var isChrome = /chrom(e|ium)/.test(navigator.userAgent.toLowerCase()) && /Google Inc/.test(navigator.vendor);
                if(fn && isChrome) {
                    arr.forEach(function (ele, index) {
                        arr[index] = {
                            index: index,
                            value: ele
                        };
                    });
                    arr.sort(function (c, d) {
                        var result = fn(c.value, d.value);
                        if(result === 0) {
                            return c.index - d.index;
                        }
                        return result;
                    });
                    arr.forEach(function (ele, index) {
                        arr[index] = ele.value;
                    });
                } else {
                    arr.sort(fn);
                }
            };
            Shape.prototype.toObj = function () {
                return {
                    filter: this._compiledFilter.normalized,
                    sort: this._compiledSort.normalized,
                    pageSize: this.pageSize(),
                    pageIndex: this.pageIndex()
                };
            };
            return Shape;
        })();
        data.Shape = Shape;        
        var ArrayDataViewBase = (function () {
            function ArrayDataViewBase(shape) {
                this.isRemote = false;
                this.localPaging = true;
                //#region items
                this.local = [];
                this._updatingShape = false;
                this._pageCount = data.observable(1);
                this._totalItemCount = data.numericObservable(0);
                //#endregion shape
                //#region loading
                this._isLoaded = data.observable(false);
                this._isLoading = data.observable(false);
                //#endregionn
                //#region editing
                this._currentEditItem = data.observable();
                this._isCurrentEditItemNew = false;
                this._currentEditItemSnapshot = null;
                this.isLoading = this._isLoading.read();
                this.isLoaded = this._isLoaded.read();
                this._changed = new data.Subscribable(this);
                this.currentEditItem = this._currentEditItem.read();
                this._initCurrency();
                this._initShape(shape);
            }
            ArrayDataViewBase.prototype.dispose = function () {
            };
            ArrayDataViewBase.prototype.count = function () {
                return this.local.length;
            };
            ArrayDataViewBase.prototype.item = function (index) {
                if(index < 0 || index >= this.local.length) {
                    data.errors.indexOutOfBounds();
                }
                return this.local[index];
            };
            ArrayDataViewBase.prototype.indexOf = function (item) {
                return $.inArray(item, this.local);
            };
            ArrayDataViewBase.prototype.getSource = function () {
                return this.sourceArray;
            };
            ArrayDataViewBase.prototype.toObservableArray = function () {
                if(!this._koArray) {
                    this._koArray = ko.observableArray(this.local);
                }
                return this._koArray;
            };
            ArrayDataViewBase._getProps = //#endregion items
            //#region properties
            function _getProps(item) {
                var cols = [];
                data.util.each(item, function (key, value) {
                    key = String(key);
                    if(key.match(/^_/)) {
                        return;
                    }
                    if($.isFunction(value) && !value.subscribe) {
                        return;
                    }
                    cols.push({
                        name: key
                    });
                });
                return cols;
            };
            ArrayDataViewBase.prototype.getProperties = function () {
                return this.count() ? ArrayDataViewBase._getProps(this.item(0)) : [];
            };
            ArrayDataViewBase.prototype._readProperty = function (item, property) {
                return data.util.getProperty(item, property);
            };
            ArrayDataViewBase.prototype.getProperty = function (itemOrIndex, property) {
                var item = this._getItem(itemOrIndex);
                return this._readProperty(item, property);
            };
            ArrayDataViewBase.prototype._writeProperty = function (item, property, newValue) {
                data.util.setProperty(item, property, newValue);
            };
            ArrayDataViewBase.prototype.setProperty = function (itemOrIndex, property, newValue) {
                var item = this._getItem(itemOrIndex);
                if(item === this.currentEditItem() && this._currentEditItemSnapshot && !(property in this._currentEditItemSnapshot)) {
                    this._currentEditItemSnapshot[property] = this.getProperty(itemOrIndex, property);
                }
                this._writeProperty(item, property, newValue);
                return this;
            };
            ArrayDataViewBase.prototype.subscribe = function (handler, context) {
                return this._changed.subscribe(handler, context);
            };
            ArrayDataViewBase.prototype.trigger = function () {
                this._currencyManager.update();
                this._changed.trigger(this.local);
                if(this._koArray) {
                    this._koArray.notifySubscribers(this.local);
                }
            };
            ArrayDataViewBase.prototype.canFilter = function () {
                return true;
            };
            ArrayDataViewBase.prototype.canSort = function () {
                return true;
            };
            ArrayDataViewBase.prototype._updateShape = function (shape) {
                this._updatingShape = true;
                try  {
                    this._shape.update(shape);
                }finally {
                    this._updatingShape = false;
                }
            };
            ArrayDataViewBase.prototype.prevPage = function () {
                if(this.pageIndex() < 1) {
                    return false;
                }
                this.pageIndex(this.pageIndex() - 1);
                return true;
            };
            ArrayDataViewBase.prototype.nextPage = function () {
                if(this.pageCount() > 0 && this.pageIndex() + 1 >= this.pageCount()) {
                    return false;
                }
                this.pageIndex(this.pageIndex() + 1);
                return true;
            };
            ArrayDataViewBase.prototype._createShape = function (onChanged) {
                return new Shape(onChanged);
            };
            ArrayDataViewBase.prototype._initShape = function (shape) {
                var _this = this;
                var onChanged = function (onlyPaging) {
                    if (typeof onlyPaging === "undefined") { onlyPaging = false; }
                    if(!_this._updatingShape) {
                        _this.refresh(null, onlyPaging && _this.localPaging);
                    }
                };
                this._shape = this._createShape(onChanged);
                if(shape) {
                    this._updateShape(shape);
                }
                this.filter = this._shape.filter;
                this.sort = this._shape.sort;
                this.pageIndex = this._shape.pageIndex;
                this.pageSize = this._shape.pageSize;
                this.pageCount = this._pageCount.read();
                this.totalItemCount = this._totalItemCount.read();
            };
            ArrayDataViewBase.prototype._localRefresh = function (doPaging) {
                if (typeof doPaging === "undefined") { doPaging = this.localPaging; }
                var result = this._shape.apply(this.sourceArray, doPaging, this.local);
                if(doPaging) {
                    this._totalItemCount(result.totalCount);
                }
                this._pageCount(data.util.pageCount(this.totalItemCount(), this.pageSize()));
                // notify
                this.trigger();
                return $.Deferred().resolve().promise();
            };
            ArrayDataViewBase.prototype._remoteRefresh = function () {
                return this._localRefresh();
            };
            ArrayDataViewBase.prototype.refresh = function (shape, local) {
                if (typeof local === "undefined") { local = false; }
                var _this = this;
                this.cancelRefresh();
                if(shape) {
                    this._updateShape(shape);
                }
                this._isLoading(true);
                var promise = local ? this._localRefresh() : this._remoteRefresh();
                return promise.then(function () {
                    _this._isLoaded(true);
                    _this._isLoading(false);
                });
            };
            ArrayDataViewBase.prototype.cancelRefresh = function () {
            };
            ArrayDataViewBase.prototype._initCurrency = function () {
                this._currencyManager = new data.CurrencyManager(this.local);
                this.currentItem = this._currencyManager.currentItem;
                this.currentPosition = this._currencyManager.currentPosition;
            };
            ArrayDataViewBase.prototype.isCurrentEditItemNew = function () {
                return this._isCurrentEditItemNew;
            };
            ArrayDataViewBase.prototype._beginEdit = function (item, isNew) {
                this.commitEdit();
                this._currentEditItemSnapshot = {
                };
                this._isCurrentEditItemNew = isNew;
                this._currentEditItem(item);
            };
            ArrayDataViewBase.prototype.canAdd = function () {
                return true;
            };
            ArrayDataViewBase.prototype.add = function (item) {
                if(!item) {
                    data.errors.argument("item");
                }
                this.commitEdit();
                this.local.push(item);
                this._beginEdit(item, true);
                this.trigger();
            };
            ArrayDataViewBase.prototype.canAddNew = function () {
                return false;
            };
            ArrayDataViewBase.prototype.addNew = function () {
                return data.errors.unsupportedOperation();
            };
            ArrayDataViewBase.prototype.editItem = function (item) {
                if (typeof item === "undefined") { item = this.currentItem(); }
                this.commitEdit();
                item = this._getItem(item);
                if(item) {
                    this._beginEdit(item, false);
                }
            };
            ArrayDataViewBase.prototype.canRemove = function () {
                return true;
            };
            ArrayDataViewBase.prototype._remove = function (entry) {
                this.local.splice(entry.index, 1);
                data.util.remove(this.sourceArray, entry.item);
                this._totalItemCount.dec();
                this.trigger();
            };
            ArrayDataViewBase.prototype.remove = function (item) {
                if (typeof item === "undefined") { item = this.currentItem(); }
                this.commitEdit();
                var entry = this._resolve(item);
                if(!entry) {
                    return false;
                }
                this._remove(entry);
                return true;
            };
            ArrayDataViewBase.prototype.canCancelEdit = function () {
                return true;
            };
            ArrayDataViewBase.prototype.cancelEdit = function () {
                var _this = this;
                var key;
                if(!this.currentEditItem()) {
                    return;
                }
                var item = this.currentEditItem();
                this._currentEditItem(null);
                if(this._isCurrentEditItemNew) {
                    data.util.remove(this.local, this.item);
                } else if(this._currentEditItemSnapshot) {
                    $.each(this._currentEditItemSnapshot, function (k, v) {
                        return _this._writeProperty(item, k, v);
                    });
                }
                this.trigger();
            };
            ArrayDataViewBase.prototype.canCommitEdit = function () {
                return true;
            };
            ArrayDataViewBase.prototype.commitEdit = function () {
                if(!this.currentEditItem()) {
                    return;
                }
                var item = this.currentEditItem();
                this._currentEditItem(null);
                if(this._isCurrentEditItemNew) {
                    this.sourceArray.push(item);
                    this._totalItemCount.inc();
                }
                var filter = this._shape._compiledFilter;
                if(!filter.isEmpty && !filter.func(item)) {
                    data.util.remove(this.local, item);
                }
                this.trigger();
            };
            ArrayDataViewBase.prototype._getItem = //#endregion editing
            function (itemOrIndex) {
                var index;
                if(data.util.isNumeric(itemOrIndex)) {
                    return this.item(itemOrIndex);
                } else {
                    return itemOrIndex;
                }
            };
            ArrayDataViewBase.prototype._resolve = function (itemOrIndex, raiseIfNotContained) {
                if (typeof raiseIfNotContained === "undefined") { raiseIfNotContained = false; }
                var index;
                if(data.util.isNumeric(itemOrIndex)) {
                    return {
                        index: itemOrIndex,
                        item: this.item(itemOrIndex)
                    };
                } else {
                    index = this.indexOf(itemOrIndex);
                    if(index < 0) {
                        if(raiseIfNotContained) {
                            data.errors.itemNotInView(itemOrIndex);
                        }
                        return null;
                    }
                    return {
                        index: index,
                        item: itemOrIndex
                    };
                }
            };
            return ArrayDataViewBase;
        })();
        data.ArrayDataViewBase = ArrayDataViewBase;        
        var ArrayDataView = (function (_super) {
            __extends(ArrayDataView, _super);
            function ArrayDataView(source, shape) {
                        _super.call(this, shape);
                this.sourceArray = source;
                this.refresh();
            }
            return ArrayDataView;
        })(ArrayDataViewBase);
        data.ArrayDataView = ArrayDataView;        
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    /// <reference path="arrayDataView.ts"/>
    (function (data) {
        var $ = jQuery;
        var RemoteDataView = (function (_super) {
            __extends(RemoteDataView, _super);
            function RemoteDataView(options) {
                        _super.call(this);
                this.isRemote = true;
                this.sourceArray = [];
                if(options) {
                    this._construct(options);
                }
            }
            RemoteDataView.prototype._construct = function (options) {
                this.options = options = $.extend({
                    localPaging: false
                }, options);
                this.localPaging = options.localPaging;
                this._updateShape(options);
            };
            return RemoteDataView;
        })(data.ArrayDataViewBase);
        data.RemoteDataView = RemoteDataView;        
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 * ----
 * Credits: Wijmo includes some MIT-licensed software, see copyright notices below.
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts" />
    /// <reference path="../External/declarations/jquery.mousewheel.d.ts" />
    /*globals window,document,jQuery*/
    /*
    * Depends:
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.ui.resizable.js
    *	jquery.ui.mouse.js
    *	jquery.wijmo.wijutil.js
    *
    */
    (function (superpanel) {
        "use strict";
        var $ = jQuery;
        var wijsuperpanel_options = (function () {
            function wijsuperpanel_options() {
                /**
                * wijCSS.
                * @ignore
                */
                this.wijCSS = {
                    superpanelHeader: "wijmo-wijsuperpanel-header",
                    superpanelFooter: "wijmo-wijsuperpanel-footer",
                    superpanelHandle: "",
                    superpanelVBarbuttonTop: "",
                    superpanelVBarbuttonBottom: "",
                    superpanelHBarbuttonLeft: "",
                    superpanelHBarbuttonRight: "",
                    superpanelHBarContainer: "",
                    superpanelVBarContainer: "",
                    superpanelButton: "",
                    superpanelButtonLeft: "",
                    superpanelButtonRight: "",
                    superpanelButtonTop: "",
                    superpanelButtonBottom: ""
                };
                /**
                * wijMobileCSS.
                * @ignore
                */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-b",
                    stateDefault: "ui-btn ui-btn-b",
                    stateHover: "ui-btn-down-c",
                    stateActive: "ui-btn-down-c"
                };
                /**
                * Selector option for auto self initialization.
                * This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijsuperpanel')";
                /** The value determines whether the wijsuperpanel can be resized.
                */
                this.allowResize = false;
                /** This value determines whether wijsuperpanel is automatically refreshed when the content size or wijsuperpanel size are changed.
                * Set this value to true if you load images in the wijsuperpanel without specifying their sizes.
                */
                this.autoRefresh = false;
                /** The animationOptions function determines whether or not the animation is shown. If true, it defines the animation effect and controls other aspects of the widget's animation, such as duration, queue, and easing.
                * @example
                * $('#superPanel').wijsuperpanel({
                *     animationOptions: {
                *         disabled: false,
                *         duration: 1000,
                *         easing: easeInQuad
                *     }
                *   });
                * @remarks
                * Set this options to null to disable animation.
                */
                this.animationOptions = {
                    queue: /**
                    * This value determines whether to queue animation operations.
                    * @type {boolean}
                    */
                    false,
                    disabled: /** This value determines whether to disable animation operations.
                    * @type {boolean}
                    */
                    false,
                    duration: /** This value sets the animation duration of the scrolling animation.
                    * @type {number}
                    */
                    250,
                    easing: /** Sets the type of animation easing effect that users experience as the panel is scrolled. You can create custom easing animations using jQuery UI Easings.
                    * @type {string}
                    */
                    undefined
                };
                /** The hScrollerActivating event handler.
                * A function called when horizontal scrollbar is activating.
                * @event
                * @dataKey {string} direction The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} targetBarLen The width of the horizontal scrollbar.
                * @dataKey {object} contentLength The width of the content.
                */
                this.hScrollerActivating = null;
                /**
                *This option contains horizontal scroller settings.
                */
                this.hScroller = {
                    scrollBarPosition: /*
                    * This value determines the position of the horizontal scroll bar.
                    * @type {string}
                    * @remarks
                    * Possible options are "bottom" and "top".
                    * "bottom" - The horizontal scroll bar is placed at the bottom of
                    * the content area.
                    * "top" - The horizontal scroll bar is placed at the top of the
                    *content area.
                    */
                    "bottom",
                    scrollBarVisibility: /** This value determines the visibility of the horizontal scroll bar.
                    * @type {string}
                    * @remarks
                    * Possible options are "auto", "visible" and "hidden".
                    * "auto" - Shows the scroll when needed.
                    * "visible" - The Scroll bar is always visible. It is disabled
                    * when not needed.
                    * "hidden" - The Scroll bar is hidden.
                    */
                    "auto",
                    scrollMode: /** This value determines the scroll mode of horizontal scrolling.
                    * @type {string}
                    * @remarks
                    * Possible options are "scrollBar", "buttons", "buttonsHover"
                    * and "edge".
                    * "scrollBar" - Scroll bars are used for scrolling.
                    * "buttons" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are clicked.
                    * "buttonsHover" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are hovered.
                    * "edge" - Scrolling occurs when the mouse is moving to the edge
                    * of the content area.
                    * Scroll modes can be combined with each other.
                    * For example, scrollMode: "scrollbar,scrollbuttons" will enable
                    * both a scrollbar and scroll buttons.
                    */
                    "scrollBar",
                    scrollValue: /** This value determines the horizontal scrolling position of
                    * wijsuperpanel.
                    * @type {number}
                    */
                    null,
                    scrollMax: /** This value sets the maximum value of the horizontal scroller.
                    * @type {number}
                    */
                    100,
                    scrollMin: /** This value sets the minimum value of the horizontal scroller.
                    * @type {number}
                    */
                    0,
                    scrollLargeChange: /** This value sets the large change value of the horizontal scroller.
                    * @type {number}
                    * @remarks
                    * Wijsuperpanel will scroll a large change when a user clicks on the
                    * tracks of scroll bars or presses left or right arrow keys on the
                    * keyboard with the shift key down.
                    * When scrollLargeChange is null, wijsuperpanel will scroll
                    * the width of content.
                    */
                    null,
                    scrollSmallChange: /** This value sets the small change value of the horizontal scroller.
                    * @type {number}
                    * @remarks
                    * Wijsuperpanel will scroll a small change when a user clicks on
                    * the arrows of scroll bars, clicks or hovers scroll buttons,
                    * presses left or right arrow keys on keyboard,
                    * and hovers on the edge of wijsuperpanel.
                    * When scrollSmallChange is null, wijsuperpanel will scroll half of
                    * the width of content.
                    */
                    null,
                    scrollMinDragLength: /** This value sets the minimum length, in pixel, of the horizontal
                    * scroll bar thumb button.
                    * @type {number}
                    */
                    6,
                    increaseButtonPosition: /** This is an object that determines the increase button position.
                    * @type {object}
                    */
                    /* @remarks
                    * Please look at the options for jquery.ui.position.js for more info.
                    */
                    null,
                    decreaseButtonPosition: /** This is an object that determines the decrease button position.
                    * @type {object}
                    */
                    null,
                    hoverEdgeSpan: /** This value sets the width, in pixels, of the horizontal hovering edge which will trigger the horizontal scrolling.
                    * @type {number}
                    */
                    20,
                    firstStepChangeFix: /** This number specifies the value to add to smallchange or largechange when scrolling the first step (scrolling from scrollMin).
                    * @type {number}
                    */
                    0
                };
                /** This value determines whether wijsuperpanel provides keyboard scrolling support.
                */
                this.keyboardSupport = false;
                /** This value determines the time interval to call the scrolling function when doing continuous scrolling.
                */
                this.keyDownInterval = 100;
                /** This value determines whether wijsuperpanel has mouse wheel support.
                * @remarks
                * Mouse wheel plugin is needed to support this feature.
                */
                this.mouseWheelSupport = true;
                /** This value determines whether to fire the mouse wheel event when wijsuperpanel is scrolled to the end.
                */
                this.bubbleScrollingEvent = true;
                /** This option determines the behavior of the resizable widget. See the JQuery UI resizable options document for more information.
                * @type {object}
                */
                this.resizableOptions = {
                    handles: "all",
                    helper: "ui-widget-content wijmo-wijsuperpanel-helper"
                };
                /** Resized event handler. This function gets called when the resized event is fired.
                * @event
                */
                this.resized = null;
                /** This function gets called when the user stops dragging the thumb buttons of the scrollbars.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                */
                this.dragStop = null;
                /** This function gets called after panel is painted.
                * @event
                */
                this.painted = null;
                /** Scrolling event handler. A function called before scrolling occurs.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {number} oldValue The scrollValue before scrolling occurs.
                * @dataKey {number} newValue The scrollValue after scrolling occurs.
                * @dataKey {object} beforePosition The position of content before scrolling occurs.
                */
                this.scrolling = null;
                /** Scroll event handler. This function is called before scrolling occurs.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} animationOptions TThe options of the animation which scrolling uses.
                * @dataKey {object} position The position of content after scrolling occurs.
                */
                this.scroll = null;
                /** Scrolled event handler. This function gets called after scrolling occurs.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} beforePosition The position of content before scrolling occurs.
                * @dataKey {object} afterPosition The position of content after scrolling occurs.
                */
                this.scrolled = null;
                /** This value determines whether to show the rounded corner of wijsuperpanel.
                * @type {boolean}
                */
                this.showRounder = true;
                /** A function called when the vertical scrollbar is activating.
                * @event
                * @dataKey {string} direction The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} targetBarLen The width of the vertical scrollbar.
                * @dataKey {object} contentLength The width of the content.
                */
                this.vScrollerActivating = null;
                /** This option contains vertical scroller settings.
                */
                this.vScroller = {
                    scrollBarPosition: /**
                    * This value determines the position of the vertical scroll bar.
                    * @type {String}
                    * @remarks
                    * Possible options are: "left", "right".
                    * "left" - The vertical scroll bar is placed at the
                    * left side of the content area.
                    * "right" - The vertical scroll bar is placed at the
                    * right side of the content area.
                    */
                    "right",
                    scrollBarVisibility: /** This value determines the visibility of the vertical scroll bar.
                    * Default.: "auto".
                    * @type {string}
                    * @remarks
                    * Possible options are "auto", "visible" and "hidden".
                    * "auto" - Shows the scroll bar when needed.
                    * "visible" - Scroll bar will always be visible.
                    * It"s disabled when not needed.
                    * "hidden" - Scroll bar will be shown.
                    */
                    "auto",
                    scrollMode: /** This value determines the scroll mode of vertical scrolling.
                    * @type {string}
                    * @remarks
                    * Possible options are: "scrollBar", "buttons",
                    * "buttonsHover" and "edge".
                    * "scrollBar" - Scroll bars are used for scrolling.
                    * "buttons" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are clicked.
                    * "buttonsHover" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are hovered.
                    * "edge" - Scrolling occurs when the mouse is moving to
                    * the edge of the content area.
                    * Scroll modes can be combined with each other.
                    * For example, vScrollMode: "scrollbar,scrollbuttons" will enable
                    * both a scrollbar and scroll buttons.
                    */
                    "scrollBar",
                    scrollValue: /** This number determines the vertical scrolling position of
                    * wijsuperpanel.
                    * @type {number}
                    */
                    null,
                    scrollMax: /** This number sets the maximum value of the vertical scroller.
                    * @type {number}
                    */
                    100,
                    scrollMin: /** This number sets the minimum value of the vertical scroller.
                    * @type {number}
                    */
                    0,
                    scrollLargeChange: /** This value sets the large change value of the vertical scroller.
                    * @type {number}
                    * @remarks
                    * wijsuperpanel will scroll a large change when a user clicks
                    * on the tracks of scroll bars or presses left or right arrow keys
                    * on the keyboard with the shift key down.
                    * When scrollLargeChange is null, wijsuperpanel
                    * will scroll the height of content.
                    */
                    null,
                    scrollSmallChange: /** This value sets the small change value of the vertical scroller.
                    * @type {number}
                    * @remarks
                    * wijsuperpanel will scroll a small change when a user clicks on the
                    * arrows of scroll bars, clicks or hovers scroll buttons, presses left
                    * or right arrow keys on keyboard, and hovers on the edge of
                    * wijsuperpanel.
                    * When scrollSmallChange is null, wijsuperpanel will scroll half of
                    * the height of content.
                    */
                    null,
                    scrollMinDragLength: /** This value sets the minimum length, in pixel, of the vertical
                    * scroll bar thumb button.
                    * @type {number}
                    */
                    6,
                    increaseButtonPosition: /** This object determines the increase button position.
                    * @type {object}
                    * @remarks
                    * Please look at the options for jquery.ui.position.js for more info.
                    */
                    null,
                    decreaseButtonPosition: /** This object determines the decrease button position.
                    * @type {object}
                    * @remarks
                    * Please look at the options for jquery.ui.position.js for more info.
                    */
                    null,
                    hoverEdgeSpan: /** This value sets the width of the horizontal hovering edge which will trigger the vertical scrolling.
                    * @type {number}
                    */
                    20,
                    firstStepChangeFix: /** This number specifies the value to add to smallchange or largechange when scrolling the first step (scrolling from scrollMin).
                    * @type {number}
                    */
                    0
                };
                /** Determines if use custom scrolling.
                */
                this.customScrolling = false;
                /** Determines if the native scroll events should be listened.
                */
                this.listenContentScroll = false;
            }
            return wijsuperpanel_options;
        })();        
        /** @widget */
        var wijsuperpanel = (function (_super) {
            __extends(wijsuperpanel, _super);
            function wijsuperpanel() {
                _super.apply(this, arguments);

            }
            wijsuperpanel.prototype.destroy = /**
            * Destroys wijsuperpanel widget and reset the DOM element.
            */
            function () {
            };
            wijsuperpanel.prototype.needToScroll = /**
            * Determine whether scoll the child DOM element to view
            * need to scroll the scroll bar
            * @param {DOMElement} child The child to scroll to.
            */
            function (child1) {
            };
            wijsuperpanel.prototype.scrollChildIntoView = /**
            * Scroll children DOM element to view.
            * @param {DOMElement} child The child to scroll to.
            */
            function (child1) {
            };
            wijsuperpanel.prototype.hScrollTo = /**
            * Scroll to horizontal position.
            * @param {number} x The position to scroll to.
            * @param {bool} isScrollValue A value that indicates whether x is value or pixel.
            */
            function (x, isScrollValue) {
            };
            wijsuperpanel.prototype.vScrollTo = /**
            * Scroll to vertical position.
            * @param {number} y The position to scroll to.
            * @param {bool} isScrollValue A value that indicates whether y is value or pixel.
            */
            function (y, isScrollValue) {
            };
            wijsuperpanel.prototype.scrollPxToValue = /**
            * Convert pixel to scroll value.
            * For example, wijsuperpanel scrolled 50px
            * which is value 1 after conversion.
            * @param {number} px Length of scrolling.
            * @param {string} dir Scrolling direction. Options are: "h" and "v".
            */
            function (px, dir) {
            };
            wijsuperpanel.prototype.scrollValueToPx = /**
            * Convert scroll value to pixel.
            * For example, scroll value is 1
            * which makes wijsuperpanel scrolled 50px after conversion.
            * @param {number} scroll value.
            * @param {string} dir Scrolling direction. Options are: "h" and "v".
            */
            function (value, dir) {
            };
            wijsuperpanel.prototype.scrollTo = /**
            * Scroll to the specified position.
            * which is value 1 after conversion.
            * @param {number} x Horizontal position to scroll to.
            * @param {number} y Vertical position to scroll to.
            * @param {bool} isScrollValue A value that indicates whether x, y are value or pixel.
            */
            function (x, y, isScrollValue) {
            };
            wijsuperpanel.prototype.refresh = /**
            * Refreshes wijsuperpanel.
            * Needs to be called after content being changed.
            * @returns {boolean} Returns true if it is successful, else returns false.
            */
            function () {
            };
            wijsuperpanel.prototype.paintPanel = /**
            * Refreshes wijsuperpanel.
            * Needs to be called after content being changed.
            * @returns {boolean} Returns true if it is successful, else returns false.
            */
            function (unfocus) {
            };
            wijsuperpanel.prototype.getContentElement = /**
            * Gets the content element of wijsuperpanel.
            * @example $("selector").wijsuperpanel("getContentElement");
            * @returns {jQuery}
            */
            function () {
            };
            return wijsuperpanel;
        })(wijmo.wijmoWidget);
        superpanel.wijsuperpanel = wijsuperpanel;        
        var superpanel_widget;
        if(!$.support.isTouchEnabled || !$.support.isTouchEnabled()) {
            var scrollerHandle = "wijmo-wijsuperpanel-handle", hbarContainerCSS = "wijmo-wijsuperpanel-hbarcontainer", vbarContainerCSS = "wijmo-wijsuperpanel-vbarcontainer", activeCss = "", innerElementHtml = "<div class='wijmo-wijsuperpanel-statecontainer'>" + "<div class='wijmo-wijsuperpanel-contentwrapper'>" + "<div class='wijmo-wijsuperpanel-templateouterwrapper'></div>" + "</div>" + "</div>", hbarHtml = "<div class='wijmo-wijsuperpanel-hbarcontainer {superpanelHBarContainer} {header}'>" + "<div class='wijmo-wijsuperpanel-handle {superpanelHandle} {stateDefault} {cornerAll}'>" + "<span class='{icon} {iconVGripSolid}'></span></div>" + "<div class='wijmo-wijsuperpanel-hbar-buttonleft {superpanelHBarbuttonLeft} {stateDefault} {cornerBL}'>" + "<span class='{icon} {iconArrowLeft}'></span></div>" + "<div class='wijmo-wijsuperpanel-hbar-buttonright {superpanelHBarbuttonRight} {stateDefault} {cornerBR}'>" + "<span class='{icon} {iconArrowRight}'></span></div>" + "</div>", vbarHtml = "<div class='wijmo-wijsuperpanel-vbarcontainer {superpanelVBarContainer} {header}'>" + "<div class='wijmo-wijsuperpanel-handle {superpanelHandle} {stateDefault} {cornerAll}'>" + "<span class='{icon} {iconHGripSolid}'></span></div>" + "<div class='wijmo-wijsuperpanel-vbar-buttontop {superpanelVBarbuttonTop} {stateDefault} {cornerTR}'>" + "<span class='{icon} {iconArrowUp}'></span></div>" + "<div class='wijmo-wijsuperpanel-vbar-buttonbottom {superpanelVBarbuttonBottom} {stateDefault} {cornerBR}'>" + "<span class='{icon} {iconArrowDown}'></span></div>" + "</div>", hButtons = "<div class='{stateDefault} wijmo-wijsuperpanel-button {superpanelButton} " + "wijmo-wijsuperpanel-buttonleft {superpanelButtonLeft}'><span class='{icon} {iconCaratLeft}'>" + "</span></div><div class='{stateDefault}" + " wijmo-wijsuperpanel-button {superpanelButton} wijmo-wijsuperpanel-buttonright {superpanelButtonRight}'>" + "<span class='{icon} {iconCaratRight}'></span></div>", vButtons = "<div class='{stateDefault} wijmo-wijsuperpanel-button {superpanelButton} " + " wijmo-wijsuperpanel-buttontop {superpanelButtonTop}'><span class='{icon} {iconCaratUp}'>" + "</span></div><div class='{stateDefault} wijmo-wijsuperpanel-button {superpanelButton}" + " wijmo-wijsuperpanel-buttonbottom {superpanelButtonBottom}'><span class='{icon} {iconCaratDown}'>" + " </span></div>";
            wijsuperpanel.prototype = $.extend(true, {
            }, $.Widget.prototype, {
                widgetEventPrefix: "wijsuperpanel",
                _setOption: function (key, value) {
                    var self = this, o = self.options, f = self._fields(), hd = f.hbarDrag, vd = f.vbarDrag, r = f.resizer;
                    // override existing
                    if(key === "animationOptions") {
                        value = $.extend(o.animationOptions, value);
                    } else if(key === "hScroller") {
                        if(value.scrollLargeChange !== undefined && value.scrollLargeChange !== null) {
                            self._autoHLarge = false;
                        }
                        value = $.extend(o.hScroller, value);
                        self._adjustScrollValue("h");
                        self.refresh();
                    } else if(key === "vScroller") {
                        if(value.scrollLargeChange !== undefined && value.scrollLargeChange !== null) {
                            self._autoVLarge = false;
                        }
                        self._adjustScrollValue("v");
                        value = $.extend(o.vScroller, value);
                        self.refresh();
                    } else if(key === "resizableOptions") {
                        value = $.extend(self.resizableOptions, value);
                    }
                    $.Widget.prototype._setOption.apply(self, arguments);
                    if($.isPlainObject(value)) {
                        self.options[key] = value;
                    }
                    switch(key) {
                        case "allowResize":
                            self._initResizer();
                            break;
                        case "disabled":
                            if(value) {
                                if(hd !== undefined) {
                                    hd.draggable("disable");
                                }
                                if(vd !== undefined) {
                                    vd.draggable("disable");
                                }
                                if(r !== undefined) {
                                    r.resizable("disable");
                                }
                            } else {
                                if(hd !== undefined) {
                                    hd.draggable("enable");
                                }
                                if(vd !== undefined) {
                                    vd.draggable("enable");
                                }
                                if(r !== undefined) {
                                    r.resizable("enable");
                                }
                            }
                            break;
                        case "mouseWheelSupport":
                        case "keyboardSupport":
                            self._bindElementEvents(self, f, self.element, o);
                            break;
                    }
                    return self;
                },
                _create: function () {
                    var self = this, o = self.options;
                    o.vScroller.dir = "v";
                    o.hScroller.dir = "h";
                    self._initMarkup();
                    self.paintPanel(o.unfocus);
                    self._initResizer();
                    if(self.options.disabled) {
                        self.disable();
                    }
                    self._detectAutoRefresh();
                    if(o.listenContentScroll) {
                        self._listenContentScroll();
                    }
                    //update for visibility change
                    if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                        self.element.wijAddVisibilityObserver(function () {
                            if(self.element.wijRemoveVisibilityObserver) {
                                self.element.wijRemoveVisibilityObserver();
                            }
                            self.refresh();
                        }, "wijsuperpanel");
                    }
                },
                _initMarkup: function () {
                    var css = this.options.wijCSS, reg = /\{(\w+?)\}/ig, callback = function (i, g1) {
                        return css[g1];
                    };
                    activeCss = css.stateActive;
                    hbarHtml = hbarHtml.replace(reg, callback);
                    vbarHtml = vbarHtml.replace(reg, callback);
                    hButtons = hButtons.replace(reg, callback);
                    vButtons = vButtons.replace(reg, callback);
                },
                _detectAutoRefresh: function () {
                    // register with auto fresh.
                                        var self = this, panels = $.wijmo.wijsuperpanel.panels;
                    if(panels === undefined) {
                        panels = [];
                        $.wijmo.wijsuperpanel.panels = panels;
                    }
                    panels.push(self);
                    // start timer to monitor content.
                    if(self.options.autoRefresh) {
                        if(!$.wijmo.wijsuperpanel.setAutoRefreshInterval) {
                            $.wijmo.wijsuperpanel.setAutoRefreshInterval = self._setAutoRefreshInterval;
                            $.wijmo.wijsuperpanel.setAutoRefreshInterval();
                        }
                    }
                },
                _setAutoRefreshInterval: function () {
                    var interval = $.wijmo.wijsuperpanel.autoRereshInterval, panels = $.wijmo.wijsuperpanel.panels, intervalID;
                    intervalID = window.setInterval(function () {
                        window.clearInterval(intervalID);
                        var count = panels.length, toContinue = false, i, panel, mainElement, autoRefresh, ele, mark;
                        for(i = 0; i < count; i++) {
                            panel = panels[i];
                            mainElement = panel.element[0];
                            autoRefresh = panel.options.autoRefresh;
                            if(autoRefresh) {
                                toContinue = true;
                            }
                            ele = panel.getContentElement();
                            mark = panel._paintedMark;
                            if(autoRefresh && ele.is(":visible") && (mark === undefined || mark.width !== ele[0].offsetWidth || mark.height !== ele[0].offsetHeight || mark.mainWidth !== mainElement.offsetWidth || mark.mainHeight !== mainElement.offsetHeight)) {
                                panel.paintPanel();
                            }
                        }
                        if(toContinue) {
                            window.setTimeout($.wijmo.wijsuperpanel.setAutoRefreshInterval, 0);
                        }
                    }, interval === undefined ? 500 : interval);
                },
                destroy: /**
                * Destroys wijsuperpanel widget and reset the DOM element.
                */
                function () {
                    var self = this, f = self._fields(), ele = self.element, buttons, templateWrapper, wijCSS = self.options.wijCSS;
                    // remove this widget from panels array.
                    $.wijmo.wijsuperpanel.panels = $.grep($.wijmo.wijsuperpanel.panels, function (value) {
                        return value !== self;
                    }, false);
                    if(!f.initialized) {
                        return;
                    }
                    if(self._radiusKey) {
                        self.element.css(self._radiusKey, "");
                    }
                    if(f.intervalID !== undefined) {
                        window.clearInterval(f.intervalID);
                        f.intervalID = undefined;
                    }
                    // destory widgets
                    if(f.resizer !== undefined) {
                        f.resizer.resizable("destroy");
                    }
                    if(f.hbarContainer !== undefined) {
                        f.hbarDrag.remove();
                        f.hbarContainer.unbind("." + self.widgetName);
                    }
                    if(f.vbarContainer !== undefined) {
                        f.vbarDrag.remove();
                        f.vbarContainer.unbind("." + self.widgetName);
                    }
                    ele.unbind("." + self.widgetName);
                    f.contentWrapper.unbind("." + self.widgetName);
                    buttons = f.stateContainer.find(">.wijmo-wijsuperpanel-button");
                    buttons.unbind("." + self.widgetName);
                    templateWrapper = f.templateWrapper;
                    templateWrapper.contents().each(function (index, e) {
                        ele.append(e);
                    });
                    f.stateContainer.remove();
                    if(f.tabindex) {
                        ele.removeAttr("tabindex");
                    }
                    ele.removeClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content, 
                        wijCSS.cornerAll
                    ].join(' '));
                    $.Widget.prototype.destroy.apply(self, arguments);
                },
                _fields: function () {
                    var self = this, ele = self.element, key = self.widgetName + "-fields", d = self._fieldsStore;
                    if(d === undefined) {
                        d = {
                        };
                        ele.data(key, d);
                        self._fieldsStore = d;
                    }
                    return d;
                },
                _hasMode: function (scroller, mode) {
                    var modes = scroller.scrollMode.split(",");
                    modes = $.map(modes, function (n) {
                        return $.trim(n).toLowerCase();
                    });
                    return $.inArray(mode.toLowerCase(), modes) > -1;
                },
                _bindElementEvents: function (self, f, ele, o) {
                    // mouse move only edge mode is used.
                                        var hEdge = self._hasMode(o.hScroller, "edge"), vEdge = self._hasMode(o.vScroller, "edge"), wn = self.widgetName;
                    if(hEdge || vEdge) {
                        if(self._mousemoveBind === undefined) {
                            self._mousemoveBind = true;
                            ele.bind("mousemove." + wn, self, self._contentMouseMove);
                            ele.bind("mouseleave." + wn, null, function () {
                                self._clearInterval();
                            });
                        }
                    } else {
                        ele.unbind("mousemove", self._contentMouseMove);
                        self._mousemoveBind = undefined;
                    }
                    if(o.mouseWheelSupport) {
                        if(self._mouseWheelBind === undefined) {
                            self._mouseWheelBind = true;
                            ele.bind("mousewheel." + wn, self, self._panelMouseWheel);
                        }
                    } else {
                        ele.unbind("mousewheel", self._panelMouseWheel);
                        self._mouseWheelBind = undefined;
                    }
                    if(o.keyboardSupport) {
                        if(self._keyboardBind === undefined) {
                            self._keyboardBind = true;
                            ele.bind("keydown." + wn, self, self._panelKeyDown);
                        }
                    } else {
                        ele.unbind("keydown", self._panelKeyDown);
                        self._keyboardBind = undefined;
                    }
                },
                _dragStop: function (e, self, dir) {
                    // Handles mouse drag stop event of thumb button.
                    var data = {
                        dragHandle: dir
                    };
                    self._trigger("dragStop", e, data);
                },
                _contentMouseMove: function (e) {
                    // Handles mouse move event of content area.
                    // Edge hover scrolling is handled in this method.
                    if(e.data.options.disabled) {
                        return;
                    }
                    var self = e.data, o = self.options, hScroller = o.hScroller, vScroller = o.vScroller, contentWrapper = $(e.currentTarget), f = self._fields(), hMode = self._hasMode(hScroller, "edge"), vMode = self._hasMode(vScroller, "edge"), mousePagePosition = {
                        X: e.pageX,
                        Y: e.pageY
                    }, off = contentWrapper.offset(), left = off.left, top = off.top, hEdge = hScroller.hoverEdgeSpan, vEdge = vScroller.hoverEdgeSpan, innerHeight = contentWrapper.innerHeight(), innerWidth = contentWrapper.innerWidth(), dir = "";
                    left = mousePagePosition.X - left;
                    top = mousePagePosition.Y - top;
                    self._clearInterval();
                    if(hMode) {
                        if(left < hEdge) {
                            dir = "left";
                        }
                        if(left > (innerWidth - hEdge)) {
                            dir = "right";
                        }
                    }
                    if(vMode) {
                        if(top < vEdge) {
                            dir = "top";
                        }
                        if(top > (innerHeight - vEdge)) {
                            dir = "bottom";
                        }
                    }
                    self._setScrollingInterval(f, dir, self, false);
                },
                _setScrollingInterval: function (f, dir, self, large) {
                    var o = self.options;
                    if(dir.length > 0) {
                        f.internalFuncID = window.setInterval(function () {
                            self._doScrolling(dir, self, large);
                        }, o.keyDownInterval);
                    }
                },
                _scrollButtonMouseOver: function (e) {
                    // Scroll buttons mouse over event handler.
                                        var self = e.data, o = self.options, button = $(e.currentTarget);
                    if(o.disabled) {
                        return;
                    }
                    if(!button.hasAllClasses(o.wijCSS.stateDisabled)) {
                        button.bind("mouseout." + self.widgetName, self, self._buttonMouseOut).bind("mousedown." + self.widgetName, self, self._buttonMouseDown).bind("mouseup." + self.widgetName, self, self._buttonMouseUp).addClass(o.wijCSS.stateHover);
                        self._buttonScroll(button, self, "buttonshover");
                    }
                },
                _buttonScroll: function (button, self, mode) {
                    // Do button scroll.
                                        var dir = "", o = self.options, f = self._fields(), hMode = self._hasMode(o.hScroller, mode), vMode = self._hasMode(o.vScroller, mode);
                    if(button.hasClass("wijmo-wijsuperpanel-buttonleft") && hMode) {
                        dir = "left";
                    } else if(button.hasClass("wijmo-wijsuperpanel-buttonright") && hMode) {
                        dir = "right";
                    } else if(button.hasClass("wijmo-wijsuperpanel-buttontop") && vMode) {
                        dir = "top";
                    } else if(button.hasClass("wijmo-wijsuperpanel-buttonbottom") && vMode) {
                        dir = "bottom";
                    }
                    if(dir.length > 0) {
                        self._clearInterval();
                        self._doScrolling(dir, self, true);
                        self._setScrollingInterval(f, dir, self, true);
                    }
                },
                _listenContentScroll: function () {
                    var self = this, o = self.options, f = self._fields(), hbarContainer = f.hbarContainer, hbarDrag = f.hbarDrag, vbarContainer = f.vbarContainer, vbarDrag = f.vbarDrag, templateWrapper = f.templateWrapper, contentWrapper = f.contentWrapper, w = contentWrapper.width(), h = contentWrapper.height(), offset = templateWrapper && templateWrapper.offset(), ox = offset && offset.left, oy = offset && offset.top, contentWidth = f.contentWidth, contentHeight = f.contentHeight;
                    contentWrapper.bind("scroll", function (event) {
                        var pos = templateWrapper.position(), x = pos.left, y = pos.top;
                        contentWrapper.scrollTop(0).scrollLeft(0);
                        templateWrapper.css({
                            left: x,
                            top: y
                        });
                        if(x <= 0 && x > w - contentWidth) {
                            self._updateScrollValue(self.scrollPxToValue(-x, "h"), o.hScroller);
                            self._scrollDrag("h", hbarContainer, hbarDrag, true);
                        }
                        if(y <= 0 && y > h - contentHeight) {
                            self._updateScrollValue(self.scrollPxToValue(-y, "v"), o.vScroller);
                            self._scrollDrag("v", vbarContainer, vbarDrag, true);
                        }
                    });
                },
                _buttonMouseDown: function (e) {
                    var self = e.data, button = $(e.currentTarget), wijCSS = self.options.wijCSS;
                    if(self.options.disabled) {
                        return;
                    }
                    if(!button.hasAllClasses(wijCSS.stateDisabled)) {
                        button.addClass(wijCSS.stateActive);
                        self._buttonScroll(button, self, "buttons");
                    }
                },
                _buttonMouseUp: function (e) {
                    var self = e.data, button = $(e.currentTarget);
                    button.removeClass(self.options.wijCSS.stateActive);
                    self._clearInterval();
                },
                _buttonMouseOut: function (e) {
                    var self = e.data, wijCSS = self.options.wijCSS, button = $(e.currentTarget);
                    button.unbind("mouseout", self._buttonMouseOut).unbind("mousedown", self._buttonMouseDown).unbind("mouseup", self._buttonMouseUp).removeClass(wijCSS.stateHover).removeClass(wijCSS.stateActive);
                    self._clearInterval();
                },
                _updateScrollValue: function (val, scroller) {
                    var ev = $.Event("scrollValueChanged");
                    scroller.scrollValue = val;
                    //TODO: add this event into options
                    this._trigger("scrollValueChanged", ev, scroller);
                },
                _panelKeyDown: function (e) {
                    // Key down handler.
                                        var self = e.data, o = self.options, shift = e.shiftKey, keycode = e.keyCode, kCode = wijmo.getKeyCodeEnum();
                    if(!o.keyboardSupport || o.disabled) {
                        return;
                    }
                    if(keycode === kCode.LEFT) {
                        self._doScrolling("left", self, shift);
                    } else if(keycode === kCode.RIGHT) {
                        self._doScrolling("right", self, shift);
                    } else if(keycode === kCode.UP) {
                        self._doScrolling("top", self, shift);
                    } else if(keycode === kCode.DOWN) {
                        self._doScrolling("bottom", self, shift);
                    }
                    e.stopPropagation();
                    e.preventDefault();
                },
                _draggingInternal: function (data, self, scroller, originalElement) {
                    var dir = scroller.dir, h = dir === "h", key = h ? "left" : "top", left = //the parameter from draggable widget is supposed to
                    //be used instead of the style property of html element
                    data.position[key] - self._getScrollContainerPadding(key), track = self._getTrackLen(dir) - originalElement[h ? "outerWidth" : "outerHeight"](true), proportion = left / track, topValue = (scroller.scrollMax - scroller.scrollLargeChange + 1), v = proportion * topValue, arg, scrollValue, val;
                    if(v < scroller.scrollMin) {
                        v = scroller.scrollMin;
                    }
                    if(v > topValue) {
                        v = topValue;
                    }
                    arg = {
                        oldValue: scroller.scrollValue,
                        newValue: v,
                        dir: dir
                    };
                    if(!self._scrolling(true, self, arg)) {
                        // event is canceled in scrolling.
                        return;
                    }
                    if(self.customScroll) {
                        val = Math.abs(self.customScroll);
                        scrollValue = self.scrollPxToValue(val, scroller.dir);
                    }
                    self._updateScrollValue(scrollValue || v, scroller);
                    self.customScroll = undefined;
                    self._setDragAndContentPosition(true, false, dir, "dragging");
                },
                _dragging: function (e, data, self) {
                    var o = self.options, originalElement = $(e.target), p = originalElement.parent();
                    if(p.hasAllClasses(hbarContainerCSS)) {
                        self._draggingInternal(data, self, o.hScroller, originalElement);
                    } else {
                        self._draggingInternal(data, self, o.vScroller, originalElement);
                    }
                },
                _panelMouseWheel: function (e, delta) {
                    var self = e.data, o = self.options, originalElement, dir = "", onHbar, hScroller = o.hScroller, vScroller = o.vScroller, scrollEnd;
                    if(!o.mouseWheelSupport || o.disabled) {
                        return;
                    }
                    originalElement = $(e.srcElement || e.originalEvent.target);
                    onHbar = originalElement.closest("." + hbarContainerCSS, self.element).size() > 0;
                    if(delta > 0) {
                        dir = onHbar ? "left" : "top";
                    } else {
                        dir = onHbar ? "right" : "bottom";
                    }
                    if(dir.length > 0) {
                        self._doScrolling(dir, self);
                    }
                    scrollEnd = false;
                    if(dir === "left") {
                        scrollEnd = !self.hNeedScrollBar || Math.abs(hScroller.scrollValue - hScroller.scrollMin) < 0.001;
                    }
                    if(dir === "right") {
                        scrollEnd = !self.hNeedScrollBar || Math.abs(hScroller.scrollValue - (hScroller.scrollMax - self._getHScrollBarLargeChange() + 1)) < 0.001;
                    }
                    if(dir === "top") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - vScroller.scrollMin) < 0.001;
                    }
                    if(dir === "bottom") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - (vScroller.scrollMax - self._getVScrollBarLargeChange() + 1)) < 0.001;
                    }
                    if(!scrollEnd || !o.bubbleScrollingEvent || dir === "left" || dir === "right") {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                },
                _documentMouseUp: function (e) {
                    var self = e.data.self, ele = e.data.ele;
                    ele.removeClass(self.options.wijCSS.stateActive);
                    self._clearInterval();
                    $(document).unbind("mouseup", self._documentMouseUp);
                },
                _scrollerMouseOver: function (e) {
                    var self = e.data, o = self.options, originalElement, ele = null, addhover = false;
                    if(o.disabled) {
                        return;
                    }
                    //Fixed an issue in IE8, In IE8, the originalElement can't get by e.originalEvent.target
                    originalElement = $(e.srcElement || e.originalEvent.target || e.originalEvent.srcElement);
                    if(originalElement.hasAllClasses(o.wijCSS.stateDefault)) {
                        ele = originalElement;
                        addhover = true;
                    } else if(originalElement.parent().hasAllClasses(o.wijCSS.stateDefault)) {
                        ele = originalElement.parent();
                        addhover = true;
                    } else if(originalElement.hasAllClasses(vbarContainerCSS) || originalElement.hasAllClasses(hbarContainerCSS)) {
                        ele = originalElement;
                    }
                    if(ele) {
                        if(addhover) {
                            ele.addClass(o.wijCSS.stateHover);
                        }
                        ele.bind("mouseout." + self.widgetName, self, self._elementMouseOut);
                        ele.bind("mousedown." + self.widgetName, self, self._elementMouseDown);
                        ele.bind("mouseup." + self.widgetName, self, self._elementMouseUp);
                    }
                },
                _elementMouseUp: function (e) {
                    var ele = $(e.currentTarget);
                    ele.removeClass(activeCss);
                },
                _elementMouseDown: function (e) {
                    var ele = $(e.currentTarget), self = e.data, hbarDrag, vbarDrag, scrollDirection = "", large = false, active = false, pos, pos2, f;
                    if(self.options.disabled || e.which !== 1) {
                        return;
                    }
                    if(ele.hasClass("wijmo-wijsuperpanel-vbar-buttontop")) {
                        scrollDirection = "top";
                        active = true;
                    } else if(ele.hasClass("wijmo-wijsuperpanel-vbar-buttonbottom")) {
                        scrollDirection = "bottom";
                        active = true;
                    } else if(ele.hasClass("wijmo-wijsuperpanel-hbar-buttonleft")) {
                        scrollDirection = "left";
                        active = true;
                    } else if(ele.hasClass("wijmo-wijsuperpanel-hbar-buttonright")) {
                        scrollDirection = "right";
                        active = true;
                    } else if(ele.hasAllClasses(scrollerHandle)) {
                        ele.addClass(activeCss);
                        return;
                    } else if(ele.hasAllClasses(hbarContainerCSS)) {
                        hbarDrag = ele.find("." + scrollerHandle);
                        pos = hbarDrag.offset();
                        if(e.pageX < pos.left) {
                            scrollDirection = "left";
                        } else {
                            scrollDirection = "right";
                        }
                        large = true;
                    } else if(ele.hasAllClasses(vbarContainerCSS)) {
                        vbarDrag = ele.find("." + scrollerHandle);
                        pos2 = vbarDrag.offset();
                        if(e.pageY < pos2.top) {
                            scrollDirection = "top";
                        } else {
                            scrollDirection = "bottom";
                        }
                        large = true;
                    }
                    self._clearInterval();
                    self._doScrolling(scrollDirection, self, large);
                    f = self._fields();
                    self._setScrollingInterval(f, scrollDirection, self, large);
                    if(active) {
                        ele.addClass(activeCss);
                    }
                    $(document).bind("mouseup." + self.widgetName, {
                        self: self,
                        ele: ele
                    }, self._documentMouseUp);
                },
                doScrolling: /**
                * Do scrolling.
                * @param {string} dir Scrolling direction. Options are: "left", "right", "top" and "bottom".
                * @param {boolean} large Whether to scroll a large change.
                */
                function (dir, large) {
                    this._doScrolling(dir, this, large);
                },
                _setScrollerValue: function (dir, scroller, smallChange, largeChange, isAdd, isLarge, self) {
                    var vMin = scroller.scrollMin, change = isLarge ? largeChange : smallChange, value = scroller.scrollValue, t = 0, vTopValue, firstStepChangeFix, data, scrollValue, val;
                    if(!value) {
                        value = vMin;
                    }
                    vTopValue = scroller.scrollMax - largeChange + 1;
                    if(value > vTopValue) {
                        value = vTopValue;
                    }
                    if(isAdd) {
                        if(Math.abs(value - vTopValue) < 0.001) {
                            self._clearInterval();
                            return false;
                        }
                        firstStepChangeFix = scroller.firstStepChangeFix;
                        t = value + change;
                        if(!isLarge && Math.abs(value - vMin) < 0.0001 && !isNaN(firstStepChangeFix)) {
                            t += firstStepChangeFix;
                        }
                        if(t > vTopValue) {
                            t = vTopValue;
                        }
                    } else {
                        if(Math.abs(value - vMin) < 0.001) {
                            self._clearInterval();
                            return false;
                        }
                        t = value - change;
                        if(t < 0) {
                            t = vMin;
                        }
                    }
                    data = {
                        oldValue: scroller.scrollValue,
                        newValue: t,
                        direction: dir,
                        dir: scroller.dir
                    };
                    if(!self._scrolling(true, self, data)) {
                        return false;
                    }
                    if(self.customScroll) {
                        val = Math.abs(self.customScroll);
                        scrollValue = self.scrollPxToValue(val, scroller.dir);
                    }
                    self._updateScrollValue(scrollValue || t, scroller);
                    self.customScroll = undefined;
                    return true;
                },
                _doScrolling: function (dir, self, large) {
                    // Does wijsuperpanel scrolling.
                    // <param name="dir" type="String">
                    // Scroll direction.
                    // Options are: "left", "right", "top" and "bottom".
                    // </param>
                    // <param name="self" type="jQuery">
                    // Pointer to the wijsuperpanel widget instance.
                    // </param>
                    // <param name="large" type="Boolean">
                    // Whether to scroll a large change.
                    // </param>
                                        var o = self.options, vScroller = o.vScroller, hScroller = o.hScroller, vSmall = self._getVScrollBarSmallChange(), vLarge = self._getVScrollBarLargeChange(), hLarge = self._getHScrollBarLargeChange(), hSmall = self._getHScrollBarSmallChange();
                    if(dir === "top" || dir === "bottom") {
                        if(!self._setScrollerValue(dir, vScroller, vSmall, vLarge, dir === "bottom", large, self)) {
                            return;
                        }
                        dir = "v";
                    } else if(dir === "left" || dir === "right") {
                        if(!self._setScrollerValue(dir, hScroller, hSmall, hLarge, dir === "right", large, self)) {
                            return;
                        }
                        dir = "h";
                    }
                    self._setDragAndContentPosition(true, true, dir);
                },
                _disableButtonIfNeeded: function (self) {
                    // Disables scrolling buttons.
                                        var f = self._fields(), o = self.options, buttonLeft = f.buttonLeft, buttonRight = f.buttonRight, buttonTop = f.buttonTop, buttonBottom = f.buttonBottom, hLargeChange, hMax, hValue, hScrollMin, vLargeChange, vMax, vValue, vScrollMin;
                    if(f.intervalID > 0) {
                        window.clearInterval(f.intervalID);
                    }
                    if(buttonLeft !== undefined) {
                        hLargeChange = self._getHScrollBarLargeChange();
                        hMax = o.hScroller.scrollMax - hLargeChange + 1;
                        hValue = o.hScroller.scrollValue;
                        hScrollMin = o.hScroller.scrollMin;
                        if(hValue === undefined) {
                            hValue = hScrollMin;
                        }
                        if(Math.abs(hValue - hScrollMin) < 0.001 || !f.hScrolling) {
                            buttonLeft.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonLeft.removeClass(o.wijCSS.stateDisabled);
                        }
                        if(Math.abs(hValue - hMax) < 0.001 || !f.hScrolling) {
                            buttonRight.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonRight.removeClass(o.wijCSS.stateDisabled);
                        }
                    }
                    if(buttonTop !== undefined) {
                        vLargeChange = self._getVScrollBarLargeChange();
                        vMax = o.vScroller.scrollMax - vLargeChange + 1;
                        vValue = o.vScroller.scrollValue;
                        vScrollMin = o.vScroller.scrollMin;
                        if(vValue === undefined) {
                            vValue = vScrollMin;
                        }
                        if(Math.abs(vValue - vScrollMin) < 0.001 || !f.vScrolling) {
                            buttonTop.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonTop.removeClass(o.wijCSS.stateDisabled);
                        }
                        if(Math.abs(vValue - vMax) < 0.001 || !f.vScrolling) {
                            buttonBottom.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonBottom.removeClass(o.wijCSS.stateDisabled);
                        }
                    }
                },
                _clearInterval: function () {
                    var f = this._fields(), intervalID = f.internalFuncID;
                    if(intervalID > 0) {
                        window.clearInterval(intervalID);
                        f.internalFuncID = -1;
                    }
                },
                _elementMouseOut: function (event) {
                    var ele = $(event.currentTarget), self = event.data;
                    ele.unbind("mouseout", self._elementMouseOut);
                    ele.unbind("mousedown", self._elementMouseDown);
                    ele.unbind("mouseup", self._elementMouseUp);
                    ele.removeClass(self.options.wijCSS.stateHover);
                },
                _getScrollOffset: function (child1) {
                    var child = $(child1), f = this._fields(), cWrapper = f.contentWrapper, tempWrapper = f.templateWrapper, childOffset, templateOffset, cWrapperOffset, tDistance, bDistance, lDistance, rDistance, result = {
                        left: null,
                        top: null
                    };
                    if(child.length === 0) {
                        return result;
                    }
                    childOffset = child.offset();
                    templateOffset = tempWrapper.offset();
                    childOffset.leftWidth = childOffset.left + child.outerWidth();
                    childOffset.topHeight = childOffset.top + child.outerHeight();
                    cWrapperOffset = cWrapper.offset();
                    cWrapperOffset.leftWidth = cWrapperOffset.left + cWrapper.outerWidth();
                    cWrapperOffset.topHeight = cWrapperOffset.top + cWrapper.outerHeight();
                    lDistance = childOffset.left - templateOffset.left;
                    if(childOffset.left < cWrapperOffset.left) {
                        result.left = lDistance;
                    } else if(childOffset.leftWidth > cWrapperOffset.leftWidth) {
                        rDistance = childOffset.leftWidth - templateOffset.left - cWrapper.innerWidth();
                        if(lDistance < rDistance) {
                            result.left = lDistance;
                        } else {
                            result.left = rDistance;
                        }
                    }
                    tDistance = childOffset.top - templateOffset.top;
                    if(childOffset.top < cWrapperOffset.top) {
                        result.top = tDistance;
                    } else if(childOffset.topHeight > cWrapperOffset.topHeight) {
                        bDistance = childOffset.topHeight - templateOffset.top - cWrapper.innerHeight();
                        if(tDistance < bDistance) {
                            result.top = tDistance;
                        } else {
                            result.top = bDistance;
                        }
                    }
                    return result;
                },
                _scrollDrag: function (dir, hbarContainer, hbarDrag, fireScrollEvent) {
                    var self = this, o = self.options, v = dir === "v", scroller = v ? o.vScroller : o.hScroller, hMin = scroller.scrollMin, hMax = scroller.scrollMax, hValue = scroller.scrollValue === undefined ? hMin : (scroller.scrollValue - hMin), hLargeChange = self._getLargeChange(dir), max = hMax - hMin - hLargeChange + 1, dragleft = -1, track, drag, padding;
                    if(hValue > max) {
                        hValue = max;
                    }
                    if(hbarContainer !== undefined) {
                        track = self._getTrackLen(dir);
                        drag = hbarDrag[v ? "outerHeight" : "outerWidth"]();
                        padding = self._getScrollContainerPadding(v ? "top" : "left");
                        dragleft = (hValue / max) * (track - drag) + padding;
                    }
                    if(dragleft >= 0) {
                        hbarDrag.css(v ? "top" : "left", dragleft + "px");
                    }
                    self._scrollEnd(fireScrollEvent, self, dir);
                },
                needToScroll: /**
                * Determine whether scoll the child DOM element to view
                * need to scroll the scroll bar
                * @param {DOMElement} child The child to scroll to.
                */
                function (child) {
                    var offset = this._getScrollOffset(child);
                    return offset.top !== null || offset.left !== null;
                },
                scrollChildIntoView: /**
                * Scroll children DOM element to view.
                * @param {DOMElement} child The child to scroll to.
                */
                function (child) {
                    var offset = this._getScrollOffset(child), left = offset.left, top = offset.top;
                    if(left !== null) {
                        this.hScrollTo(left);
                    }
                    if(top !== null) {
                        this.vScrollTo(top);
                    }
                },
                hScrollTo: /**
                * Scroll to horizontal position.
                * @param {number} x The position to scroll to.
                * @param {bool} isScrollValue A value that indicates whether x is value or pixel.
                */
                function (x, isScrollValue) {
                    var o = this.options;
                    this._updateScrollValue(!!isScrollValue ? x : this.scrollPxToValue(x, "h"), o.hScroller);
                    this._setDragAndContentPosition(true, true, "h", "nonestop");
                },
                vScrollTo: /**
                * Scroll to vertical position.
                * @param {number} y The position to scroll to.
                * @param {bool} isScrollValue A value that indicates whether y is value or pixel.
                */
                function (y, isScrollValue) {
                    var o = this.options;
                    this._updateScrollValue(!!isScrollValue ? y : this.scrollPxToValue(y, "v"), o.vScroller);
                    this._setDragAndContentPosition(true, true, "v", "nonestop");
                },
                scrollPxToValue: /**
                * Convert pixel to scroll value.
                * For example, wijsuperpanel scrolled 50px
                * which is value 1 after conversion.
                * @param {number} px Length of scrolling.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (px, dir) {
                    var o = this.options, m = (dir === "h" ? "outerWidth" : "outerHeight"), m1 = (dir === "h" ? "contentWidth" : "contentHeight"), scroller = (dir === "h" ? "hScroller" : "vScroller"), f = this._fields(), cWrapper = f.contentWrapper, size = f[m1], contentHeight = cWrapper[m](), vMin = o[scroller].scrollMin, vMax = o[scroller].scrollMax, vRange = vMax - vMin, vLargeChange = (dir === "h" ? this._getHScrollBarLargeChange() : this._getVScrollBarLargeChange()), maxv = vRange - vLargeChange + 1, ret = maxv * (px / (size - contentHeight));
                    if(ret < vMin) {
                        ret = vMin;
                    }
                    if(ret > maxv) {
                        ret = maxv;
                    }
                    return ret;
                },
                scrollValueToPx: /**
                * Convert scroll value to pixel.
                * For example, scroll value is 1
                * which makes wijsuperpanel scrolled 50px after conversion.
                * @param {number} scroll value.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (value, dir) {
                    var self = this, o = self.options, f = self._fields(), h = dir === "h", outerDir, contentDir, scroller, cWrapper, size, contentSize, min, max, largeChange, maxv, px;
                    outerDir = h ? "outerWidth" : "outerHeight";
                    contentDir = h ? "contentWidth" : "contentHeight";
                    scroller = h ? "hScroller" : "vScroller";
                    largeChange = h ? self._getHScrollBarLargeChange() : self._getVScrollBarLargeChange();
                    cWrapper = f.contentWrapper;
                    size = f[contentDir];
                    contentSize = cWrapper[outerDir]();
                    min = o[scroller].scrollMin;
                    max = o[scroller].scrollMax;
                    maxv = (max - min) - largeChange + 1;
                    if(value === undefined || value < min) {
                        value = min;
                    }
                    if(value > maxv) {
                        value = maxv;
                    }
                    px = (size - contentSize) * (value / maxv);
                    return Math.round(px);
                },
                scrollTo: /**
                * Scroll to the specified position.
                * which is value 1 after conversion.
                * @param {number} x Horizontal position to scroll to.
                * @param {number} y Vertical position to scroll to.
                * @param {bool} isScrollValue A value that indicates whether the x, y are value or pixel.
                */
                function (x, y, isScrollValue) {
                    this.hScrollTo(x, isScrollValue);
                    this.vScrollTo(y, isScrollValue);
                },
                refresh: /**
                * Refreshes wijsuperpanel.
                * Needs to be called after content being changed.
                * @returns {boolean} Returns true if it is successful, else returns false.
                */
                function () {
                    this.paintPanel();
                },
                paintPanel: /** @ignore
                * Refreshes wijsuperpanel.
                * Needs to be called after content being changed.
                * @returns {boolean} Returns true if it is successful, else returns false.
                */
                function (unfocus) {
                    var self = this, ele = self.element, focused, o, f, templateWrapper;
                    if(ele.is(":visible")) {
                        focused = typeof document.activeElement != 'unknown' ? document.activeElement : undefined;
                        o = self.options;
                        f = self._fields();
                        if(!f.initialized) {
                            self._initialize(f, ele, self);
                        }
                        self._resetLargeChange(self, f, o);
                        self._bindElementEvents(self, f, ele, o);
                        templateWrapper = f.templateWrapper;
                        templateWrapper.css({
                            "float": "left",
                            left: "0px",
                            top: "0px",
                            width: "auto",
                            height: "auto"
                        });
                        // hide and show wrapper div to force the width to change
                        // for some browser.
                        templateWrapper.hide();
                        templateWrapper.show();
                        f.contentWidth = templateWrapper.width();
                        f.contentHeight = templateWrapper.height();
                        templateWrapper.css("float", "");
                        self._setRounder(self, ele);
                        self._setInnerElementsSize(f, ele);
                        if(self._testScroll(self, f, o) === false) {
                            return false;
                        }
                        self._initScrollBars(self, f, o);
                        self._initScrollButtons(self, f, o);
                        self._trigger("painted");
                        self._paintedMark = {
                            date: new Date(),
                            mainWidth: ele[0].offsetWidth,
                            mainHeight: ele[0].offsetHeight,
                            width: f.contentWidth,
                            height: f.contentWidth
                        };
                        if(focused !== undefined && !unfocus) {
                            $(focused).focus();
                        }
                        return true;
                    }
                    return false;
                },
                _adjustScrollValue: function (dir) {
                    var isHori = dir === "h", self = this, o = this.options, needScroll = isHori ? self.hNeedScrollBar : self.vNeedScrollBar, scroller = isHori ? o.hScroller : o.vScroller, max = scroller.scrollMax, min = scroller.scrollMin, largeChange, topValue;
                    if(needScroll) {
                        largeChange = isHori ? self._getHScrollBarLargeChange() : self._getVScrollBarLargeChange();
                        topValue = max - largeChange + 1;
                        if(scroller.scrollValue > topValue) {
                            scroller.scrollValue = topValue;
                        }
                        if(scroller.scrollValue < min) {
                            scroller.scrollValue = min;
                        }
                    }
                },
                _resetLargeChange: function (self, f, o) {
                    var handle;
                    if(self._autoVLarge) {
                        o.vScroller.scrollLargeChange = null;
                    }
                    if(self._autoHLarge) {
                        o.hScroller.scrollLargeChange = null;
                    }
                    f.vTrackLen = undefined;
                    f.hTrackLen = undefined;
                    if(f.vbarContainer) {
                        // fixed bug when the original draggable element removed when it's being dragged.
                        // use detach to keep the events to be fired(IE).
                        handle = f.vbarContainer.children("." + scrollerHandle + ":eq(0)");
                        handle.detach();
                        f.vbarContainer.remove();
                        f.vbarContainer = undefined;
                    }
                    if(f.hbarContainer) {
                        handle = f.hbarContainer.children("." + scrollerHandle + ":eq(0)");
                        handle.detach();
                        f.hbarContainer.remove();
                        f.hbarContainer = undefined;
                    }
                },
                _initialize: function (f, ele, self) {
                    var wijCSS = self.options.wijCSS;
                    f.initialized = true;
                    // ensure width and height
                    ele.addClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content
                    ].join(' '));
                    f.oldHeight = ele.css("height");
                    var old = ele.css("overflow");
                    ele.css("overflow", "");
                    // set height to element
                    ele.height(ele.height());
                    ele.css("overflow", old);
                    self._createAdditionalDom(self, f, ele);
                },
                getContentElement: /**
                * Gets the content element of wijsuperpanel.
                * @example $("selector").wijsuperpanel("getContentElement");
                * @returns {jQuery}
                */
                function () {
                    return this._fields().templateWrapper;
                },
                _setButtonPosition: function (self, o, scroller, dir, target, f, state) {
                    var h = dir === "h", mouseoverkey = "mouseover." + self.widgetName, decKey = h ? "buttonLeft" : "buttonTop", incKey = h ? "buttonRight" : "buttonBottom", decButton = f[decKey], incButton = f[incKey], html, buttons, defaultPosition;
                    if(self._hasMode(scroller, "buttons") || self._hasMode(scroller, "buttonshover")) {
                        html = h ? hButtons : vButtons;
                        if(decButton === undefined) {
                            buttons = $(html).appendTo(state);
                            buttons.bind(mouseoverkey, self, self._scrollButtonMouseOver);
                            f[decKey] = decButton = state.children(h ? ".wijmo-wijsuperpanel-buttonleft" : ".wijmo-wijsuperpanel-buttontop");
                            f[incKey] = incButton = state.children(h ? ".wijmo-wijsuperpanel-buttonright" : ".wijmo-wijsuperpanel-buttonbottom");
                        }
                        defaultPosition = {
                            my: h ? "left" : "top",
                            of: target,
                            at: h ? "left" : "top",
                            collision: "none"
                        };
                        $.extend(defaultPosition, scroller.decreaseButtonPosition);
                        decButton.position(defaultPosition);
                        defaultPosition = {
                            my: h ? "right" : "bottom",
                            of: target,
                            at: h ? "right" : "bottom",
                            collision: "none"
                        };
                        $.extend(defaultPosition, scroller.increaseButtonPosition);
                        incButton.position(defaultPosition);
                    } else if(decButton !== undefined) {
                        decButton.remove();
                        incButton.remove();
                        f[decKey] = f[incKey] = undefined;
                    }
                },
                _initScrollButtons: function (self, f, o) {
                    var a = f.contentWrapper, state = f.stateContainer;
                    self._setButtonPosition(self, o, o.hScroller, "h", a, f, state);
                    self._setButtonPosition(self, o, o.vScroller, "v", a, f, state);
                },
                _getVScrollBarSmallChange: function () {
                    var o = this.options, va;
                    if(!o.vScroller.scrollSmallChange) {
                        va = this._getVScrollBarLargeChange();
                        o.vScroller.scrollSmallChange = va / 2;
                    }
                    return o.vScroller.scrollSmallChange;
                },
                _getVScrollBarLargeChange: function () {
                    return this._getLargeChange("v");
                },
                _getLargeChange: function (dir) {
                    var self = this, o = self.options, f = self._fields(), v = dir === "v", scroller = v ? o.vScroller : o.hScroller, clientKey = v ? "innerHeight" : "innerWidth", offsetKey = v ? "contentHeight" : "contentWidth", autoKey = v ? "_autoVLarge" : "_autoHLarge", hMax, hMin, hRange, content, contentWidth, wrapperWidth, percent, large;
                    if(scroller.scrollLargeChange) {
                        return scroller.scrollLargeChange;
                    }
                    // calculate large change if empty
                    hMax = scroller.scrollMax;
                    hMin = scroller.scrollMin;
                    hRange = hMax - hMin;
                    content = f.contentWrapper;
                    contentWidth = content[clientKey]();
                    wrapperWidth = f[offsetKey];
                    percent = contentWidth / (wrapperWidth - contentWidth);
                    large = ((hRange + 1) * percent) / (1 + percent);
                    if(isNaN(large)) {
                        large = 0;
                    }
                    scroller.scrollLargeChange = large;
                    self[autoKey] = true;
                    return scroller.scrollLargeChange;
                },
                _getHScrollBarSmallChange: function () {
                    var o = this.options, va;
                    if(!o.hScroller.scrollSmallChange) {
                        va = this._getHScrollBarLargeChange();
                        o.hScroller.scrollSmallChange = va / 2;
                    }
                    return o.hScroller.scrollSmallChange;
                },
                _getHScrollBarLargeChange: function () {
                    return this._getLargeChange("h");
                },
                _initScrollBars: function (self, f, o) {
                    // Set scroll bar initial position.
                                        var hScroller = o.hScroller, hMax = hScroller.scrollMax, hMin = hScroller.scrollMin, hRange = hMax - hMin, vScroller = o.vScroller, vMax = vScroller.scrollMax, vMin = vScroller.scrollMin, vRange = vMax - vMin, hbarDrag = f.hbarDrag, vbarDrag = f.vbarDrag, hLargeChange, track, dragLen, difference, icon, vLargeChange, track1, dragLen1, difference1, icon1;
                    if(self.hNeedScrollBar && hbarDrag.is(":visible")) {
                        hLargeChange = self._getHScrollBarLargeChange();
                        track = self._getTrackLen("h");
                        dragLen = self._getDragLength(hRange, hLargeChange, track, o.hScroller.scrollMinDragLength);
                        hbarDrag.width(dragLen);
                        difference = hbarDrag.outerWidth(true) - hbarDrag.width();
                        hbarDrag.width(dragLen - difference);
                        icon = hbarDrag.children("span");
                        icon.css("margin-left", (hbarDrag.width() - icon[0].offsetWidth) / 2);
                        if(track <= hbarDrag.outerWidth(true)) {
                            hbarDrag.hide();
                        } else {
                            hbarDrag.show();
                        }
                        //fixed bug the dragger will be reset after refresh
                        if(self._isDragging == true) {
                            $(document).trigger("mouseup");
                            self._isDragging = false;
                        }
                    }
                    if(self.vNeedScrollBar && vbarDrag.is(":visible")) {
                        vLargeChange = self._getVScrollBarLargeChange();
                        track1 = self._getTrackLen("v");
                        dragLen1 = self._getDragLength(vRange, vLargeChange, track1, o.vScroller.scrollMinDragLength);
                        vbarDrag.height(dragLen1);
                        difference1 = vbarDrag.outerHeight(true) - vbarDrag.height();
                        vbarDrag.height(dragLen1 - difference1);
                        icon1 = vbarDrag.children("span");
                        icon1.css("margin-top", (vbarDrag.height() - icon1[0].offsetHeight) / 2);
                        if(track1 <= vbarDrag.outerHeight(true)) {
                            vbarDrag.hide();
                        } else {
                            vbarDrag.show();
                        }
                        //fixed bug the dragger will be reset after refresh
                        if(self._isDragging == true) {
                            $(document).trigger("mouseup");
                            self._isDragging = false;
                        }
                    }
                    self._setDragAndContentPosition(false, false, "both");
                },
                _getTrackLen: function (dir) {
                    // Get the length of the track.
                    // <param name="dir" type="String">
                    // Options are: "v" and "h".
                    // "v" - Vertical scroll track.
                    // "h" - Horizontal scroll track.
                    // </param>
                                        var self = this, f = self._fields(), key = dir + "TrackLen", hbarContainer = f.hbarContainer, vbarContainer = f.vbarContainer, track = 0, padding = 0, border = 0;
                    if(f[key] !== undefined) {
                        return f[key];
                    }
                    if(dir === "h") {
                        padding = self._getScrollContainerPadding("h");
                        border = self._getScrollContainerBorders("h");
                        track = hbarContainer.innerWidth();
                    }
                    if(dir === "v") {
                        padding = self._getScrollContainerPadding("v");
                        border = self._getScrollContainerBorders("v");
                        track = vbarContainer.innerHeight();
                    }
                    f[key] = (track - padding - border);
                    return f[key];
                },
                _getScrollContainerPadding: function (paddingType) {
                    // Get the padding of the scroll bar container.
                                        var self = this, f = self._fields(), padding = 0, container, key;
                    if(paddingType === "h") {
                        padding = self._getScrollContainerPadding("left") + self._getScrollContainerPadding("right");
                    } else if(paddingType === "v") {
                        padding = self._getScrollContainerPadding("top") + self._getScrollContainerPadding("bottom");
                    } else {
                        if(paddingType === "left" || paddingType === "right") {
                            container = f.hbarContainer;
                        } else {
                            container = f.vbarContainer;
                        }
                        key = paddingType + "Padding";
                        if(f[key] !== undefined) {
                            padding = f[key];
                            return padding;
                        }
                        if(container && container.css) {
                            padding = parseFloat(container.css("padding-" + paddingType));
                        }
                        f[key] = padding;
                    }
                    return padding;
                },
                _getScrollContainerBorders: function (dir) {
                    // Get the border width of the scroll bar container.
                                        var self = this, f = self._fields(), borders = 0, key;
                    key = dir + "Borders";
                    if(f[key] !== undefined) {
                        borders = f[key];
                        return borders;
                    }
                    if(dir === "h") {
                        borders = self._getScrollContainerBorder("left") + self._getScrollContainerBorder("right");
                    } else if(dir === "v") {
                        borders = self._getScrollContainerBorder("top") + self._getScrollContainerBorder("bottom");
                    }
                    f[key] = borders;
                    return borders;
                },
                _getScrollContainerBorder: function (borderType) {
                    var self = this, f = self._fields(), border = 0, container, key, borderStyle, borderWidth;
                    if(borderType === "left" || borderType === "right") {
                        container = f.hbarContainer;
                    } else {
                        container = f.vbarContainer;
                    }
                    key = borderType + "Border";
                    if(f[key] !== undefined) {
                        border = f[key];
                        return border;
                    }
                    if(container && container.css) {
                        borderWidth = container.css("border-" + borderType + "-width").toLowerCase();
                        border = parseFloat(borderWidth);
                        if(isNaN(border)) {
                            borderStyle = container.css("border-" + borderType + "-style").toLowerCase();
                            switch(borderStyle) {
                                case "none":
                                case "hidden":
                                    border = 0;
                                    break;
                                default:
                                    switch(borderWidth) {
                                        case "thin":
                                            border = 1;
                                            break;
                                        case "medium":
                                            border = 3;
                                            break;
                                        case "thick":
                                            border = 5;
                                            break;
                                        default:
                                            border = 0;
                                            break;
                                    }
                                    break;
                            }
                        }
                    }
                    f[key] = border;
                    return border;
                },
                _triggerScroll: function (contentLeft, dir, contentAnimationOptions) {
                    var data = {
                        position: contentLeft,
                        dir: dir,
                        animationOptions: contentAnimationOptions
                    };
                    this._trigger("scroll", null, data);
                },
                _contentDragAnimate: function (dir, animated, hbarContainer, hbarDrag, stop, fireScrollEvent, dragging) {
                    var self = this, o = self.options, v = dir === "v", scroller = v ? o.vScroller : o.hScroller, tempKey = v ? "outerHeight" : "outerWidth", paddingKey = v ? "top" : "left", hMin = scroller.scrollMin, hMax = scroller.scrollMax, hRange = hMax - hMin, hValue = scroller.scrollValue === undefined ? hMin : scroller.scrollValue, hLargeChange = self._getLargeChange(dir), max = hRange - hLargeChange + 1, f = self._fields(), tempWrapper = f.templateWrapper, contentLeft, dragleft, track, drag, r, padding, dragAnimationOptions, properties, contentAnimationOptions, userComplete, properties1, key;
                    contentLeft = self.scrollValueToPx(hValue, dir);
                    dragleft = -1;
                    if(hbarContainer !== undefined) {
                        if(animated && hbarDrag.is(":animated") && stop !== "nonestop") {
                            hbarDrag.stop(true, false);
                        }
                        track = self._getTrackLen(dir);
                        drag = hbarDrag[tempKey](true);
                        r = track - drag;
                        padding = self._getScrollContainerPadding(paddingKey);
                        dragleft = (hValue / max) * r + padding;
                    }
                    if(animated && o.animationOptions && !o.animationOptions.disabled) {
                        if(dragleft >= 0 && dragging !== "dragging") {
                            dragAnimationOptions = $.extend({
                            }, o.animationOptions);
                            // not trigger scrolled when stop
                            dragAnimationOptions.complete = undefined;
                            if(v) {
                                properties = {
                                    top: dragleft
                                };
                            } else {
                                properties = {
                                    left: dragleft
                                };
                            }
                            hbarDrag.animate(properties, dragAnimationOptions);
                        }
                        contentAnimationOptions = $.extend({
                        }, o.animationOptions);
                        userComplete = o.animationOptions.complete;
                        contentAnimationOptions.complete = function () {
                            self._scrollEnd(fireScrollEvent, self, dir);
                            if($.isFunction(userComplete)) {
                                userComplete(arguments);
                            }
                        };
                        if(animated && tempWrapper.is(":animated") && stop !== "nonestop") {
                            tempWrapper.stop(true, false);
                        }
                        if(v) {
                            properties1 = {
                                top: -contentLeft
                            };
                        } else {
                            properties1 = {
                                left: -contentLeft
                            };
                        }
                        if(!o.customScrolling) {
                            tempWrapper.animate(properties1, contentAnimationOptions);
                        } else {
                            self._scrollEnd(fireScrollEvent, self, dir, hValue);
                        }
                        self._triggerScroll(contentLeft, dir, contentAnimationOptions);
                    } else if(scroller.scrollBarVisibility !== "hidden") {
                        key = v ? "top" : "left";
                        if(dragleft >= 0 && dragging !== "dragging") {
                            hbarDrag[0].style[key] = dragleft + "px";
                        }
                        if(!o.customScrolling) {
                            tempWrapper[0].style[key] = -contentLeft + "px";
                        }
                        self._triggerScroll(contentLeft, dir);
                        self._scrollEnd(fireScrollEvent, self, dir, hValue);
                    }
                },
                _setDragAndContentPosition: function (fireScrollEvent, animated, dir, stop, dragging) {
                    var self = this, f = self._fields(), hbarContainer = f.hbarContainer, hbarDrag = f.hbarDrag, vbarContainer = f.vbarContainer, vbarDrag = f.vbarDrag;
                    if((dir === "both" || dir === "h") && f.hScrolling) {
                        self._contentDragAnimate("h", animated, hbarContainer, hbarDrag, stop, fireScrollEvent, dragging);
                    }
                    if((dir === "both" || dir === "v") && f.vScrolling) {
                        self._contentDragAnimate("v", animated, vbarContainer, vbarDrag, stop, fireScrollEvent, dragging);
                    }
                    if(f.intervalID > 0) {
                        window.clearInterval(f.intervalID);
                    }
                    f.intervalID = window.setInterval(function () {
                        self._disableButtonIfNeeded(self);
                    }, 500);
                },
                _scrolling: function (fireEvent, self, d) {
                    var r = true;
                    if(fireEvent) {
                        d.beforePosition = self.getContentElement().position();
                        self._beforePosition = d.beforePosition;
                        r = self._trigger("scrolling", null, d);
                        self.customScroll = d.customScroll;
                    }
                    return r;
                },
                _scrollEnd: function (fireEvent, self, dir, newValue) {
                    if(fireEvent) {
                        // use settimeout to return to caller immediately.
                        window.setTimeout(function () {
                            var content = self.getContentElement(), after, d;
                            if(!content.is(":visible")) {
                                return;
                            }
                            after = self.getContentElement().position();
                            d = {
                                dir: dir,
                                beforePosition: self._beforePosition,
                                afterPosition: after
                            };
                            if(!isNaN(newValue)) {
                                d.newValue = newValue;
                            }
                            self._trigger("scrolled", null, d);
                        }, 0);
                    }
                },
                _getDragLength: function (range, largeChange, track, min) {
                    var divide = range / largeChange, dragLength = track / divide, minidrag = min;
                    if(dragLength < minidrag) {
                        dragLength = minidrag;
                    } else if((dragLength + 1) >= track) {
                        dragLength = track - 1;
                    }
                    return Math.round(dragLength);
                },
                _needScrollbar: function (scroller, needscroll) {
                    var scrollbarMode = this._hasMode(scroller, "scrollbar"), barVisibility = scroller.scrollBarVisibility, needScrollBar = scrollbarMode && (barVisibility === "visible" || (barVisibility === "auto" && needscroll));
                    return needScrollBar;
                },
                _bindBarEvent: function (barContainer, barDrag, dir) {
                    var self = this;
                    barContainer.bind("mouseover." + self.widgetName, self, self._scrollerMouseOver);
                    if(!$.fn.draggable) {
                        return;
                    }
                    barDrag.draggable({
                        axis: dir === "h" ? "x" : "y",
                        start: function (e, data) {
                            //fixed an issue that when disabled, the bar can be dragged.
                            if(self.options.disabled) {
                                return false;
                            }
                            self._isDragging = true;
                        },
                        drag: function (e, data) {
                            self._dragging(e, data, self);
                        },
                        containment: "parent",
                        stop: function (e) {
                            self._dragStop(e, self, dir);
                            $(e.target).removeClass(activeCss);
                            self._isDragging = false;
                        }
                    });
                },
                _createBarIfNeeded: function (hNeedScrollBar, scrollerWrapper, dir, html, content) {
                    if(hNeedScrollBar) {
                        var self = this, data, f = self._fields(), strBarContainer = dir + "barContainer", strBarDrag = dir + "barDrag", hbar = dir === "h", contentLength = content[hbar ? "innerHeight" : "innerWidth"](), c = f[strBarContainer] = $(html), targetBarLen, d;
                        scrollerWrapper.append(c);
                        targetBarLen = c[0][hbar ? "offsetHeight" : "offsetWidth"];
                        contentLength = contentLength - targetBarLen;
                        data = {
                            direction: hbar ? "horizontal" : "vertical",
                            targetBarLen: targetBarLen,
                            contentLength: contentLength
                        };
                        if(self._trigger(hbar ? "hScrollerActivating" : "vScrollerActivating", null, data) === false) {
                            return false;
                        }
                        d = f[strBarDrag] = c.find("." + scrollerHandle);
                        self._bindBarEvent(c, d, dir);
                        content[hbar ? "height" : "width"](contentLength);
                    }
                },
                _setScrollbarPosition: function (wrapper, self, content, targetBarContainer, referBarContainer, targetNeedScrollBar, referNeedScrollBar, targetScrollBarPosition, referScrollBarPosition, dir, scrollingNeed) {
                    var hbar = dir === "h", targetBarLen, targetPadding, targetBorder, targetBarPosition, barPosition1, contentPosition1, barPosition2, contentPosition2, contentLength2, referBarWidth, css = self.options.wijCSS;
                    if(targetNeedScrollBar) {
                        targetBarLen = targetBarContainer[0][hbar ? "offsetHeight" : "offsetWidth"];
                        targetPadding = self._getScrollContainerPadding(dir);
                        targetBorder = self._getScrollContainerBorders(dir);
                        targetBarPosition = hbar ? "top" : "left";
                        barPosition1 = hbar ? {
                            top: "0px",
                            bottom: "auto",
                            left: "auto",
                            right: "auto"
                        } : {
                            left: "0px",
                            right: "auto",
                            top: "auto",
                            bottom: "auto"
                        };
                        contentPosition1 = hbar ? {
                            top: targetBarLen + "px",
                            left: null
                        } : {
                            left: targetBarLen + "px"
                        };
                        barPosition2 = hbar ? {
                            top: "auto",
                            right: "auto",
                            left: "auto",
                            bottom: "0px"
                        } : {
                            left: "auto",
                            right: "0px",
                            top: "auto",
                            bottom: "auto"
                        };
                        contentPosition2 = hbar ? {
                            top: "",
                            left: null
                        } : {
                            left: ""
                        };
                        contentLength2 = content[hbar ? "innerWidth" : "innerHeight"]();
                        if(targetScrollBarPosition === targetBarPosition) {
                            targetBarContainer.css(barPosition1);
                            content.css(contentPosition1);
                            if(hbar) {
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonleft").removeClass(css.cornerBL).addClass(css.cornerTL);
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonright").removeClass(css.cornerBR).addClass(css.cornerTR);
                                targetBarContainer.removeClass(css.cornerBottom).addClass(css.cornerTop);
                            } else {
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttontop").removeClass(css.cornerTR).addClass(css.cornerTL);
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttonbottom").removeClass(css.cornerBR).addClass(css.cornerBL);
                                targetBarContainer.removeClass(css.cornerRight).addClass(css.cornerLeft);
                            }
                        } else {
                            targetBarContainer.css(barPosition2);
                            content.css(contentPosition2);
                            if(hbar) {
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonleft").removeClass(css.cornerTL).addClass(css.cornerBL);
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonright").removeClass(css.cornerBL).addClass(css.cornerBR);
                                targetBarContainer.removeClass(css.cornerTop).addClass(css.cornerBottom);
                            } else {
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttontop").removeClass(css.cornerTL).addClass(css.cornerTR);
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttonbottom").removeClass(css.cornerBL).addClass(css.cornerBR);
                                targetBarContainer.removeClass(css.cornerLeft).addClass(css.cornerRight);
                            }
                        }
                        referBarWidth = 0;
                        if(referNeedScrollBar) {
                            referBarWidth = referBarContainer[0][hbar ? "offsetWidth" : "offsetHeight"];
                            if(referScrollBarPosition === "left") {
                                targetBarContainer.css("right", "0px");
                            } else if(referScrollBarPosition === "right") {
                                targetBarContainer.css("left", "0px");
                            } else if(referScrollBarPosition === "top") {
                                targetBarContainer.css("bottom", "0px");
                            } else if(referScrollBarPosition === "bottom") {
                                targetBarContainer.css("top", "0px");
                            }
                        }
                        if(!hbar/*vbar*/  && referNeedScrollBar) {
                            referBarWidth = 0;
                        }
                        // When calculate the height or width of the scroll barcontainer, the border widht of the scroll bar container shall be removed too.
                        targetBarContainer[hbar ? "width" : "height"](contentLength2 - targetPadding - targetBorder);
                        self._enableDisableScrollBar(dir, targetBarContainer, !scrollingNeed);
                    } else {
                        wrapper.css(hbar ? "left" : "top", "");
                    }
                },
                _testScroll: function (self, f, o) {
                    var wrapper = f.templateWrapper, content = f.contentWrapper, scrollerWrapper = f.stateContainer, contentWidth = content.innerWidth(), contentHeight = content.innerHeight(), wrapperWidth = f.contentWidth, wrapperHeight = f.contentHeight, hNeedScrollBar, vNeedScrollBar, hbarContainer, vbarContainer, hbarPosition, vbarPosition;
                    f.hScrolling = wrapperWidth > contentWidth;
                    f.vScrolling = wrapperHeight > contentHeight;
                    hNeedScrollBar = self.hNeedScrollBar = self._needScrollbar(o.hScroller, f.hScrolling);
                    if(self._createBarIfNeeded(hNeedScrollBar, scrollerWrapper, "h", hbarHtml, content) === false) {
                        return false;
                    }
                    // having h scroll bar, but no vscroll bar, we need to test vscrolling again.
                    if(hNeedScrollBar && !f.vScrolling) {
                        wrapper.css("float", "left");
                        f.contentHeight = wrapper.height();
                        f.vScrolling = f.contentHeight > (contentHeight - f.hbarContainer[0].offsetHeight);
                        wrapper.css("float", "");
                    }
                    vNeedScrollBar = self.vNeedScrollBar = self._needScrollbar(o.vScroller, f.vScrolling);
                    if(self._createBarIfNeeded(vNeedScrollBar, scrollerWrapper, "v", vbarHtml, content) === false) {
                        return false;
                    }
                    if(vNeedScrollBar && !f.hScrolling) {
                        wrapper.css("float", "left");
                        f.contentWidth = wrapper.width();
                        f.hScrolling = f.contentWidth > (contentWidth - f.vbarContainer[0].offsetWidth);
                        wrapper.css("float", "");
                        if(f.hScrolling && !hNeedScrollBar) {
                            hNeedScrollBar = self.hNeedScrollBar = self._needScrollbar(o.hScroller, f.hScrolling);
                            if(self._createBarIfNeeded(hNeedScrollBar, scrollerWrapper, "h", hbarHtml, content) === false) {
                                return false;
                            }
                        }
                    }
                    hbarContainer = f.hbarContainer;
                    vbarContainer = f.vbarContainer;
                    hbarPosition = o.hScroller.scrollBarPosition;
                    vbarPosition = o.vScroller.scrollBarPosition;
                    self._setScrollbarPosition(wrapper, self, content, hbarContainer, vbarContainer, hNeedScrollBar, vNeedScrollBar, hbarPosition, vbarPosition, "h", f.hScrolling);
                    self._setScrollbarPosition(wrapper, self, content, vbarContainer, hbarContainer, vNeedScrollBar, hNeedScrollBar, vbarPosition, hbarPosition, "v", f.vScrolling);
                },
                _enableDisableScrollBar: function (bar, barContainer, disable) {
                    // Disables scroll bar.
                    // <param name="bar" type="String">
                    // Scrollbar to disable.
                    // Options are: "h" and "v"
                    // </param>
                    // <param name="barContainer" type="jQuery">
                    // The scroll bar container jQuery object.
                    // </param>
                    // <param name="disable" type="Boolean">
                    // Whether to disable scroll bar.
                    // </param>
                    var o = this.options;
                    if(bar === "v") {
                        barContainer[disable ? "addClass" : "removeClass"]("wijmo-wijsuperpanel-vbarcontainer-disabled");
                        barContainer.find("." + o.wijCSS.stateDefault)[disable ? "addClass" : "removeClass"](o.wijCSS.stateDisabled);
                    } else if(bar === "h") {
                        barContainer[disable ? "addClass" : "removeClass"]("wijmo-wijsuperpanel-hbarcontainer-disabled");
                        barContainer.find("." + o.wijCSS.stateDefault)[disable ? "addClass" : "removeClass"](o.wijCSS.stateDisabled);
                    }
                    barContainer.children("." + scrollerHandle)[disable ? "hide" : "show"]();
                },
                _initResizer: function () {
                    // Initialize reseizer of wijsuperpanel.
                                        var self = this, o = self.options, f = self._fields(), resizer = f.resizer, resizableOptions, oldstop;
                    if(!$.fn.resizable) {
                        return;
                    }
                    if(!resizer && o.allowResize) {
                        resizableOptions = o.resizableOptions;
                        oldstop = resizableOptions.stop;
                        resizableOptions.stop = function (e) {
                            self._resizeStop(e, self);
                            if($.isFunction(oldstop)) {
                                oldstop(e);
                            }
                        };
                        f.resizer = resizer = self.element.resizable(resizableOptions);
                    }
                    if(!o.allowResize && f.resizer) {
                        resizer.resizable("destroy");
                        f.resizer = null;
                    }
                },
                _resizeStop: function (e, self) {
                    // give the chance to autoRefresh polling to repaint.
                    if(!this.options.autoRefresh) {
                        self.paintPanel(true);
                    }
                    self._trigger("resized");
                },
                _createAdditionalDom: function (self, f, ele) {
                    // make sure the key pressing event work in FireFox.
                    if(!ele.attr("tabindex")) {
                        ele.attr("tabindex", "-1");
                        f.tabindex = true;
                    }
                    var stateContainer = f.stateContainer = $(innerElementHtml), templateW, wijCSS = self.options.wijCSS;
                    // move child element to content wrapper div of wijsuperpanel.
                    f.contentWrapper = stateContainer.children();
                    templateW = f.templateWrapper = f.contentWrapper.children();
                    ele.contents().each(function (index, el) {
                        var jel = $(el);
                        if(jel.hasAllClasses(wijCSS.superpanelHeader)) {
                            f.header = jel;
                            return;
                        }
                        if(jel.hasAllClasses(wijCSS.superpanelFooter)) {
                            f.footer = jel;
                            return;
                        }
                        templateW[0].appendChild(el);
                    });
                    // apeend header to first element.
                    if(f.header !== undefined) {
                        ele.prepend(f.header);
                    }
                    ele[0].appendChild(stateContainer[0]);
                    // apeend footer to first element.
                    if(f.footer !== undefined) {
                        f.footer.insertAfter(stateContainer);
                    }
                },
                _setRounder: function (self, ele) {
                    if(this.options.showRounder) {
                        ele.addClass(this.options.wijCSS.cornerAll);
                        if(self._rounderAdded) {
                            return;
                        }
                        if($.browser.msie) {
                            return;
                        }
                        var key1 = "", key = "", value, border;
                        if($.browser.webkit) {
                            key = "WebkitBorderTopLeftRadius";
                            key1 = "WebkitBorderRadius";
                        } else if($.browser.mozilla) {
                            key = "MozBorderRadiusBottomleft";
                            key1 = "MozBorderRadius";
                        } else {
                            key = "border-top-left-radius";
                            key1 = "border-radius";
                        }
                        value = ele.css(key);
                        border = parseInt(value, 10);
                        // adding 1 extra to out-most radius.
                        ele.css(key1, border + 1);
                        self._rounderAdded = true;
                        self._radiusKey = key1;
                    } else {
                        ele.removeClass(this.options.wijCSS.cornerAll);
                    }
                },
                _setInnerElementsSize: function (f, ele) {
                    var state = f.stateContainer, content = f.contentWrapper, height = 0, style, clientHeight, clientWidth, style2;
                    if(f.header !== undefined) {
                        height += f.header.outerHeight();
                    }
                    if(f.footer !== undefined) {
                        height += f.footer.outerHeight();
                    }
                    style = state[0].style;
                    clientHeight = ele.innerHeight() - height;
                    clientWidth = ele.innerWidth();
                    // hide element before setting width and height to improve javascript performance in FF3.
                    style.display = "none";
                    style.height = clientHeight + "px";
                    style.width = clientWidth + "px";
                    style2 = content[0].style;
                    style2.height = clientHeight + "px";
                    style2.width = clientWidth + "px";
                    style.display = "";
                }
            });
            wijsuperpanel.prototype.options = $.extend(true, {
            }, wijmo.wijmoWidget.prototype.options, new wijsuperpanel_options());
            $.wijmo.registerWidget("wijsuperpanel", wijsuperpanel.prototype);
        } else {
            //use native scrollbar
                        var scrollerHandle = "wijmo-wijsuperpanel-handle", innerElementHtml = "<div class='wijmo-wijsuperpanel-statecontainer' " + "style='float: left; height: 100%; -webkit-overflow-scrolling: auto;'>" + "<div class='wijmo-wijsuperpanel-contentwrapper-touch'>" + "</div></div>", panelContainerClass = "wijmo-wijsuperpanel-panelContainer", assistContainerClass = "wijmo-wijsuperpanel-assistContainer", simulateScrollClass = "wijmo-wijsuperpanel-simulateScrollBar", scrollBarEleClass = "wijmo-wijsuperpanel-scrollBarEle", isIOS = window.navigator.userAgent.match(/iPhone|iPad|iPod/i), isWIN = window.navigator.userAgent.match(/Windows/i), scrollBarEleHtml = isIOS ? "<div class='" + scrollBarEleClass + "' style='position: absolute; width: 3px; background:#7E7E7E; -webkit-border-radius: 1px; display: none'></div>" : "", assistElementHtml = "<div class='" + assistContainerClass + "' style='position: absolute;'><div class='" + simulateScrollClass + "' " + "style='position: absolute; overflow-x: hidden; -webkit-overflow-scrolling: touch; -ms-overflow-style: -ms-autohiding-scrollbar'>" + "<div></div></div>" + scrollBarEleHtml + "</div>", scrollWidth = isWIN ? 18 : 4;
            wijsuperpanel.prototype = $.extend(true, {
            }, $.Widget.prototype, {
                widgetEventPrefix: "wijsuperpanel",
                _setOption: function (key, value) {
                    var self = this, ele = self.element, o = self.options, f = self._fields();
                    if(key === "animationOptions" || key === "resizableOptions") {
                        value = $.extend(o[key], value);
                    } else if(key === "hScroller" || key === "vScroller") {
                        var dir = key === "hScroller" ? "h" : "v";
                        value = $.extend(o[key], value);
                        self._adjustScrollValue(dir);
                        self.refresh();
                    }
                    if(key === "customScrolling") {
                        if(o[key] !== value) {
                            o[key] = value;
                            self._initialize(f, ele, self);
                            self._bindElementEvents();
                        }
                    }
                    $.Widget.prototype._setOption.apply(self, arguments);
                    switch(key) {
                        case "allowResize":
                            self._initResizer();
                            break;
                        case "disabled":
                            self._handleDisabledOption(value, self.element);
                            break;
                        case "mouseWheelSupport":
                        case "keyboardSupport":
                            self._bindElementEvents(self, f, self.element, o);
                            break;
                    }
                },
                _create: function () {
                    var self = this, o = self.options;
                    o.vScroller.dir = "v";
                    o.hScroller.dir = "h";
                    self._createDom();
                    if(self.options.disabled) {
                        self.disable();
                    }
                    //update for visibility change
                    if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                        self.element.wijAddVisibilityObserver(function () {
                            self.refresh();
                            if(self.element.wijRemoveVisibilityObserver) {
                                self.element.wijRemoveVisibilityObserver();
                            }
                        }, "wijsuperpanel");
                    }
                },
                _handleDisabledOption: function (disabled, ele) {
                    var self = this;
                    if(disabled) {
                        if(!self.disabledDiv) {
                            self.disabledDiv = self._createDisabledDiv(ele);
                        }
                        self.disabledDiv.appendTo("body");
                    } else {
                        if(self.disabledDiv) {
                            self.disabledDiv.remove();
                            self.disabledDiv = null;
                        }
                    }
                },
                _createDisabledDiv: function (outerEle) {
                    var self = this, ele = outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
                    return $("<div></div>").addClass("ui-disabled").css({
                        "z-index": "99999",
                        position: "absolute",
                        width: disabledWidth,
                        height: disabledHeight,
                        left: eleOffset.left,
                        top: eleOffset.top
                    });
                },
                _createDom: function () {
                    var self = this, el = self.element;
                    self.paintPanel();
                    self._initResizer();
                    self._bindElementEvents();
                },
                _applyOverflow: function (stateContainer) {
                    var css = {
                    }, o = this.options, hs = o.hScroller.scrollBarVisibility, vs = o.vScroller.scrollBarVisibility;
                    css["overflow-x"] = hs;
                    css["overflow-y"] = vs;
                    if(hs === "visible" && vs === "visible") {
                        css["overflow-x"] = "auto";
                        css["overflow-y"] = "auto";
                    }
                    css["touch-action"] = "";
                    css["ms-touch-action"] = "";
                    if(o.customScrolling) {
                        // ** Enable native horizontal scroll bar **
                        //css["overflow-x"] = "hidden";
                        css["overflow-y"] = "hidden";
                        css["touch-action"] = "none";
                        css["ms-touch-action"] = "none";
                        if(css["overflow-x"] === "auto") {
                            css["touch-action"] = "pan-x";
                            css["ms-touch-action"] = "pan-x";
                        }
                    }
                    stateContainer.css(css);
                },
                _createAdditionalDom: function (self, f, ele) {
                    if(!ele.attr("tabindex")) {
                        ele.attr("tabindex", "-1");
                        f.tabindex = true;
                    }
                    var container = $("<div class='" + panelContainerClass + "'></div>"), customScrolling = self.options.customScrolling, stateContainer = f.stateContainer = $(innerElementHtml), assistContainer = f.assistContainer = $(assistElementHtml), simulateScroll = f.simulateScroll = assistContainer.find("." + simulateScrollClass), customScrollBarEle = f.customScrollBarEle = assistContainer.find("." + scrollBarEleClass), wijCSS = self.options.wijCSS, containerCreated = false;
                    // move child element to content wrapper div of wijsuperpanel.
                    f.contentWrapper = stateContainer.children();
                    ele.contents().each(function (index, el) {
                        var jel = $(el);
                        if(jel.hasAllClasses(wijCSS.superpanelHeader)) {
                            f.header = jel;
                            return;
                        }
                        if(jel.hasAllClasses(wijCSS.superpanelFooter)) {
                            f.footer = jel;
                            return;
                        }
                        if(jel.hasClass(panelContainerClass)) {
                            containerCreated = true;
                            return false;
                        }
                        f.contentWrapper[0].appendChild(el);
                    });
                    // append header to first element.
                    if(f.header !== undefined) {
                        ele.prepend(f.header);
                    }
                    if(containerCreated) {
                        container = ele.children("." + panelContainerClass);
                        stateContainer = f.stateContainer = container.find(".wijmo-wijsuperpanel-statecontainer");
                        f.contentWrapper = stateContainer.children();
                    }
                    container[0].appendChild(stateContainer[0]);
                    ele[0].appendChild(container[0]);
                    // Ensure assist div stay behind the state contianer.
                    if(container.children("." + assistContainerClass).length > 0) {
                        f.assistContainer = container.children("." + assistContainerClass);
                        f.simulateScroll = f.assistContainer.find("." + simulateScrollClass);
                        f.customScrollBar = f.assistContainer.find("." + scrollBarEleClass);
                    }
                    if(customScrolling) {
                        container[0].appendChild(f.assistContainer[0]);
                    } else {
                        f.assistContainer.remove();
                    }
                    self._resetDom();
                    container.height(stateContainer.height()).width(stateContainer.width() + scrollWidth);
                    // append footer to first element.
                    if(f.footer !== undefined) {
                        f.footer.insertAfter(container);
                    }
                    f.contentWrapper.css("float", "left");
                    f.contentWidth = f.contentWrapper.width();
                    f.contentHeight = f.contentWrapper.height();
                    f.contentWrapper.css("float", "");
                    if(customScrolling) {
                        self._setAssistElementStyle(f);
                    }
                    self._applyOverflow(f.stateContainer);
                },
                _setAssistElementStyle: function (f) {
                    var self = this, vs = self.options.vScroller.scrollBarVisibility, stateContainer = f.stateContainer, assistContainer = f.assistContainer, sumitScroll = f.simulateScroll, stateContainer, containterHeight, contentHeight, scrollDiv, left;
                    containterHeight = stateContainer.height();
                    contentHeight = f.contentHeight;
                    left = stateContainer.position().left + stateContainer.width() - scrollWidth;
                    scrollDiv = sumitScroll.children();
                    sumitScroll.css("width", scrollWidth).css("height", containterHeight).css("overflow-y", vs);
                    assistContainer.css("left", (left) + "px").css("width", scrollWidth).css("height", containterHeight);
                    scrollDiv.css("width", scrollWidth + 2).css("height", contentHeight).css("background", "transparent");
                    self._setCustomScrollDragLengthForIOS(self.options, f);
                },
                _setCustomScrollDragLengthForIOS: function (o, f) {
                    if(!isIOS) {
                        return;
                    }
                    var self = this, scrollBarEle = f.customScrollBarEle, range = o.vScroller.scrollMax - o.vScroller.scrollMin, largeChange = self._getVScrollBarLargeChange(), track = f.stateContainer.height(), divide = range / largeChange, dragLength = track / divide, minidrag = o.vScroller.scrollMinDragLength || 6;
                    if(dragLength < minidrag) {
                        dragLength = minidrag;
                    } else if((dragLength + 1) >= track) {
                        dragLength = track - 1;
                    }
                    dragLength = Math.round(dragLength);
                    scrollBarEle.height(dragLength);
                },
                _elementScrolled: function (curScrollLeft, curScrollTop, originalScrollLeft, originalScrollTop, customScrolling) {
                    var self = this, o = self.options, ele = self.element, direction, dir, oldValue, newValue, scrollPx;
                    if(curScrollTop === originalScrollTop && curScrollLeft === originalScrollLeft) {
                        return;
                    }
                    if(curScrollTop === originalScrollTop) {
                        if(customScrolling) {
                            return;
                        }
                        dir = "h";
                        if(curScrollLeft > originalScrollLeft) {
                            direction = "right";
                        } else {
                            direction = "left";
                        }
                        oldValue = o.hScroller.scrollValue;
                        scrollPx = curScrollLeft;
                    } else {
                        dir = "v";
                        if(curScrollTop > originalScrollTop) {
                            direction = "bottom";
                        } else {
                            direction = "top";
                        }
                        oldValue = o.vScroller.scrollValue;
                        scrollPx = curScrollTop;
                    }
                    newValue = self.scrollPxToValue(scrollPx, dir);
                    newValue = Math.round(newValue);
                    self._trigger("scrolling", null, {
                        dir: dir,
                        direction: direction,
                        oldValue: oldValue,
                        newValue: newValue,
                        beforePosition: {
                            left: -originalScrollLeft,
                            top: -originalScrollTop
                        }
                    });
                    //scroll event
                    self._triggerScroll(scrollPx, dir);
                    //update scroll value
                    self._updateScrollValue(scrollPx, dir);
                    //scrolled event
                    self._trigger("scrolled", null, {
                        dir: dir,
                        beforePosition: {
                            left: -originalScrollLeft,
                            top: -originalScrollTop
                        },
                        afterPosition: {
                            left: -curScrollLeft,
                            top: -curScrollTop
                        },
                        newValue: newValue
                    });
                },
                _bindElementEvents: function () {
                    var self = this, ele = self.element, o = self.options, f = self._fields(), wn = self.widgetName, scrollEle = f.stateContainer, originalScrollLeft = scrollEle.scrollLeft(), originalScrollTop = scrollEle.scrollTop(), simulateScroll = f.simulateScroll, currentTop, currentLeft, scrollBarEle = f.customScrollBarEle, scrollBarEleTop, scrollBarEleHeight, innerHeight, scrollHeight, startPointY, endPointY, y_Offset, startPointX, endPointX, x_Offset, horizontalMove = false, hasMouseDown = false, fadeTime, hasScrollBarEle = isIOS && (scrollBarEle.length > 0);
                    simulateScroll.unbind();
                    scrollEle.unbind("." + wn);
                    $(document).unbind("mouseup." + wn);
                    if(o.customScrolling) {
                        if(simulateScroll.length > 0) {
                            innerHeight = simulateScroll.children().height();
                            scrollHeight = simulateScroll.height();
                            originalScrollTop = simulateScroll.scrollTop();
                            if(hasScrollBarEle) {
                                scrollBarEle.css("display", "block");
                                scrollBarEleHeight = scrollBarEle.height();
                                scrollBarEle.css("display", "none");
                                scrollBarEleTop = scrollBarEle.position().top;
                            }
                            simulateScroll.bind("scroll", function (event, data) {
                                currentTop = simulateScroll.scrollTop();
                                currentLeft = scrollEle.scrollLeft();
                                if(hasScrollBarEle) {
                                    scrollBarEleTop = self._getCustomScrollOffset(currentTop, innerHeight, scrollHeight, scrollBarEleHeight);
                                    if(scrollBarEleTop < 0) {
                                        scrollBarEleTop = 0;
                                    }
                                    scrollBarEle.css("top", scrollBarEleTop + "px");
                                }
                                self._elementScrolled(currentLeft, currentTop, originalScrollLeft, originalScrollTop, true);
                                originalScrollLeft = currentLeft;
                                originalScrollTop = currentTop;
                            });
                            scrollEle.bind("wijmousedown." + wn, function (event) {
                                startPointY = event.pageY;
                                startPointX = event.pageX;
                                hasMouseDown = true;
                                if(fadeTime) {
                                    clearTimeout(fadeTime);
                                }
                                if(hasScrollBarEle) {
                                    scrollBarEle.stop().fadeIn(100);
                                }
                            });
                            scrollEle.bind("wijmousemove." + wn, function (event) {
                                if(hasMouseDown) {
                                    endPointY = event.pageY;
                                    y_Offset = endPointY - startPointY;
                                    endPointX = event.pageX;
                                    x_Offset = endPointX - startPointX;
                                    horizontalMove = (Math.abs(y_Offset) < Math.abs(x_Offset));
                                    if(y_Offset) {
                                        if(!horizontalMove) {
                                            currentTop = simulateScroll.scrollTop();
                                            simulateScroll.scrollTop(currentTop - y_Offset);
                                        }
                                        startPointY = endPointY;
                                    }
                                }
                                if(!$.browser.msie && !horizontalMove) {
                                    event.stopPropagation();
                                    event.preventDefault();
                                }
                            });
                            scrollEle.bind("wijmouseup." + wn, function (event) {
                                startPointY = event.pageY;
                                startPointX = event.pageX;
                                hasMouseDown = false;
                                horizontalMove = false;
                                if(hasScrollBarEle) {
                                    fadeTime = setTimeout(function () {
                                        scrollBarEle.fadeOut("slow");
                                    }, 1000);
                                }
                            });
                            $(document).bind("mouseup." + wn, function (event) {
                                hasMouseDown = false;
                                horizontalMove = false;
                                startPointY = event.pageY;
                                startPointX = event.pageX;
                            });
                        }
                        scrollEle.bind("mousewheel." + wn, self, self._panelMouseWheel);
                    }
                    scrollEle.bind("scroll", function (event, data) {
                        if(o.customScrolling && simulateScroll.length > 0) {
                            currentTop = simulateScroll.scrollTop();
                        } else {
                            currentTop = scrollEle.scrollTop();
                        }
                        currentLeft = scrollEle.scrollLeft();
                        self._elementScrolled(currentLeft, currentTop, originalScrollLeft, originalScrollTop, false);
                        originalScrollLeft = currentLeft;
                        originalScrollTop = currentTop;
                    });
                    if(o.keyboardSupport) {
                        if(self._keyboardBind === undefined) {
                            self._keyboardBind = true;
                            ele.bind("keydown." + wn, self, self._panelKeyDown);
                        }
                    } else {
                        ele.unbind("keydown." + wn, self._panelKeyDown);
                        self._keyboardBind = undefined;
                    }
                    if(!o.mouseWheelSupport) {
                        ele.bind("mousewheel", function (event) {
                            event.stopPropagation();
                            return false;
                        });
                    }
                },
                _getCustomScrollOffset: function (scrollOffset, innerScrollHeight, scrollHeight, customScrollHeight) {
                    var customOffset, divide;
                    divide = (scrollHeight - customScrollHeight) / (innerScrollHeight - scrollHeight);
                    return scrollOffset * divide;
                },
                _panelMouseWheel: // ** Add private methods for customize mouse wheel event. ** //
                // ** Copy code from Default Superpanel ** //
                function (e, delta) {
                    var self = e.data, o = self.options, originalElement, dir = "", onHbar, hScroller = o.hScroller, vScroller = o.vScroller, scrollEnd, vSmall, vLarge, vSCrollValue, vScrollPx, assistDiv;
                    if(!o.mouseWheelSupport || o.disabled) {
                        return;
                    }
                    originalElement = $(e.srcElement || e.originalEvent.target);
                    onHbar = originalElement.closest("." + hbarContainerCSS, self.element).size() > 0;
                    if(onHbar) {
                        e.stopPropagation();
                        e.preventDefault();
                        return;
                    }
                    if(delta > 0) {
                        dir = "top";
                    } else {
                        dir = "bottom";
                    }
                    if(dir.length > 0) {
                        vSmall = self._getVScrollBarSmallChange();
                        vLarge = self._getVScrollBarLargeChange();
                        if(!self._setScrollerValue(dir, vScroller, vSmall, vLarge, dir === "bottom", false, self)) {
                            return;
                        }
                        vSCrollValue = vScroller.scrollValue;
                        vScrollPx = vSCrollValue ? self._scrollValueToPx(vSCrollValue, "v") : 0;
                        if(vSCrollValue !== undefined) {
                            self._fields().assistContainer.find("." + simulateScrollClass).prop("scrollTop", vScrollPx);
                        }
                    }
                    scrollEnd = false;
                    if(dir === "top") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - vScroller.scrollMin) < 0.001;
                    }
                    if(dir === "bottom") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - (vScroller.scrollMax - self._getVScrollBarLargeChange() + 1)) < 0.001;
                    }
                    if(!scrollEnd || !o.bubbleScrollingEvent) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                },
                _getVScrollBarSmallChange: function () {
                    var o = this.options, va;
                    if(!o.vScroller.scrollSmallChange) {
                        va = this._getVScrollBarLargeChange();
                        o.vScroller.scrollSmallChange = va / 2;
                    }
                    return o.vScroller.scrollSmallChange;
                },
                _getVScrollBarLargeChange: function () {
                    var self = this, o = self.options, f = self._fields(), scroller = o.vScroller, autoKey = "_autoVLarge", vMax, vMin, vRange, content, contentHeight, wrapperHeight, percent, large;
                    if(scroller.scrollLargeChange) {
                        return scroller.scrollLargeChange;
                    }
                    // calculate large change if empty
                    vMax = scroller.scrollMax;
                    vMin = scroller.scrollMin;
                    vRange = vMax - vMin;
                    content = f.simulateScroll;
                    contentHeight = content["innerHeight"]();
                    wrapperHeight = f["contentHeight"];
                    percent = contentHeight / (wrapperHeight - contentHeight);
                    large = ((vRange + 1) * percent) / (1 + percent);
                    if(isNaN(large)) {
                        large = 0;
                    }
                    scroller.scrollLargeChange = large;
                    self[autoKey] = true;
                    return scroller.scrollLargeChange;
                },
                _setScrollerValue: function (dir, scroller, smallChange, largeChange, isAdd, isLarge, self) {
                    var o = this.options, vMin = scroller.scrollMin, change = isLarge ? largeChange : smallChange, value = scroller.scrollValue, t = 0, vTopValue, firstStepChangeFix, data, scrollValue, val, ev;
                    if(!value) {
                        value = vMin;
                    }
                    vTopValue = scroller.scrollMax - largeChange + 1;
                    if(value > vTopValue) {
                        value = vTopValue;
                    }
                    if(isAdd) {
                        if(Math.abs(value - vTopValue) < 0.0001) {
                            self._clearInterval();
                            return false;
                        }
                        firstStepChangeFix = scroller.firstStepChangeFix;
                        t = value + change;
                        if(!isLarge && Math.abs(value - vMin) < 0.0001 && !isNaN(firstStepChangeFix)) {
                            t += firstStepChangeFix;
                        }
                        if(t > vTopValue) {
                            t = vTopValue;
                        }
                    } else {
                        if(Math.abs(value - vMin) < 0.0001) {
                            self._clearInterval();
                            return false;
                        }
                        t = value - change;
                        if(t < 0) {
                            t = vMin;
                        }
                    }
                    data = {
                        oldValue: scroller.scrollValue,
                        newValue: t,
                        direction: dir,
                        dir: scroller.dir
                    };
                    if(!self._scrolling(true, self, data)) {
                        return false;
                    }
                    if(self.customScroll) {
                        val = Math.abs(self.customScroll);
                        scrollValue = self.scrollPxToValue(val, scroller.dir);
                    }
                    scroller.scrollValue = scrollValue || t;
                    ev = $.Event("scrollValueChanged");
                    this._trigger("scrollValueChanged", ev, scroller);
                    self.customScroll = undefined;
                    return true;
                },
                _clearInterval: function () {
                    var f = this._fields(), intervalID = f.internalFuncID;
                    if(intervalID > 0) {
                        window.clearInterval(intervalID);
                        f.internalFuncID = -1;
                    }
                },
                _scrolling: function (fireEvent, self, d) {
                    var r = true;
                    if(fireEvent) {
                        d.beforePosition = self.getContentElement().position();
                        self._beforePosition = d.beforePosition;
                        r = self._trigger("scrolling", null, d);
                        self.customScroll = d.customScroll;
                    }
                    return r;
                },
                _setScrollingInterval: // ** End ** //
                function (f, dir, self, large) {
                    var o = self.options;
                    if(dir.length > 0) {
                        f.internalFuncID = window.setInterval(function () {
                            self._doScrolling(dir, self, large);
                        }, o.keyDownInterval);
                    }
                },
                _triggerScroll: function (contentLeft, dir) {
                    var data = {
                        position: contentLeft,
                        dir: dir
                    };
                    this._trigger("scroll", null, data);
                },
                _panelKeyDown: function (e) {
                    // Key down handler.
                                        var self = e.data, o = self.options, shift, keycode, kCode = wijmo.getKeyCodeEnum();
                    if(!o.keyboardSupport || o.disabled) {
                        return;
                    }
                    shift = e.shiftKey;
                    keycode = e.keyCode;
                    if(keycode === kCode.LEFT) {
                        self._doScrolling("left", self, shift);
                    } else if(keycode === kCode.RIGHT) {
                        self._doScrolling("right", self, shift);
                    } else if(keycode === kCode.UP) {
                        self._doScrolling("top", self, shift);
                    } else if(keycode === kCode.DOWN) {
                        self._doScrolling("bottom", self, shift);
                    }
                    e.stopPropagation();
                    e.preventDefault();
                },
                _doScrolling: function (dir, self, large) {
                    var value, orient, func, f = self._fields(), ele = self.options.customScrolling ? f.simulateScroll[0] : f.stateContainer[0], animateOpt = {
                    }, scrollVal;
                    if(dir === "top" || dir === "bottom") {
                        orient = "v";
                        func = "scrollTop";
                    } else if(dir === "left" || dir === "right") {
                        orient = "h";
                        func = "scrollLeft";
                    }
                    if(large) {
                        value = self._getLargeChange(orient);
                    } else {
                        value = self._getSmallChange(orient);
                    }
                    scrollVal = ele[func];
                    if(dir === "top" || dir === "left") {
                        animateOpt[func] = scrollVal - value;
                    } else {
                        animateOpt[func] = scrollVal + value;
                    }
                    self._animateTo(animateOpt);
                },
                _getLargeChange: function (div) {
                    var self = this, f = self._fields(), largeChange, length = div == "h" ? f.clientWidth : f.clientHeight;
                    if(length) {
                        largeChange = length;
                    } else {
                        largeChange = f.stateContainer[div == "h" ? "width" : "height"]();
                    }
                    return largeChange;
                },
                _getSmallChange: function () {
                    return this._getLargeChange() / 2;
                },
                _setRounder: function (self, ele) {
                    var cornerCSS = this.options.wijCSS.cornerAll;
                    if(this.options.showRounder) {
                        ele.addClass(cornerCSS);
                        if(self._rounderAdded) {
                            return;
                        }
                        if($.browser.msie) {
                            return;
                        }
                        var key1 = "", key = "", value, border;
                        if($.browser.webkit) {
                            key = "WebkitBorderTopLeftRadius";
                            key1 = "WebkitBorderRadius";
                        } else if($.browser.mozilla) {
                            key = "MozBorderRadiusBottomleft";
                            key1 = "MozBorderRadius";
                        } else {
                            key = "border-top-left-radius";
                            key1 = "border-radius";
                        }
                        value = ele.css(key);
                        border = parseInt(value, 10);
                        ele.css(key1, border + 1);
                        self._rounderAdded = true;
                        self._radiusKey = key1;
                    } else {
                        ele.removeClass(cornerCSS);
                    }
                },
                _initResizer: function () {
                    // Initialize reseizer of wijsuperpanel.
                                        var self = this, o = self.options, f = self._fields(), resizer = f.resizer, resizableOptions, oldstop;
                    if(!$.fn.resizable) {
                        return;
                    }
                    if(!resizer && o.allowResize) {
                        resizableOptions = o.resizableOptions;
                        oldstop = resizableOptions.stop;
                        resizableOptions.stop = function (e) {
                            self._resetDom();
                            self._trigger("resized");
                            if($.isFunction(oldstop)) {
                                oldstop(e);
                            }
                        };
                        f.resizer = resizer = self.element.resizable(resizableOptions);
                    }
                    if(!o.allowResize && f.resizer) {
                        resizer.resizable("destroy");
                        f.resizer = null;
                    }
                },
                _adjustScrollValue: function (dir) {
                    var isHori = dir === "h", self = this, o = this.options, needScroll = isHori ? self.hNeedScrollBar : self.vNeedScrollBar, scroller = isHori ? o.hScroller : o.vScroller, max = scroller.scrollMax, min = scroller.scrollMin, largeChange, topValue;
                    if(needScroll) {
                        largeChange = isHori ? self._getHScrollBarLargeChange() : self._getVScrollBarLargeChange();
                        topValue = max - largeChange + 1;
                        if(scroller.scrollValue > topValue) {
                            scroller.scrollValue = topValue;
                        }
                        if(scroller.scrollValue < min) {
                            scroller.scrollValue = min;
                        }
                    }
                },
                _resetDom: function () {
                    var self = this, o = self.options, ele = self.element, f = self._fields(), width = ele.width(), height = ele.height();
                    //minus header and footer's height if they exist.
                    //fix #37099
                    if(f.header !== undefined) {
                        height -= f.header.outerHeight();
                    }
                    if(f.footer !== undefined) {
                        height -= f.footer.outerHeight();
                    }
                    if(f.stateContainer.length) {
                        f.stateContainer.css({
                            width: width,
                            height: height
                        });
                        f.clientWidth = f.stateContainer[0].clientWidth;
                        f.clientHeight = f.stateContainer[0].clientHeight;
                    }
                    self._initScrollPosition();
                },
                _fields: function () {
                    var self = this, ele = self.element, key = self.widgetName + "-fields", d = self._fieldsStore;
                    if(d === undefined) {
                        d = {
                        };
                        ele.data(key, d);
                        self._fieldsStore = d;
                    }
                    return d;
                },
                _getScrollOffset: function (child1) {
                    var child = $(child1), f, cWrapper, childOffset, templateOffset, cWrapperOffset, tDistance, bDistance, lDistance, rDistance, result = {
                        left: null,
                        top: null
                    };
                    if(child.length === 0) {
                        return result;
                    }
                    f = this._fields();
                    cWrapper = f.contentWrapper;
                    childOffset = child.offset();
                    childOffset.leftWidth = childOffset.left + child.outerWidth();
                    childOffset.topHeight = childOffset.top + child.outerHeight();
                    cWrapperOffset = cWrapper.offset();
                    cWrapperOffset.leftWidth = cWrapperOffset.left + f.clientWidth;
                    cWrapperOffset.topHeight = cWrapperOffset.top + f.clientHeight;
                    lDistance = childOffset.left - cWrapperOffset.left;
                    if(childOffset.left < cWrapperOffset.left) {
                        result.left = lDistance;
                    } else if(childOffset.leftWidth > cWrapperOffset.leftWidth) {
                        rDistance = childOffset.leftWidth - cWrapperOffset.left - f.clientWidth;
                        if(lDistance < rDistance) {
                            result.left = lDistance;
                        } else {
                            result.left = rDistance;
                        }
                    }
                    tDistance = childOffset.top - cWrapperOffset.top;
                    if(childOffset.top < cWrapperOffset.top) {
                        result.top = tDistance;
                    } else if(childOffset.topHeight > cWrapperOffset.topHeight) {
                        bDistance = childOffset.topHeight - cWrapperOffset.top - f.clientHeight;
                        if(tDistance < bDistance) {
                            result.top = tDistance;
                        } else {
                            result.top = bDistance;
                        }
                    }
                    return result;
                },
                _initialize: function (f, ele, self) {
                    var wijCSS = self.options.wijCSS;
                    f.initialized = true;
                    ele.addClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content
                    ].join(' '));
                    self._setRounder(self, ele);
                    self._createAdditionalDom(self, f, ele);
                    self._trigger("painted");
                    self._initScrollPosition();
                },
                _initScrollPosition: function () {
                    var o = this.options, hScroller = o.hScroller, vScroller = o.vScroller, hScrollValue = hScroller.scrollValue, vSCrollValue = vScroller.scrollValue, f = this._fields(), vScrollElement = o.customScrolling ? f.simulateScroll : f.stateContainer, hScrollPx = hScrollValue ? this._scrollValueToPx(hScrollValue, "h") : 0, vScrollPx = vSCrollValue ? this._scrollValueToPx(vSCrollValue, "v") : 0;
                    if(hScrollValue) {
                        f.stateContainer.prop("scrollLeft", hScrollPx);
                    }
                    if(vSCrollValue) {
                        vScrollElement.prop("scrollTop", vScrollPx);
                    }
                },
                _updateScrollValue: function (px, dir) {
                    var value = this.scrollPxToValue(px, dir), o = this.options, scroller = (dir === "h" ? "hScroller" : "vScroller"), ev = $.Event("scrollValueChanged");
                    o[scroller].scrollValue = value;
                    this._trigger("scrollValueChanged", ev, o[scroller]);
                },
                scrollPxToValue: /**
                * Convert pixel to scroll value.
                * For example, wijsuperpanel scrolled 50px
                * which is value 1 after conversion.
                * @param {number} px Length of scrolling.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (px, dir) {
                    var self = this, o = self.options, f = self._fields(), clientLengthKey, scrollLengthKey, scroller, vScrollElement, hScrollElement, cWrapper, clientLengthValue, scrollLengthValue, vMin, vMax, vRange, ret;
                    clientLengthKey = (dir === "h" ? "clientWidth" : "clientHeight");
                    scrollLengthKey = (dir === "h" ? "scrollWidth" : "scrollHeight");
                    scroller = (dir === "h" ? "hScroller" : "vScroller");
                    hScrollElement = f.stateContainer[0];
                    vScrollElement = o.customScrolling ? f.simulateScroll[0] : hScrollElement , cWrapper = dir === "h" ? hScrollElement : vScrollElement;
                    clientLengthValue = cWrapper[clientLengthKey];
                    scrollLengthValue = cWrapper[scrollLengthKey];
                    vMin = o[scroller].scrollMin;
                    vMax = o[scroller].scrollMax - self._getVScrollBarLargeChange() + 1;
                    vRange = vMax - vMin;
                    ret = vRange * px / (scrollLengthValue - clientLengthValue) + vMin;
                    return ret;
                },
                scrollValueToPx: /**
                * Convert scroll value to pixel.
                * For example, scroll value is 1
                * which makes wijsuperpanel scroll 50px after conversion.
                * @param {number} value of scrolling.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (value, dir) {
                    return this._scrollValueToPx(value, dir);
                },
                _scrollValueToPx: function (value, dir) {
                    var self = this, o = self.options, f = self._fields(), clientLengthKey, scrollLengthKey, scroller, cWrapper, clientLengthValue, scrollLengthValue, vMin, vMax, vRange, ret, vScrollElement, hScrollElement;
                    clientLengthKey = (dir === "h" ? "clientWidth" : "clientHeight");
                    scrollLengthKey = (dir === "h" ? "scrollWidth" : "scrollHeight");
                    scroller = (dir === "h" ? "hScroller" : "vScroller");
                    hScrollElement = f.stateContainer[0];
                    vScrollElement = o.customScrolling ? f.simulateScroll[0] : hScrollElement , cWrapper = (dir === "h" ? hScrollElement : vScrollElement);
                    clientLengthValue = cWrapper[clientLengthKey];
                    scrollLengthValue = cWrapper[scrollLengthKey];
                    vMin = o[scroller].scrollMin;
                    vMax = o[scroller].scrollMax - self._getVScrollBarLargeChange() + 1;
                    vRange = vMax - vMin;
                    if(value === undefined || value < vMin) {
                        value = vMin;
                    }
                    if(value > vMax) {
                        value = vMax;
                    }
                    ret = (value - vMin) * (scrollLengthValue - clientLengthValue) / vRange;
                    return ret;
                },
                _animateTo: function (to) {
                    var self = this, ele = self.element, o = self.options, ao = o.animationOptions, f = self._fields();
                    if(o.customScrolling) {
                        f.simulateScroll.animate(to, ao);
                    } else {
                        f.stateContainer.animate(to, ao);
                    }
                },
                destroy: function () {
                    var self = this, ele = self.element, o = self.options, f = self._fields(), cWrapper, container, wijCSS = o.wijCSS;
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                    }
                    if(f.resizer !== undefined) {
                        f.resizer.resizable("destroy");
                    }
                    ele.unbind("." + self.widgetName);
                    ele.removeClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content, 
                        wijCSS.cornerAll
                    ].join(' '));
                    container = ele.find("." + panelContainerClass);
                    cWrapper = f.contentWrapper;
                    cWrapper.contents().each(function (index, e) {
                        ele.append(e);
                    });
                    f.stateContainer.remove();
                    f.assistContainer.remove();
                    container.remove();
                    $.Widget.prototype.destroy.apply(self, arguments);
                },
                doScrolling: function (dir, large) {
                    /// <summary>
                    /// Do scrolling.
                    /// </summary>
                    /// <param name="dir" type="string">
                    ///   Scrolling direction. Options are: "left", "right", "top" and "bottom".
                    /// </param>
                    /// <param name="large" type="Boolean">
                    /// Whether to scroll a large change.
                    /// </param>
                    this._doScrolling(dir, this, large);
                },
                paintPanel: function (unfocus) {
                    var self = this, ele = self.element, f = self._fields();
                    if(!f.initialized) {
                        this._initialize(f, ele, self);
                    }
                },
                needToScroll: function (child1) {
                    /// <summary>
                    /// Determine whether scoll the child DOM element to view
                    /// need to scroll the scroll bar
                    /// </summary>
                    /// <param name="child" type="DOMElement/JQueryObj">
                    /// The child to scroll to.
                    /// </param>
                    var offset = this._getScrollOffset(child1);
                    return offset.top !== null || offset.left !== null;
                },
                scrollChildIntoView: function (child1) {
                    /// <summary>
                    /// Scroll child DOM element into view.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("scrollChildIntoView", $("li#reditem"));
                    /// </summary>
                    /// <param name="child" type="DOMElement/JQueryObj">
                    /// The child to scroll to.
                    /// </param>
                                        var offset = this._getScrollOffset(child1), left = offset.left, top = offset.top;
                    this.scrollTo(left, top);
                },
                getContentElement: function () {
                    /// <summary>
                    /// Gets the content element of wijsuperpanel.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("getContentElement");
                    /// </summary>
                    /// <returns type="JQueryObj" />
                    return this._fields().contentWrapper;
                },
                hScrollTo: function (x, isScrollValue) {
                    /// <summary>
                    /// Scrolls to the indicated horizontal position.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("hScrollTo", 100);
                    /// </summary>
                    /// <param name="x" type="Number">
                    /// The position to scroll to.
                    /// </param>
                    /// <param name="isScrollValue" type="Boolean">
                    /// A value that indicates whether x is value or pixel.
                    /// </param>
                    var val = !!isScrollValue ? this._scrollValueToPx(x) : x;
                    //this._updateScrollValue(val, "h");
                    this._animateTo({
                        "scrollLeft": val
                    });
                },
                vScrollTo: function (y, isScrollValue) {
                    /// <summary>
                    /// Scrolls to the indicated vertical position.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("vScrollTo", 100);
                    /// </summary>
                    /// <param name="y" type="Number">
                    /// The position to scroll to.
                    /// </param>
                    /// <param name="isScrollValue" type="Boolean">
                    /// A value that indicates whether x is value or pixel.
                    /// </param>
                    var val = !!isScrollValue ? this._scrollValueToPx(y) : y;
                    //this._updateScrollValue(val, "v");
                    this._animateTo({
                        "scrollTop": val
                    });
                },
                refresh: function () {
                    /// <summary>
                    /// Refreshes the wijsuperpanel.
                    /// Needs to be called after content being changed.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("refresh");
                    /// </summary>
                    /// <returns type="Boolean">
                    /// Returns true if it is successful, else returns false.
                    /// </returns>
                                        var self = this, f = self._fields();
                    self._applyOverflow(f.stateContainer);
                    self._resetDom();
                },
                scrollTo: function (x, y, isScrollValue) {
                    /// <summary>
                    /// Scroll to specified position.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("scrollTo", 100, 100);
                    /// </summary>
                    /// <param name="x" type="Number">
                    /// Horizontal position to scroll to.
                    /// </param>
                    /// <param name="y" type="Number">
                    /// Vertical position to scroll to.
                    /// </param>
                    /// <param name="isScrollValue" type="Boolean">
                    /// A value that indicates whether x,y are value or pixel.
                    /// </param>
                                        var valX = !!isScrollValue ? this._scrollValueToPx(x) : x, valY = !!isScrollValue ? this._scrollValueToPx(y) : y;
                    //this._updateScrollValue(valX, "h");
                    //this._updateScrollValue(valY, "v");
                    //this._animateTo({ "scrollTop": valY, "scrollLeft": valX });
                    this._animateTo({
                        "scrollTop": valY
                    });
                    this._animateTo({
                        "scrollLeft": valX
                    });
                }
            });
            //,
            //scrollPxToValue: function (px, dir) {
            //    /// <summary>
            //    /// Convert pixel to scroll value.
            //    /// For example, wijsuperpanel scrolled 50px
            //    ///which is value 1 after conversion.
            //    /// </summary>
            //    /// <param name="px" type="Number">
            //    /// Length of scrolling.
            //    /// </param>
            //    /// <param name="dir" type="String">
            //    /// Scrolling direction. Options are: "h" and "v".
            //    /// </param>
            //    return px;
            //}
            wijsuperpanel.prototype.options = $.extend(true, {
            }, wijmo.wijmoWidget.prototype.options, {
                wijCSS: {
                    superpanelHeader: "wijmo-wijsuperpanel-header",
                    superpanelFooter: "wijmo-wijsuperpanel-footer",
                    superpanelHandle: "",
                    superpanelVBarbuttonTop: "",
                    superpanelVBarbuttonBottom: "",
                    superpanelHBarbuttonLeft: "",
                    superpanelHBarbuttonRight: "",
                    superpanelHBarContainer: "",
                    superpanelVBarContainer: "",
                    superpanelButton: "",
                    superpanelButtonLeft: "",
                    superpanelButtonRight: "",
                    superpanelButtonTop: "",
                    superpanelButtonBottom: ""
                },
                wijMobileCSS: {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-b",
                    stateDefault: "ui-btn ui-btn-b",
                    stateHover: "ui-btn-down-c",
                    stateActive: "ui-btn-down-c"
                },
                initSelector: /// <summary>
                /// Selector option for auto self initialization.
                ///	This option is internal.
                /// </summary>
                ":jqmData(role='wijsuperpanel')",
                allowResize: false,
                animationOptions: {
                    queue: false,
                    disabled: false,
                    duration: 250,
                    easing: undefined
                },
                hScroller: {
                    scrollBarVisibility: "auto",
                    scrollValue: null,
                    scrollMax: 100,
                    firstStepChangeFix: 0,
                    scrollMin: 0,
                    hoverEdgeSpan: 20
                },
                keyboardSupport: false,
                keyDownInterval: 100,
                mouseWheelSupport: true,
                resizableOptions: {
                    handles: "all",
                    helper: "ui-widget-content wijmo-wijsuperpanel-helper"
                },
                resized: null,
                painted: null,
                scroll: null,
                showRounder: true,
                vScroller: {
                    scrollBarVisibility: "auto",
                    scrollValue: null,
                    scrollMax: 100,
                    scrollMin: 0,
                    firstStepChangeFix: 0,
                    hoverEdgeSpan: 20
                }
            });
            $.wijmo.registerWidget("wijsuperpanel", wijsuperpanel.prototype);
        }
    })(wijmo.superpanel || (wijmo.superpanel = {}));
    var superpanel = wijmo.superpanel;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
/*
 * Depends:
 * jquery-1.9.1.js
 * jquery.ui.core.js
 * jquery.ui.widget.js
 * globalize.js
 * jquery.wijmo.widget.js
 * jquery.wijmo.wijutil.js
 * wijmo.data.js
 *
 * Optional dependencies for paging feature:
 * jquery.wijmo.wijpager.js
 *
 * Optional dependencies for scrolling feature:
 * jquery.wijmo.wijsuperpanel.js
 *
 * Optional dependencies for filtering feature:
 * jquery.ui.position.js
 * jquery.wijmo.wijinputdateformat.js
 * jquery.wijmo.wijinputdate.js
 * jquery.wijmo.wijinputtextformat.js
 * jquery.wijmo.wijinputtext.js
 * jquery.wijmo.wijinputnumberformat.js
 * jquery.wijmo.wijinputnumber.js
 * jquery.wijmo.wijlist.js
 *
 * Optional dependencies for column moving feature:
 * jquery.ui.draggable.js
 * jquery.ui.droppable.js
 * jquery.ui.position.js
 *
 */

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../../../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="interfaces.ts" />
    /// <reference path="bands_traversing.ts" />
    /// <reference path="misc.ts"/>
    /// <reference path="cellInfo.ts"/>
    /// <reference path="selection.ts"/>
    /// <reference path="cellEditorHelper.ts"/>
    /// <reference path="cellFormatterHelper.ts"/>
    /// <reference path="cellStyleFormatterHelper.ts"/>
    /// <reference path="rowStyleFormatterHelper.ts"/>
    /// <reference path="fixedView.ts"/>
    /// <reference path="flatView.ts"/>
    /// <reference path="dataViewWrapper.ts"/>
    /// <reference path="filterOperators.ts"/>
    /// <reference path="columnsGenerator.ts"/>
    /// <reference path="rowAccessor.ts"/>
    /// <reference path="grouper.ts"/>
    /// <reference path="renderBoundsCollection.ts"/>
    /// <reference path="uiDragndrop.ts"/>
    /// <reference path="uiSelection.ts"/>
    /// <reference path="uiResizer.ts"/>
    /// <reference path="uiFrozener.ts"/>
    /// <reference path="c1field.ts"/>
    /// <reference path="c1band.ts"/>
    /// <reference path="c1buttonfield.ts"/>
    /// <reference path="sketchTable.ts"/>
    /// <reference path="../../../data/src/core.ts"/>
    /// <reference path="../../../data/src/dataView.ts"/>
    /// <reference path="../data/converters.ts"/>
    /// <reference path="../data/koDataView.ts"/> // add reference, otherwise it will be not added to the grunt output.
    /// <reference path="../../../wijpager/jquery.wijmo.wijpager.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        function extendWidgetOptions(baseOptions, newOptions) {
            var result = $.extend(true, {
            }, baseOptions, newOptions);
            delete result.constructor// Remove the constructor because the widget.options object is a ts class now (widgetName_options).
            ;
            return result;
        }
        grid.extendWidgetOptions = extendWidgetOptions;
        /** @widget
        * Represents the wijgrid widget.
        */
        var wijgrid = (function (_super) {
            __extends(wijgrid, _super);
            function wijgrid() {
                _super.apply(this, arguments);

                // private fields **
                this._dataOffset = 0;
                // h. pos, v. pos, virtual scroll index
                this.rowOuterHeight = -1;
                this._windowResizeTimer = 0;
                this.mEditSkechRowIndex = -1;
                this.mCurrentCellLocker = false;
            }
            wijgrid.CSS = {
                wijgrid: "wijmo-wijgrid",
                root: "wijmo-wijgrid-root",
                editedCellMarker: "wijmo-wijgrid-cell-edit",
                inputMarker: "wijgridinput",
                table: "wijmo-wijgrid-table",
                TH: "wijgridth",
                TD: "wijgridtd",
                cellContainer: "wijmo-wijgrid-innercell",
                aggregateContainer: "wijmo-wijgrid-aggregate",
                rowHeader: "wijmo-wijgrid-rowheader",
                currentRowHeaderCell: "wijmo-wijgrid-current-rowheadercell",
                currentHeaderCell: "wijmo-wijgrid-current-headercell",
                currentCell: "wijmo-wijgrid-current-cell",
                cellAlignLeft: "wijalign-left",
                cellAlignRight: "wijalign-right",
                cellAlignCenter: "wijalign-center",
                filterList: "wijmo-wijgrid-filterlist",
                filter: "wijmo-wijgrid-filter",
                filterInput: "wijmo-wijgrid-filter-input",
                filterTrigger: "wijmo-wijgrid-filter-trigger",
                filterNativeHtmlEditorWrapper: "wijgrid-input-wrapper",
                headerArea: "wijmo-wijgrid-header",
                footerArea: "wijmo-wijgrid-footer",
                headerRow: "wijmo-wijgrid-headerrow",
                row: "wijmo-wijgrid-row",
                dataRow: "wijmo-wijgrid-datarow",
                altRow: "wijmo-wijgrid-alternatingrow",
                emptyDataRow: "wijmo-wijgrid-emptydatarow",
                filterRow: "wijmo-wijgrid-filterrow",
                groupHeaderRow: "wijmo-wijgrid-groupheaderrow",
                groupFooterRow: "wijmo-wijgrid-groupfooterrow",
                groupHeaderRowCollapsed: "wijmo-wijgrid-groupheaderrow-collapsed",
                groupHeaderRowExpanded: "wijmo-wijgrid-groupheaderrow-expanded",
                footerRow: "wijmo-wijgrid-footerrow",
                loadingOverlay: "wijmo-wijgrid-overlay",
                loadingText: "wijmo-wijgrid-loadingtext",
                groupArea: "wijmo-wijgrid-group-area",
                groupAreaEmpty: "wijmo-wijgrid-group-area-empty",
                groupAreaButton: "wijmo-wijgrid-group-button",
                groupAreaButtonSort: "wijmo-wijgrid-group-button-sort",
                groupAreaButtonClose: "wijmo-wijgrid-group-button-close",
                groupToggleVisibilityButton: "wijmo-wijgrid-grouptogglebtn",
                fixedView: "wijmo-wijgrid-fixedview",
                scroller: "wijmo-wijgrid-scroller",
                dndHelper: "wijmo-wijgrid-dnd-helper",
                dndArrowTopContainer: "wijmo-wijgrid-dnd-arrow-top",
                dndArrowBottomContainer: "wijmo-wijgrid-dnd-arrow-bottom",
                freezingHandleV: "wijmo-wijgrid-freezing-handle-v",
                freezingHandleH: "wijmo-wijgrid-freezing-handle-h",
                freezingHandleContent: "wijmo-wijgrid-freezing-handle-content",
                resizingHandle: "wijmo-wijgrid-resizehandle",
                headerCellSortIcon: "wijmo-wijgrid-sort-icon",
                headerCellText: "wijmo-wijgrid-headertext",
                c1basefield: "wijmo-c1basefield",
                c1band: "wijmo-c1band",
                c1field: "wijmo-c1field"
            };
            wijgrid.prototype._createWidget = // stores the deficient filters (one of the filterOperator\ filterValue values is unknown) during the dataView round trip by the dataKey.
            // * override
            function (options, element) {
                // Late binding, a fix for the case if options.data contains a complex object leading to stack overflow when $.extend is called in the widget factory.
                var data = options && (wijmo).data.util.isClassInstance(options.data) && !((typeof wijdatasource === "function") && (options.data instanceof wijdatasource)) && options.data;
                if(data) {
                    options._lateBindingFlag = true;
                    delete options.data;
                }
                _super.prototype._createWidget.apply(this, arguments);
                if(data) {
                    delete options._lateBindingFlag;
                    options.data = data// restore option value (fixes an issue when a single options object is passed to multiple instances of the wijgrid: $("table").wijgrid({...});
                    ;
                    this.option("data", data);
                }
            };
            wijgrid.prototype._create = function () {
                var self = this;
                if(!this.element.is("table")) {
                    throw "invalid markup";
                }
                this.mCurrentCellLocker = false;
                this._windowResizeTimer = 0;
                this._dataOffset = 0;
                this._scrollingState = {
                    x: null,
                    y: null,
                    index: 0
                };
                this.rowOuterHeight = -1;
                this._initialized = false;
                this._destroyed = false;
                this._rendered = false;
                this._eventUID = undefined;
                ;
                this._dataViewWrapper = undefined;
                this._originalHtml = undefined;
                this._originalAttr = undefined;
                this._originalCssText = undefined;
                this._autoHeight = undefined;
                this._autoWidth = undefined;
                this._renderCounter = 0;
                this.$superPanelHeader = undefined;
                this.$topPagerDiv = undefined;
                this.$bottomPagerDiv = undefined;
                this.$groupArea = undefined;
                this.__uid = undefined;
                this._wijDataView = undefined;
                this.outerDiv = undefined;
                this.sketchTable = undefined;
                this.cellFormatter = undefined;
                this.rowStyleFormatter = undefined;
                this.cellStyleFormatter = undefined;
                this._eventUID = wijmo.grid.getUID();
                this._spinnerIsActivated = false;
                this.deficientFilters = {
                };
                // ** jQuery UI 1.9.0 fix
                                var hasData = ("data" in this.options), data = hasData && this.options.data;
                if(hasData) {
                    delete this.options.data;
                }
                this.options = $.extend(true, {
                }, this.options);
                // handle juice objectValue serialize
                if($.isFunction(window["wijmoASPNetParseOptions"])) {
                    window["wijmoASPNetParseOptions"](this.options);
                }
                if(hasData) {
                    this.options.data = data;
                }
                // jQuery UI 1.9.0 fix **
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = (window).wijmoApplyWijTouchUtilEvents($);
                }
                this._initialized = false;
                this._destroyed = false;
                // culture
                this.mClosestCulture = Globalize.findClosestCulture(this.options.culture) || Globalize.findClosestCulture("default");
                // initialize data
                this._dataViewWrapper = new wijmo.grid.dataViewWrapper(this);
                this._originalHtml = this.element.html()// store original html. Will be restored in the destroy() method.
                ;
                this._originalAttr = {
                };
                this._originalCssText = this.element[0].style.cssText;
                this.element.addClass(wijmo.grid.wijgrid.CSS.root);
                this.element.wrap("<div class=\"" + this.options.wijCSS.widget + " " + wijmo.grid.wijgrid.CSS.wijgrid + " " + this.options.wijCSS.wijgrid + " " + this.options.wijCSS.content + " " + this.options.wijCSS.cornerAll + "\"></div>")// outer div
                ;
                this.outerDiv = this.element.parent();
                var styleHeight = this.element[0].style.height, styleWidth = this.element[0].style.width;
                if(styleHeight) {
                    this.outerDiv.css("height", styleHeight);
                }
                this._autoHeight = (styleHeight == "" || styleHeight == "auto");
                if(styleWidth) {
                    this.outerDiv.css("width", this.element[0].style.width);
                }
                this._autoWidth = (styleWidth == "" || styleWidth == "auto");
                this.element.css({
                    "height": "",
                    "width": ""
                });
                if(this.options.disabled) {
                    this.disable();
                }
                // formatters
                this.cellFormatter = new wijmo.grid.cellFormatterHelper();
                this.rowStyleFormatter = new wijmo.grid.rowStyleFormatterHelper(this);
                this.cellStyleFormatter = new wijmo.grid.cellStyleFormatterHelper(this);
                // * set bounds
                this._viewPortBounds({
                    start: 0,
                    end: 0
                });
                if(this._allowVirtualScrolling()) {
                    this._viewPortBounds().start = this._scrollingState.index// == 0 by default.
                    ;
                    if(this._serverSideVirtualScrolling()) {
                        this._dataOffset = this._scrollingState.index;
                    }
                }
                // set bounds *
                // wijObservable
                if(this.element.wijAddVisibilityObserver) {
                    this.element.wijAddVisibilityObserver(function (e) {
                        //if (self.element.is(":visible")) {
                        if(self._initialized && !self._destroyed && (e.target !== self.outerDiv[0])) {
                            // ignore notification triggered by baseView,
                            self.setSize();
                        }
                        //}
                                            }, "wijgrid");
                }
                this._renderCounter = 0;
            };
            wijgrid.prototype._destroy = function () {
                var tmp, self = this;
                try  {
                    this._view().dispose();
                    this._detachEvents(true);
                    if(this._resizerui) {
                        this._resizerui.dispose();
                        this._resizerui = null;
                    }
                    if(this._frozenerui) {
                        this._frozenerui.dispose();
                        this._frozenerui = null;
                    }
                    if(this._selectionui) {
                        this._selectionui.dispose();
                        this._selectionui = null;
                    }
                    if(this._dragndropui) {
                        this._dragndropui.dispose();
                        this._dragndropui = null;
                    }
                    this._dataViewWrapper.dispose();
                    // cleanup $data
                    wijmo.grid.remove$dataByPrefix(this.element, this._data$prefix);
                    if(this.element.wijRemoveVisibilityObserver) {
                        this.element.wijRemoveVisibilityObserver();
                    }
                    // ** restore original content
                    // restore content and destroy children widgets + data.
                    this.element.insertBefore(this.outerDiv);
                    this.outerDiv.remove();
                    this.element.html(this._originalHtml);
                    // restore attributes
                    $.each(this._originalAttr, function (key, value) {
                        if(value === undefined) {
                            self.element.removeAttr(key);
                        } else {
                            self.element.attr(key, value);
                        }
                    });
                    this.element.removeClass(wijmo.grid.wijgrid.CSS.root);
                    this.element[0].style.cssText = this._originalCssText// restore style properties
                    ;
                    // restore original content **
                                    }finally {
                    this._destroyed = true;
                }
            };
            wijgrid.prototype._init = function () {
                this.$superPanelHeader = null;
                this.$topPagerDiv = null;
                this.$bottomPagerDiv = null;
                this.$groupArea = null;
                this._prevHoveredSketchRowIndex = -1;
                // culture
                this.mClosestCulture = Globalize.findClosestCulture(this.options.culture) || Globalize.findClosestCulture("default");
                if(!this.options.data) {
                    // dataSource is a domTable
                    if(!this._field("thead")) {
                        // read tHead section
                        this._field("thead", wijmo.grid.readTableSection(this.element, 1));
                    }
                    if(!this._field("tfoot")) {
                        // read tFoot section
                        this._field("tfoot", wijmo.grid.readTableSection(this.element, 3));
                    }
                }
                this._initialized = this._initialized || false// to avoid reinitialization.
                ;
                this.ensureControl(true);
            };
            wijgrid.prototype._setOption = function (key, value) {
                var presetFunc = this["_preset_" + key], oldValue = this.options[key], optionChanged, postsetFunc;
                if(presetFunc !== undefined) {
                    value = presetFunc.apply(this, [
                        value, 
                        oldValue
                    ]);
                }
                optionChanged = (value !== oldValue) || (key.toLowerCase() === "columns")// same reference, handle a situation when the option.columns array was modifed directly. (TFS issue #41296)
                ;
                //$.Widget.prototype._setOption.apply(this, arguments); note: there is no dynamic linkage between the arguments and the formal parameter values when strict mode is used
                _super.prototype._setOption.apply(this, [
                    key, 
                    value
                ])// update this.options
                ;
                if(optionChanged) {
                    postsetFunc = this["_postset_" + key];
                    if(postsetFunc !== undefined) {
                        postsetFunc.apply(this, [
                            value, 
                            oldValue
                        ]);
                    }
                }
            };
            wijgrid.prototype.columns = // * override
            // * public
            /** Returns a one-dimensional array of widgets bound to visible column headers.
            * @example
            * var colWidgets = $("#element").wijgrid("columns");
            * @remarks
            * wijgrid columns are represented as widgets. This method returns a one-dimensional array of widgets that are bound to visible column headers.
            *
            * The column widget is initiated with values taken from the corresponding item in the wijgrid.options.columns array. However, the options of a column widget instance reference not the original object but a copy created by the widget factory. Due to that, changes to the wijgrid.options.columns options are not automatically propagated to the column widget options and vice versa.
            * To solve this issue, the wijgrid synchronized the column widget option values with the source items. This synchronization occurs inside the ensureControl() method which is automatically called at each action requiring the wijgrid to enter.
            *
            * Still, there is a drawback. For example, a user may want to filter wijgrid data from user code as in this sample:
            *
            *	$("#element").wijgrid("option", "columns")[0].filterValue = "newValue";
            *	$("#element").wijgrid("ensureControl", true); // make wijgrid re-shape data and re-render.
            *
            * In the sample above, nothing will happen since at synchronization user changes will be ignored.You need to change the filterValue of a column widget. This is what the columns() method is for:
            *
            *	$("#element").wijgrid("columns")[0].options.filterValue = "newValue";
            *	$("#element").wijgrid("ensureControl", true); // make wijgrid re-shape data and re-render.
            *
            * Here's the best way to change the filterValue:
            *
            *	$("#element").wijgrid("columns")[0].option("filterValue", "newValue"); // column widget handles all the needful.
            *
            * @returns {Object[]} A one-dimensional array of widgets bound to visible column headers.
            */
            function () {
                return this._field("columns") || [];
            };
            wijgrid.prototype.currentCell = /** @ignore */
            function (a, b, changeSelection) {
                var currentCell, view = this._view(), rows = this._rows();
                if(arguments.length === 0) {
                    // getter
                    currentCell = this._field("currentCell");
                    if(!currentCell) {
                        this._field("currentCell", currentCell = wijmo.grid.cellInfo.outsideValue);
                    }
                    return currentCell;
                } else {
                    // setter
                    //currentCell = (arguments.length === 1)
                    //	? (<wijmo.grid.cellInfo>a)._clone()
                    //	: new wijmo.grid.cellInfo(<number>a, <number>b);
                    currentCell = (typeof (a) !== "number") ? (a)._clone() : new wijmo.grid.cellInfo(a, b);
                    if(!currentCell.isEqual(wijmo.grid.cellInfo.outsideValue)) {
                        if(!currentCell._isValid()) {
                            throw "invalid arguments";
                        }
                        currentCell._clip(this._getDataCellsRange(grid.dataRowsRangeMode.sketch));
                        if(currentCell.rowIndex() >= 0) {
                            var rowInfo = view._getRowInfoBySketchRowIndex(currentCell.rowIndex());
                            if(!rowInfo || !(rowInfo.type & wijmo.grid.rowType.data)) {
                                return;
                            }
                        }
                    }
                    currentCell._setGridView(this);
                    this._changeCurrentCell(null, currentCell, {
                        changeSelection: changeSelection || false,
                        setFocus: false
                    });
                    return this._field("currentCell");
                }
            };
            wijgrid.prototype.data = /** Gets an array of underlying data.
            * @example
            * var data = $("#element").wijgrid("data");
            * @returns {object[]} An array of underlying data.
            */
            function () {
                //return this._dataViewWrapper.dataView()();
                return this._dataViewWrapper.dataView().getSource();
            };
            wijgrid.prototype.dataView = /** Gets an underlying wijdataview instance.
            * @example
            * var dataView = $("#element").wijgrid("dataView");
            * @returns {wijmo.data.IDataView} An underlying wijdataview instance.
            */
            function () {
                return this._dataViewWrapper.dataView();
            };
            wijgrid.prototype.doRefresh = /** Re-renders wijgrid.
            * @example
            * $("#element").wijgrid("doRefresh");
            * @param {Object} userData Infrastructure, not intended to be used by user.
            */
            function (userData) {
                var _this = this;
                if(!$.isPlainObject(userData)) {
                    userData = {
                    };
                }
                var leaves, self = this, uid = wijmo.grid.EXPANDO, virtualRefresh = userData && userData.virtualScrollData;
                if(!this._initialized) {
                    try  {
                        this._prepareColumnOptions(this.options.columns, this.options.columnsAutogenerationMode, this._dataViewWrapper.getFieldsInfo(), true, true)// prepare static and dynamic columns
                        ;
                    } catch (e) {
                        throw e;
                    }finally {
                        //ownerise the column for bug 16936, 17079
                        this._ownerise(true);
                        this._initialized = true;
                    }
                } else {
                    //				if (userData && $.isFunction(userData.beforeRefresh)) {
                    //					userData.beforeRefresh.apply(this);
                    //				}
                                    }
                if(!virtualRefresh) {
                    // do not rebuild leaves during virtual scrolling callback
                    this._rebuildLeaves()// build leaves, visible leaves, set dataIndex etc
                    ;
                    var dataSlice = grid.lazy(this._dataViewWrapper.data, this._dataViewWrapper);
                    var dataView = this._dataViewWrapper.dataView();
                    var totalsRequest = this._prepareTotalsRequest(true);
                    if(totalsRequest.length) {
                        $.each(this._field("leaves"), function (i, column) {
                            // copy totals
                            column._totalsValue = (dataSlice().totals) ? dataSlice().totals[column.dataKey] : undefined;
                        });
                    }
                    // this._setPageCount(dataSlice);
                    if(dataView.count()) {
                        // process data items
                        leaves = this._field("leaves");
                        var lazyTable = new wijmo.grid.LazySketchTable({
                            count: function () {
                                return dataView.count();
                            },
                            getRange: function (start, count, dest, offset) {
                                for(var i = 0; i < count; i++) {
                                    var index = start + i;
                                    var dataItem = dataView.item(index);
                                    dest[offset + i] = _this._buildSketchRow({
                                        values: dataItem,
                                        originalRowIndex: index
                                    }, leaves);
                                }
                            }
                        });
                        if(this._hasGrouping() || this._hasMerging()) {
                            lazyTable.ensureNotLazy();
                        }
                        this.sketchTable = lazyTable;
                    } else {
                        this.sketchTable = new wijmo.grid.SketchTable();
                        var emptyData = dataSlice().emptyData;
                        if(emptyData) {
                            // process empty data row
                            leaves = this._field("visibleLeaves");
                            $.each(emptyData, function (i, item) {
                                self.sketchTable.add(self._buildSketchRowEmptyDataItem(item, leaves, i === emptyData.length - 1));
                            });
                        }
                    }
                }
                this._onRendering(userData);
                if(!virtualRefresh) {
                    this._refresh(userData);
                } else {
                    this._refreshVirtual(userData);
                }
                if(userData && $.isFunction(userData.beforeOnRendered)) {
                    userData.beforeOnRendered.apply(this, [
                        userData
                    ]);
                }
                var view = this._view();
                if(this.mEditSkechRowIndex >= 0 && (view._isRowRendered(this.mEditSkechRowIndex) >= 0)) {
                    var rowInfo = view._getRowInfoBySketchRowIndex(this.mEditSkechRowIndex);
                    if(rowInfo && (rowInfo.state & wijmo.grid.renderState.editing)) {
                        view._makeRowEditable(rowInfo);
                    }
                }
                this._onRendered(userData);
                if(userData && $.isFunction(userData.afterRefresh)) {
                    userData.afterRefresh.apply(this, [
                        userData
                    ]);
                }
            };
            wijgrid.prototype.beginEdit = /** Puts the current cell into edit mode, as long as the editingMode options is set to "cell".
            * @example
            * $("#element").wijgrid({}
            *		editingMode: "cell",
            *		currentCellChanged: function (e, args) {
            *			if ($(e.target).wijgrid("option", "isLoaded")) {
            *				window.setTimeout(function () {
            *					$(e.target).wijgrid("beginEdit");
            *				}, 100);
            *			}
            *		}
            * });
            * @returns {Boolean} True if the cell is successfully put into edit mode, otherwise false.
            */
            function () {
                if(!this._allowCellEditing()) {
                    throw "Can be used only if the editingMode option is set to \"cell\".";
                }
                return this._beginEditInternal(null);
            };
            wijgrid.prototype.endEdit = /** Finishes editing the current cell.
            * @example
            * // endEdit is being called from within the saveChanges function
            * function saveChanges() {
            *		$("#element").wijgrid("endEdit");
            * }
            * @returns {Boolean} True if the editing was finished successfully, othewise false.
            */
            function () {
                return this._endEditInternal(null);
            };
            wijgrid.prototype.editRow = /** Starts editing of the specified row, can only be used when the editingMode option is set to "row".
            * @example
            * $("#element").wijgrid("editRow", 0);
            * @param {Number} dataItemIndex Determines the data item to edit.
            */
            function (dataItemIndex) {
                if(this.options.editingMode !== "row") {
                    throw "Can be used only if the editingMode option is set to \"row\".";
                }
                if(this.mEditSkechRowIndex >= 0) {
                    this.cancelRowEditing()// only one row can be edited at a time.
                    ;
                }
                if(dataItemIndex >= 0) {
                    var sketchRowIndex = -1, sketchRow;
                    for(var i = 0; i < this.sketchTable.count() && sketchRowIndex < 0; i++) {
                        sketchRow = this.sketchTable.row(i);
                        if(sketchRow.isDataRow() && ((sketchRow.dataItemIndex()) === dataItemIndex)) {
                            sketchRowIndex = i;
                        }
                    }
                    if(sketchRowIndex >= 0) {
                        var view = this._view();
                        this.mEditSkechRowIndex = sketchRowIndex;
                        sketchRow.renderState |= wijmo.grid.renderState.editing;
                        if(view._isRowRendered(this.mEditSkechRowIndex) >= 0) {
                            var rowInfo = view._getRowInfoBySketchRowIndex(this.mEditSkechRowIndex, false);// get a live IRowInfo object.
                            
                            rowInfo.state |= wijmo.grid.renderState.editing// ??
                            ;
                            view._removeBodyRow(rowInfo.sectionRowIndex, false)// delete an exisiting row
                            ;
                            rowInfo = view._insertBodyRow(sketchRow, rowInfo.sectionRowIndex, rowInfo.dataItemIndex, -1)//  create and render a new one
                            ;
                            view._makeRowEditable(rowInfo);
                            this.selection()._ensureSelectionInRow(this.mEditSkechRowIndex);
                        }
                    }
                }
            };
            wijgrid.prototype.updateRow = /** Finishes editing and updates the datasource.
            * @example
            * $("#element").wijgrid("updateRow");
            */
            function () {
                if(this.mEditSkechRowIndex >= 0) {
                    var dataView = wijmo.grid.asEditableDataView(this._dataViewWrapper.dataView()), errorOccurs = false;
                    if(!dataView) {
                        throw "The provided DataView doesn't supports the editing operation.";
                    }
                    try  {
                        var sketchRow = this.sketchTable.row(this.mEditSkechRowIndex), view = this._view();
                        if(!sketchRow || !sketchRow.isDataRow() || !(sketchRow.renderState & wijmo.grid.renderState.editing)) {
                            throw "Invalid row";
                        }
                        if(this._view()._isRowRendered(this.mEditSkechRowIndex) >= 0) {
                            var rowInfo = view._getRowInfoBySketchRowIndex(this.mEditSkechRowIndex, false);// get a live IRowInfo object.
                            
                            // ** get the new values and update an underlying data source
                                                        var leaves = this._field("visibleLeaves"), cells = [], cellEditor = new wijmo.grid.cellEditorHelper();
                            for(var i = 0; i < leaves.length; i++) {
                                var column = leaves[i];
                                if(wijmo.grid.validDataKey(column.dataKey) && !column.readOnly) {
                                    var $cell = rowInfo.$rows.children("td, th").eq(i);
                                    if($cell.length) {
                                        var state = view._changeCellRenderState($cell, wijmo.grid.renderState.none, true);// dont change anything, just get a state.
                                        
                                        if(state & wijmo.grid.renderState.editing) {
                                            // make sure that cell is in edit state (the user did not cancel the beforeCellEdit event, for example)
                                                                                        var cellInfo = view.getAbsoluteCellInfo($cell[0], true), updateRes = cellEditor.updateCell(this, cellInfo, null);
                                            if(!(updateRes & grid.updateCellResult.success)) {
                                                errorOccurs = true;
                                                return;
                                            }
                                            if(!(updateRes & grid.updateCellResult.notEdited)) {
                                                cells.push(cellInfo);
                                            }
                                        }
                                    }
                                }
                            }
                            for(var i = 0; i < cells.length; i++) {
                                cellEditor.cellEditEnd(this, cells[i], null);
                            }
                            // collect new values and update underlying data source **
                            // ** no errors, update DOM **
                            sketchRow.renderState &= ~wijmo.grid.renderState.editing;
                            rowInfo.state &= ~wijmo.grid.renderState.editing// ??
                            ;
                            view._removeBodyRow(rowInfo.sectionRowIndex, false)// delete an exisiting row
                            ;
                            rowInfo = view._insertBodyRow(sketchRow, rowInfo.sectionRowIndex, rowInfo.dataItemIndex, -1)//  create and render a new one
                            ;
                            this.selection()._ensureSelectionInRow(this.mEditSkechRowIndex);
                        } else {
                            sketchRow.renderState &= ~wijmo.grid.renderState.editing;
                        }
                    }finally {
                        if(!errorOccurs) {
                            this.mEditSkechRowIndex = -1;
                        }
                    }
                }
            };
            wijgrid.prototype.cancelRowEditing = /** Discards changes and finishes editing of the edited row.
            * @example
            * $("#element").wijgrid("cancelRowEditing");
            */
            function () {
                if(this.mEditSkechRowIndex >= 0) {
                    try  {
                        var sketchRow = this.sketchTable.row(this.mEditSkechRowIndex), view = this._view();
                        if(!sketchRow || !sketchRow.isDataRow() || !(sketchRow.renderState & wijmo.grid.renderState.editing)) {
                            throw "Invalid row.";
                        }
                        sketchRow.renderState &= ~wijmo.grid.renderState.editing;
                        if(this._view()._isRowRendered(this.mEditSkechRowIndex) >= 0) {
                            var rowInfo = view._getRowInfoBySketchRowIndex(this.mEditSkechRowIndex, false);// get a live IRowInfo object.
                            
                            rowInfo.state &= ~wijmo.grid.renderState.editing// ??
                            ;
                            view._removeBodyRow(rowInfo.sectionRowIndex, false)// delete an exisiting row
                            ;
                            rowInfo = view._insertBodyRow(sketchRow, rowInfo.sectionRowIndex, rowInfo.dataItemIndex, -1)//  create and render a new one
                            ;
                            this.selection()._ensureSelectionInRow(this.mEditSkechRowIndex);
                        }
                    }finally {
                        this.mEditSkechRowIndex = -1;
                    }
                }
            };
            wijgrid.prototype.deleteRow = /** Deletes the specified row.
            * @example
            * $("#element").wijgrid("cancelRowEditing");
            * @param {Number} dataItemIndex Determines the data item to edit.
            */
            function (dataItemIndex) {
                if(dataItemIndex >= 0) {
                    var dataView = wijmo.grid.asEditableDataView(this._dataViewWrapper.dataView());
                    if(!dataView || !dataView.canRemove()) {
                        throw "The provided DataView doesn't supports the deleting operation.";
                    }
                    // dataView.remove(dataItemIndex); // the whole wijgrid will be re-rendered.
                    this._dataViewWrapper.ignoreChangeEvent(true);
                    dataView.remove(dataItemIndex);
                    this._dataViewWrapper.ignoreChangeEvent(false);
                    this.ensureControl(true, {
                        forceDataLoad: // forcibly reload a dataView.
                        true
                    });
                }
            };
            wijgrid.prototype.ensureControl = /** Moves the column widget options to the wijgrid options and renders the wijgrid. Use this method when you need to re-render the wijgrid and reload remote data from the datasource.
            * @example
            * // Adds a new row to the viewModel and refreshes the wijgrid
            * var len = viewModel.data().length;
            * viewModel.data.push(new Person({ ID: len, Company: "New Company" + len, Name: "New Name" + len }));
            * $("#element").wijgrid("ensureControl", true);
            * @param {Boolean} loadData Determines if the wijgrid must load data from a linked data source before rendering.
            */
            function (loadData, userData) {
                this._loading();
                if(!$.isPlainObject(userData)) {
                    userData = {
                        data: null,
                        afterRefresh: null,
                        beforeRefresh: null
                    };
                }
                if(this._initialized) {
                    if(!userData || !userData.virtualScrollData) {
                        // performance tweak, processing the expandInfo objects is slow.
                        this._convertWidgetsToOptions();
                    }
                } else {
                    // this._prepareColumnOptions(false); // prepare static columns only (to make a proper sorting or filtering request to remote service)
                    this._prepareColumnOptions(this.options.columns, this.options.columnsAutogenerationMode, this._dataViewWrapper.isDataLoaded() && this._dataViewWrapper.getFieldsInfo(), this._dataViewWrapper.isDataLoaded(), false);
                    if(!this._dataViewWrapper.isOwnDataView()) {
                        // map sorting\ filtering\ paging settings from external dataView to the grid's options during initialization stage
                        (new wijmo.grid.settingsManager(this)).MapDVToWG();
                    }
                }
                this._ownerise(true);
                // * TODO: move to the doRefresh?
                if(this._initialized) {
                    if(userData && $.isFunction(userData.beforeRefresh)) {
                        userData.beforeRefresh.apply(this);
                    }
                }
                // *
                if(!userData || !userData.virtualScrollData) {
                    this.mAllowVirtualScrolling = undefined;
                    this.mEditSkechRowIndex = -1;
                }
                if(loadData === true) {
                    this._dataViewWrapper.load(userData);
                } else {
                    this.doRefresh(userData);
                    this._loaded();
                }
            };
            wijgrid.prototype.getCellInfo = /** Gets an instance of the wijmo.grid.cellInfo class that represents the grid's specified cell.
            * @example
            * var cellInfo = $("#element").wijgrid("getCellInfo", domCell);
            * @param {Object} domCell A HTML DOM Table cell object
            * @returns {wijmo.grid.cellInfo} Object that represents a cell of the grid.
            */
            function (domCell) {
                var cellInfo = null;
                if(domCell && (domCell = this._findUntilOuterDiv(domCell, {
                    td: true,
                    th: true
                }))) {
                    // test affinity
                    cellInfo = this._view().getAbsoluteCellInfo(domCell, false);
                }
                return cellInfo;
            };
            wijgrid.prototype.getFilterOperatorsByDataType = /** Returns a one-dimensional array of filter operators which are applicable to the specified data type.
            * @example
            * var operators = $("#element").wijgrid("getFilterOperatorsByDataType", "string");
            * @param {String} dataType Specifies the type of data to which you apply the filter operators. Possible values are: "string", "number", "datetime", "currency" and "boolean".
            * @returns {wijmo.grid.IFilterOperator[]} A one-dimensional array of filter operators.
            */
            function (dataType) {
                return (new wijmo.grid.filterOperatorsCache(this)).getByDataType(dataType || "string");
            };
            wijgrid.prototype.pageCount = /** Gets the number of pages.
            * @example
            * var pageCount = $("#element").wijgrid("pageCount");
            * @returns {Number} The number of pages.
            */
            function () {
                if(this._customPagingEnabled()) {
                    return Math.ceil(this.options.totalRows / this.options.pageSize) || 1;
                }
                return this.options.allowPaging ? (this._dataViewWrapper.dataView()).pageCount() : 1;
            };
            wijgrid.prototype._closestCulture = function () {
                return this.mClosestCulture;
            };
            wijgrid.prototype._serverShaping = function () {
                // used to support asp.net C1GridView
                return false;
            };
            wijgrid.prototype._pageIndexForDataView = function () {
                /** Infrastructure */
                return this.options.pageIndex;
            };
            wijgrid.prototype.setSize = /** Sets the size of the grid using the width and height parameters.
            * @example
            * $("#element").wijgrid("setSize", 200, 200);
            * @param {String|Number} width Determines the width of the grid.
            * @param {String|Number} height Determines the height of the grid.
            */
            function (width, height) {
                var view = this._view(), scrollValue = null, outerDiv = this.outerDiv, visibleLeaves = this._field("visibleLeaves"), leavesWithFilter = [];
                if(view && view.getScrollValue) {
                    scrollValue = view.getScrollValue();
                }
                if(width || (width === 0)) {
                    this._autoWidth = false;
                    outerDiv.width(width);
                }
                if(height || (height === 0)) {
                    this._autoHeight = false;
                    outerDiv.height(height);
                }
                $.each(visibleLeaves, function (index, leaf) {
                    var th = view.getHeaderCell(index), cols = view.getJoinedCols(index);
                    $(th).css("width", "");
                    $.each(cols, function (index, col) {
                        $(col).css("width", "");
                    });
                });
                // recalculate sizes
                this._setSizeInternal(scrollValue);
                var frozener = this._UIFrozener();
                if(frozener) {
                    frozener.refresh();
                }
            };
            wijgrid.prototype._setSizeInternal = function (scrollValue) {
                this._view().updateSplits(scrollValue);
            };
            wijgrid.prototype.selection = /** Gets an object that manages selection in the grid.
            * @example
            * // Use the row index to add the row to the selection object
            * var selection = $("#element").wijgrid("selection");
            * selection.addRows(2);
            * @remarks
            * See the description of the wijmo.grid.selection class for more details.
            * @returns {wijmo.grid.selection} Object that manages selection in the grid.
            */
            function () {
                var selection = this._field("selection");
                if(!selection) {
                    this._field("selection", selection = new wijmo.grid.selection(this));
                }
                return selection;
            };
            wijgrid.prototype._onDataViewCurrentPositionChanged = // * public
            function (e, args) {
                var cellInfo = this._currentCellFromDataView(this.currentCell().cellIndex());
                // move currentCell to the new position
                cellInfo = this.currentCell(cellInfo, null, true);
            };
            wijgrid.prototype._resetColumns = function () {
                this._ownerise(false);
                wijmo.grid.traverse(this.options.columns, function (column, columns) {
                    if(column.dynamic) {
                        // remove autogenerated columns
                        var idx = $.inArray(column, columns);
                        if(idx >= 0) {
                            columns.splice(idx, 1);
                        }
                    } else {
                        // restore original values
                        column.dataKey = column._originalDataKey;
                        column.headerText = column._originalHeaderText;
                    }
                });
                this._initialized = false// to generate columns when doRefresh() or ensureControl() methods will be called
                ;
            };
            wijgrid.prototype._resetDataProperties = function () {
                this.options.pageIndex = 0;
            };
            wijgrid.prototype._resetVerticalBounds = function () {
                var bounds = this._viewPortBounds();
                //bounds.start = bounds.end = 0;
                bounds.start = 0// #52058: reset the .start property only. Let wijgrid to update the .end property when the underlying data will be refreshed actually.
                ;
                this._scrollingState.index = 0;
                this._scrollingState.y = 0;
            };
            wijgrid.prototype._onDataViewLoading = function () {
                this._activateSpinner()// if data loading proccess was triggered outside the wijgrid.
                ;
                this._trigger("dataLoading");
            };
            wijgrid.prototype._onDataViewReset = function (userData, resetColumns) {
                if(!this.options._lateBindingFlag) {
                    // ignore dataView reset during initialization (seee wijgrid._createWidget method)
                    (new wijmo.grid.settingsManager(this)).MapDVToWG();
                    this._trigger("dataLoaded");
                    if(resetColumns) {
                        this._resetColumns();
                    }
                    this.doRefresh(userData);
                    this._loaded();
                } else {
                    delete this.options._lateBindingFlag;
                }
            };
            wijgrid.prototype._onDataViewLoaded = function () {
            };
            wijgrid.prototype._loading = function () {
                this._activateSpinner();
                this._trigger("loading");
            };
            wijgrid.prototype._loaded = function () {
                this._deactivateSpinner();
                this._trigger("loaded");
            };
            wijgrid.prototype._buildSketchRow = function (wrappedDataItem, leaves) {
                var i, len, leaf, cellAttr, value, tmp, expando = wijmo.data.Expando.getFrom(wrappedDataItem.values, false), rowAttributes = expando ? expando[wijmo.grid.EXPANDO] : null, sketchRow = new grid.SketchDataRow(wrappedDataItem.originalRowIndex, wijmo.grid.renderState.rendering, rowAttributes && rowAttributes.rowAttributes), cellAttributes = rowAttributes && rowAttributes.cellsAttributes;
                for(i = 0 , len = leaves.length; i < len; i++) {
                    leaf = leaves[i];
                    if(wijmo.grid.validDataKey(leaf.dataKey)) {
                        cellAttr = cellAttributes ? cellAttributes[leaf.dataKey] : null;
                        value = this._dataViewWrapper.getValue(wrappedDataItem.values, leaf.dataKey);
                        sketchRow.add(new grid.ValueCell(this.parse(leaf, value), cellAttr));
                    }
                }
                return sketchRow;
            };
            wijgrid.prototype._buildSketchRowEmptyDataItem = function (dataItem, leaves, isLastRow) {
                var i, len, sketchRow = new grid.SketchRow(wijmo.grid.rowType.emptyDataRow, wijmo.grid.renderState.rendering, null), leavesLen = leaves.length;
                for(i = 0 , len = dataItem.length; i < len; i++) {
                    sketchRow.add(new grid.HtmlCell(dataItem[i], {
                        colSpan: (leavesLen > 0 && isLastRow) ? leavesLen : 1
                    }));
                }
                return sketchRow;
            };
            wijgrid.prototype._prepareColumnOptions = function (columns, generationMode, fieldsInfo, dataLoaded, finalStage) {
                wijmo.grid.traverse(columns, function (column) {
                    column.isBand = ($.isArray(column.columns) || (column.clientType === "c1band"));
                    if(grid.c1commandbtnfield.test(column) || grid.c1btnfield.test(column)) {
                        column.dataKey = null;
                    }
                    column._originalDataKey = column.dataKey;
                    column._originalHeaderText = column.headerText;
                });
                // set .isLeaf
                new wijmo.grid.bandProcessor().getVisibleHeight(columns, true);
                // prepare leaves
                                var leaves = [], headerRow = this._originalHeaderRowData(), footerRow = this._originalFooterRowData(), autogenerationMode = (generationMode || "").toLowerCase(), self = this;
                if(dataLoaded) {
                    wijmo.grid.columnsGenerator.generate(autogenerationMode, fieldsInfo, columns);
                }
                wijmo.grid.setTraverseIndex(columns)// build indices (linearIdx, travIdx, parentIdx)
                ;
                // * merge options with defaults and build "pure" leaves list.
                wijmo.grid.traverse(columns, function (column) {
                    // merge options **
                    column.isBand = ($.isArray(column.columns) || (column.clientType === "c1band"));
                    wijmo.grid.shallowMerge(column, grid.c1basefield.prototype.options)// merge with the c1basefield default options
                    ;
                    if(!column.isBand) {
                        if(grid.c1commandbtnfield.test(column)) {
                            column.clientType = "c1commandbtnfield";
                            wijmo.grid.shallowMerge(column, grid.c1btnfieldbase.prototype.options);
                            wijmo.grid.shallowMerge(column, grid.c1commandbtnfield.prototype.options);
                            column.editCommand = (column.editCommand || {
                            });
                            wijmo.grid.shallowMerge(column.editCommand, grid.c1commandbtnfield.prototype.options.editCommand);
                            column.cancelCommand = (column.cancelCommand || {
                            });
                            wijmo.grid.shallowMerge(column.cancelCommand, grid.c1commandbtnfield.prototype.options.cancelCommand);
                            column.deleteCommand = (column.deleteCommand || {
                            });
                            wijmo.grid.shallowMerge(column.deleteCommand, grid.c1commandbtnfield.prototype.options.deleteCommand);
                            column.updateCommand = (column.updateCommand || {
                            });
                            wijmo.grid.shallowMerge(column.updateCommand, grid.c1commandbtnfield.prototype.options.updateCommand);
                        } else {
                            if(grid.c1btnfield.test(column)) {
                                column.clientType = "c1btnfield";
                                wijmo.grid.shallowMerge(column, grid.c1btnfieldbase.prototype.options);
                                wijmo.grid.shallowMerge(column, grid.c1btnfield.prototype.options);
                            } else {
                                wijmo.grid.shallowMerge(column, grid.c1field.prototype.options)// merge with the c1field default options
                                ;
                                column.groupInfo = column.groupInfo || {
                                };
                                wijmo.grid.shallowMerge(column.groupInfo, grid.c1field.prototype.options.groupInfo);
                                if(!column.clientType) {
                                    column.clientType = "c1field";
                                }
                            }
                        }
                    } else {
                        column.clientType = "c1band";
                    }
                    // ** merge options
                    if(column.isLeaf && !column.isBand) {
                        leaves.push(column);
                    }
                });
                this._field("leaves", leaves)// contains static columns only when dataLoaded == false, used by the "dynamic data load" feature during request initialization.
                ;
                if(dataLoaded) {
                    // assume headerText and footerText
                    $.each(leaves, $.proxy(function (i, leaf) {
                        var thIndex = (typeof (leaf.dataKey) === "number") ? leaf.dataKey : i;
                        if(autogenerationMode === "merge" || leaf.dynamic === true) {
                            // assume headerText options of the static columns only when using "merge" mode.
                            if(leaf.headerText === undefined) {
                                if(self._dataViewWrapper && self._dataViewWrapper.isBoundedToDOM() && headerRow && (thIndex < headerRow.length)) {
                                    leaf.headerText = $.trim(headerRow[thIndex])// copy th
                                    ;
                                } else {
                                    if(wijmo.grid.validDataKey(leaf.dataKey)) {
                                        leaf.headerText = "" + leaf.dataKey// copy dataKey
                                        ;
                                    }
                                }
                            }
                        }
                        if(self._dataViewWrapper && self._dataViewWrapper.isBoundedToDOM() && footerRow && (thIndex < footerRow.length)) {
                            leaf._footerTextDOM = $.trim(footerRow[thIndex]);
                        }
                    }, this));
                }
            };
            wijgrid.prototype._rebuildLeaves = function () {
                var tmpColumns = [], leaves = [], tmp;
                if(this._showRowHeader()) {
                    // append rowHeader
                    tmp = wijmo.grid.createDynamicField({
                        clientType: "c1basefield",
                        dataIndex: -1,
                        travIdx: -1,
                        parentVis: true,
                        allowMoving: false,
                        allowSizing: false,
                        allowSort: false,
                        isRowHeader: true
                    });
                    tmp.owner = this;
                    tmpColumns.push(tmp);
                }
                $.each(this.options.columns, function (index, item) {
                    tmpColumns.push(item)// append columns
                    ;
                });
                // generate span table and build leaves
                this._columnsHeadersTable(new wijmo.grid.bandProcessor().generateSpanTable(tmpColumns, leaves));
                this._field("leaves", leaves);
                this._onLeavesCreated();
            };
            wijgrid.prototype._onLeavesCreated = function () {
                var leaves = this._field("leaves"), fieldsInfo = this._dataViewWrapper.getFieldsInfo(), meta, dataIndex = 0, visLeavesIdx = 0, self = this;
                // build visible leaves list, set dataParsers, dataIndices
                this._field("visibleLeaves", $.grep(leaves, function (leaf, index) {
                    leaf.leavesIdx = index;
                    if(wijmo.grid.validDataKey(leaf.dataKey)) {
                        leaf.dataIndex = dataIndex++;
                    } else {
                        leaf.dataIndex = -1;
                    }
                    if(!leaf.isBand) {
                        meta = fieldsInfo[leaf.dataKey];
                        if(meta) {
                            leaf._underlyingDataType = meta.type;
                            leaf._underlyingDataFormatString = meta.format;
                        }
                        if($.isFunction(leaf.dataParser)) {
                            leaf.dataParser = new (leaf.dataParser)();
                        }
                    }
                    if(leaf.parentVis) {
                        leaf.visLeavesIdx = visLeavesIdx++;
                        return true;
                    }
                    return false;
                }));
            };
            wijgrid.prototype._allowEditing = function () {
                return (this.options.allowEditing === true) || // obsolete
                (this.options.editingMode === "cell") || (this.options.editingMode === "row");
            };
            wijgrid.prototype._allowCellEditing = function () {
                var editingMode = this.options.editingMode;
                if(editingMode === "row") {
                    return false;
                }
                return (this.options.allowEditing === true) || // obsolete
                (editingMode === "cell");
            };
            wijgrid.prototype._allowVirtualScrolling = function () {
                if(this.mAllowVirtualScrolling === undefined) {
                    this.mAllowVirtualScrolling = !this.options.allowPaging && this.options.allowVirtualScrolling && (this.options.staticRowIndex < 0) && (this.options.scrollMode !== "none") && !this._hasMerging();
                }
                return this.mAllowVirtualScrolling;
            };
            wijgrid.prototype._headerRows = function () {
                return this._view().headerRows();
            };
            wijgrid.prototype._filterRow = function () {
                return this._view().filterRow();
            };
            wijgrid.prototype._rows = function () {
                return this._view().bodyRows();
            };
            wijgrid.prototype._localizeFilterOperators = function (locArray) {
                var self = this, helper = new wijmo.grid.filterOperatorsCache(this);
                $.each(locArray, function (i, o) {
                    if(o.name) {
                        var fop = helper.getByName(o.name);
                        if(fop) {
                            fop.displayName = o.displayName;
                        }
                    }
                });
            };
            wijgrid.prototype._KeyDownEventListener = function () {
                if(!this.mKeyDownEventListener) {
                    var view = this._view(), $fe = view && view.focusableElement();
                    if($fe) {
                        this.mKeyDownEventListener = new grid.keyDownEventListener(this, $fe);
                    }
                }
                return this.mKeyDownEventListener;
            };
            wijgrid.prototype._UIDragndrop = function (force) {
                if(!this._dragndropui && force) {
                    this._dragndropui = new wijmo.grid.uiDragndrop(this);
                }
                return this._dragndropui;
            };
            wijgrid.prototype._UIFrozener = function (force) {
                if(!this._frozenerui && force) {
                    this._frozenerui = new wijmo.grid.uiFrozener(this);
                }
                return this._frozenerui;
            };
            wijgrid.prototype._UIResizer = function (force) {
                if(!this._resizerui && force) {
                    this._resizerui = new wijmo.grid.uiResizer(this);
                }
                return this._resizerui;
            };
            wijgrid.prototype._UISelection = function (force) {
                if(!this._selectionui && force) {
                    this._selectionui = new wijmo.grid.uiSelection(this);
                }
                return this._selectionui;
            };
            wijgrid.prototype._postset_allowColMoving = // * propeties (pre-\ post-)
            function (value, oldValue) {
                var self = this;
                $.each(this.columns(), function (idx, wijField) {
                    if(value) {
                        self._UIDragndrop(true).attach(wijField);
                    } else {
                        self._UIDragndrop(true).detach(wijField);
                    }
                });
                var groupedWidgets = this._field("groupedWidgets");
                if(groupedWidgets) {
                    $.each(groupedWidgets, function (idx, wijField) {
                        if(value) {
                            self._UIDragndrop(true).attach(wijField);
                        } else {
                            self._UIDragndrop(true).detach(wijField);
                        }
                    });
                }
            };
            wijgrid.prototype._postset_allowEditing = function (value, oldValue) {
                // deprecated
                this._postset_editingMode(this.options.editingMode, undefined);
            };
            wijgrid.prototype._postset_allowSorting = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_columns = function (value, oldValue) {
                this._initialized = false;
                this.ensureControl(true);
            };
            wijgrid.prototype._postset_allowPaging = function (value, oldValue) {
                this.ensureControl(true);
            };
            wijgrid.prototype._postset_freezingMode = function (value, oldValue) {
                if(this._frozenerui) {
                    this._frozenerui.refresh();
                }
            };
            wijgrid.prototype._postset_culture = function (value, oldValue) {
                this.mClosestCulture = Globalize.findClosestCulture(value) || Globalize.findClosestCulture("default");
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_customFilterOperators = function (value, oldValue) {
                var dataView = this._dataViewWrapper.dataView();
            };
            wijgrid.prototype._postset_data = function (value, oldValue) {
                this._resetColumns();
                // this._resetDataProperties();
                if(this._dataViewWrapper) {
                    this._dataViewWrapper.dispose();
                }
                this._dataViewWrapper = new wijmo.grid.dataViewWrapper(this);
                this.ensureControl(true);
            };
            wijgrid.prototype._postset_disabled = function (value, oldValue) {
                // update children widgets
                                var self = this, view = this._view();
                wijmo.grid.iterateChildrenWidgets(this.outerDiv, function (index, widget) {
                    if(widget !== self) {
                        widget.option("disabled", value);
                    }
                });
                if(view) {
                    view.ensureDisabledState();
                }
            };
            wijgrid.prototype._postset_editingMode = function (value, oldValue) {
                if(this.mKeyDownEventListener) {
                    this.mKeyDownEventListener.dispose();
                    this.mKeyDownEventListener = null;
                    this._KeyDownEventListener();
                }
            };
            wijgrid.prototype._postset_groupIndent = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_groupAreaCaption = function (value, oldValue) {
                var groupedColumns = this._groupedColumns();
                if(this.$groupArea && (!groupedColumns || !groupedColumns.length)) {
                    // update html when the group area is empty only.
                    this.$groupArea.html(value || "&nbsp;");
                }
            };
            wijgrid.prototype._postset_highlightCurrentCell = function (value, oldValue) {
                var currentCell = this.currentCell();
                if(currentCell && currentCell._isValid()) {
                    this._highlightCellPosition(currentCell, value);
                }
            };
            wijgrid.prototype._preset_pageIndex = function (value, oldValue) {
                if(isNaN(value)) {
                    throw "out of range";
                }
                var pageCount = this.pageCount(), fn = function (val) {
                    if(val > pageCount - 1) {
                        val = pageCount - 1;
                    }
                    if(val < 0) {
                        val = 0;
                    }
                    return val;
                }, args;
                value = fn(value);
                if(this.options.allowPaging && value !== oldValue) {
                    args = {
                        newPageIndex: value
                    };
                    if(!this._onPageIndexChanging(args)) {
                        value = oldValue;
                    } else {
                        value = fn(args.newPageIndex);
                    }
                }
                return value;
            };
            wijgrid.prototype._postset_pageIndex = function (value, oldValue) {
                if(this.options.allowPaging) {
                    var args = {
                        newPageIndex: value
                    };
                    if(this._customPagingEnabled()) {
                        this._convertWidgetsToOptions();
                        this._onPageIndexChanged(args)// Allow user the ability to load a new data and refresh the grid.
                        ;
                    } else {
                        this.ensureControl(true, {
                            afterRefresh: function () {
                                this._onPageIndexChanged(args);
                            }
                        });
                    }
                }
            };
            wijgrid.prototype._preset_pageSize = function (value, oldValue) {
                if(isNaN(value)) {
                    throw "out of range";
                }
                if(value <= 0) {
                    value = 1;
                }
                return value;
            };
            wijgrid.prototype._postset_pageSize = function (value, oldValue) {
                this._resetDataProperties();
                if(this.options.allowPaging && !this._customPagingEnabled()) {
                    this.ensureControl(true);
                }
            };
            wijgrid.prototype._postset_pagerSettings = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_rowHeight = function (value, oldValue) {
                this.rowOuterHeight = -1;
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_scrollMode = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_selectionMode = function (value, oldValue) {
                var selection = this.selection(), currentCell = this.currentCell(), hasSelection = this.selection().selectedCells().length();
                selection.beginUpdate();
                selection.clear();
                if(currentCell && currentCell._isValid() && hasSelection) {
                    selection._selectRange(new wijmo.grid.cellInfoRange(currentCell, currentCell), false, false, wijmo.grid.cellRangeExtendMode.none, null);
                }
                selection.endUpdate();
                this._view().toggleDOMSelection(value === "none")// disable or enable DOM selection
                ;
            };
            wijgrid.prototype._postset_showFilter = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_showGroupArea = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_showRowHeader = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._postset_staticRowIndex = function () {
                if(this.options.scrollMode !== "none") {
                    // staticRowIndex is ignored when scrolling is turned off.
                    this.ensureControl(false);
                }
            };
            wijgrid.prototype._postset_staticColumnIndex = function () {
                if(this.options.scrollMode !== "none") {
                    this.ensureControl(false);
                }
            };
            wijgrid.prototype._postset_allowVirtualScrolling = function (value, oldValue) {
                this.ensureControl(false);
            };
            wijgrid.prototype._preset_allowVirtualScrolling = function (value, oldValue) {
                if(isNaN(value) || value < 0) {
                    throw "out of range";
                }
                return value;
            };
            wijgrid.prototype._activateSpinner = // * propeties (pre-\ post-)
            // * private
            function () {
                if(!this._spinnerIsActivated) {
                    var defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this.options.wijCSS, loadingText = this.outerDiv.append("<div class=\"" + defCSS.loadingOverlay + " " + wijCSS.wijgridLoadingOverlay + " " + wijCSS.overlay + "\"></div>" + "<span class=\"" + defCSS.loadingText + " " + wijCSS.wijgridLoadingText + " " + wijCSS.content + " " + wijCSS.cornerAll + "\">" + "<span class=\"" + wijCSS.icon + " " + wijCSS.iconClock + "\"></span>" + this.options.loadingText + "</span>").find("> ." + defCSS.loadingText);
                    loadingText.position({
                        my: "center",
                        at: "center center",
                        of: this.outerDiv,
                        collision: "none"
                    });
                    this._spinnerIsActivated = true;
                }
            };
            wijgrid.prototype._customPagingEnabled = function () {
                return this.options.allowPaging && this.options.totalRows >= 0;
            };
            wijgrid.prototype._deactivateSpinner = function () {
                if(this._spinnerIsActivated) {
                    try  {
                        var defCSS = wijmo.grid.wijgrid.CSS;
                        this.outerDiv.find("> ." + defCSS.loadingOverlay + ", > ." + defCSS.loadingText).remove();
                    }finally {
                        this._spinnerIsActivated = false;
                    }
                }
            };
            wijgrid.prototype._columnWidgetsFactory = function ($node, columnOpt) {
                var columnWidget, clientType = columnOpt.clientType;
                if(!clientType && columnOpt.isBand) {
                    clientType = "c1band";
                }
                columnOpt = $.extend({
                }, columnOpt, {
                    disabled: this.options.disabled
                });
                try  {
                    $.data($node[0], "wijgridowner", this)// pass owner to the widget constructor
                    ;
                    switch(clientType) {
                        case //columnWidget = $node[clientType](columnOpt);
                        "c1basefield":
                            columnWidget = $node.c1basefield(columnOpt);
                            break;
                        case "c1band":
                            columnWidget = $node.c1band(columnOpt);
                            break;
                        case "c1btnfield":
                            columnWidget = $node.c1btnfield(columnOpt);
                            break;
                        case "c1commandbtnfield":
                            columnWidget = $node.c1commandbtnfield(columnOpt);
                            break;
                        default:
                            columnWidget = $node.c1field(columnOpt);
                    }
                }finally {
                    $.removeData($node[0], "wijgridowner");
                }
                return columnWidget;
            };
            wijgrid.prototype._convertWidgetsToOptions = function () {
                if(this._initialized && this._mergeWidgetsWithOptions) {
                    this._ownerise(false);
                    this._widgetsToOptions();
                    this._ownerise(true);
                }
            };
            wijgrid.prototype._field = function (name, value) {
                return wijmo.grid.dataPrefix(this.element, this._data$prefix, name, value);
            };
            wijgrid.prototype._removeField = function (name) {
                var internalDataName = this._data$prefix + name;
                this.element.removeData(internalDataName);
            };
            wijgrid.prototype._prepareTotalsRequest = function (isLocal) {
                var leaves = this._field("leaves"), result, test;
                if(!leaves || !this.options.showFooter) {
                    return [];
                }
                result = $.map((leaves), function (element, index) {
                    if(!element.isBand && wijmo.grid.validDataKey(element.dataKey) && element.aggregate && element.aggregate !== "none") {
                        if(isLocal) {
                            return [
                                {
                                    column: element,
                                    aggregate: element.aggregate
                                }
                            ];
                        } else {
                            return [
                                {
                                    dataKey: element.dataKey,
                                    aggregate: element.aggregate
                                }
                            ];
                        }
                    }
                    return null;
                });
                return result;
            };
            wijgrid.prototype._widgetsToOptions = function () {
                var colOptionsList = wijmo.grid.flatten(this.options.columns);
                $.each(this.columns(), function (index, colWidget) {
                    delete colWidget.options.columns// only options of the column itself will be merged at the next step.
                    ;
                    var congruentColOption = colOptionsList[colWidget.options.travIdx];
                    $.extend(true, congruentColOption, colWidget.options);
                    congruentColOption.filterValue = colWidget.options.filterValue;
                    congruentColOption.filterOperator = colWidget.options.filterOperator;
                });
            };
            wijgrid.prototype._recreateColumnWidgets = function () {
                $.each(this.columns(), function (index, item) {
                    item.destroy();
                });
                var columns = [], headerRows = this._headerRows(), visibleColumns, i, len, column, headerRowObj, th, columnWidget;
                if(/* tHead.length*/ headerRows && headerRows.length()) {
                    visibleColumns = []// visible bands and leaves
                    ;
                    wijmo.grid.traverse(this.options.columns, function (column) {
                        if(column.parentVis) {
                            visibleColumns.push(column);
                        }
                    });
                    for(i = 0 , len = visibleColumns.length; i < len; i++) {
                        column = visibleColumns[i];
                        headerRowObj = headerRows.item(column.thY);
                        th = wijmo.grid.rowAccessor.getCell(headerRowObj, column.thX);
                        columnWidget = this._columnWidgetsFactory($(th), column);
                        columns.push(columnWidget.data(wijmo.grid.widgetName(columnWidget)))// store actual widget instance
                        ;
                    }
                }
                this._field("columns", columns);
            };
            wijgrid.prototype._groupedColumns = function (force) {
                var result;
                force = !(result = this._field("groupedColumns")) || force;
                if(force) {
                    result = [];
                    var leaves = this._field("leaves") || [], rebuildIndexes = false, isGrouped = function (column) {
                        return column.groupInfo && column.groupInfo.position && (column.groupInfo.position !== "none");
                    };
                    $.each(leaves, function (i, column) {
                        if(isGrouped(column)) {
                            rebuildIndexes = rebuildIndexes || (column.groupedIndex === undefined);
                            if(!rebuildIndexes) {
                                result.push(column);
                            }
                        } else {
                            delete column.groupedIndex;
                        }
                    });
                    if(rebuildIndexes) {
                        $.each(leaves, function (i, column) {
                            if(isGrouped(column)) {
                                column.groupedIndex = result.length;
                                result.push(column);
                            }
                        });
                    } else {
                        result.sort(function (a, b) {
                            return a.groupedIndex - b.groupedIndex;
                        });
                        $.each(result, function (i, column) {
                            column.groupedIndex = i;
                        });
                    }
                    this._field("groupedColumns", result);
                }
                return result || [];
            };
            wijgrid.prototype._ownerise = function (flag) {
                if(flag) {
                    var self = this;
                    wijmo.grid.traverse(this.options.columns, function (column) {
                        column.owner = self;
                        var tmp, i, len;
                        if((tmp = column.groupInfo)) {
                            tmp.owner = column;
                            if(tmp.expandInfo) {
                                for(i = 0 , len = tmp.expandInfo.length; i < len; i++) {
                                    tmp.expandInfo[i].owner = tmp;
                                }
                            }
                        }
                    });
                } else {
                    wijmo.grid.traverse(this.options.columns, function (column) {
                        delete column.owner;
                        var tmp, i, len;
                        if((tmp = column.groupInfo)) {
                            delete tmp.owner;
                            if(tmp.expandInfo) {
                                for(i = 0 , len = tmp.expandInfo.length; i < len; i++) {
                                    delete tmp.expandInfo[i].owner;
                                }
                            }
                        }
                    });
                }
            };
            wijgrid.prototype._ensureRenderableBounds = function (bounds) {
                return wijmo.grid.ensureBounds(bounds, this._renderableRowsCount() - 1);
            };
            wijgrid.prototype._ensureTotalRowsBounds = function (bounds) {
                return wijmo.grid.ensureBounds(bounds, this._totalRowsCount() - 1);
            };
            wijgrid.prototype._ensureViewPortBoundsVisible = function (bounds) {
                var visibleTotal = this._renderableRowsCount();
                if(bounds.end >= visibleTotal) {
                    bounds.start -= bounds.end - (visibleTotal - 1);
                    bounds.end = visibleTotal - 1;
                    bounds.start = Math.max(0, bounds.start);
                    bounds.end = Math.max(0, bounds.end);
                }
                return bounds;
            };
            wijgrid.prototype._renderableBoundsCollection = function () {
                return this.mRenderableBoundsCollection;
            };
            wijgrid.prototype._rebuildRenderBoundsCollection = function () {
                var start = -1, end = -1, rangeFound = false, total = this._totalRowsCount();
                // <- overrided by c1gridview
                                this.mRenderableBoundsCollection = new wijmo.grid.renderBoundsCollection(total - 1);
                if(this._allowVirtualScrolling() && this._serverSideVirtualScrolling()) {
                    this.mRenderableBoundsCollection.add({
                        start: 0,
                        end: total - 1
                    })// all rows, groping is disabled
                    ;
                } else {
                    if(!this._allowVirtualScrolling() || !this._hasGrouping()) {
                        // assumption: if there is no grouping, then all sketch rows are visible
                        this.mRenderableBoundsCollection.add({
                            start: 0,
                            end: total - 1
                        })// all rows
                        ;
                    } else {
                        // gets only visible rows from the sketchTable
                        for(var i = 0; i < this.sketchTable.count(); i++) {
                            var sketchItem = this.sketchTable.row(i);
                            if(sketchItem.extInfo.state & wijmo.grid.renderStateEx.hidden) {
                                if(start >= 0) {
                                    this.mRenderableBoundsCollection.add({
                                        start: start,
                                        end: end
                                    });
                                    rangeFound = false;
                                }
                                start = end = -1;
                            } else {
                                if(start < 0) {
                                    rangeFound = true;
                                    start = end = i;
                                } else {
                                    end++;
                                }
                            }
                        }
                        if(rangeFound) {
                            this.mRenderableBoundsCollection.add({
                                start: start,
                                end: end
                            });
                        }
                    }
                }
            };
            wijgrid.prototype._refresh = function (userData) {
                // apply grouping
                new wijmo.grid.grouper().group(this, this.sketchTable, this._field("leaves"));
                // apply merging
                new wijmo.grid.merger().merge(this.sketchTable, this._field("visibleLeaves"));
                this._rebuildRenderBoundsCollection();
                //this._ensureViewPortBounds(this._viewPortBounds());
                // view
                if(this.options.scrollMode !== "none") {
                    this.mView = new wijmo.grid.fixedView(this, this._viewPortBounds());
                } else {
                    this.mView = new wijmo.grid.flatView(this, this._viewPortBounds());
                }
                this._render();
                // (re)create iternal widgets
                this._ownerise(false);
                this._recreateColumnWidgets();
                this._ownerise(true);
                // pager
                if(this.options.allowPaging) {
                    // top pager
                    if(this.$topPagerDiv) {
                        this.$topPagerDiv.wijpager(this._pagerSettings2PagerWidgetSettings()).css("zIndex", 5);
                    }
                    // bottom pager
                    if(this.$bottomPagerDiv) {
                        this.$bottomPagerDiv.wijpager(this._pagerSettings2PagerWidgetSettings()).css("zIndex", 5);
                    }
                }
                // (re)create iternal widgets
                            };
            wijgrid.prototype._refreshVirtual = function (userData) {
                var scrollData = userData.virtualScrollData, diffData = {
                    top: 0,
                    bottom: 0
                };
                if(scrollData.data) {
                    diffData = this._processVirtualData(scrollData);
                }
                this._updateRowInfos(scrollData, diffData);
                this._renderVirtualIntoView(scrollData);
                // debug
                /*var rows = this._view().bodyRows();
                for (var i = 0; i < rows.length(); i++) {
                var ri = this._view()._getRowInfo(rows.item(i));
                var innerDiv = ri.$rows.find("td:first ." + wijmo.grid.wijgrid.CSS.wijgridCellContainer);
                var html = innerDiv.html();
                
                html = "d:" + ri.dataItemIndex + " s:" + ri.sectionRowIndex + "  ||" + ri.data[0] + "|| " + html;
                innerDiv.html(html);
                }*/
                // debug
                /*if (scrollData.data && scrollData.mode === intersectionMode.reset) {
                this._view().vsUI.scrollToRow(scrollData.newBounds.start, true); // original scrollIndex could change due pageSize alignment, so we need to re-set position of the vertical scrollbar.
                }*/
                            };
            wijgrid.prototype._updateRowInfos = function (scrollData, diffData) {
                var bounds = this._viewPortBounds(), view = this._view(), newBounds = scrollData.newBounds, rows = this._view().bodyRows(), relMatch, i, diff, rowInfo;
                switch(scrollData.mode) {
                    case grid.intersectionMode.reset:
                        break;
                    case grid.intersectionMode.overlapBottom:
                        relMatch = {
                            start: // zero-based
                            newBounds.start - bounds.start,
                            end: bounds.end - bounds.start
                        };
                        diff = newBounds.start - bounds.start;
                        for(i = relMatch.start; i <= relMatch.end; i++) {
                            rowInfo = view._getRowInfo(rows.item(i), false);
                            rowInfo.sectionRowIndex -= diff;
                            if(diffData.top !== 0) {
                                rowInfo.dataItemIndex += diffData.top;
                            }
                            view._setRowInfo(rowInfo.$rows, rowInfo);
                        }
                        break;
                    case grid.intersectionMode.overlapTop:
                        relMatch = {
                            start: // zero-based
                            bounds.start - bounds.start,
                            end: newBounds.end - bounds.start
                        };
                        diff = bounds.start - newBounds.start;
                        for(i = relMatch.start; i <= relMatch.end; i++) {
                            rowInfo = view._getRowInfo(rows.item(i), false);
                            rowInfo.sectionRowIndex += diff;
                            if(diffData.top !== 0) {
                                rowInfo.dataItemIndex += diffData.top;
                            }
                            view._setRowInfo(rowInfo.$rows, rowInfo);
                        }
                        break;
                }
            };
            wijgrid.prototype._renderVirtualIntoView = function (scrollData) {
                var bounds = this._viewPortBounds(), self = this, sketchRow, view = this._view(), match, i, sectionRowIndex;
                switch(scrollData.mode) {
                    case grid.intersectionMode.reset:
                        // remove all rows
                        view._clearBody();
                        // add new rows
                        var count = scrollData.newBounds.end - scrollData.newBounds.start + 1;
                        this._renderableBoundsCollection().forEachIndex(scrollData.newBounds.start, count, function (sketchIndex) {
                            sketchRow = self.sketchTable.row(sketchIndex - self._dataOffset);
                            view._insertBodyRow(sketchRow, -1, sketchRow.dataItemIndex(), sketchIndex);
                        });
                        view._rebuildOffsets();
                        break;
                    case grid.intersectionMode.overlapBottom:
                        match = {
                            start: scrollData.newBounds.start,
                            end: bounds.end
                        };
                        // remove rows from the top
                        for(i = 0; i < match.start - bounds.start; i++) {
                            view._removeBodyRow(0);
                        }
                        // add new rows to the bottom
                        var count = scrollData.newBounds.end - match.end;
                        this._renderableBoundsCollection().forEachIndex(match.end + 1, count, function (sketchIndex) {
                            sketchRow = self.sketchTable.row(sketchIndex - self._dataOffset);
                            view._insertBodyRow(sketchRow, -1, sketchRow.dataItemIndex(), sketchIndex);
                        });
                        break;
                    case grid.intersectionMode.overlapTop:
                        match = {
                            start: bounds.start,
                            end: scrollData.newBounds.end
                        };
                        // remove rows from the bottom
                        for(i = 0; i < bounds.end - scrollData.newBounds.end; i++) {
                            view._removeBodyRow(match.end - match.start + 1)// relative index starting from zero.
                            ;
                        }
                        // add new tows to the top
                        sectionRowIndex = 0;
                        var count = bounds.start - scrollData.newBounds.start;
                        this._renderableBoundsCollection().forEachIndex(scrollData.newBounds.start, count, function (sketchIndex) {
                            sketchRow = self.sketchTable.row(sketchIndex - self._dataOffset);
                            view._insertBodyRow(sketchRow, sectionRowIndex++, sketchRow.dataItemIndex(), sketchIndex);
                        });
                        break;
                    default:
                        // "none", same range
                        break;
                }
            };
            wijgrid.prototype._processVirtualData = function (scrollData) {
                var dvw = this._dataViewWrapper, source = dvw.dataView().getSource(), dataItem, leaves = this._field("leaves"), i, alignedViewBounds, cachedBounds, exceeded = 0, dataDiff = {
                    top: 0,
                    bottom: 0
                }, rowAttributes, margin = this._serverSideVirtualScrollingMargin();
                //  * extend underlying data
                switch(scrollData.mode) {
                    case grid.intersectionMode.reset:
                        this.sketchTable.clear();
                        dvw._unsafeSplice(0, source.length);
                        this._dataOffset = scrollData.request.index;
                        // append
                        for(i = 0; i < scrollData.data.length; i++) {
                            dvw._unsafePush(dataItem = scrollData.data[i])// append rows to a dataStore
                            ;
                            this.sketchTable.add(this._buildSketchRow(dvw._wrapDataItem(dataItem, i), leaves));
                        }
                        break;
                    case grid.intersectionMode.overlapBottom:
                        // append
                        for(i = 0; i < scrollData.data.length; i++) {
                            dvw._unsafePush(dataItem = scrollData.data[i])// append rows to a dataStore
                            ;
                            this.sketchTable.add(this._buildSketchRow(dvw._wrapDataItem(dataItem, source.length - 1), leaves));
                        }
                        dataDiff.bottom = scrollData.data.length;
                        break;
                    case grid.intersectionMode.overlapTop:
                        // prepend
                        for(i = scrollData.data.length - 1; i >= 0; i--) {
                            dvw._unsafeSplice(0, 0, dataItem = scrollData.data[i]);
                            this.sketchTable.insert(0, this._buildSketchRow(dvw._wrapDataItem(dataItem, i), leaves));
                        }
                        this._dataOffset = scrollData.request.index;
                        dataDiff.top = scrollData.data.length;
                        break;
                }
                // extend underlying data *
                // * remove cached items exceeded cached bounds
                // [margin][pageSize = viewBounds][margin]
                alignedViewBounds = this._ensureTotalRowsBounds({
                    start: scrollData.newBounds.start,
                    end: scrollData.newBounds.end
                });
                cachedBounds = {
                    start: this._dataOffset,
                    end: this._dataOffset + source.length - 1
                };
                // remove items from the bottom
                exceeded = (cachedBounds.end - alignedViewBounds.end) - margin;
                if(exceeded > 0) {
                    dataDiff.bottom -= exceeded;
                    dvw._unsafeSplice(source.length - exceeded, exceeded);
                    this.sketchTable.removeLast(exceeded);
                }
                // remove items from the top
                exceeded = (alignedViewBounds.start - cachedBounds.start) - margin;
                if(exceeded > 0) {
                    dataDiff.top -= exceeded;
                    dvw._unsafeSplice(0, exceeded);
                    this.sketchTable.removeFirst(exceeded);
                    this._dataOffset += exceeded;
                }
                // remove data exceeded cached bounds *
                // * update metadata
                this.sketchTable.updateIndexes();
                // update metadata *
                dvw._refreshSilent();
                return dataDiff;
            };
            wijgrid.prototype._needToCreatePagerItem = function () {
                return this.options.allowPaging === true;
            };
            wijgrid.prototype._isMobileEnv = function () {
                return this._isMobile;
            };
            wijgrid.prototype._isTouchEnv = function () {
                return !!($.support.isTouchEnabled && $.support.isTouchEnabled());
            };
            wijgrid.prototype._render = function () {
                var view = this._view(), o = this.options, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this.options.wijCSS, content;
                view.render();
                // YK: for fixing pager is not align to top and bottom when header is fixed.
                content = this.outerDiv;
                if(o.scrollMode !== "none") {
                    // fixed header content
                    content = this.outerDiv.find("div." + defCSS.scroller + ":first");
                }
                this.$superPanelHeader = null;
                // ** top pager (top div)
                if(this.$topPagerDiv) {
                    if(this.$topPagerDiv.data("wijmo-wijpager")) {
                        this.$topPagerDiv.wijpager("destroy");
                    }
                    this.$topPagerDiv.remove();
                }
                this.$topPagerDiv = null;
                if(this._needToCreatePagerItem() && ((o.pagerSettings.position === "top") || (o.pagerSettings.position === "topAndBottom"))) {
                    if(!this.$topPagerDiv) {
                        content.prepend(this.$superPanelHeader = $("<div class=\"wijmo-wijsuperpanel-header\"></div>"));
                        this.$superPanelHeader.prepend(this.$topPagerDiv = $("<div class=\"" + defCSS.headerArea + " " + wijCSS.wijgridHeaderArea + " " + wijCSS.header + " " + wijCSS.cornerTop + "\"></div>"));
                    }
                }
                // top pager **
                if(o.showGroupArea) {
                    this._processGroupArea(content);
                } else {
                    this.$groupArea = null;
                }
                // ** bottom pager (bottom div)
                if(this.$bottomPagerDiv) {
                    if(this.$bottomPagerDiv.data("wijmo-wijpager")) {
                        this.$bottomPagerDiv.wijpager("destroy");
                    }
                    this.$bottomPagerDiv.remove();
                }
                this.$bottomPagerDiv = null;
                if(this._needToCreatePagerItem() && ((o.pagerSettings.position === "bottom") || (o.pagerSettings.position === "topAndBottom"))) {
                    if(!this.$bottomPagerDiv) {
                        content.append(this.$bottomPagerDiv = $("<div class=\"" + defCSS.footerArea + " " + wijCSS.wijgridFooterArea + " wijmo-wijsuperpanel-footer " + wijCSS.stateDefault + " " + wijCSS.cornerBottom + "\"></div>"));
                    }
                }
                // bottom pager **
                            };
            wijgrid.prototype._processGroupArea = function (content) {
                var self = this, groupCollection = this._groupedColumns(), groupWidgetCollection = [], defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this.options.wijCSS;
                this.$groupArea = $("<div class=\"" + wijCSS.content + " " + wijCSS.helperClearFix + " " + defCSS.groupArea + " " + wijCSS.wijgridGroupArea + "\"></div>");
                if(groupCollection.length > 0) {
                    $.each(groupCollection, function (index, item) {
                        var groupElement = $("<a href=\"#\"></a>").appendTo(self.$groupArea);
                        try  {
                            $.data(groupElement[0], "wijgridowner", self)// pass owner to the constructor
                            ;
                            groupElement.c1groupedfield($.extend({
                            }, {
                                allowMoving: item.allowMoving,
                                allowSort: item.allowSort,
                                dataIndex: item.dataIndex,
                                dataKey: item.dataKey,
                                headerText: item.headerText,
                                isBand: item.isBand,
                                isLeaf: item.isLeaf,
                                linearIdx: item.linearIdx,
                                parentIdx: item.parentIdx,
                                sortDirection: item.sortDirection,
                                travIdx: item.travIdx,
                                groupedIndex: item.groupedIndex
                            }, {
                                disabled: self.options.disabled
                            }));
                        }finally {
                            $.removeData(groupElement[0], "wijgridowner");
                        }
                        groupWidgetCollection.push(groupElement.data("wijmo-c1groupedfield"));
                    });
                } else {
                    this.$groupArea.addClass(defCSS.groupAreaEmpty).css("padding", 0).html(// disable padding (inherited)
                    this.options.groupAreaCaption || "&nbsp;");
                }
                this._field("groupedWidgets", groupWidgetCollection);
                if(!this.$superPanelHeader) {
                    content.prepend(this.$superPanelHeader = $("<div class=\"wijmo-wijsuperpanel-header\"></div>"));
                }
                this.$superPanelHeader.prepend(this.$groupArea);
                this._UIDragndrop(true).attachGroupArea(this.$groupArea);
            };
            wijgrid.prototype._pagerSettings2PagerWidgetSettings = function () {
                return $.extend({
                }, this.options.pagerSettings, {
                    disabled: this.options.disabled,
                    pageCount: this.pageCount(),
                    pageIndex: this.options.pageIndex,
                    pageIndexChanging: $.proxy(this._onPagerWidgetPageIndexChanging, this),
                    pageIndexChanged: $.proxy(this._onPagerWidgetPageIndexChanged, this)
                });
            };
            wijgrid.prototype._showRowHeader = function () {
                return (this.options.showRowHeader === true) && (this.options.staticColumnsAlignment !== "right");
            };
            wijgrid.prototype._attachEvents = function () {
                var view = this._view(), $fe = view.focusableElement(), self = this;
                $fe.bind("keydown." + this.widgetName, $.proxy(this._onKeyDown, this));
                $fe.bind("focusin." + this.widgetName, $.proxy(this._onFocusIn, this));
                this._KeyDownEventListener();
                $.each(view.subTables(), function (index, element) {
                    var domTable = element.element();
                    if(domTable) {
                        if(domTable.tHead) {
                            $(domTable.tHead).bind("click." + self.widgetName, $.proxy(self._onClick, self));
                        }
                        if(domTable.tBodies.length) {
                            $(domTable.tBodies[0]).bind("click." + self.widgetName, $.proxy(self._onClick, self)).bind("dblclick." + self.widgetName, $.proxy(self._onDblClick, self)).bind("mousemove." + self.widgetName, $.proxy(self._onMouseMove, self)).bind("mouseout." + self.widgetName, $.proxy(self._onMouseOut, self));
                        }
                    }
                });
                $(window).bind("resize." + this.widgetName + "." + this._eventUID, $.proxy(this._onWindowResize, this));
            };
            wijgrid.prototype._detachEvents = function (destroy) {
                var view = this._view(), self = this, $fe;
                this._windowResizeTimer = 0;
                $(window).unbind("resize." + this.widgetName + "." + this._eventUID);
                if(view) {
                    $fe = view.focusableElement();
                    $fe.unbind("." + this.widgetName);
                    $.each(view.subTables(), function () {
                        var domTable = this.element();// item (this) is a htmlTableAccessor instance
                        
                        if(domTable) {
                            if(domTable.tHead) {
                                $(domTable.tHead).unbind("." + self.widgetName);
                            }
                            if(domTable.tBodies.length) {
                                $(domTable.tBodies[0]).unbind("." + self.widgetName);
                            }
                        }
                    });
                }
            };
            wijgrid.prototype._handleSort = function (column, multiSort) {
                var columns = this.options.columns, travIdx = column.travIdx, newSortDirection, args;
                //if (this.options.allowSorting && ($.inArray(columnWidget, columns) >= 0)) {
                if(column && this.options.allowSorting) {
                    newSortDirection = ((column.sortDirection === "none") ? "ascending" : ((column.sortDirection === "ascending") ? "descending" : "ascending"));
                    args = {
                        column: column,
                        sortDirection: newSortDirection,
                        sortCommand: column.dataKey + " " + (newSortDirection === "ascending" ? "asc" : "desc")
                    };
                    if(this._onColumnSorting(args)) {
                        column.sortDirection = args.sortDirection;
                        if(multiSort) {
                            column.sortOrder = this._customSortOrder++;
                        } else {
                            this._customSortOrder = 1000// reset to default
                            ;
                            // reset sortDirection for all column widgets except sorting one and grouped columns
                            $.each(this.columns(), function (index, item) {
                                item.options.sortOrder = 0;
                                if(item.options.travIdx !== travIdx && !(item.options.groupInfo && item.options.groupInfo.position !== "none")) {
                                    item.options.sortDirection = "none";
                                }
                            });
                            // ensure invisible columns.
                            wijmo.grid.traverse(columns, function (item) {
                                item.sortOrder = 0;
                                if(item.travIdx !== travIdx && !(item.groupInfo && item.groupInfo.position !== "none")) {
                                    item.sortDirection = "none";
                                }
                            });
                        }
                        args = {
                            column: column,
                            sortDirection: column.sortDirection,
                            sortCommand: column.dataKey + " " + (column.sortDirection === "ascending" ? "asc" : "desc")
                        };
                        if(this._customPagingEnabled()) {
                            this._convertWidgetsToOptions();
                            this._onColumnSorted(args)// Allow user the ability to load a new data and refresh the grid.
                            ;
                        } else {
                            this.ensureControl(true, {
                                afterRefresh: function () {
                                    this._onColumnSorted(args);
                                }
                            });
                        }
                    }
                }
            };
            wijgrid.prototype._handleDragnDrop = function (dragTravIdx, dropTravIdx, at, dragInGroup, dropInGroup) {
                var drag = wijmo.grid.getColumnByTravIdx(this.options.columns, dragTravIdx), drop = wijmo.grid.getColumnByTravIdx(this.options.columns, dropTravIdx), dragSource = dragInGroup ? "groupArea" : "columns", dropSource = dropInGroup ? "groupArea" : "columns";
                if(dropInGroup) {
                    // drag is dropped into the group area
                    if(this._onColumnGrouping({
                        drag: drag.found,
                        drop: drop ? drop.found : null,
                        dragSource: dragSource,
                        dropSource: dropSource,
                        at: at
                    })) {
                        this.ensureControl(true, {
                            beforeRefresh: function () {
                                if(!drop) {
                                    // drag is dropped into the empty group area.
                                    drag.found.groupedIndex = 0;
                                } else {
                                    switch(at) {
                                        case "left":
                                            drag.found.groupedIndex = drop.found.groupedIndex - 0.5;
                                            break;
                                        case "right":
                                            drag.found.groupedIndex = drop.found.groupedIndex + 0.5;
                                            break;
                                    }
                                }
                                if(!dragInGroup) {
                                    $.extend(true, drag.found, {
                                        groupInfo: {
                                            position: "header"
                                        }
                                    });
                                }
                            },
                            afterRefresh: function () {
                                this._onColumnGrouped({
                                    drag: drag.found,
                                    drop: drop ? drop.found : null,
                                    dragSource: dragSource,
                                    dropSource: dropSource,
                                    at: at
                                });
                            }
                        });
                    }
                } else {
                    if(this._onColumnDropping({
                        drag: drag.found,
                        drop: drop.found,
                        at: at
                    })) {
                        this.ensureControl(false, {
                            beforeRefresh: function () {
                                /* modifying the wijgrid.options.columns option */
                                drag.at.splice(drag.found.linearIdx, 1);
                                //because when drag is before drop, the index of drop is affected.
                                switch(at) {
                                    case "left":
                                        if(drag.at === drop.at && drag.found.linearIdx < drop.found.linearIdx) {
                                            drop.at.splice(drop.found.linearIdx - 1, 0, drag.found);
                                        } else {
                                            drop.at.splice(drop.found.linearIdx, 0, drag.found);
                                        }
                                        break;
                                    case "right":
                                        if(drag.at === drop.at && drag.found.linearIdx < drop.found.linearIdx) {
                                            drop.at.splice(drop.found.linearIdx, 0, drag.found);
                                        } else {
                                            drop.at.splice(drop.found.linearIdx + 1, 0, drag.found);
                                        }
                                        break;
                                    case "center":
                                        // drop is a band
                                        drop.found.columns.push(drag.found);
                                        break;
                                }
                                // rebuild indices (linearIdx, travIdx, parentIdx)
                                wijmo.grid.setTraverseIndex(this.options.columns);
                            },
                            afterRefresh: function () {
                                this._onColumnDropped({
                                    drag: drag.found,
                                    drop: drop.found,
                                    at: at
                                });
                            }
                        });
                    }
                }
            };
            wijgrid.prototype._handleFilter = function (column, rawOperator, rawValue) {
                var operator = (new wijmo.grid.filterOperatorsCache(this)).getByName(rawOperator), value, ok, args;
                if(operator) {
                    if(operator.arity > 1) {
                        // check value
                        value = this.parse(column.options, rawValue);
                        ok = (value !== null && (wijmo.grid.getDataType(column.options) === "string" || !isNaN(value)));
                    } else {
                        ok = true;
                    }
                    if(ok) {
                        args = {
                            column: column.options,
                            operator: operator.name,
                            value: value
                        };
                        if(this._onColumnFiltering(args)) {
                            column.options.filterValue = args.value;
                            column.options.filterOperator = args.operator;
                            this._resetDataProperties();
                            this._resetVerticalBounds();
                            if(this._customPagingEnabled()) {
                                this._convertWidgetsToOptions();
                                this._onColumnFiltered({
                                    column: column.options
                                })// Allow user the ability to load a new data and refresh the grid.
                                ;
                            } else {
                                this.ensureControl(true, {
                                    afterRefresh: function () {
                                        this._onColumnFiltered({
                                            column: column.options
                                        });
                                    }
                                });
                            }
                        }
                    }
                }
            };
            wijgrid.prototype._handleUngroup = function (columnTravIdx) {
                var column = wijmo.grid.getColumnByTravIdx(this.options.columns, columnTravIdx), result;
                if(column && column.found) {
                    result = column.found;
                    if(this._onColumnUngrouping({
                        column: result
                    })) {
                        this.ensureControl(true, {
                            beforeRefresh: function () {
                                delete result.groupedIndex;
                                $.extend(true, result, {
                                    groupInfo: {
                                        position: "none"
                                    }
                                });
                            },
                            afterRefresh: function () {
                                this._onColumnUngrouped({
                                    column: result
                                });
                            }
                        });
                    }
                }
            };
            wijgrid.prototype._onVirtualScrolling = function (newBounds, request, mode, scrollIndex, completeCallback, data/* opt*/ ) {
                var self = this;
                this.ensureControl(this._serverSideVirtualScrolling(), {
                    virtualScrollData: {
                        newBounds: newBounds,
                        request: request,
                        mode: mode,
                        data: data
                    },
                    beforeOnRendered: function (userData) {
                        var bounds = self._viewPortBounds();
                        $.extend(bounds, userData.virtualScrollData.newBounds);
                    },
                    afterRefresh: function (userData) {
                        (self._view())._adjustRowsHeights();
                        if(completeCallback) {
                            completeCallback(scrollIndex);
                        }
                    }
                });
            };
            
            wijgrid.prototype._handleVirtualScrolling = function (scrollIndex, forceIntersectionMode, completeCallback) {
                if (typeof forceIntersectionMode === "undefined") { forceIntersectionMode = null; }
                var view = this._view(), bounds = this._viewPortBounds(), newBounds = this._ensureRenderableBounds({
                    start: scrollIndex,
                    end: scrollIndex + view.getVirtualPageSize() - 1
                }), cachedDataBounds = this._ensureTotalRowsBounds({
                    start: this._dataOffset,
                    end: this._dataOffset + this._dataViewWrapper.dataView().count() - 1
                }), request = null, mode, virtualPageSize = (this._view()).getVirtualPageSize();
                // check viewBounds
                if(forceIntersectionMode) {
                    mode = forceIntersectionMode;
                } else {
                    if(newBounds.start > bounds.end || newBounds.end < bounds.start) {
                        // mode = "reset"
                        mode = grid.intersectionMode.reset;
                    } else {
                        if(newBounds.start > bounds.start) {
                            mode = grid.intersectionMode.overlapBottom;
                        } else {
                            if(newBounds.start < bounds.start) {
                                mode = grid.intersectionMode.overlapTop;
                            } else {
                                mode = newBounds.start !== bounds.start || newBounds.end !== bounds.end ? grid.intersectionMode.reset : // TODO: enhance handling the case when new range is included in the old one.
                                grid.intersectionMode.none// same range, "none"
                                ;
                            }
                        }
                    }
                }
                // quick fix
                //mode = intersectionMode.reset;
                //
                // check dataBounds
                if(this._serverSideVirtualScrolling()) {
                    switch(mode) {
                        case grid.intersectionMode.reset:
                            // align view bounds by pageSize
                            request = {
                                index: scrollIndex,
                                maxCount: // (scrollIndex == newBounds.start)
                                virtualPageSize
                            };
                            break;
                        case grid.intersectionMode.overlapBottom:
                            if(newBounds.end > cachedDataBounds.end) {
                                request = {
                                    index: cachedDataBounds.end + 1,
                                    maxCount: virtualPageSize
                                };
                            }
                            break;
                        case grid.intersectionMode.overlapTop:
                            if(newBounds.start < cachedDataBounds.start) {
                                request = {
                                    index: Math.max(0, cachedDataBounds.start - virtualPageSize),
                                    maxCount: 0
                                };
                                request.maxCount = cachedDataBounds.start - request.index;
                            }
                            break;
                    }
                }
                if(mode !== grid.intersectionMode.none) {
                    this._onVirtualScrolling(newBounds, request, mode, scrollIndex, completeCallback)// note: scrollIndex could be changed
                    ;
                }
            };
            wijgrid.prototype._serverSideVirtualScrolling = function () {
                return false;
            };
            wijgrid.prototype._serverSideVirtualScrollingMargin = function () {
                var margin = (this._view()).getVirtualPageSize() * 2;
                if(margin < 20) {
                    margin = 20;
                }
                return margin;
            };
            wijgrid.prototype._onColumnDropping = // * event handlers
            function (args) {
                return this._trigger("columnDropping", null, args);
            };
            wijgrid.prototype._onColumnDropped = function (args) {
                this._trigger("columnDropped", null, args);
            };
            wijgrid.prototype._onColumnGrouping = function (args) {
                return this._trigger("columnGrouping", null, args);
            };
            wijgrid.prototype._onColumnGrouped = function (args) {
                this._trigger("columnGrouped", null, args);
            };
            wijgrid.prototype._onColumnUngrouping = function (args) {
                return this._trigger("columnUngrouping", null, args);
            };
            wijgrid.prototype._onColumnUngrouped = function (args) {
                this._trigger("columnUngrouped", null, args);
            };
            wijgrid.prototype._onColumnFiltering = function (args) {
                return this._trigger("filtering", null, args);
            };
            wijgrid.prototype._onColumnFiltered = function (args) {
                this._trigger("filtered", null, args);
            };
            wijgrid.prototype._onFilterOperatorsListShowing = function (args) {
                this._trigger("filterOperatorsListShowing", null, args);
            };
            wijgrid.prototype._onColumnSorting = function (args) {
                return this._trigger("sorting", null, args);
            };
            wijgrid.prototype._onColumnSorted = function (args) {
                this._trigger("sorted", null, args);
            };
            wijgrid.prototype._onCurrentCellChanged = function (e, info) {
                var _this = this;
                var o = this.options, currentCell = this.currentCell(), rowInfo = currentCell.row(), completed = // can be null
                function () {
                    var currentCell = _this.currentCell(), dataRange = _this._getDataCellsRange(grid.dataRowsRangeMode.sketch);
                    if(_this.options.highlightCurrentCell) {
                        var oldCell = new wijmo.grid.cellInfo(info.changingEventArgs.oldCellIndex, info.changingEventArgs.oldRowIndex, _this);
                        if(oldCell._isValid && dataRange._containsCellInfo(oldCell)) {
                            _this._highlightCellPosition(oldCell, false)// remove the old one
                            ;
                        }
                        _this._highlightCellPosition(currentCell, true)// highlight the current one
                        ;
                    }
                    var domCell;
                    if(info.setFocus && (domCell = currentCell.tableCell())) {
                        _this._setFocusOnCell(info.hasFocusedChild ? $(e.target) : $(domCell), info.hasFocusedChild, currentCell.column());
                    }
                    _this._trigger("currentCellChanged");
                    var eventType = (e && (e.type || "").toLowerCase()) || "";
                    // ** set selection
                    if(info.changeSelection) {
                        var selection = _this.selection(), selectionMode = _this.options.selectionMode.toLowerCase(), extendMode = info.selectionExtendMode || wijmo.grid.cellRangeExtendMode.none;
                        selection.beginUpdate();
                        if(eventType) {
                            if(currentCell._isValid()) {
                                switch(eventType) {
                                    case "focusin":
                                    case "click":
                                        if(!e.shiftKey || (!selection._multipleRangesAllowed() && selectionMode !== "singlerange")) {
                                            selection._startNewTransaction(currentCell);
                                        }
                                        if(e.shiftKey && e.ctrlKey) {
                                            selection._clearRange(new wijmo.grid.cellInfoRange(currentCell, currentCell), extendMode);
                                        } else {
                                            selection._selectRange(new wijmo.grid.cellInfoRange(selection._anchorCell(), currentCell), e.ctrlKey, e.shiftKey, extendMode, null);
                                        }
                                        break;
                                    case "keydown":
                                        if(!e.shiftKey || (!selection._multipleRangesAllowed() && selectionMode !== "singlerange")) {
                                            selection._startNewTransaction(currentCell);
                                        }
                                        selection._selectRange(new wijmo.grid.cellInfoRange(selection._anchorCell(), currentCell), false, e.shiftKey, wijmo.grid.cellRangeExtendMode.none, null);
                                        break;
                                }
                            }
                        } else {
                            // * move selection to the current position *
                            selection.clear();
                            if(currentCell._isValid()) {
                                // attach selection to the current cell
                                selection._startNewTransaction(currentCell);
                                selection._selectRange(new wijmo.grid.cellInfoRange(currentCell, currentCell), false, false, wijmo.grid.cellRangeExtendMode.none, null);
                            }
                        }
                        selection.endUpdate();
                    }
                    // set selection **
                    // cell editing
                    if(eventType === "click" && _this._editBySingleClick()) {
                        _this._beginEditInternal(e);
                    }
                };
                this.mCurrentCellLocker = true;
                // notify dataView
                this._dataViewWrapper.currentPosition((rowInfo && (rowInfo.type & wijmo.grid.rowType.data)) ? rowInfo.dataItemIndex : -1);
                if(o.scrollMode !== "none" && currentCell && !currentCell.isEqual(wijmo.grid.cellInfo.outsideValue)) {
                    var scrollToCell = currentCell, rowInfo = scrollToCell.row();
                    if(rowInfo && !(rowInfo.type & wijmo.grid.rowType.data) && !scrollToCell.tableCell()) {
                        // test for groupFoooter\ groupHeader
                        scrollToCell = currentCell._clone();
                        scrollToCell.cellIndex(0);
                    }
                    (this._view()).scrollTo(scrollToCell, function () {
                        try  {
                            completed();
                        }finally {
                            _this.mCurrentCellLocker = false;
                        }
                    }, info);
                } else {
                    try  {
                        completed();
                    }finally {
                        this.mCurrentCellLocker = false;
                    }
                }
            };
            wijgrid.prototype._onPageIndexChanging = function (args) {
                return this._trigger("pageIndexChanging", null, args);
            };
            wijgrid.prototype._onPageIndexChanged = function (args) {
                this._trigger("pageIndexChanged", null, args);
            };
            wijgrid.prototype._onPagerWidgetPageIndexChanging = function (sender, args) {
                args.handled = true;
            };
            wijgrid.prototype._onPagerWidgetPageIndexChanged = function (sender, args) {
                this._setOption("pageIndex", args.newPageIndex);
            };
            wijgrid.prototype._onRendering = function (userData) {
                var view = this._view();
                this._rendered = false;
                if(userData.virtualScrollData) {
                    //this.selection().clear(); // clear selection
                    //if (this.options.highlightCurrentCell) {
                    //	this._highlightCellPosition(this.currentCell(), false); // remove highlighning
                    //}
                                    } else {
                    var currentCell = this._field("currentCell");
                    this._field("currentCellPrevCycle", currentCell ? {
                        x: currentCell.cellIndex(),
                        y: currentCell.rowIndex(),
                        dataItemIndex: currentCell.row() ? currentCell.row().dataItemIndex : -1
                    } : {
                        x: -1,
                        y: -1,
                        dataItemIndex: -1
                    });
                    this._field("currentCell", null);
                    if(view) {
                        view.dispose();
                    }
                    this._detachEvents(false);
                    this.element.detach();
                    this.element.css({
                        "table-layout": // Chrome issue
                        "",
                        "width": ""
                    });
                    this.element.empty();
                    this.outerDiv.empty();
                    this.outerDiv.append(this.element);
                    if(this._selectionui) {
                        this._selectionui.dispose();
                        this._selectionui = null;
                    }
                    if(this._resizerui) {
                        this._resizerui.dispose();
                        this._resizerui = null;
                    }
                    if(this._frozenerui) {
                        this._frozenerui.dispose();
                        this._frozenerui = null;
                    }
                    if(this.mKeyDownEventListener) {
                        this.mKeyDownEventListener.dispose();
                        this.mKeyDownEventListener = null;
                    }
                }
                this._trigger("rendering");
            };
            wijgrid.prototype._onRendered = function (userData) {
                var view = this._view(), currentCell, hasSelection = this.selection().selectedCells().length() > 0;
                this._rendered = true;
                this._renderCounter++;
                if(!userData.virtualScrollData) {
                    this._field("selection", null)// always recreate selection object
                    ;
                    // attach events
                    this._attachEvents();
                    // ** current cell
                    this._setAttr(view.focusableElement(), "tabIndex", 0)// to handle keyboard\ focus events
                    ;
                    var prevCurrentCell = this._field("currentCellPrevCycle");
                    //if (this._dataViewWrapper.isOwnDataView() && (prevCurrentCell.dataItemIndex >= 0)) { // if own dataView is used then restore dataView.currentPosition() from previous currentCell position.
                    //	var cnt = this._dataViewWrapper.dataView().count();
                    //	if (prevCurrentCell.dataItemIndex >= cnt) {
                    //		prevCurrentCell.dataItemIndex = cnt - 1;
                    //	}
                    //	this._dataViewWrapper.currentPosition(prevCurrentCell.dataItemIndex);
                    //}
                    currentCell = this._currentCellFromDataView(prevCurrentCell.x);
                    if(!currentCell._isValid() && this.options.showSelectionOnRender) {
                        currentCell = this._getFirstDataRowCell(0);
                    }
                    this.currentCell(currentCell, null, true);
                    // current cell *
                    // selection ui
                    this._UISelection(true);
                    // initialize resizer
                    var resizer = new wijmo.grid.uiResizer(this);
                    $.each(this.columns(), function (index, colWidget) {
                        var o = colWidget.options;
                        if(o.visible && o.parentVis && o.isLeaf) {
                            resizer.addElement(colWidget);
                        }
                    });
                    this._resizerui = resizer;
                    this._setSizeInternal(this._scrollingState)// set sizes, create wijsuperpanel, restore scrolling state.
                    ;
                    //frozener
                    if(this.options.scrollMode !== "none") {
                        this._frozenerui = new wijmo.grid.uiFrozener(this);
                    }
                } else {
                    var currentCell = this.currentCell();
                    this.currentCell(currentCell, null, false);
                    if(currentCell._isEdit() && !currentCell.row()) {
                        currentCell._isEdit(false)// reset editing if sketchRow is not available (C1GridView virtual scrolling)
                        ;
                    }
                    this.selection()._ensureSelection();
                }
                this._trigger("rendered");
            };
            wijgrid.prototype._onClick = // note: can be called by the _onFocusIn method!
            function (e) {
                if(!this._canInteract() || !e.target) {
                    return;
                }
                var view = this._view(), clickedCell = this._findUntilOuterDiv(e.target, {
                    td: true,
                    th: true
                }), $row, clickedCellInfo, extendMode = wijmo.grid.cellRangeExtendMode.none, currentCell, selection, clickedCellChanged = false, clickEvent = !!(e && (e.type === "click"));
                // real click event?
                                if(clickedCell) {
                    if(clickEvent && $(e.target).hasClass(wijmo.grid.wijgrid.CSS.groupToggleVisibilityButton)) {
                        this._onGroupBtnClick(e);
                        // #29676: stop event from bubbling up to the parent grid (if available)
                        e.stopPropagation();
                        return false;
                    }
                    $row = $(clickedCell).closest("tr");
                    if(!$row.length) {
                        return;
                    }
                    clickedCellInfo = view.getAbsoluteCellInfo(clickedCell, false);
                    if($row.hasClass(wijmo.grid.wijgrid.CSS.dataRow) || $row.hasClass(wijmo.grid.wijgrid.CSS.headerRow)) {
                        if(clickedCellInfo.cellIndex() < 0 || clickedCellInfo.rowIndex() < 0) {
                            // header cell, rowheader cell or filter cell
                            if(clickedCellInfo.rowIndex() >= 0) {
                                // rowheader cell
                                // move current cell to the first cell of the clicked row
                                clickedCellInfo = new wijmo.grid.cellInfo(0, clickedCellInfo.rowIndex());
                                extendMode = wijmo.grid.cellRangeExtendMode.row;
                                clickedCellChanged = true;
                            } else {
                                // header cell
                                if(clickedCellInfo.cellIndex() >= 0) {
                                    // move current cell to the first data cell of the clicked column
                                    clickedCellInfo = this._getFirstDataRowCell(clickedCellInfo.cellIndex());
                                    extendMode = wijmo.grid.cellRangeExtendMode.column;
                                    clickedCellChanged = true;
                                }
                            }
                        }
                        if(!clickedCellChanged) {
                            clickedCellInfo = view.getAbsoluteCellInfo(clickedCell, true);
                        }
                        // change current cell and set focus to it (if the target element is not already focused)
                        this._changeCurrentCell(e, clickedCellInfo, {
                            changeSelection: true,
                            setFocus: clickEvent,
                            selectionExtendMode: extendMode
                        });
                    }
                    if(clickEvent) {
                        var cellClickedArgs = {
                            cell: clickedCellInfo
                        };
                        this._trigger("cellClicked", null, cellClickedArgs);
                    }
                }
            };
            wijgrid.prototype._onDblClick = function (e) {
                if(!this._editBySingleClick()) {
                    this._beginEditInternal(e);
                }
            };
            wijgrid.prototype._onGroupBtnClick = function (e) {
                if(!this._canInteract()) {
                    return;
                }
                var $row = $(e.target).closest("tr"), gh = wijmo.grid.groupHelper, groupInfo = gh.getGroupInfo($row[0]), column, group, self = this;
                if(groupInfo) {
                    column = gh.getColumnByGroupLevel(this._field("leaves"), groupInfo.level);
                    if(column) {
                        group = column.groupInfo.expandInfo[groupInfo.index];
                        if(group.isExpanded) {
                            group.collapse();
                        } else {
                            group.expand(e.shiftKey);
                        }
                        if(this._allowVirtualScrolling()) {
                            this._rebuildRenderBoundsCollection();
                            (this._view()).vsUI._changeVisibleRowsCount(this._renderableBoundsCollection().capacity());
                            this._ensureViewPortBoundsVisible(this._viewPortBounds());
                            this._handleVirtualScrolling(this._viewPortBounds().start, grid.intersectionMode.reset);
                        }
                        //this._view().ensureHeight(); /*dma*/
                        this.setSize()// recalculate sizes (#39295)
                        ;
                    }
                }
            };
            wijgrid.prototype._onKeyDown = function (e) {
                var isKeyDownListenerElement = this._KeyDownEventListener().isHiddenInput($(e.target));
                if(!this._canInteract() || (isKeyDownListenerElement && this._KeyDownEventListener().canHandle(e))) {
                    // the focus is inside the hidden input and the printable key has been pressed.
                    return true;
                }
                var tag = (e.target).tagName.toLowerCase(), $target = $(e.target), currentCell = this.currentCell(), keyCodeEnum = wijmo.getKeyCodeEnum();
                if(!isKeyDownListenerElement && // && $target.is(":focusable") // "unsupported pseudo: focusable" exception in IE10?
                (tag === "input" || tag === "option" || tag === "select" || tag === "textarea") && ($target.closest("tr.wijmo-wijgrid-datarow").length === 0)) {
                    return true;
                }
                if(this._allowCellEditing()) {
                    // ESC: cancel editing, F2: finish editing
                    if((e.which === keyCodeEnum.ESCAPE || e.which === 113) && (currentCell._isValid() && currentCell._isEdit())) {
                        this._endEditInternal(e);
                        return false;
                    } else {
                        if(e.which === 113) {
                            // F2: start editing
                            this._beginEditInternal(e);
                            return false;
                        }
                    }
                }
                if(!this.options.allowKeyboardNavigation) {
                    return true;
                }
                var nextCell;
                switch(e.which) {
                    case keyCodeEnum.DOWN:
                    case keyCodeEnum.PAGE_DOWN:
                    case keyCodeEnum.UP:
                    case keyCodeEnum.PAGE_UP:
                    case keyCodeEnum.LEFT:
                    case keyCodeEnum.RIGHT:
                    case keyCodeEnum.HOME:
                    case keyCodeEnum.END:
                    case keyCodeEnum.TAB:
                        if(e.which === keyCodeEnum.TAB) {
                            var visibleLeaves = this._field("visibleLeaves");
                            // There is no data in the grid, will bubble the keydown event out of the grid.
                            if(!visibleLeaves || !visibleLeaves.length) {
                                return true;
                            }
                        }
                        if(isKeyDownListenerElement || this._canMoveToAnotherCell(e.target, e.which)) {
                            var dataRange = this._getDataCellsRange(grid.dataRowsRangeMode.renderable);
                            nextCell = this._getNextCurrentCell(dataRange, currentCell, e.keyCode, e.shiftKey);
                        }
                        break;
                }
                if(nextCell) {
                    // change current cell and set focus to it (always set focus to change the IME mode).
                    this._changeCurrentCell(e, nextCell, {
                        changeSelection: true,
                        setFocus: true
                    });
                    return false;// stop bubbling
                    
                }
                return true;
            };
            wijgrid.prototype._onFocusIn = function (e) {
                if(this.options.allowKeyboardNavigation && e && e.target && $(e.target).is(":input") && // optimization, test for inputs only
                !this._KeyDownEventListener().isHiddenInput($(e.target))) {
                    // optimization, ignore IME hidden inputs
                    this._onClick(e)// simulate a click
                    ;
                }
            };
            wijgrid.prototype._onMouseMove = function (e) {
                var view = this._view(), frozener = this._frozenerui, hoveredCell, $hoveredRow, hoveredCellInfo, rowObj, rowInfo, $rs = wijmo.grid.renderState;
                if(!this.options.highlightOnHover || !this._canInteract() || (frozener && frozener.inProgress())) {
                    return;
                }
                hoveredCell = this._findUntilOuterDiv(e.target, {
                    td: true,
                    th: true
                });
                if(hoveredCell) {
                    $hoveredRow = $(hoveredCell).closest("tr");
                    if(!$hoveredRow.length || !($hoveredRow.hasClass(wijmo.grid.wijgrid.CSS.dataRow) || $hoveredRow.hasClass(wijmo.grid.wijgrid.CSS.headerRow))) {
                        return;
                    }
                    hoveredCellInfo = view.getAbsoluteCellInfo(hoveredCell, true);
                    var hoveredSketchIndex = hoveredCellInfo.rowIndex();
                    if(hoveredSketchIndex !== this._prevHoveredSketchRowIndex) {
                        // clear previous row
                        if(this._prevHoveredSketchRowIndex !== undefined && (view._isRowRendered(this._prevHoveredSketchRowIndex) >= 0)) {
                            rowInfo = view._getRowInfoBySketchRowIndex(this._prevHoveredSketchRowIndex);
                            if(rowInfo) {
                                view._changeRowRenderState(rowInfo, $rs.hovered, false);
                                this.rowStyleFormatter.format(rowInfo);
                            }
                        }
                        // highlight current row
                        this._prevHoveredSketchRowIndex = hoveredSketchIndex;
                        if(hoveredSketchIndex >= 0) {
                            rowInfo = view._getRowInfoBySketchRowIndex(hoveredSketchIndex);
                            if(rowInfo) {
                                view._changeRowRenderState(rowInfo, $rs.hovered, true);
                                this.rowStyleFormatter.format(rowInfo);
                            }
                        }
                    }
                }
            };
            wijgrid.prototype._onMouseOut = function (e) {
                if(!this._canInteract()) {
                    return;
                }
                var firstParentRow = this._findUntilOuterDiv(e.relatedTarget, {
                    tr: true
                });
                if(!firstParentRow || !$(firstParentRow).hasClass(wijmo.grid.wijgrid.CSS.dataRow)) {
                    // remove hovering
                                        var hovRowIndex = this._prevHoveredSketchRowIndex, view = this._view();
                    if(hovRowIndex >= 0) {
                        var rowInfo = view._getRowInfoBySketchRowIndex(hovRowIndex);
                        if(rowInfo && rowInfo.$rows) {
                            view._changeRowRenderState(rowInfo, wijmo.grid.renderState.hovered, false);
                            this.rowStyleFormatter.format(rowInfo);
                        }
                        this._prevHoveredSketchRowIndex = -1;
                    }
                }
            };
            wijgrid.prototype._onWindowResize = function (e) {
                var self = this;
                // reset timer
                if(this._windowResizeTimer > 0) {
                    window.clearTimeout(this._windowResizeTimer);
                    this._windowResizeTimer = 0;
                }
                if(this._windowResizeTimer !== -1) {
                    this._windowResizeTimer = window.setTimeout(function () {
                        self._windowResizeTimer = -1// lock
                        ;
                        try  {
                            if(!self._destroyed && self._initialized && self.element.parent().length) {
                                self.setSize();
                            }
                        }finally {
                            self._windowResizeTimer = 0// unlock
                            ;
                        }
                    }, 50);
                }
            };
	    
            wijgrid.prototype._fieldResized = // * event handlers
            // * resizing
            function (fieldWidget, oldWidth, newWidth) {
                if(oldWidth < 0) {
                    oldWidth = 0;
                }
                if(newWidth <= 0) {
                    newWidth = 1;
                }
                var resizingArgs = {
                    column: fieldWidget.options,
                    oldWidth: oldWidth,
                    newWidth: newWidth
                };
                if(this._trigger("columnResizing", null, resizingArgs) !== false) {
                    if(isNaN(resizingArgs.newWidth) || resizingArgs.newWidth < 0) {
                        resizingArgs.newWidth = 1;
                    }
                    fieldWidget.option("width", resizingArgs.newWidth)// update widget option first (tfs issue 32108)
                    ;
                    var resizedArgs = {
                        column: fieldWidget.options
                    };
                    this._trigger("columnResized", null, resizedArgs);
                }
            };
            wijgrid.prototype._setFocusOnCell = // * resizing
            function (element, focusableChild, column) {
                if(focusableChild) {
                    //if (!element.is(":focus")) {
                    //	element.focus(); // ensure that element still has focus.
                    //}
                                    } else {
                    this._KeyDownEventListener().focus(element, column);
                }
            };
            wijgrid.prototype._findFocusedChild = function (parent) {
                var result = parent.find(":focus");
                return result.length ? result : null;
            };
            wijgrid.prototype._changeCurrentCell = // * currentCell
            // returns false when currentCellChanging event was cancelled, otherwise true.
            function (e, cellInfo, info) {
                if(this.mCurrentCellLocker === true) {
                    // skip until the _onCurrentCellChanged will not be completed.
                    return;
                }
                var currentCell = this.currentCell(), dataRange = this._getDataCellsRange(grid.dataRowsRangeMode.sketch);
                // if cellInfo has a valid value
                if((dataRange._isValid() && dataRange._containsCellInfo(cellInfo)) || (cellInfo.isEqual(wijmo.grid.cellInfo.outsideValue))) {
                    var $target = e && e.target && $(e.target), domCell = cellInfo.tableCell(), $container = cellInfo.container(), $focusedChild = null;
                    info.hasFocusedChild = !!(domCell && $target && ($target[0] !== domCell) && ($target[0] !== $container[0]) && !this._KeyDownEventListener().isHiddenInput($target) && /* $target.is(":focus") */ ($focusedChild = this._findFocusedChild($container)))// $focusedChild can differs from $target (#56472)
                    ;
                    // other cell than current cell
                    if(currentCell.cellIndex() !== cellInfo.cellIndex() || currentCell.rowIndex() !== cellInfo.rowIndex()) {
                        var currentCellChangingArgs = {
                            cellIndex: cellInfo.cellIndex(),
                            rowIndex: cellInfo.rowIndex(),
                            oldCellIndex: currentCell.cellIndex(),
                            oldRowIndex: currentCell.rowIndex()
                        };
                        if(this._trigger("currentCellChanging", null, currentCellChangingArgs)) {
                            var cellEditCompleted = false;
                            if(!this._allowCellEditing() || !currentCell._isEdit() || (cellEditCompleted = this._endEditInternal(null))) {
                                info.changingEventArgs = currentCellChangingArgs;
                                currentCell = cellInfo._clone();
                                currentCell._setGridView(this);
                                this._field("currentCell", currentCell)// set currentCell
                                ;
                                this._onCurrentCellChanged(e, info);
                            }
                        } else {
                            return false;
                        }
                    } else {
                        // the same cell
                        if(this.options.highlightCurrentCell) {
                            this._highlightCellPosition(currentCell, true)// ensure
                            ;
                        }
                        if(domCell && !currentCell._isEdit()) {
                            if(e && this._editBySingleClick()) {
                                this._beginEditInternal(e);
                            } else {
                                if(info.setFocus) {
                                    this._setFocusOnCell(info.hasFocusedChild ? $focusedChild : $(domCell), info.hasFocusedChild, currentCell.column());
                                }
                            }
                        }
                    }
                } else {
                    // cellInfo is invalid
                    // do nothing
                    // this._highlightCellPosition(currentCell, false);
                    // this._field("currentCell", currentCell.outsideValue); // set currentCell
                                    }
                return true;
            };
            wijgrid.prototype._highlightCellPosition = function (cellInfo, add) {
                if(cellInfo && cellInfo._isValid()) {
                    var x = cellInfo.cellIndexAbs(), y = cellInfo.rowIndexAbs(), $rs = wijmo.grid.renderState, view = this._view(), rowInfo, obj, state;
                    // * column header cell * - change even if the cell is not rendered.
                    obj = view.getHeaderCell(x);
                    if(obj) {
                        rowInfo = view._getRowInfo(this._headerRows().item(cellInfo.column().thY));
                        obj = $(obj);
                        state = view._changeCellRenderState(obj, $rs.current, add);
                        // highlight column header cell
                        this.cellStyleFormatter.format(obj, x, cellInfo.column(), rowInfo, state);
                    }
                    if(cellInfo._isRendered()) {
                        // * row header cell *
                        obj = view.getJoinedRows(y, 0);
                        if(obj) {
                            // change row state
                            rowInfo = view._getRowInfo(obj);
                            view._changeRowRenderState(rowInfo, $rs.current, add);
                            // highlight row header cell
                            this.rowStyleFormatter.format(rowInfo);
                        }
                        // * data cell *
                        obj = view.getCell(x, y);
                        if(obj) {
                            obj = $(obj);
                            state = view._changeCellRenderState(obj, $rs.current, add);
                            // highlight data cell
                            this.cellStyleFormatter.format(obj, x, cellInfo.column(), rowInfo, state)// rowInfo is taken from the previous step
                            ;
                        }
                    }
                }
            };
            wijgrid.prototype._beginEditInternal = // * currentCell
            // * editing
            function (e) {
                if(this._canInteract() && this._allowCellEditing()) {
                    var cell = this.currentCell(), column = cell.column(), res;
                    if(column && !column.readOnly) {
                        res = new wijmo.grid.cellEditorHelper().cellEditStart(this, cell, e);
                        if(res) {
                            // this._view().ensureWidth(undefined, column.visLeavesIdx);
                                                    }
                        return res;
                    }
                }
                return false;
            };
            wijgrid.prototype._endEditInternal = function (e) {
                if(this._canInteract() && this._allowCellEditing()) {
                    var cell = this.currentCell(), cellEditor = new wijmo.grid.cellEditorHelper(), updateRes = cellEditor.updateCell(this, cell, e);
                    if(updateRes & grid.updateCellResult.success) {
                        if(updateRes & grid.updateCellResult.notEdited) {
                            return true;
                        }
                        cellEditor.cellEditEnd(this, cell, e);
                        cell = this.currentCell();
                        // set focus to listen keypress\ keydown event.
                        var domCell = cell.tableCell();
                        if(domCell) {
                            this._KeyDownEventListener().focus($(domCell), cell.column());
                        } else {
                            $(this._view().focusableElement()).focus();
                        }
                        if(!this._allowVirtualScrolling()) {
                            // avoid horizontal scrollbar movement.
                            this._view().ensureHeight(cell.rowIndex());
                        }
                        return true;
                    }
                }
                return false;
            };
            wijgrid.prototype._onViewInsertEmptyRow = // * editing
            // * view handlers
            function (rowType, renderState, sectionRowIndex, dataRowIndex, dataItemIndex, virtualDataItemIndex, groupByValue) {
                return null;// default action
                
            };
            wijgrid.prototype._onViewCreateEmptyCell = function (rowInfo, dataCellIndex, column) {
                return null;// default action
                
            };
            wijgrid.prototype._onViewCellRendered = function (rowInfo, $cell, cellIndex, column) {
            };
            wijgrid.prototype._onViewRowRendered = function (rowInfo, rowAttr, rowStyle) {
            };
            wijgrid.prototype._getDataParser = // view handlers *
            // misc
            function (column) {
                return column.dataParser || wijmo.data.defaultParsers[column.dataType] || wijmo.data.defaultParsers.string;
            };
            wijgrid.prototype.parse = /** @ignore */
            function (column, value) {
                //// old behaviour
                //var parser = this._getDataParser(column);
                //return parser.parse(value, this._field("closestCulture"), column.dataFormatString, this.options.nullString, true);
                                var fromType = wijmo.grid.getDataType(column), toType = wijmo.grid.getDataType(column);
                if($.isFunction(value)) {
                    value = value()// observable
                    ;
                }
                value = wijmo.data.convert(value, fromType, toType, {
                    culture: this.mClosestCulture,
                    format: column.dataFormatString || column._underlyingDataFormatString,
                    nullString: this.options.nullString,
                    parser: column.dataParser
                });
                // custom parser
                return value;
            };
            wijgrid.prototype.toStr = /** @ignore */
            function (column, value) {
                //// old behaviour
                //var parser = this._getDataParser(column);
                //return parser.toStr(value, this._field("closestCulture"), column.dataFormatString, this.options.nullString, true);
                                var dataView = this._dataViewWrapper.dataView(), fromType = wijmo.grid.getDataType(column), toType = // column._underlyingDataType || "string",
                "string";
                value = wijmo.data.convert(value, fromType, toType, {
                    culture: this.mClosestCulture,
                    format: column.dataFormatString || column._underlyingDataFormatString,
                    nullString: this.options.nullString,
                    parser: column.dataParser
                });
                // custom parser
                return value;
            };
            wijgrid.prototype.parseFailed = /** @ignore */
            function (column, value, dataItem, cell) {
                return value;
            };
            wijgrid.prototype._funcOptions = function () {
                return [
                    "cellStyleFormatter", 
                    "rowStyleFormatter", 
                    "afterCellEdit", 
                    "afterCellUpdate", 
                    "beforeCellEdit", 
                    "beforeCellUpdate", 
                    "cellClicked", 
                    "columnDragging", 
                    "columnDragged", 
                    "columnDropping", 
                    "columnDropped", 
                    "columnResizing", 
                    "columnResized", 
                    "columnGrouping", 
                    "columnGrouped", 
                    "columnUngrouping", 
                    "columnUngrouped", 
                    "currentCellChanging", 
                    "currentCellChanged", 
                    "filtering", 
                    "filtered", 
                    "filterOperatorsListShowing", 
                    "groupAggregate", 
                    "groupText", 
                    "invalidCellValue", 
                    "pageIndexChanging", 
                    "pageIndexChanged", 
                    "selectionChanged", 
                    "sorting", 
                    "sorted", 
                    /*"ajaxError",*/ "dataLoading", 
                    "dataLoaded", 
                    "loading", 
                    "loaded", 
                    "rendering", 
                    "rendered"
                ];
            };
            wijgrid.prototype._canInteract = function () {
                return !this.options.disabled;/* && this._dataViewWrapper.isLoaded();*/
                
            };
            wijgrid.prototype._canMoveToAnotherCell = function (domElement, keyCode) {
                var tag = domElement.tagName.toLowerCase(), len, selectionRange, kc, res;
                switch(tag) {
                    case "input":
                        if($(domElement).hasClass(wijmo.grid.wijgrid.CSS.inputMarker)) {
                            var input = domElement;
                            if(input.type === "text") {
                                len = input.value.length;
                                selectionRange = new wijmo.grid.domSelection(input).getSelection();
                                kc = wijmo.getKeyCodeEnum();
                                res = ((keyCode === kc.TAB) || (keyCode === kc.UP || keyCode === kc.DOWN || keyCode === kc.PAGE_DOWN || keyCode === kc.PAGE_UP) || (selectionRange.length === 0 && ((selectionRange.start === 0 && (keyCode === kc.LEFT || keyCode === kc.HOME)) || (selectionRange.end >= len && (keyCode === kc.RIGHT || keyCode === kc.END)))));
                                return res;
                            }
                            return true;
                        }
                        return false;
                    case "textarea":
                    case "select":
                        return false;
                }
                return true;
            };
            wijgrid.prototype._editBySingleClick = function () {
                var value = (this.options.editingInitOption || "").toLowerCase();
                switch(value) {
                    case "click":
                    case "doubleclick":
                        break;
                    case "auto":
                    default:
                        value = this._isMobileEnv() ? "click" : "doubleclick";
                        break;
                }
                return value === "click";
            };
            wijgrid.prototype._getDataToAbsOffset = function () {
                var x = 0, y = 0, headerRows = this._headerRows();
                if(this._showRowHeader()) {
                    x++;
                }
                if(headerRows) {
                    y += headerRows.length();
                }
                if(this._filterRow()) {
                    y++;
                }
                return {
                    x: x,
                    y: y
                };
            };
            wijgrid.prototype._currentCellFromDataView = function (cellIndex) {
                var dataViewRowIndex = this._dataViewWrapper.currentPosition(), cellInfo = new wijmo.grid.cellInfo(cellIndex, this._dataViewDataRowIndexToGrid(dataViewRowIndex), null);
                // normalize
                if(cellInfo.rowIndex() < 0) {
                    cellInfo.cellIndex(-1);
                } else {
                    if(cellInfo.cellIndex() < 0) {
                        cellInfo.cellIndex(0);
                    }
                }
                return cellInfo;
            };
            wijgrid.prototype._dataViewDataRowIndexToGrid = function (rowIndex) {
                if(this.sketchTable) {
                    for(var i = 0; i < this.sketchTable.count(); i++) {
                        var sketchRow = this.sketchTable.row(i);
                        if(sketchRow.isDataRow() && sketchRow.dataItemIndex() === rowIndex) {
                            return i;
                        }
                    }
                }
                return -1;
            };
            wijgrid.prototype._getDataCellsRange = function (mode, lastRowEntirelyVisible) {
                if (typeof lastRowEntirelyVisible === "undefined") { lastRowEntirelyVisible = false; }
                var minCol = 0, minRow = 0, maxCol = this._field("visibleLeaves").length - 1, maxRow;
                switch(mode) {
                    case grid.dataRowsRangeMode.rendered:
                        if(this._rendered) {
                            maxRow = this._rows().length() - 1;
                            break;
                        }
                        // otherwise fallthrough to the .sketch
                                            case grid.dataRowsRangeMode.sketch:
                        maxRow = this._totalRowsCount() - 1;
                        break;
                    case grid.dataRowsRangeMode.renderable:
                        maxRow = this._renderableRowsCount() - 1;
                        break;
                }
                if(this._showRowHeader()) {
                    maxCol--;
                }
                if(lastRowEntirelyVisible && maxRow > 0) {
                    maxRow--;
                }
                if(maxCol < 0 || maxRow < 0) {
                    minCol = minRow = maxCol = maxRow = -1;
                }
                return new wijmo.grid.cellInfoRange(new wijmo.grid.cellInfo(minCol, minRow, null), new wijmo.grid.cellInfo(maxCol, maxRow, null));
            };
            wijgrid.prototype._getDataItem = function (dataItemIndex) {
                return this.dataView().item(dataItemIndex);
            };
            wijgrid.prototype._getFirstDataRowCell = function (absCellIndex) {
                var rowIndex, len, rowInfo, view = this._view(), rows = this._rows(), $rt = wijmo.grid.rowType;
                for(rowIndex = 0 , len = rows.length(); rowIndex < len; rowIndex++) {
                    rowInfo = view._getRowInfo(rows.item(rowIndex));
                    if(rowInfo.type & $rt.data) {
                        return new wijmo.grid.cellInfo(absCellIndex, rowIndex);
                    }
                }
                return wijmo.grid.cellInfo.outsideValue;
            };
            wijgrid.prototype._getNextCurrentCell = function (dataRange, cellInfo, keyCode, shiftKeyPressed) {
                var cellIndex = cellInfo.cellIndex(), rowIndex = cellInfo.rowIndex(), keyCodeEnum = wijmo.getKeyCodeEnum(), sketchTable = this.sketchTable, renderedRowIndex = this._renderableBoundsCollection().getRenderedIndex(rowIndex), rbc = this._renderableBoundsCollection(), tmp, dataRowsOnly = (keyCode === keyCodeEnum.TAB), self = this, sss = self._serverSideVirtualScrolling(), findNextVisibleRow = function (further, startFrom, maxRowsToTouch, dataRowsOnly) {
                    if (typeof dataRowsOnly === "undefined") { dataRowsOnly = false; }
                    var iterator = further ? rbc.forEachIndex : rbc.forEachIndexBackward, cnt = 0, result = null;
                    iterator.call(rbc, startFrom, -1, function (absIdx) {
                        var sketchIdx = absIdx - self._dataOffset;
                        if(sss && (sketchIdx < 0 || sketchIdx >= sketchTable.count())) {
                            // exceeded sketchTable bounds
                            result = absIdx;
                            return false;
                        }
                        var sketchRow = sketchTable.row(sketchIdx), isDataRow = // this row is rendered, but we doesn't know whether it visible or not.
                        sketchRow.isDataRow();
                        // test dataType and visibility
                        if((!dataRowsOnly || isDataRow) && (!(sketchRow.extInfo.state & wijmo.grid.renderStateEx.hidden))) {
                            result = absIdx;
                            if(++cnt >= maxRowsToTouch) {
                                return false;// stop iteration
                                
                            }
                        }
                    });
                    return result;
                };
                switch(keyCode) {
                    case keyCodeEnum.ENTER:
                    case keyCodeEnum.DOWN:
                        if((tmp = findNextVisibleRow(true, renderedRowIndex + 1, 1)) != null) {
                            rowIndex = tmp;
                        }
                        break;
                    case keyCodeEnum.PAGE_DOWN:
                        if((tmp = findNextVisibleRow(true, renderedRowIndex + 1, this._pageSizeKey)) != null) {
                            rowIndex = tmp;
                        }
                        break;
                    case keyCodeEnum.UP:
                        if((tmp = findNextVisibleRow(false, renderedRowIndex - 1, 1)) != null) {
                            rowIndex = tmp;
                        }
                        break;
                    case keyCodeEnum.PAGE_UP:
                        if((tmp = findNextVisibleRow(false, renderedRowIndex - 1, this._pageSizeKey)) != null) {
                            rowIndex = tmp;
                        }
                        break;
                    case keyCodeEnum.TAB:
                        // note: iterate through data rows only
                        if(shiftKeyPressed) {
                            cellIndex--;
                            if(cellIndex < dataRange.topLeft().cellIndex()) {
                                cellIndex = dataRange.bottomRight().cellIndex();
                                if((tmp = findNextVisibleRow(false, renderedRowIndex - 1, 1, true)) != null) {
                                    rowIndex = tmp;
                                } else {
                                    // reached the top?
                                    if((tmp = findNextVisibleRow(false, rbc.capacity() - 1, 1, true)) != null) {
                                        rowIndex = tmp;
                                    }
                                }
                            }
                        } else {
                            cellIndex++;
                            if(cellIndex > dataRange.bottomRight().cellIndex()) {
                                cellIndex = dataRange.topLeft().cellIndex();
                                if((tmp = findNextVisibleRow(true, renderedRowIndex + 1, 1, true)) != null) {
                                    rowIndex = tmp;
                                } else {
                                    // reached the bottom?
                                    if((tmp = findNextVisibleRow(true, 0, 1, true)) != null) {
                                        rowIndex = tmp;
                                    }
                                }
                            }
                        }
                        break;
                    case keyCodeEnum.END:
                        cellIndex = dataRange.bottomRight().cellIndex();
                        break;
                    case keyCodeEnum.HOME:
                        cellIndex = dataRange.topLeft().cellIndex();
                        break;
                    case keyCodeEnum.LEFT:
                        if(cellIndex > dataRange.topLeft().cellIndex()) {
                            cellIndex--;
                        }
                        break;
                    case keyCodeEnum.RIGHT:
                        if(cellIndex < dataRange.bottomRight().cellIndex()) {
                            cellIndex++;
                        }
                        break;
                }
                return new wijmo.grid.cellInfo(cellIndex, rowIndex, this);
            };
            wijgrid.prototype._findUntilOuterDiv = function (start, tagsToFind) {
                var current = start, outerDiv = this.outerDiv[0], stopper, nodeName, item = null;
                for(; current; current = current.parentNode) {
                    nodeName = current.nodeName && current.nodeName.toLowerCase();
                    if(nodeName) {
                        if(current === outerDiv) {
                            stopper = current;
                            break;
                        }
                        if(tagsToFind[nodeName]) {
                            item = current;
                        }
                    }
                }
                return stopper ? item : null;
            };
            wijgrid.prototype._getStaticIndex = function (bRow) {
                var result, dataRange = this._getDataCellsRange(grid.dataRowsRangeMode.rendered);
                if(this._hasSpannedCells()) {
                    return -1;// can't use static columns\ rows
                    
                }
                if(bRow) {
                    result = Math.min(this.options.staticRowIndex, dataRange.bottomRight().rowIndex());
                } else {
                    result = Math.min(this.options.staticColumnIndex, dataRange.bottomRight().cellIndex());
                }
                if(result < -1) {
                    result = -1;
                }
                return result;
            };
            wijgrid.prototype._getStaticOffsetIndex = function (isColumn) {
                var index = 0;
                if(isColumn) {
                    if(this._showRowHeader()) {
                        // row header is always fixed
                        index++;
                    }
                } else {
                    index = this._columnsHeadersTable().length//the whole header is fixed in case of staticRowIndex >= 0.
                    ;
                    if(this.options.showFilter) {
                        index++// filter row is placed inside the header, so it is fixed too.
                        ;
                    }
                }
                return index;
            };
            wijgrid.prototype._getRealStaticColumnIndex = // index of the fixed leaf inside the visibleLeaves collection.
            function () {
                var offsetStaticIndex = this._getStaticOffsetIndex(true), staticColumnIndex = this._getStaticIndex(false), realIndex = staticColumnIndex + offsetStaticIndex;
                if(staticColumnIndex >= 0) {
                    var leaves = this._field("visibleLeaves"), allColumns = wijmo.grid.flatten(this.options.columns), len = leaves.length;
                    if(realIndex < len - 1) {
                        var parent = wijmo.grid.getTompostParent(leaves[realIndex], allColumns);
                        // If child column of some band is fixed then the top and right-most column of the root band contained current column will be fixed.
                        if(parent) {
                            for(realIndex++; realIndex < len; realIndex++) {
                                var nextParent = wijmo.grid.getTompostParent(leaves[realIndex], allColumns);
                                if(nextParent !== parent) {
                                    realIndex--;
                                    break;
                                }
                            }
                        }
                    }
                    if(realIndex >= len) {
                        realIndex = len - 1;
                    }
                }
                return realIndex;
            };
            wijgrid.prototype._getRealStaticRowIndex = function () {
                var offsetStaticIndex = this._getStaticOffsetIndex(false);
                return this._getStaticIndex(true) + offsetStaticIndex;
            };
            wijgrid.prototype._hasMerging = function () {
                var leaves = this._field("leaves"), i, len, leaf, result = false;
                if(leaves) {
                    for(i = 0 , len = leaves.length; (i < len) && !result; i++) {
                        leaf = leaves[i];
                        result = result || (leaf.parentVis && (leaf.rowMerge && (leaf.rowMerge !== "none")))// merged visible column?
                        ;
                    }
                }
                return result;
            };
            wijgrid.prototype._hasGrouping = function () {
                var leaves = this._field("leaves"), i, len, leaf, result = false;
                for(i = 0 , len = leaves.length; (i < len) && !result; i++) {
                    leaf = leaves[i];
                    result = leaf.groupInfo && (leaf.groupInfo.position !== "none")// grouped column?
                    ;
                }
                return result;
            };
            wijgrid.prototype._hasSpannedCells = function () {
                return this._hasGrouping() || this._hasMerging();
            };
            wijgrid.prototype._columnsHeadersTable = function (value) {
                if(arguments.length) {
                    this._field("columnsHeadersTable", value);
                }
                return this._field("columnsHeadersTable");
            };
            wijgrid.prototype._view = function () {
                return this.mView;
            };
            wijgrid.prototype._originalFooterRowData = function () {
                var footer = this._field("tfoot");
                return (footer && footer.length) ? footer[0] : // first row only
                null;
            };
            wijgrid.prototype._originalHeaderRowData = function () {
                var header = this._field("thead");
                return (header && header.length) ? header[0] : // first row only
                null;
            };
            wijgrid.prototype._setAttr = // set one or more attribute and store original values in the this._originalAttr object if $element == this.element.
            // (key, value), (map)
            function ($element, key, value) {
                var self = this;
                if($element === this.element) {
                    // store original values
                    if(arguments.length === 2) {
                        // map
                        $.each(key, function (k, v) {
                            if(!(k in self._originalAttr)) {
                                self._originalAttr[k] = $element.attr(k);
                            }
                        });
                        return $element.attr(key);
                    } else {
                        // key, value
                        if(!(key in this._originalAttr)) {
                            this._originalAttr[key] = $element.attr(key);
                        }
                        return $element.attr(key, value);
                    }
                } else {
                    return (arguments.length === 3) ? $element.attr(key, value) : $element.attr(key);// .attr(map)
                    
                }
                return this;
            };
            wijgrid.prototype._totalRowsCount = // used by virtual scrolling
            function () {
                /*if (this._dataStore.isDynamic()) {
                return this._dataStore.totalCount();
                }*/
                return this.sketchTable.count();
            };
            wijgrid.prototype._renderableRowsCount = function () {
                return this._renderableBoundsCollection().capacity();
            };
            wijgrid.prototype._trackScrollingPosition = function (x, y) {
                this._scrollingState.x = x;
                this._scrollingState.y = y;
            };
            wijgrid.prototype._trackScrollingIndex = function (index) {
                this._scrollingState.index = index;
            };
            wijgrid.prototype._uid = function () {
                if(this.__uid === undefined) {
                    this.__uid = wijmo.grid.getUID();
                }
                return "wijgrid" + this.__uid;
            };
            wijgrid.prototype._viewPortBounds = function (value) {
                if(arguments.length) {
                    this.mViewPortBounds = value;
                }
                return this.mViewPortBounds;
            };
            wijgrid.prototype._viewPortBoundsOfEntirelyShownRows = function () {
                var bounds = this._viewPortBounds(), isLast = false, count = bounds.end - bounds.start + 1;
                if(this._allowVirtualScrolling()) {
                    var view = this._view();
                    if(count < view.getVirtualPageSize()) {
                        isLast = true;
                    }
                }
                if(!isLast) {
                    bounds = $.extend({
                    }, bounds);
                    bounds.end--;
                }
                return bounds;
            };
            return wijgrid;
        })(wijmo.wijmoWidget);
        grid.wijgrid = wijgrid;        
        wijgrid.prototype.widgetEventPrefix = "wijgrid";
        wijgrid.prototype._data$prefix = "wijgrid";
        wijgrid.prototype._customSortOrder = 1000;
        wijgrid.prototype._pageSizeKey = 10;
        wijgrid.prototype._mergeWidgetsWithOptions = true;
        var wijgrid_options = (function () {
            function wijgrid_options() {
                /** @ignore */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-b",
                    stateHover: "ui-btn-down-c",
                    stateActive: "ui-btn-down-c",
                    stateHighlight: "ui-btn-down-e"
                };
                this.wijCSS = {
                    wijgrid: "",
                    wijgridTable: "",
                    wijgridTH: "",
                    wijgridTD: "",
                    wijgridCellContainer: "",
                    wijgridRowHeader: "",
                    wijgridCurrentRowHeaderCell: "",
                    wijgridCurrentHeaderCell: "",
                    wijgridCurrentCell: "",
                    wijgridCellAlignLeft: "",
                    wijgridCellAlignRight: "",
                    wijgridCellAlignCenter: "",
                    wijgridFilterList: "",
                    wijgridFilter: "",
                    wijgridFilterInput: "",
                    wijgridFilterTrigger: "",
                    wijgridFilterNativeHtmlEditorWrapper: "",
                    wijgridHeaderArea: "",
                    wijgridFooterArea: "",
                    wijgridHeaderRow: "",
                    wijgridRow: "",
                    wijgridDataRow: "",
                    wijgridAltRow: "",
                    wijgridEmptyDataRow: "",
                    wijgridFilterRow: "",
                    wijgridGroupHeaderRow: "",
                    wijgridGroupFooterRow: "",
                    wijgridGroupHeaderRowCollapsed: "",
                    wijgridGroupHeaderRowExpanded: "",
                    wijgridFooterRow: "",
                    wijgridLoadingOverlay: "",
                    wijgridLoadingText: "",
                    wijgridGroupArea: "",
                    wijgridGroupAreaButton: "",
                    wijgridGroupAreaButtonSort: "",
                    wijgridGroupAreaButtonClose: "",
                    wijgridGroupToggleVisibilityButton: "",
                    wijgridFixedView: "",
                    wijgridScroller: "",
                    wijgridDndHelper: "",
                    wijgridDndArrowTopContainer: "",
                    wijgridDndArrowBottomContainer: "",
                    wijgridFreezingHandleV: "",
                    wijgridFreezingHandleH: "",
                    wijgridResizingHandle: "",
                    wijgridHeaderCellSortIcon: "",
                    wijgridHeaderCellText: ""
                };
                /** A value indicating whether columns can be moved.
                * @example
                * // Columns cannot be dragged and moved if this option is set to false
                * $("#element").wijgrid({ allowColMoving: false });
                * @remarks
                * This option must be set to true in order to drag column headers to the group area.
                */
                this.allowColMoving = false;
                /** Determines whether the column width can be increased and decreased by dragging the sizing handle, or the edge of the column header, with the mouse.
                * @example
                * // The sizing handle cannot be dragged and column width cannot be changed if this option is set to false
                * $("#element").wijgrid({ allowColSizing: false });
                */
                this.allowColSizing = false;
                /** Determines whether the user can make changes to cell contents in the grid.
                * This option is obsolete. Use the editingMode option instead.
                * @example
                * // Users cannot change cell contents in the grid if this option is set to false
                * $("#element").wijgrid({ allowEditing: false });
                */
                this.allowEditing = false;
                /** Determines whether the user can move the current cell using the arrow keys.
                * @example
                * // Users cannot move the selection using arrow keys if this option is set to false
                * $("#element").wijgrid({ allowKeyboardNavigation: false });
                */
                this.allowKeyboardNavigation = true;
                /** Determines whether the grid should display paging buttons. The number of rows on a page is determined by the pageSize option.
                * @example
                * // Grid displays paging buttons when allowPaging is true. The pageSize here sets 5 rows to a page.
                * $("#element").wijgrid({ allowPaging: false, pageSize: 5 });
                */
                this.allowPaging = false;
                /** Determines whether the widget can be sorted by clicking the column header.
                * @example
                * // Sort a column by clicking its header when allowSorting is set to true
                * $("#element").wijgrid({ allowSorting: false });
                */
                this.allowSorting = false;
                /** A value that indicates whether virtual scrolling is allowed. Set allowVirtualScrolling to true when using large amounts of data to improve efficiency.
                * @example
                * $("#element").wijgrid({ allowVirtualScrolling: false });
                * @remarks
                * This option is ignored if the grid uses paging, columns merging or fixed rows. This option cannot be enabled when using dynamic wijdatasource.
                */
                this.allowVirtualScrolling = false;
                /** This function is called each time wijgrid needs to change cell appearence, for example, when the current cell position is changed or cell is selected.
                * Can be used for customization of cell style depending on its state.
                * @example
                * // Make the text of the current cell italic.
                * $("#element").wijgrid({
                *		highlightCurrentCell: true,
                *		cellStyleFormatter: function(args) {
                *			if ((args.row.type & wijmo.grid.rowType.data)) {
                *				if (args.state & wijmo.grid.renderState.current) {
                *					args.$cell.css("font-style", "italic");
                *				} else {
                *					args.$cell.css("font-style", "normal");
                *				}
                *			}
                *		}
                * });
                * @param {wijmo.grid.ICellStyleFormaterArgs} args The data with this function.
                * @remarks
                * The args.state parameters equal to wijmo.grid.renderState.rendering means that the cell is being created,
                * at this moment you can apply general formatting to it indepentant of any particular state, like "current" or "selected".
                */
                this.cellStyleFormatter = undefined;
                /** An array of column options.
                * @example
                * $("#element").wijgrid({ columns: [ { headerText: "column0", allowSort: false }, { headerText: "column1", dataType: "number" } ] });
                */
                this.columns = [];
                /** Determines behavior for column autogeneration. Possible values are: "none", "append", "merge".
                * @example
                * $("#element").wijgrid({ columnsAutogenerationMode: "merge" });
                * @remarks
                * Possible values are:
                * "none": Column auto-generation is turned off.
                * "append": A column will be generated for each data field and added to the end of the columns collection.
                * "merge": Each column having dataKey option not specified will be automatically bound to the first unreserved data field.For each data field not bound to any column a new column will be generated and added to the end of the columns collection.
                *
                * To prevent automatic binding of a column to a data field set its dataKey option to null.
                *
                * Note: columns autogeneration process affects the options of columns and the columns option itself.
                */
                this.columnsAutogenerationMode = "merge";
                /** Determines the culture ID.
                * @example
                * // This code sets the culture to English.
                * $("#element").wijgrid({ culture: "en" });
                * @remarks
                * Please see the https://github.com/jquery/globalize for more information.
                */
                this.culture = "";
                /** An array of custom user filters. Use this option if you want to extend the default set of filter operators with your own. Custom filters will be shown in the filter dropdown.
                * @example
                * var oddFilterOp = {
                *	name: "customOperator-Odd",
                *	arity: 1,
                *	applicableTo: ["number"],
                *	operator: function(dataVal) { return (dataVal % 2 !== 0); }
                * }
                *
                * $("#element").wijgrid({ customFilterOperators: [oddFilterOp] });
                */
                this.customFilterOperators = [];
                /** Determines the datasource.
                * Possible datasources include:
                *		1. A DOM table. This is the default datasource, used if the data option is null. Table must have no cells with rowSpan and colSpan attributes.
                *		2. A two-dimensional array, such as [[0, "a"], [1, "b"]].
                *		3. An array of objects, such as [{field0: 0, field1: "a"}, {field0: 1, field1: "b'}].
                *		4. A wijdatasource.
                *		5. A wijdataview.
                * @example
                * // DOM table
                * $("#element").wijgrid();
                * // two-dimensional array
                * $("#element").wijgrid({ data: [[0, "a"], [1, "b"]] });
                */
                this.data = null;
                /** Determines an action to bring a cell in the editing mode when the editingMode option is set to "cell". Possible values are: "click", "doubleClick", "auto".
                * @example
                * $("#element").wijgrid({ editingInitOption: "auto" });
                * @remarks
                * Possible values are:
                *	"click": cell is edited via a single click.
                *	"doubleClick": cell is edited via a double click.
                *	"auto": action is determined automatically depending upon user environment. If user has a mobile platform then "click" is used, "doubleClick" otherwise.
                */
                this.editingInitOption = "auto";
                /** Determines the editing mode. Possible values are: "none", "row", "cell",
                * @example
                * $("#element").wijgrid({
                *    editingMode: "row",
                *    columns: [{
                *       showEditButton: true
                *    }]
                * });
                * @remarks
                * Possible values are:
                * "none": the editing ability is disabled.
                *	"cell": a single cell can be edited via a double click.
                *	"row": a whole row can be edited via a command column.
                */
                this.editingMode = "none";
                /** Determines if the exact column width, in pixels, is used.
                * @example
                * $("#element").wijgrid({ ensureColumnsPxWidth: true });
                * @remarks
                * By default, wijgrid emulates the table element behavior when using a number as the width. This means wijgrid may not have the exact width specified. If exact width is needed, please set the ensureColumnsPxWidth option of wijgrid to true. If this option is set to true, wijgrid will not expand itself to fit the available space.Instead, it will use the width option of each column widget.
                */
                this.ensureColumnsPxWidth = false;
                /** Determines the order of items in the filter drop-down list.
                * Possible values are: "none", "alphabetical", "alphabeticalCustomFirst" and "alphabeticalEmbeddedFirst"
                * @example
                * $("#element").wijgrid({ filterOperatorsSortMode: "alphabeticalCustomFirst" });
                * @remarks
                * Possible values are:
                *	"none": Operators follow the order of addition; built-in operators appear before custom ones.
                *	"alphabetical": Operators are sorted alphabetically.
                *	"alphabeticalCustomFirst": Operators are sorted alphabetically with custom operators appearing before built-in ones.
                *	"alphabeticalEmbeddedFirst": Operators are sorted alphabetically with built-in operators appearing before custom operators.
                *
                * "NoFilter" operator is always first.
                */
                this.filterOperatorsSortMode = "alphabeticalCustomFirst";
                /** Determines whether the user can change position of the static column or row by dragging the vertical or horizontal freezing handle with the mouse. Possible values are: "none", "columns", "rows", "both".
                * @example
                * $("#element").wijgrid({ freezingMode: "both" });
                * @remarks
                * Possible values are:
                * "none": The freezing handle cannot be dragged.
                * "columns": The user can drag the vertical freezing handle to change position of the static column.
                * "rows": The user can drag the horizontal freezing handle to change position of the static row.
                * "both": The user can drag both horizontal and vertical freezing handles.
                */
                this.freezingMode = "none";
                /** Determines the caption of the group area.
                * @example
                * // Set the groupAreaCaption to a string and the text appears above the grid
                * $("#element").wijgrid({ groupAreaCaption: "Drag a column here to group by that column." });
                */
                this.groupAreaCaption = "Drag a column here to group by that column.";
                /** Determines the indentation of the groups, in pixels.
                * @example
                * // Set the groupIndent option to the number of pixels to indent data when grouping.
                * $("#element").wijgrid({ groupIndent: 15 });
                */
                this.groupIndent = 10;
                /** Determines whether the position of the current cell is highlighted or not.
                * @example
                * $("#element").wijgrid({ highlightCurrentCell: false });
                */
                this.highlightCurrentCell = false;
                /** Determines whether hovered row is highlighted or not.
                * @example
                * $("#element").wijgrid({ highlightCurrentCell: true });
                */
                this.highlightOnHover = true;
                /** Determines the text to be displayed when the grid is loading.
                * @example
                * $("#element").wijgrid({ loadingText: "Loading..."});
                */
                this.loadingText = "Loading...";
                /** Cell values equal to this property value are considered null values. Use this option if you want to change default representation of null values (empty strings) with something else.
                * @example
                * $("#element").wijgrid({ nullString: "" });
                * @remarks
                * Case-sensitive for built-in parsers.
                */
                this.nullString = "";
                /** Determines the zero-based index of the current page. You can use this to access a specific page, for example, when using the paging feature.
                * @example
                * $("#element").wijgrid({ pageIndex: 0 });
                */
                this.pageIndex = 0;
                /** Number of rows to place on a single page.
                * The default value is 10.
                * @example
                * // The pageSize here sets 10 rows to a page. The allowPaging option is set to true so paging buttons appear.
                * $("#element").wijgrid({ pageSize: 10 });
                */
                this.pageSize = 10;
                /** Determines the pager settings for the grid including the mode (page buttons or next/previous buttons), number of page buttons, and position where the buttons appear.
                * @example
                * // Display the pager at the top of the wijgrid.
                * $("#element").wijgrid({ pagerSettings: { position: "top" } });
                * @remarks
                * See the wijpager documentation for more information on pager settings.
                */
                this.pagerSettings = {
                    mode: "numeric",
                    pageButtonCount: 10,
                    position: "bottom"
                };
                /** A value indicating whether DOM cell attributes can be passed within a data value.
                * @example
                * // Render the style attribute passed within the data.
                * $("#element").wijgrid({
                *		readAttributesFromData: false });
                *		data: [
                *			[ [1, { "style": "color: red" } ], a ]
                *		]
                * });
                * @remarks
                * This option allows binding collection of values to data and automatically converting them as attributes of corresponded DOM table cells during rendering.
                * Values should be passed as an array of two items, where first item is a value of the data field, the second item is a list of values:
                * $("#element").wijgrid({
                *		data: [
                *			[ [1, { "style": "color: red", "class": "myclass" } ], a ]
                *		]
                * });
                *
                * or
                *
                * $("#element").wijgrid({
                *		data: [
                *			{ col0: [1, { "style": "color: red", "class": "myclass" }], col1: "a" }
                *		]
                * });
                *
                * Note: during conversion wijgrid extracts the first item value and makes it data field value, the second item (list of values) is removed:
                * [ { col0: 1, col1: "a" } ]
                *
                * If DOM table is used as a datasource then attributes belonging to the cells in tBody section of the original table will be read and applied to the new cells.
                *
                * rowSpan and colSpan attributes are not allowed.
                */
                this.readAttributesFromData = false;
                /** Determines the height of a rows when virtual scrolling is used.
                * @example
                * $("#element").wijgrid({ rowHeight: 20 });
                * @remarks
                * Can be set only during creation
                */
                this.rowHeight = -1;
                /** Function used for styling rows in wijgrid.
                * @example
                * // Make text of the alternating rows italic.
                * $("#demo").wijgrid({
                *		data: [
                *			[0, "Nancy"], [1, "Susan"], [2, "Alice"], [3, "Kate"]
                *		],
                *		rowStyleFormatter (args) {
                *			if ((args.state & wijmo.grid.renderState.rendering) && (args.type & wijmo.grid.rowType.dataAlt)) {
                *				args.$rows.find("td").css("font-style", "italic");
                *			}
                *		}
                * });
                * @param {wijmo.grid.IRowInfo} args The data with this function.
                */
                this.rowStyleFormatter = undefined;
                /** Determines which scrollbars are active and if they appear automatically based on content size.
                * Possbile values are: "none", "auto", "horizontal", "vertical", "both".
                * @example
                * // The horizontal and vertical scrollbars are active when the scrollMode is set to both.
                * $("#element").wijgrid({ scrollMode: "both" });
                * @remarks
                * Possible values are:
                *	"none": Scrolling is not used; the staticRowIndex and staticColumnIndex values are ignored.
                *	"auto": Scrollbars appear automatically depending upon content size.
                *	"horizontal": The horizontal scrollbar is active.
                *	"vertical": The vertical scrollbar is active.
                *	"both": Both horizontal and vertical scrollbars are active.
                */
                this.scrollMode = "none";
                /** Determines which cells, range of cells, columns, or rows can be selected at one time.
                * Possible values are: "none", "singleCell", "singleColumn", "singleRow", "singleRange", "multiColumn", "multiRow" and "multiRange".
                * @example
                * // Set selectionMode to muliColumn and users can select more than one column using the CTRL or SHIFT keys.
                * $("#element").wijgrid({ selectionMode: "multiColumn" });
                * @remarks
                * Possible values are:
                * "none": Selection is turned off.
                * "singleCell": Only a single cell can be selected at a time.
                * "singleColumn": Only a single column can be selected at a time.
                * "singleRow": Only a single row can be selected at a time.
                * "singleRange": Only a single range of cells can be selected at a time.
                * "multiColumn": It is possible to select more than one row at the same time using the mouse and the CTRL or SHIFT keys.
                * "multiRow": It is possible to select more than one row at the same time using the mouse and the CTRL or SHIFT keys.
                * "multiRange": It is possible to select more than one cells range at the same time using the mouse and the CTRL or SHIFT keys.
                */
                this.selectionMode = "singleRow";
                /** A value indicating whether the filter row is visible.
                * Filter row is used to display column filtering interface.
                * @example
                * // Set showFilter to true to view the filter row.
                * $("#element").wijgrid({ showFilter: true });
                */
                this.showFilter = false;
                /** A value indicating whether the footer row is visible.
                * Footer row is used for displaying of tfoot section of original table, and to show totals.
                * @example
                * // Set showFooter to true to view the footer row.
                * $("#element").wijgrid({ showFooter: true });
                */
                this.showFooter = false;
                /** A value indicating whether group area is visible.
                * Group area is used to display headers of groupped columns. User can drag columns from/to group area by dragging column headers with mouse, if allowColumnMoving option is on.
                * @example
                * // Set showGroupArea to true to display the group area.
                * $("#element").wijgrid({ showGroupArea: true });
                */
                this.showGroupArea = false;
                /** A value indicating whether a selection will be automatically displayed at the current cell position when the wijgrid is rendered.
                * Set this option to false if you want to prevent wijgrid from selecting the currentCell automatically.
                * @example
                * $("#element").wijgrid({ showSelectionOnRender: true });
                */
                this.showSelectionOnRender = true;
                /** A value indicating whether the row header is visible.
                * @example
                * $("#element").wijgrid({ showRowHeader: true });
                */
                this.showRowHeader = false;
                /** Indicates the index of columns that will always be shown on the left when the grid view is scrolled horizontally.
                * Note that all columns before the static column will be automatically marked as static, too.
                * This can only take effect when the scrollMode option is not set to "none".
                * It will be considered "-1" when grouping or row merging is enabled. A "-1" means there is no data column but the row header is static. A zero (0) means one data column and row header are static.
                * @example
                * $("#element").wijgrid({ staticColumnIndex: -1 });
                */
                this.staticColumnIndex = -1;
                /** Gets or sets the alignment of the static columns area. Possible values are "left", "right".
                * @example
                * $("#element").wijgrid({ staticColumnsAlignment: "left" });
                * @remarks
                * The "right" mode has limited functionality:
                *  - The showRowHeader value is ignored.
                *  - Changing staticColumnIndex at run-time by dragging the vertical bar is disabled.
                */
                this.staticColumnsAlignment = "left";
                /** Indicates the index of data rows that will always be shown on the top when the wijgrid is scrolled vertically.
                * Note, that all rows before the static row will be automatically marked as static, too.
                * This can only take effect when the scrollMode option is not set to "none". This will be considered "-1" when grouping or row merging is enabled.
                * A "-1" means there is no data row but the header row is static.A zero (0) means one data row and the row header are static.
                * @example
                * $("#element").wijgrid({ staticRowIndex: -1 });
                */
                this.staticRowIndex = -1;
                /** Gets or sets the virtual number of items in the wijgrid and enables custom paging.
                * Setting option to a positive value activates custom paging, the number of displayed rows and the total number of pages will be determined by the totalRows and pageSize values.
                * @example
                * $("#element").wijgrid({ totalRows: -1 });
                * @remarks
                * In custom paging mode sorting, paging and filtering are not performed automatically.
                * This must be handled manually using the sorted, pageIndexChanged, and filtered events. Load the new portion of data there followed by the ensureControl(true) method call.
                */
                this.totalRows = -1;
                /* --- events */
                /** The afterCellEdit event handler is a function called after cell editing is completed.
                * This function can assist you in completing many tasks, such as in making changes once editing is completed; in tracking changes in cells, columns, or rows; or in integrating custom editing functions on the front end.
                * @event
                * @example
                * // Once cell editing is complete, the function calls the destroy method to destroy the wijcombobox widget and the wijinputnumber widget which are used as the custom editors.
                * $("#element").wijgrid({
                *		afterCellEdit: function(e, args) {
                *			switch (args.cell.column().dataKey) {
                *				case "Position":
                *					args.cell.container().find("input").wijcombobox("destroy");
                *					break;
                *				case "Acquired":
                *					args.cell.container().find("input").wijinputnumber("destroy");
                *					break;
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ afterCellEdit: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridaftercelledit", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IAfterCellEditEventArgs} args The data with this event.
                */
                this.afterCellEdit = null;
                /** The afterCellUpdate event handler is a function that is called after a cell has been updated. Among other functions, this event allows you to track and store the indices of changed rows or columns.
                * @event
                * @example
                * // Once the cell has been updated, the information from the underlying data is dumped into the "#log" element.
                * $("#element").wijgrid({
                *		afterCellUpdate: function(e, args) {
                *			$("#log").html(dump($("#demo").wijgrid("data")));
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ afterCellUpdate: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridaftercellupdate", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IAfterCellUpdateEventArgs} args The data with this event.
                */
                this.afterCellUpdate = null;
                /** The beforeCellEdit event handler is a function that is called before a cell enters edit mode.
                * The beforeCellEdit event handler assists you in appending a widget, data, or other item to a wijgrid's cells before the cells enter edit mode. This event is cancellable if the editigMode options is set to "cell".
                * @event
                * @example
                * // Allow the user to change the price only if the product hasn't been discontinued:
                * $("#element").wijgrid({
                *		beforeCellEdit: function(e, args) {
                *			return !((args.cell.column().dataKey === "Price") && args.cell.row().data.Discontinued);
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ beforeCellEdit: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridbeforecelledit", function (e, args) {
                *		// some code here
                * });
                *
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IBeforeCellEditEventArgs} args The data with this event.
                */
                this.beforeCellEdit = null;
                /** The beforeCellUpdate event handler is a function that is called before the cell is updated with new or user-entered data. This event is cancellable if the editingMode options is set to "cell".
                * There are many instances where this event is helpful, such as when you need to check a cell's value before the update occurs or when you need to apply an alert message based on the cell's value.
                * @event
                * @example
                * // In this sample, you use args.value to check the year that the user enters in the "Acquired" column.
                * // If it's less than 1990 or greater than the current year, then the event handler will return false to cancel updating and show the user an alert message.
                * $("#element").wijgrid({
                *		beforeCellUpdate: function(e, args) {
                *			switch (args.cell.column().dataKey) {
                *				case "Acquired":
                *					var $editor = args.cell.container().find("input"),
                *						value = $editor.wijinputnumber("getValue"),
                *						curYear = new Date().getFullYear();
                *
                *					if (value < 1990 || value > curYear) {
                *						$editor.addClass("ui-state-error");
                *						alert("value must be between 1990 and " + curYear);
                *						$editor.focus();
                *						return false;
                *					}
                *
                *					args.value = value;
                *					break;
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ beforeCellUpdate: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridbeforecellupdate", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IBeforeCellUpdateEventArgs} args The data with this event.
                */
                this.beforeCellUpdate = null;
                /** The cellClicked event handler is a function that is called when a cell is clicked. You can use this event to get the information of a clicked cell using the args parameter.
                * @event
                * @example
                * // The sample uses the cellClicked event to trigger an alert when the cell is clicked.
                * $("#element").wijgrid({
                *		cellClicked: function (e, args) {
                *			alert(args.cell.value());
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ cellClicked: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcellclicked", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.ICellClickedEventArgs} args The data with this event.
                */
                this.cellClicked = null;
                /** The columnDragging event handler is a function that is called when column dragging has been started, but before the wijgrid handles the operation. This event is cancellable.
                * @event
                * @example
                * // Preventing a user from dragging a specific column
                * $("#element").wijgrid({
                *		columnDragging: function (e, args) {
                *			return !(args.drag.dataKey == "ID");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnDragging: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumndragging", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnDraggingEventArgs} args The data with this event.
                */
                this.columnDragging = null;
                /** The columnDragged event handler is a function that is called when column dragging has been started. You can use this event to find the column being dragged or the dragged column's location.
                * @event
                * @example
                * // Supply a callback function to handle the columnDragged event:
                * $("#element").wijgrid({
                *		columnDragged: function (e, args) {
                *			alert("The '" + args.drag.headerText + "' column is being dragged from the '" + args.dragSource + "' location");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnDragged: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumndragged", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnDraggedEventArgs} args The data with this event.
                */
                this.columnDragged = null;
                /** The columnDropping event handler is a function that is called when a column is dropped into the columns area, but before wijgrid handles the operation. This event is cancellable.
                * @event
                * @example
                * // Preventing user from dropping any column before the "ID" column.
                * $("#element").wijgrid({
                *		columnDropping: function (e, args) {
                *			return !(args.drop.dataKey == "ID" && args.at == "left");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnDropping: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumndropping", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnDroppingEventArgs} args The data with this event.
                */
                this.columnDropping = null;
                /** The columnDropped event handler is a function that is called when a column has been dropped into the columns area.
                * @event
                * @example
                * // Supply a callback function to handle the columnDropped event:
                * $("#element").wijgrid({
                *		columnDropped: function (e, args) {
                *			"The '" + args.drag.headerText + "' column has been dropped onto the '" + args.drop.headerText + "' column at the '" + args.at + "' position"
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnDropped: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumndropped", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnDroppedEventArgs} args The data with this event.
                */
                this.columnDropped = null;
                /** The columnGrouping event handler is a function that is called when a column is dropped into the group area, but before the wijgrid handles the operation. This event is cancellable.
                * @event
                * @example
                * // Preventing user from grouping the "UnitPrice" column.
                * $("#element").wijgrid({
                *		columnGrouping: function (e, args) {
                *			return !(args.drag.headerText == "UnitPrice");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnGrouping: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumngrouping", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnGroupingEventArgs} args The data with this event.
                */
                this.columnGrouping = null;
                /** The columnGrouped event handler is a function that is called when a column has been dropped into the group area.
                * @event
                * @example
                * // Supply a callback function to handle the columnGrouped event:
                * $("#element").wijgrid({
                *		columnGrouped: function (e, args) {
                *			alert("The '" + args.drag.headerText "' column has been grouped");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnGrouped: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumngrouped", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnGroupedEventArgs} args The data with this event.
                */
                this.columnGrouped = null;
                /** The columnResizing event handler is called when a user resizes the column but before the wijgrid handles the operation. This event is cancellable.
                * @event
                * @example
                * // Prevent setting the width of "ID" column less than 100 pixels
                * $("#element").wijgrid({
                *		columnResizing: function (e, args) {
                *			if (args.column.dataKey == "ID" && args.newWidth < 100) {
                *				args.newWidth = 100;
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnResizing: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumnresizing", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnResizingEventArgs} args The data with this event.
                */
                this.columnResizing = null;
                /** The columnResized event handler is called when a user has changed a column's size.
                * @event
                * @example
                * // Supply a callback function to handle the columnGrouped event:
                * $("#element").wijgrid({
                *		columnResized: function (e, args) {
                *			alert("The '" + args.column.headerText + "' has been resized");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnResized: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumnresized", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnResizedEventArgs} args The data with this event.
                */
                this.columnResized = null;
                /** The columnUngrouping event handler is called when a column has been removed from the group area but before the wjgrid handles the operation. This event is cancellable.
                * @event
                * @example
                * // Preventing user from ungrouping the "UnitPrice" column.
                * $("#element").wijgrid({
                *		columnUngrouping: function (e, args) {
                *			return !(args.column.headerText == "UnitPrice");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnUngrouping: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumnungrouping", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnUngroupingEventArgs} args The data with this event.
                */
                this.columnUngrouping = null;
                /** The columnUngrouped event handler is called when a column has been removed from the group area.
                * @event
                * @example
                * // Supply a callback function to handle the columnGrouped event:
                * $("#element").wijgrid({
                *		columnUngrouped: function (e, args) {
                *			alert("The '" + args.column.headerText + "' has been ungrouped");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ columnUngrouped: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcolumnungrouped", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IColumnUngroupedEventArgs} args The data with this event.
                */
                this.columnUngrouped = null;
                /** The currentCellChanging event handler is called before the cell is changed. You can use this event to get a selected row or column or to get a data row bound to the current cell. This event is cancellable.
                * @event
                * @example
                * // Gets the data row bound to the current cell.
                * $("#element").wijgrid({
                *		currentCellChanging: function (e, args) {
                *			var rowObj = $(e.target).wijgrid("currentCell").row();
                *			if (rowObj) {
                *				var dataItem = rowObj.data; // current data item (before the cell is changed).
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ currentCellChanging: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcurrentcellchanging", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.ICurrentCellChangingEventArgs} args The data with this event.
                */
                this.currentCellChanging = null;
                /** The currentCellChanged event handler is called after the current cell is changed.
                * @event
                * @example
                * // Gets the data row bound to the current cell.
                * $("#element").wijgrid({
                *		currentCellChanged: function (e, args) {
                *			var rowObj = $(e.target).wijgrid("currentCell").row();
                *			if (rowObj) {
                *				var dataItem = rowObj.data; // current data item (after the cell is changed).
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ currentCellChanged: function (e) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridcurrentcellchanged", function (e) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                */
                this.currentCellChanged = null;
                /** The filterOperatorsListShowing event handler is a function that is called before the filter drop-down list is shown. You can use this event to customize the list of filter operators for your users.
                * @event
                * @example
                * // Limit the filters that will be shown to the "Equals" filter operator
                * $("#element").wijgrid({
                *		filterOperatorsListShowing: function (e, args) {
                *			args.operators = $.grep(args.operators, function(op) {
                *				return op.name === "Equals" || op.name === "NoFilter";
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ filterOperatorsListShowing: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridfilteroperatorslistshowing", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IFilterOperatorsListShowingEventArgs} args The data with this event.
                */
                this.filterOperatorsListShowing = null;
                /** The filtering event handler is a function that is called before the filtering operation is started. For example, you can use this event to change a filtering condition before a filter will be applied to the data. This event is cancellable.
                * @event
                * @example
                * // Prevents filtering by negative values
                * $("#element").wijgrid({
                *		filtering: function (e, args) {
                *			if (args.column.dataKey == "Price" && args.value < 0) {
                *				args.value = 0;
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ filtering: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridfiltering", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IFilteringEventArgs} args The data with this event.
                */
                this.filtering = null;
                /** The filtered event handler is a function that is called after the wijgrid is filtered.
                * @event
                * @example
                * //
                * $("#element").wijgrid({
                *		filtered: function (e, args) {
                *			alert("The filtered data contains: " + $(this).wijgrid("dataView").count() + " rows");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ filtered: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridfiltered", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IFilteredEventArgs} args The data with this event.
                */
                this.filtered = null;
                /** The groupAggregate event handler is a function that is called when groups are being created and the column object's aggregate option has been set to "custom". This event is useful when you want to calculate custom aggregate values.
                * @event
                * @example
                * // This sample demonstrates using the groupAggregate event handler to calculate an average in a custom aggregate:
                * $("#element").wijgrid({
                *		groupAggregate: function (e, args) {
                *			if (args.column.dataKey == "Price") {
                *				var aggregate = 0;
                *
                *				for (var i = args.groupingStart; i <= args.groupingEnd; i++) {
                *					aggregate += args.data[i].valueCell(args.column.dataIndex).value;
                *				}
                *
                *				aggregate = aggregate/ (args.groupingEnd - args.groupingStart + 1);
                *				args.text = aggregate;
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ groupAggregate: function (e, args) {
                *		// some code here
                * }});
                * Bind to the event by type:
                *
                * $("#element").bind("wijgridgroupaggregate", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IGroupAggregateEventArgs} args The data with this event.
                */
                this.groupAggregate = null;
                /** The groupText event handler is a function that is called when groups are being created and the groupInfo option has the groupInfo.headerText or the groupInfo.footerText options set to "custom". This event can be used to customize group headers and group footers.
                * @event
                * @example
                * // The following sample sets the groupText event handler to avoid empty cells. The custom formatting applied to group headers left certain cells appearing as if they were empty. This code avoids that:
                * $("#element").wijgrid({
                *		groupText: function (e, args) {
                *			if (!args.groupText) {
                *				args.text = "null";
                *			}
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ groupText: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridgrouptext", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IGroupTextEventArgs} args The data with this event.
                */
                this.groupText = null;
                /** The invalidCellValue event handler is a function called when a cell needs to start updating but the cell value is invalid. So if the value in a wijgrid cell can't be converted to the column target type, the invalidCellValue event will fire.
                * @event
                * @example
                * // Adds a style to the cell if the value entered is invalid
                * $("#element").wijgrid({
                *		invalidCellValue: function (e, args) {
                *			$(args.cell.container()).addClass("ui-state-error");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ invalidCellValue: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridinvalidcellvalue", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IInvalidCellValueEventArgs} args The data with this event.
                */
                this.invalidCellValue = null;
                /** The pageIndexChanging event handler is a function that is called before the page index is changed. This event is cancellable.
                * @event
                * @example
                * // Cancel the event by returning false
                * $("#element").wijgrid({
                *		pageIndexChanging: function (e, args) {
                *			return false;
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ pageIndexChanging: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridpageindexchanging", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IPageIndexChangingEventArgs} args The data with this event.
                */
                this.pageIndexChanging = null;
                /** The pageIndexChanged event handler is a function that is called after the page index is changed, such as when you use the numeric buttons to swtich between pages or assign a new value to the pageIndex option.
                * @event
                * @example
                * // Supply a callback function to handle the pageIndexChanged event:
                * $("#element").wijgrid({
                *		pageIndexChanged: function (e, args) {
                *			alert("The new pageIndex is: " + args.newPageIndex);
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ pageIndexChanged: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridpageindexchanged", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.IPageIndexChangedEventArgs} args The data with this event.
                */
                this.pageIndexChanged = null;
                /** The selectionChanged event handler is a function that is called after the selection is changed.
                * @event
                * @example
                * // Get the value of the first cell of the selected row.
                * $("#element").wijgrid({
                *		selectionMode: "singleRow",
                *		selectionChanged: function (e, args) {
                *			alert(args.addedCells.item(0).value());
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ selectionChanged: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridselectionchanged", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.ISelectionChangedEventArgs} args The data with this event.
                */
                this.selectionChanged = null;
                /** The sorting event handler is a function that is called before the sorting operation is started. This event is cancellable.
                * The allowSorting option must be set to "true" for this event to fire.
                * @event
                * @example
                * // Preventing user from sorting the "ID" column.
                * $("#element").wijgrid({
                *		sorting: function (e, args) {
                *			return !(args.column.headerText === "ID");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ sorting: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridsorting", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.ISortingEventArgs} args The data with this event.
                */
                this.sorting = null;
                /** The sorted event handler is a function that is called after the widget is sorted. The allowSorting option must be set to "true" to allow this event to fire.
                * @event
                * @example
                * // The following code handles the sorted event and will give you access to the column and the sort direction
                * $("#element").wijgrid({
                *		sorted: function (e, args) {
                *			alert("Column " + args.column.headerText + " sorted in " + args.sortDirection + " order");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ sorted: function (e, args) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridsorted", function (e, args) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                * @param {wijmo.grid.ISortedEventArgs} args The data with this event.
                */
                this.sorted = null;
                /* events --- */
                /* --- life-cycle events */
                //			/// <summary>
                //			/// The ajaxError event handler. A function called when wijgrid is bound to remote data and
                //			/// the ajax request fails.
                //			/// Default: null.
                //			/// Type: Function.
                //			/// Code example:
                //			/// Supply a callback function to handle the ajaxError event:
                //			/// $("#element").wijgrid({ ajaxError: function (e, args) { } });
                //			/// Bind to the event by type:
                //			/// $("#element").bind("wijgridajaxerror", function (e, args) { });
                //			/// </summary>
                //			/// <param name="e" type="Object">The jQuery.Event object.</param>
                //			/// <param name="args" type="Object">
                //			/// The data corresponded with this event.
                //			/// args.XMLHttpRequest: the XMLHttpRequest object.
                //			/// args.textStatus: a string describing the error type.
                //			/// args.errorThrown: an exception object.
                //			///
                //			/// Refer to the jQuery.ajax.error event documentation for more details on this arguments.
                //			/// </param>
                //			ajaxError: null,
                /** The dataLoading event handler is a function that is called when the wijgrid loads a portion of data from the underlying datasource. This can be used for modification of data sent to server if using dynamic remote wijdatasource.
                * @event
                * @example
                * // This sample allows you to set the session ID when loading a portion of data from the remote wijdatasource:
                * $("#element").wijgrid({
                *		data: new wijdatasource({
                *			proxy: new wijhttpproxy({
                *				// some code here
                *			})
                *		}),
                *		dataLoading: function (e) {
                *			var dataSource = $(this).wijgrid("option", "data");
                *			dataSource.proxy.options.data.sessionID = getSessionID();
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ dataLoading: function (e) {
                * // some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgriddataloading", function (e) {
                * // some code here
                * });
                * @param {Object} e The jQuery.Event object.
                */
                this.dataLoading = null;
                /** The dataLoaded event handler is a function that is called when data is loaded.
                * @event
                * @example
                * // Display the number of entries found
                * $("#element").wijgrid({
                *		dataLoaded: function (e) {
                *			alert($(this).wijgrid("dataView").count());
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ dataLoaded: function (e) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgriddataloaded", function (e) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                */
                this.dataLoaded = null;
                /** The loading event handler is a function that is called at the beginning of the wijgrid's lifecycle. You can use this event to activate a custom load progress indicator.
                * @event
                * @example
                * // Creating an indeterminate progressbar during loading
                * $("#element").wijgrid({
                *		loading: function (e) {
                *			$("#progressBar").show().progressbar({ value: false });
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ loading: function (e) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridloading", function (e) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                */
                this.loading = null;
                /** The loaded event handler is a function that is called at the end the wijgrid's lifecycle when wijgrid is filled with data and rendered. You can use this event to manipulate the grid html content or to finish a custom load indication.
                * @event
                * @example
                * // The loaded event in the sample below ensures that whatever is selected on load is cleared
                * $("#element").wijgrid({
                *		loaded: function (e) {
                *			$(e.target).wijgrid("selection").clear(); // clear selection
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ loaded: function (e) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridloaded", function (e) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                */
                this.loaded = null;
                /** The rendering event handler is a function that is called when the wijgrid is about to render. Normally you do not need to use this event.
                * @event
                * @example
                * $("#element").wijgrid({
                *		rendering: function (e) {
                *			alert("rendering");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ rendering: function (e) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridrendering", function (e) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                */
                this.rendering = null;
                /** The rendered event handler is a function that is called when the wijgrid is rendered. Normally you do not need to use this event.
                * @event
                * @example
                * $("#element").wijgrid({
                *		rendered: function (e) {
                *			alert("rendered");
                *		}
                * });
                * @remarks
                * You can bind to the event either by type or by name.
                * Bind to the event by name:
                * $("#element").wijgrid({ rendered: function (e) {
                *		// some code here
                * }});
                *
                * Bind to the event by type:
                * $("#element").bind("wijgridrendered", function (e) {
                *		// some code here
                * });
                * @param {Object} e The jQuery.Event object.
                */
                this.rendered = null;
            }
            return wijgrid_options;
        })();        
        //wijgrid.prototype.options = $.extend(true, {}, wijmoWidget.prototype.options, new wijgrid_options());
        wijgrid.prototype.options = wijmo.grid.extendWidgetOptions(wijmo.wijmoWidget.prototype.options, new wijgrid_options());
        $.wijmo.registerWidget("wijgrid", wijgrid.prototype);
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var SketchObject = (function () {
            function SketchObject(attr) {
                if(attr) {
                    this.__attr = attr;
                }
            }
            SketchObject.prototype.attrs = function () {
                return this.__attr;
            };
            SketchObject.prototype.ensureAttr = function () {
                this.__attr = this.__attr || {
                };
                return this.__attr;
            };
            SketchObject.prototype.attr = function (name, value) {
                if(arguments.length == 0) {
                    return this.__attr;
                }
                if(arguments.length == 1) {
                    return this.__attr ? this.__attr[name] : null;
                } else {
                    this.ensureAttr()[name] = value;
                }
            };
            SketchObject.prototype.style = function (name, newValue) {
                if(arguments.length == 0) {
                    return this.__style;
                } else if(arguments.length == 1) {
                    return this.__style && this.__style[name];
                } else {
                    this.ensureStyle()[name] = newValue;
                }
            };
            SketchObject.prototype.deleteAttr = function (name) {
                if(this.__attr) {
                    delete this.__attr[name];
                }
            };
            SketchObject.prototype.deleteStyle = function (name) {
                if(this.__style) {
                    delete this.__style[name];
                }
            };
            SketchObject.prototype.ensureStyle = /** Creates style object if it does not exist. Then returns it */
            function () {
                this.__style = this.__style || {
                };
                return this.__style;
            };
            return SketchObject;
        })();
        grid.SketchObject = SketchObject;        
        /** @ignore */
        var SketchCell = (function (_super) {
            __extends(SketchCell, _super);
            function SketchCell(attr) {
                        _super.call(this, attr);
            }
            SketchCell.prototype.visible = function (newValue) {
                if(arguments.length == 0) {
                    return !(this._visible === false);
                } else {
                    this._visible = newValue;
                }
            };
            return SketchCell;
        })(SketchObject);
        grid.SketchCell = SketchCell;        
        /** @ignore */
        /* A sketch cell with a value */
        var ValueCell = (function (_super) {
            __extends(ValueCell, _super);
            function ValueCell(value, attr) {
                        _super.call(this, attr);
                this.value = value;
            }
            return ValueCell;
        })(SketchCell);
        grid.ValueCell = ValueCell;        
        /** @ignore */
        /* A sketch cell with raw html */
        var HtmlCell = (function (_super) {
            __extends(HtmlCell, _super);
            function HtmlCell(html, attr) {
                        _super.call(this, attr);
                this.html = html || "";
            }
            HtmlCell.nbsp = function nbsp() {
                return new HtmlCell("&nbsp;", null);
            };
            return HtmlCell;
        })(SketchCell);
        grid.HtmlCell = HtmlCell;        
        /** @ignore */
        var SketchRow = (function (_super) {
            __extends(SketchRow, _super);
            function SketchRow(rowType, renderState, attrs) {
                        _super.call(this, attrs);
                this.rowType = rowType;
                this.renderState = renderState;
                this.extInfo = {
                    state: grid.renderStateEx.none
                };
            }
            SketchRow.prototype.isDataRow = /** returns true if this is data row or data alternative row */
            function () {
                return (this.rowType & wijmo.grid.rowType.data) == wijmo.grid.rowType.data;
            };
            SketchRow.prototype.dataItemIndex = function (offset) {
                if (typeof offset === "undefined") { offset = 0; }
                return -1;
            };
            SketchRow.prototype.cellCount = function () {
                return this._cells ? this._cells.length : 0;
            };
            SketchRow.prototype._ensureCells = /** create the cell table if it does not exist yet */
            function () {
                this._cells = this._cells || [];
            };
            SketchRow.prototype.add = /** add a cell to the end */
            function (elem) {
                this._ensureCells();
                this._cells.push(elem);
            };
            SketchRow.prototype.insert = /** insert a cell */
            function (index, elem) {
                this._ensureCells();
                this._cells.splice(index, 0, elem);
            };
            SketchRow.prototype.cell = function (index) {
                return this._cells[index];
            };
            SketchRow.prototype.valueCell = function (index) {
                return this.cell(index);
            };
            SketchRow.prototype.removeAt = /** remove a cell by index */
            function (index) {
                if(!this._cells) {
                    throw "Wrong index";
                }
                this._cells.splice(index, 1);
            };
            SketchRow.prototype.clear = /** remove all cells */
            function () {
            };
            SketchRow.prototype.getRowInfo = function () {
                return {
                    type: this.rowType,
                    state: this.renderState,
                    sectionRowIndex: null,
                    dataRowIndex: null,
                    virtualDataItemIndex: null,
                    dataItemIndex: this.dataItemIndex(),
                    $rows: null,
                    _extInfo: this.extInfo
                };
            };
            return SketchRow;
        })(SketchObject);
        grid.SketchRow = SketchRow;        
        /** @ignore */
        var SketchDataRow = (function (_super) {
            __extends(SketchDataRow, _super);
            function SketchDataRow(originalRowIndex, renderState, attrs) {
                        _super.call(this, wijmo.grid.rowType.data | ((originalRowIndex % 2) == 1 ? wijmo.grid.rowType.dataAlt : 0), renderState, attrs);
                this.originalRowIndex = originalRowIndex;
            }
            SketchDataRow.prototype.dataItemIndex = function (offset) {
                if (typeof offset === "undefined") { offset = 0; }
                return offset + this.originalRowIndex;
            };
            SketchDataRow.prototype.isDataRow = function () {
                return true;
            };
            return SketchDataRow;
        })(SketchRow);
        grid.SketchDataRow = SketchDataRow;        
        /** @ignore */
        var SketchGroupRow = (function (_super) {
            __extends(SketchGroupRow, _super);
            function SketchGroupRow(header, attrs) {
                var rowType = header ? wijmo.grid.rowType.groupHeader : //"groupHeader"
                wijmo.grid.rowType.groupFooter;// "groupFooter"
                
                        _super.call(this, rowType, wijmo.grid.renderState.rendering, attrs);
            }
            SketchGroupRow.prototype.getRowInfo = function () {
                var info = _super.prototype.getRowInfo.call(this);
                if(this.groupByValue !== undefined) {
                    info.groupByValue = this.groupByValue;
                }
                return info;
            };
            return SketchGroupRow;
        })(SketchRow);
        grid.SketchGroupRow = SketchGroupRow;        
        /** @ignore */
        var SketchTable = (function () {
            function SketchTable() {
                this._table = [];
            }
            SketchTable.prototype.getRawTable = function () {
                return this._table;
            };
            SketchTable.prototype.row = function (index) {
                return this._table[index];
            };
            SketchTable.prototype.valueAt = function (rowIndex, colIndex) {
                return this.row(rowIndex).valueCell(colIndex).value;
            };
            SketchTable.prototype.count = function (newValue) {
                if(typeof newValue === "number") {
                    this._table.length = newValue;
                }
                return this._table.length;
            };
            SketchTable.prototype.add = function (row) {
                this._table.push(row);
            };
            SketchTable.prototype.insert = function (index, row) {
                this._table.splice(index, 0, row);
            };
            SketchTable.prototype.clear = function () {
                this._table.length = 0;
            };
            SketchTable.prototype.removeFirst = function (count) {
                if (typeof count === "undefined") { count = 1; }
                this._table.splice(0, count);
            };
            SketchTable.prototype.removeLast = function (count) {
                if (typeof count === "undefined") { count = 1; }
                this._table.splice(this._table.length - count, count);
            };
            SketchTable.prototype.replace = function (index, row) {
                var oldRows = this._table.splice(index, 1, row);
                if(oldRows && oldRows.length && row) {
                    row.extInfo = oldRows[0].extInfo;
                }
            };
            SketchTable.prototype.updateIndexes = function () {
                for(var i = 0; i < this._table.length; i++) {
                    var sketchRow = this._table[i];
                    if(this._table[i].isDataRow()) {
                        (sketchRow).originalRowIndex = i;
                    }
                }
            };
            SketchTable.prototype.isLazy = function () {
                return false;
            };
            SketchTable.prototype.ensureNotLazy = function () {
            };
            return SketchTable;
        })();
        grid.SketchTable = SketchTable;        
        /** @ignore */
        var LazySketchTable = (function (_super) {
            __extends(LazySketchTable, _super);
            function LazySketchTable(source) {
                        _super.call(this);
                this.mIsLazy = true;
                this.pageSize = 30;
                if(source == null) {
                    throw "Row source is null";
                }
                this.mSource = source;
                this._table.length = source.count();
            }
            LazySketchTable.prototype.isLazy = function () {
                return this.mIsLazy;
            };
            LazySketchTable.prototype.ensureNotLazy = /** Convert to not lazy and create rows if they don't exist*/
            function () {
                if(!this.isLazy()) {
                    return;
                }
                this.ensureRange();
                this.mIsLazy = false;
            };
            LazySketchTable.prototype.invalidate = function () {
                this._table = new Array(this.mSource.count());
                if(!this.isLazy()) {
                    this.updateRange();
                }
            };
            LazySketchTable.prototype.row = function (index) {
                if(!_super.prototype.row.call(this, index)) {
                    this.ensureRange(Math.max(0, index - this.pageSize / 2), this.pageSize);
                }
                return _super.prototype.row.call(this, index);
            };
            LazySketchTable.prototype.ensureRange = /** Create sketch rows if the don't exist yet.
            * Cannot create anything other than data rows.
            * Requires source
            */
            function (start, length) {
                if (typeof start === "undefined") { start = 0; }
                if (typeof length === "undefined") { length = this._table.length - start; }
                if(!this.isLazy()) {
                    return;
                }
                if(start < 0) {
                    throw "Wrong range start";
                }
                this._table.length = this.mSource.count();
                if(this._table.length == 0) {
                    if(length > 0) {
                        throw "Wrong range length";
                    }
                    return;
                }
                // skip existing rows in the beginning
                while(start < this._table.length && this._table[start]) {
                    start++;
                }
                // is there anything to create?
                if(start >= this._table.length) {
                    return;
                }
                var last = Math.min(start + length - 1, this._table.length - 1);
                // skip existing rows in the end
                while(last >= start && this._table[last]) {
                    last--;
                }
                length = last - start + 1;
                if(length > 0) {
                    this.updateRange(start, length);
                }
            };
            LazySketchTable.prototype.updateRange = function (start, length) {
                if (typeof start === "undefined") { start = 0; }
                if (typeof length === "undefined") { length = this._table.length - start; }
                if(this.mSource == null) {
                    throw "Cannot create sketch row because source is null";
                }
                this.mSource.getRange(start, length, this._table, start);
            };
            return LazySketchTable;
        })(SketchTable);
        grid.LazySketchTable = LazySketchTable;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../../../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @widget */
        var c1basefield = (function (_super) {
            __extends(c1basefield, _super);
            function c1basefield() {
                _super.apply(this, arguments);

            }
            c1basefield.prototype._create = function () {
                var wijgrid = $.data(this.element[0], "wijgridowner");
                this._field("owner", wijgrid);
                wijmo.grid.widgetName(this.element[0], this.widgetFullName);
                this._destroyed = false;
                this.element.addClass(wijgrid.options.wijCSS.widget + " " + wijmo.grid.wijgrid.CSS.c1basefield + " " + wijgrid.options.wijCSS.stateDefault);
                if(this.options.disabled) {
                    this.disable();
                }
                if(wijgrid.options.allowColMoving) {
                    wijgrid._UIDragndrop(true).attach(this);
                }
            };
            c1basefield.prototype._init = function () {
                this.element.wrapInner("<div class='" + wijmo.grid.wijgrid.CSS.cellContainer + " " + this._owner().options.wijCSS.wijgridCellContainer + "'></div>");
                this._refreshHeaderCell();
            };
            c1basefield.prototype.destroy = function () {
                try  {
                    _super.prototype.destroy.apply(this, arguments);
                }finally {
                    this._destroyed = true;
                }
            };
            c1basefield.prototype._destroy = function () {
                if(this._isDestroyed()) {
                    return;
                }
                var wijgrid = this._owner();
                if(wijgrid && wijgrid._UIDragndrop()) {
                    wijgrid._UIDragndrop().detach(this);
                }
                wijmo.grid.remove$dataByPrefix(this.element, this._data$prefix);
                var defCSS = wijmo.grid.wijgrid.CSS, wijCSS = wijgrid.options.wijCSS;
                this.element.removeClass(wijCSS.widget + " " + defCSS.c1basefield + " " + wijCSS.c1basefield + " " + wijCSS.stateDefault).html(this.element.find("." + defCSS.headerCellText).html())// restore initial cell content
                ;
            };
            c1basefield.prototype._field = function (name, value) {
                return wijmo.grid.dataPrefix(this.element, this._data$prefix, name, value);
            };
            c1basefield.prototype._removeField = function (name) {
                var internalDataName = this._data$prefix + name;
                this.element.removeData(internalDataName);
            };
            c1basefield.prototype._setOption = //isInvokedOutside stands for whether setOption is invoked by related widget
            function (key, value) {
                var presetFunc = this["_preset_" + key], oldValue = this.options[key], optionChanged, postsetFunc;
                if(presetFunc !== undefined) {
                    value = presetFunc.apply(this, [
                        value, 
                        oldValue
                    ]);
                }
                optionChanged = (value !== oldValue);
                //$.Widget.prototype._setOption.apply(this, arguments);  note: there is no dynamic linkage between the arguments and the formal parameter values when strict mode is used
                _super.prototype._setOption.apply(this, [
                    key, 
                    value
                ]);
                if(optionChanged) {
                    if(this.options.groupedIndex !== undefined) {
                        var groupedWidget = this._owner()._field("groupedWidgets")[this.options.groupedIndex];
                        if(groupedWidget && (key in groupedWidget.options)) {
                            groupedWidget._setOption(key, value)// update linked grouped column widget
                            ;
                        }
                    }
                    postsetFunc = this["_postset_" + key];
                    if(postsetFunc !== undefined) {
                        postsetFunc.apply(this, [
                            value, 
                            oldValue
                        ]);
                    }
                }
            };
            c1basefield.prototype._postset_allowMoving = function (value, oldValue) {
                //no need to detach because there is allowMoving judgment in draganddrop
                /*
                if (value) {
                if (this._owner().options.allowColMoving) {
                this._owner()._dragndrop(true).attach(this);
                }
                } else {
                this._owner()._dragndrop(true).detach(this);
                }
                */
                            };
            c1basefield.prototype._preset_clientType = function (value, oldValue) {
                throw "read-only";
            };
            c1basefield.prototype._postset_headerText = function (value, oldValue) {
                this._refreshHeaderCell();
            };
            c1basefield.prototype._postset_visible = function (value, oldValue) {
                this._owner().ensureControl(false);
            };
            c1basefield.prototype._postset_width = function (value, oldValue) {
                var wijgrid = this._owner();
                if(wijgrid) {
                    this.options.ensurePxWidth = true// prevent auto expanding
                    ;
                    var found = wijmo.grid.getColumnByTravIdx(wijgrid.options.columns, this.options.travIdx);
                    if(found) {
                        // *update options *
                        found.found.width = value;
                        found.found.ensurePxWidth = true// prevent auto expanding
                        ;
                    }
                    wijgrid.setSize()// recalculate sizes and auto expand other columns if possible.
                    ;
                }
                /*// change width of column.
                var view = this._owner()._view(),
                index = this.options.visLeavesIdx,
                oldRealValue = $(view.getHeaderCell(index)).outerWidth();
                view.ensureWidth(index, value, oldRealValue);*/
                            };
            c1basefield.prototype._owner = function () {
                return this._field("owner");
            };
            c1basefield.prototype._canSize = function () {
                return this.options.allowSizing && this._owner().options.allowColSizing;
            };
            c1basefield.prototype._canDrag = // drag-n-drop
            function () {
                return this.options.allowMoving === true;
            };
            c1basefield.prototype._canDropTo = function (wijField) {
                // parent can't be dropped into a child
                if(wijmo.grid.isChildOf(this._owner().options.columns, wijField, this)) {
                    return false;
                }
                return true;
            };
            c1basefield.prototype._createHeaderContent = function ($container) {
                return $container.html(this.options.headerText || "&nbsp;");// html(value) returns "" if value is undefined
                
            };
            c1basefield.prototype._decorateHeaderContent = function ($container) {
                return $container.wrapInner("<span class=\"" + wijmo.grid.wijgrid.CSS.headerCellText + " " + this._owner().options.wijCSS.wijgridHeaderCellText + "\" />");
            };
            c1basefield.prototype._refreshHeaderCell = function () {
                var $container = this.element.children("." + wijmo.grid.wijgrid.CSS.cellContainer).empty();
                this._createHeaderContent($container);
                this._decorateHeaderContent($container);
            };
            c1basefield.prototype._isDestroyed = function () {
                return this._destroyed;
            };
            return c1basefield;
        })(wijmo.wijmoWidget);
        grid.c1basefield = c1basefield;        
        c1basefield.prototype._data$prefix = "c1basefield";
        var c1basefield_options = (function () {
            function c1basefield_options() {
                /** A value indicating whether the column can be moved.
                * @example
                * $("#element").wijgrid({ columns: [ { allowMoving: true } ] });
                */
                this.allowMoving = true;
                /** A value indicating whether the column can be sized.
                * @example
                * $("#element").wijgrid({ columns: [ { allowSizing: true } ] });
                */
                this.allowSizing = true;
                /** This function is called each time wijgrid needs to create cell content.
                * This occurs when rows are being rendered or cell editing is about to finish.
                * You can use it to customize cell content.
                * @example
                * // Add an image which URL is obtained from the "Url" data field to the column cells.
                * $("#demo").wijgrid({
                *		data: [
                *			{ ID: 0, Url: "/images/0.jpg" },
                *			{ ID: 1, Url: "/images/1.jpg" }
                *		],
                *		columns: [
                *			{},
                *			{
                *				cellFormatter: function (args) {
                *					if (args.row.type & wijmo.grid.rowType.data) {
                *						args.$container
                *							.empty()
                *							.append($("<img />")
                *								.attr("src", args.row.data.Url));
                *
                *						return true;
                *					}
                *				}
                *			}
                *		]
                * });
                * @type {Function}
                * @param {wijmo.grid.IC1BaseFieldCellFormatterArgs} args The data with this function.
                * @returns {Boolean} True if container content has been changed and wijgrid should not apply the default formatting to the cell.
                * @remarks
                * Important: cellFormatter should not alter content of header and filter row cells container.
                */
                this.cellFormatter = undefined;
                /** A value indicating the key of the data field associated with a column.
                * If an array of objects is used as a datasource for wijgrid, this should be string value,
                * otherwise this should be an integer determining an index of the field in the datasource.
                * @type {String|Number}
                * @example
                * $("#element").wijgrid({ columns: [{ dataKey: "ProductID" }]});
                */
                this.dataKey = undefined;
                /** Determines whether to use number type column width as the real width of the column.
                * @example
                * $("#element").wijgrid({ columns: [{ ensurePxWidth: true }]});
                * @remarks
                * If this option is set to true, wijgrid will use the width option of the column widget.
                * If this option is undefined, wijgrid will refer to the ensureColumnsPxWidth option.
                */
                this.ensurePxWidth = undefined;
                /** Gets or sets the footer text.
                * The text may include a placeholder: "{0}" is replaced with the aggregate.
                * @example
                * $("#element").wijgrid({ columns: [{ footerText: "footer" }]});
                * @remarks
                * If the value is undefined the footer text will be determined automatically depending on the type of the datasource:
                * DOM table - text in the footer cell.
                */
                this.footerText = undefined;
                /** Gets or sets the header text.
                * @example
                * $("#element").wijgrid({ columns: [ { headerText: "column0" } ] });
                * @remarks
                * If the value is undefined the header text will be determined automatically depending on the type of the datasource:
                * DOM table - text in the header cell.
                * Array of objects - dataKey (name of the field associated with column).
                * Two-dimensional array - dataKey (index of the field associated with column).
                */
                this.headerText = undefined;
                /** Gets or sets the text alignment of data cells. Possible values are "left", "right", "center".
                * @example
                * $("#element").wijgrid({ columns: [{ textAligment: "right" }]});
                */
                this.textAlignment = undefined;
                /** A value indicating whether column is visible.
                * @example
                * $("#element").wijgrid({ columns: [{ visible: true }]});
                */
                this.visible = true;
                /** Determines the width of the column.
                * @type {String|Number}
                * @example
                * $("#element").wijgrid({ columns: [ { width: 150 } ] });
                * $("#element").wijgrid({ columns: [ { width: "10%" } ]});
                * @remarks
                * The option could either be a number of string.
                * Use number to specify width in pixel, use string to specify width in percentage.
                * By default, wijgrid emulates the table element behavior when using number as width. This means wijgrid may not have the exact width specified. If exact width is needed, please set ensureColumnsPxWidth option of wijgrid to true.
                */
                this.width = undefined;
            }
            return c1basefield_options;
        })();
        grid.c1basefield_options = c1basefield_options;        
        ;
        //c1basefield.prototype.options = $.extend(true, {}, wijmoWidget.prototype.options, new c1basefield_options());
        c1basefield.prototype.options = wijmo.grid.extendWidgetOptions(wijmo.wijmoWidget.prototype.options, new c1basefield_options());
        $.wijmo.registerWidget("c1basefield", c1basefield.prototype);
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="c1basefield.ts"/>
    /// <reference path="interfaces.ts"/>
    /// <reference path="../../../wijinput/jquery.wijmo.wijinputdate.ts"/>
    /// <reference path="../../../wijinput/jquery.wijmo.wijinputtext.ts"/>
    /// <reference path="../../../wijinput/jquery.wijmo.wijinputnumber.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @widget */
        var c1field = (function (_super) {
            __extends(c1field, _super);
            function c1field() {
                _super.apply(this, arguments);

            }
            c1field.prototype._create = function () {
                _super.prototype._create.apply(this, arguments);
                var wijgrid = this._owner();
                this.element.addClass(wijgrid.options.wijCSS.widget + " " + wijmo.grid.wijgrid.CSS.c1field);
            };
            c1field.prototype._destroy = function () {
                if(this._isDestroyed()) {
                    return;
                }
                var wijgrid = this._owner();
                this.element.find("*").unbind("." + this.widgetName);
                if(this.$filterEditor) {
                    this.$filterEditor.closest("td").find(// column filter cell
                    "*").unbind("." + this.widgetName);
                    switch(this._getInputEditorType(this.options)) {
                        case "date":
                            if(this.$filterEditor.data("wijmo-wijinputdate")) {
                                this.$filterEditor.wijinputdate("destroy");
                            }
                            break;
                        case "text":
                            if(this.$filterEditor.data("wijmo-wijinputtext")) {
                                this.$filterEditor.wijinputtext("destroy");
                            }
                            break;
                        case "numberCurrency":
                        case "numberNumber":
                        case "numberPercent":
                            if(this.$filterEditor.data("wijmo-wijinputnumber")) {
                                this.$filterEditor.wijinputnumber("destroy");
                            }
                            break;
                    }
                    this.$filterEditor = null;
                }
                this.element.removeClass(wijgrid.options.wijCSS.widget + " " + wijmo.grid.wijgrid.CSS.c1field);
                this._removeDropDownFilterList();
                _super.prototype._destroy.apply(this, arguments);
            };
            c1field.prototype._init = function () {
                _super.prototype._init.apply(this, arguments);
                this.$filterEditor = null;
                var wijgrid = this._owner();
                this.filterRow = wijgrid._filterRow();
                if(wijgrid.options.showFilter && this.options.showFilter && (this.options.dataIndex >= 0)) {
                    this._prepareFilterCell();
                }
            };
            c1field.prototype._postset_aggregate = function (value, oldValue) {
                this._owner().ensureControl(false);
            };
            c1field.prototype._postset_allowSort = function (value, oldValue) {
                //this.element.find("#contentCell").empty();
                //this._headerTextDOM(this.options.headerText);
                this._refreshHeaderCell();
            };
            c1field.prototype._postset_dataType = function (value, oldValue) {
                throw "read-only";
            };
            c1field.prototype._postset_dataParser = function (value, oldValue) {
                this._owner().ensureControl(false);
            };
            c1field.prototype._postset_disabled = function (value, oldValue) {
                if(this.$filterEditor) {
                    $.each(this.$filterEditor.data(), function (key, widget) {
                        // update the disabled option of the filter editor
                        if(widget && widget.widgetName && widget.option) {
                            widget.option("disabled", value);
                        }
                    });
                }
            };
            c1field.prototype._postset_dataFormatString = function (value, oldValue) {
                this._owner().ensureControl(false);
            };
            c1field.prototype._postset_filterOperator = function (value, oldValue) {
                this._owner().ensureControl(true);
            };
            c1field.prototype._postset_filterValue = function (value, oldValue) {
                this._owner().ensureControl(true);
            };
            c1field.prototype._postset_groupInfo = function (value, oldValue) {
                this._owner().ensureControl(true);
            };
            c1field.prototype._postset_rowMerge = function (value, oldValue) {
                this._owner().ensureControl(false);
            };
            c1field.prototype._postset_showFilter = function (value, oldValue) {
                this._owner().ensureControl(false);
            };
            c1field.prototype._postset_sortDirection = function (value, oldValue) {
                this.options.sortOrder = 0;
                this._owner().ensureControl(true);
            };
            c1field.prototype._postset_width = function (value, oldValue) {
                _super.prototype._postset_width.apply(this, arguments);
            };
            c1field.prototype._canDropTo = function (wijField) {
                if(_super.prototype._canDropTo.apply(this, arguments)) {
                    //the grouped column can't be dropped into group area
                    if(this.options.groupedIndex !== undefined && (wijField instanceof $.wijmo.c1groupedfield)) {
                        return false;
                    }
                    return true;
                }
                return false;
            };
            c1field.prototype._isSortable = function () {
                return wijmo.grid.validDataKey(this.options.dataKey);//return this.options.dataIndex >= 0;
                
            };
            c1field.prototype._isSortableUI = function () {
                var grid = this._owner();
                return grid && grid.options.allowSorting && this.options.allowSort && this._isSortable();
            };
            c1field.prototype._decorateHeaderContent = function ($container) {
                var wijgrid = this._owner(), defCSS = wijmo.grid.wijgrid.CSS, wijCSS = wijgrid.options.wijCSS;
                if(!this._isSortable()) {
                    _super.prototype._decorateHeaderContent.apply(this, arguments)// plain text
                    ;
                } else {
                    if(this._isSortableUI()) {
                        $container.wrapInner(// clickable text
                        "<a class=\"" + defCSS.headerCellText + " " + wijCSS.wijgridHeaderCellText + "\" href=\"#\" role=\"button\" />").children("a").bind("click." + this.widgetName, this, $.proxy(this._onHrefClick, this));
                    } else {
                        _super.prototype._decorateHeaderContent.apply(this, arguments)// plain text
                        ;
                    }
                    // icons
                    var baseSortCSS = defCSS.headerCellSortIcon + " " + wijCSS.wijgridHeaderCellSortIcon + " " + wijCSS.icon;
                    switch(this.options.sortDirection) {
                        case // sorting icon
                        "ascending":
                            $container.append($("<span class=\"" + baseSortCSS + " " + wijCSS.iconArrowUp + "\"></span>"));
                            break;
                        case "descending":
                            $container.append($("<span class=\"" + baseSortCSS + " " + wijCSS.iconArrowDown + "\"></span>"));
                            break;
                    }
                }
            };
            c1field.prototype._prepareFilterCell = function () {
                var filterCellIndex = this.options.visLeavesIdx, wijgrid = this._owner(), filterCell = null, dataValue, editorOptions, self = this, editorType, inputType = wijmo.grid.HTML5InputSupport.getDefaultInputType(wijgrid._isMobileEnv(), this.options), wijCSS = wijgrid.options.wijCSS, defCSS = wijmo.grid.wijgrid.CSS;
                if(filterCellIndex >= 0) {
                    wijgrid = this._owner();
                    if(this.filterRow) {
                        filterCell = $(wijmo.grid.rowAccessor.getCell(this.filterRow, filterCellIndex));
                    } else {
                        throw "exception";
                    }
                    this.$filterEditor = filterCell.find("input");
                    //the problem of inputing in the filter textbox
                    filterCell.bind((($.support).selectstart ? "selectstart" : "mousedown"), function (event) {
                        event.stopPropagation();
                    });
                    dataValue = wijgrid.parse(this.options, wijmo.grid.filterHelper.getSingleValue(this.options.filterValue));
                    // set default value
                    if(dataValue === null || dataValue === "undefined") {
                        switch(wijmo.grid.getDataType(this.options)) {
                            case "boolean":
                                dataValue = false;
                                break;
                            case "number":
                            case "currency":
                                dataValue = 0;
                                break;
                            case "datetime":
                                dataValue = new Date()// current date
                                ;
                                break;
                            default:
                                dataValue = "";
                        }
                    }
                    editorOptions = {
                        culture: wijgrid.options.culture,
                        disabled: wijgrid.options.disabled,
                        decimalPlaces: (function (pattern) {
                            // map decimal places specified within the dataFormatString option into the decimalPlaces option of the wijinputnumber.
                            var test = /^(n|p|c){1}(\d*)$/.exec(pattern);
                            if(test && test[2]) {
                                return parseInt(test[2], 10);
                            }
                            test = /^(d){1}(\d*)$/.exec(pattern);
                            if(test) {
                                return 0;// left padding is not supported by wijinputnumber
                                
                            }
                            return 2;
                        })(this.options.dataFormatString),
                        imeMode: this.options.imeMode,
                        triggerMouseUp: function (e) {
                            if(wijgrid) {
                                $.each(wijgrid.columns(), function (index, wijInstance) {
                                    if(wijInstance.$dropDownFilterList) {
                                        // close the dropdown list
                                        wijInstance._removeDropDownFilterList();
                                    }
                                });
                            }
                        }
                    };
                    this.$filterEditor.bind("keypress." + this.widgetName, $.proxy(this._onFilterEditorKeyPress, this));
                    // create editor
                    switch(editorType = this._getInputEditorType(this.options)) {
                        case "date":
                            if(inputType === "text") {
                                this.$filterEditor.wijinputdate($.extend(editorOptions, {
                                    date: dataValue,
                                    dateFormat: this.options.dataFormatString || undefined,
                                    showTrigger: true
                                }));
                            } else {
                                // html5 editor
                                this._createHtmlEditor(this.$filterEditor, inputType, wijmo.grid.HTML5InputSupport.toStr(dataValue, inputType));
                            }
                            break;
                        case "text":
                            this.$filterEditor.wijinputtext($.extend(editorOptions, {
                                text: dataValue + ""
                            }));
                            break;
                        case "numberCurrency":
                            this.$filterEditor.wijinputnumber($.extend(editorOptions, {
                                type: "currency",
                                value: dataValue
                            }));
                            break;
                        case "numberNumber":
                            if(inputType === "text") {
                                this.$filterEditor.wijinputnumber($.extend(editorOptions, {
                                    value: dataValue
                                }));
                            } else {
                                // html5 editor
                                this._createHtmlEditor(this.$filterEditor, inputType, wijmo.grid.HTML5InputSupport.toStr(dataValue, inputType));
                            }
                            break;
                        case "numberPercent":
                            this.$filterEditor.wijinputnumber($.extend(editorOptions, {
                                type: "percent",
                                value: dataValue * 100
                            }));
                            break;
                        default:
                            throw wijmo.grid.stringFormat("Unsupported editor type: \"{0}\"", editorType);
                    }
                    // create button
                    //var filterButton = filterCell.find(".filterBtn");
                    filterCell.find("." + defCSS.filterTrigger).attr(// filter button
                    {
                        "role": "button",
                        "aria-haspopup": "true"
                    }).bind("mouseenter." + this.widgetName, function (e) {
                        if(!self.options.disabled) {
                            $(this).addClass(wijCSS.stateDefault + " " + wijCSS.stateHover);
                        }
                    }).bind("mouseleave." + this.widgetName, function (e) {
                        if(!self.options.disabled) {
                            $(this).removeClass(wijCSS.stateDefault + " " + wijCSS.stateHover + " " + wijCSS.stateActive);
                        }
                    }).bind("mouseup." + this.widgetName, this, function (e) {
                        if(!self.options.disabled) {
                            $(this).removeClass(wijCSS.stateDefault + " " + wijCSS.stateActive);
                        }
                    }).bind("mousedown." + this.widgetName, {
                        column: this
                    }, $.proxy(this._onFilterBtnClick, this)).bind("click." + this.widgetName, function (e) {
                        e.preventDefault();
                    })// prevent # being added to url.
                    ;
                }
            };
            c1field.prototype._createHtmlEditor = function (input, inputType, value) {
                var defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._owner().options.wijCSS;
                (input[0]).type = inputType// use it instead of .attr("type", inputType) to avoid the "'type' property/attribute cannot be changed." exception.
                ;
                return input.addClass(wijCSS.stateDefault).wrap("<span class=\"" + defCSS.filterNativeHtmlEditorWrapper + " " + wijCSS.wijgridFilterNativeHtmlEditorWrapper + "\"></span").val(value);
            };
            c1field.prototype._onFilterBtnClick = function (e) {
                var _this = this;
                var column = e.data.column, maxItemsCount = 8, wijgrid = column._owner(), filterOpLowerCase, applicableFilters, args, items, width, eventUID;
                if(column.options.disabled) {
                    return false;
                }
                if(column.$dropDownFilterList) {
                    // close the dropdown list
                    column._removeDropDownFilterList();
                    return false;
                }
                (e.target).focus()//TFS #24253: In IE9, wijgrid is distorted on opening filter drop-down in a scrollable grid
                ;
                filterOpLowerCase = wijmo.grid.filterHelper.getSingleOperatorName(column.options.filterOperator).toLowerCase();
                applicableFilters = wijgrid.getFilterOperatorsByDataType(wijmo.grid.getDataType(column.options));
                args = {
                    operators: $.extend(true, [], applicableFilters),
                    column: // make a copy, so user can localize operators without affecting other controls
                    column.options
                };
                wijgrid._onFilterOperatorsListShowing(args);
                items = [];
                if(args.operators) {
                    $.each(args.operators, function (key, operator) {
                        items.push({
                            label: operator.displayName || operator.name,
                            value: operator.name,
                            selected: operator.name.toLowerCase() === filterOpLowerCase
                        });
                    });
                }
                column.$dropDownFilterList = $("<div />").addClass(wijmo.grid.wijgrid.CSS.filterList + " " + wijgrid.options.wijCSS.wijgridFilterList).appendTo(document.body).wijlist({
                    autoSize: true,
                    maxItemsCount: maxItemsCount,
                    selected: function (e, data) {
                        var filterValue = _this._getFilterValueFromEditor(column);
                        column._removeDropDownFilterList();
                        wijgrid._handleFilter(column, data.item.value, filterValue);
                    }
                });
                // ** zIndex
                column.$dropDownFilterList.css("z-index", wijmo.grid.getZIndex(wijgrid.outerDiv, 9999))// 9999 is the default value
                ;
                // zIndex **
                column.$dropDownFilterList.wijlist("setItems", items).wijlist("renderList");
                width = column.$dropDownFilterList.width() | 150;
                column.$dropDownFilterList.width(items.length > maxItemsCount ? width + 20 : width).wijlist("refreshSuperPanel").position({
                    of: $(e.currentTarget),
                    my: "left top",
                    at: "left bottom"
                });
                (column.$dropDownFilterList).$button = $(e.currentTarget);
                eventUID = (column.$dropDownFilterList).eventUID = wijmo.grid.getUID();
                $(document).bind("mousedown." + column.widgetName + "." + eventUID, {
                    column: column
                }, column._onDocMouseDown);
            };
            c1field.prototype._onFilterEditorKeyPress = function (e) {
                if(e && (e.which === 13)) {
                    //if (e && (e.which === wijmo.getKeyCodeEnum().ENTER))
                                        var wijgrid = this._owner(), filterValue = this._getFilterValueFromEditor(this), filterOperator = (this.options.filterOperator || "").toLowerCase();
                    if(!filterValue) {
                        // empty value - reset filtering
                        filterValue = undefined;
                        filterOperator = "nofilter";
                    } else {
                        if(!filterOperator || (filterOperator === "nofilter")) {
                            // no filter operator - use default
                            filterOperator = (wijmo.grid.getDataType(this.options) === "string") ? "contains" : "equals";
                        }
                    }
                    this._removeDropDownFilterList();
                    wijgrid._handleFilter(this, filterOperator, filterValue);
                }
            };
            c1field.prototype._onDocMouseDown = function (e) {
                var $target = $(e.target), defCSS = wijmo.grid.wijgrid.CSS, $filterList = $target.parents("." + defCSS.filterList + ":first"), $filterButton = $target.is("." + defCSS.filterTrigger) ? $target : $target.parents("." + defCSS.filterTrigger + ":first");
                if(($filterButton.length && ($filterButton[0] === e.data.column.$dropDownFilterList.$button[0])) || ($filterList.length && ($filterList[0] === e.data.column.$dropDownFilterList[0]))) {
                    // do nothing
                                    } else {
                    e.data.column._removeDropDownFilterList();
                }
            };
            c1field.prototype._onHrefClick = function (args) {
                if(args.data.options.disabled) {
                    return false;
                }
                if(args.data.options.allowSort) {
                    var wijgrid = args.data._owner();
                    wijgrid._handleSort(args.data.options, args.ctrlKey);
                }
                return false;
            };
            c1field.prototype._removeDropDownFilterList = function () {
                if(this.$dropDownFilterList) {
                    var eventUID = (this.$dropDownFilterList).eventUID;
                    this.$dropDownFilterList.remove();
                    this.$dropDownFilterList = null;
                    $(document).unbind("mousedown." + this.widgetName + "." + eventUID, this._onDocMouseDown);
                }
            };
            c1field.prototype._getInputEditorType = // "text", "date", "numberNumber", "numberPercent", "numberCurrency"
            function (column) {
                switch(wijmo.grid.getDataType(column)) {
                    case "number":
                        return (column.dataFormatString && column.dataFormatString.indexOf("p") === 0) ? "numberPercent" : "numberNumber";
                    case "currency":
                        return "numberCurrency";
                    case "datetime":
                        return "date";
                    default:
                        return "text";
                }
            };
            c1field.prototype._getFilterValueFromEditor = function (column) {
                var wijgrid = column._owner(), inputType = wijmo.grid.HTML5InputSupport.getDefaultInputType(wijgrid._isMobileEnv(), column.options), filterValue;
                switch(column._getInputEditorType(column.options)) {
                    case "date":
                        if(inputType === "text") {
                            filterValue = column.$filterEditor.wijinputdate("option", "date") || new Date()// current date
                            ;
                        } else {
                            filterValue = wijmo.grid.HTML5InputSupport.parse(column.$filterEditor.val(), inputType) || new Date();
                        }
                        break;
                    case "text":
                        filterValue = column.$filterEditor.wijinputtext("option", "text");
                        break;
                    case "numberNumber":
                        if(inputType !== "text") {
                            filterValue = wijmo.grid.HTML5InputSupport.parse(column.$filterEditor.val(), inputType) || 0;
                            break;
                        }
                        // fall through
                                            case "numberCurrency":
                        filterValue = column.$filterEditor.wijinputnumber("option", "value");
                        break;
                    case "numberPercent":
                        filterValue = column.$filterEditor.wijinputnumber("option", "value") / 100;
                        break;
                }
                return filterValue;
            };
            return c1field;
        })(grid.c1basefield);
        grid.c1field = c1field;        
        var c1field_options = (function (_super) {
            __extends(c1field_options, _super);
            function c1field_options() {
                _super.apply(this, arguments);

                /** Causes the grid to calculate aggregate values on the column and place them in the column footer cell or group header and footer rows.
                * Possible values are: "none", "count", "sum", "average", "min", "max", "std", "stdPop", "var", "varPop" and "custom".
                * @example
                * $("#element").wijgrid({ columns: [{ aggregate: "count" }]});
                * @remarks
                * Possible values are:
                * "none": no aggregate is calculated or displayed.
                * "count": count of non-empty values.
                * "sum": sum of numerical values.
                * "average": average of the numerical values.
                * "min": minimum value (numerical, string, or date).
                * "max": maximum value (numerical, string, or date).
                * "std": standard deviation (using formula for Sample, n-1).
                * "stdPop": standard deviation (using formula for Population, n).
                * "var": variance (using formula for Sample, n-1).
                * "varPop": variance (using formula for Population, n).
                * "custom": custom value (causing grid to throw groupAggregate event).
                *
                * If the showFooter option is off or grid does not contain any groups, setting the "aggregate" option has no effect.
                */
                this.aggregate = "none";
                /** A value indicating whether column can be sorted.
                * @example
                * $("#element").wijgrid({ columns: [{ allowSort: true }] });
                */
                this.allowSort = true;
                /** Column data type. Used to determine the rules for sorting, grouping, aggregate calculation, and so on.
                * Possible values are: "string", "number", "datetime", "currency" and "boolean".
                * @example
                * $("#element").wijgrid({ columns: [{ dataType: "string" }]});
                * @remarks
                * Possible values are:
                * "string": if using built-in parser any values are acceptable; "&nbsp;" considered as an empty string, nullString as null.
                * "number": if using built-in parser only numeric values are acceptable, also "&nbsp;", "" and nullString which are considered as null. Any other value throws an exception.
                * "datetime": if using built-in parser only date-time values are acceptable, also "&nbsp;", "" and nullString which are considered as null. Any other value throws an exception.
                * "currency": if using built-in parser only numeric and currency values are acceptable, also "&nbsp;", "" and nullString which are considered as null. Any other value throws an exception.
                * "boolean": if using built-in parser only "true" and "false" (case-insensitive) values are acceptable, also "&nbsp;", "" and nullString which are considered as null. Any other value throws an exception.
                */
                this.dataType = undefined;
                /** Data converter that is able to translate values from a string representation to column data type and back.
                * @example
                * var myBoolParser = {
                *		parseDOM: function (value, culture, format, nullString) {
                *			return this.parse(value.innerHTML, culture, format, nullString);
                *		},
                *		parse: function (value, culture, format, nullString) {
                *			if (typeof (value) === "boolean")  return value;
                *
                *			if (!value || (value === "&nbsp;") || (value === nullString)) {
                *				return null;
                *			}
                *
                *			switch (value.toLowerCase()) {
                *				case "on": return true;
                *				case "off": return false;
                *			}
                *
                *			return NaN;
                *		},
                *		toStr: function (value, culture, format, nullString) {
                *			if (value === null)  return nullString;
                *				return (value) ? "on" : "off";
                *			}
                *		}
                * }
                *
                * $("#element").wijgrid({ columns: [ { dataType: "boolean", dataParser: myBoolParser } ] });
                * @remarks
                * If undefined, than the built-in parser for supported datatypes will be used.
                */
                this.dataParser = undefined;
                /** A pattern used for formatting and parsing column values.
                * @example
                * $("#element").wijgrid({
                *		columns: [
                *			{ dataType: "currency" },
                *			{ dataType: "number" },
                *			{ dataType: "number", dataFormatString: "p0" }
                *		]
                * });
                * @remarks
                * The default value is undefined ("n" pattern will be used for "number" dataType, "d" for "datetime", "c" for "currency").
                * Please see the https://github.com/jquery/globalize for a full explanation and additional values.
                */
                this.dataFormatString = undefined;
                /** A value indicating whether data values are HTML-encoded before they are displayed in a cell.
                * @example
                * $("#element").wijgrid({
                *		data: [
                *			[0, "<b>value</b>"],
                *			[1, "&amp;"],
                *		],
                *		columns: [
                *			{ headerText: "ID" },
                *			{ headerText: "Value", encodeHtml: true }
                *		]
                * });
                */
                this.encodeHtml = false;
                /** An operations set for filtering. Must be either one of the embedded operators or custom filter operator.
                * Operator names are case insensitive.
                *
                * @example
                * $("#element").wijgrid({ columns: [{ dataType: "number", filterOperator: "Equals", filterValue: 0 }]});
                * @remarks
                * Embedded filter operators include:
                * "NoFilter": no filter.
                * "Contains": applicable to "string" data type.
                * "NotContain": applicable to "string" data type.
                * "BeginsWith": applicable to "string" data type.
                * "EndsWith": applicable to "string" data type.
                * "Equals": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                * "NotEqual": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                * "Greater": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                * "Less": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                * "GreaterOrEqual": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                * "LessOrEqual": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                * "IsEmpty": applicable to "string".
                * "NotIsEmpty": applicable to "string".
                * "IsNull": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                * "NotIsNull": applicable to "string", "number", "datetime", "currency" and "boolean" data types.
                *
                * Full option value is:
                *		[filterOperartor1, ..., filterOperatorN]
                * where each filter item is an object of the following kind:
                *		{ name: <operatorName>, condition: "or"|"and" }
                * where:
                *		name: filter operator name.
                *		condition: logical condition to other operators, "or" is by default.
                * Example:
                *		filterOperator: [ { name: "Equals" }, { name: "NotEqual", condition: "and" } ]
                * It is possible to use shorthand notation, the following statements are equivalent:
                *		filterOperator: [ { name: "Equals" }, { name: "BeginsWith" } ]
                *		filterOperator: [ "Equals", "BeginsWith" ]
                * In the case of a single operator option name may contain only filter operator name, the following statements are equivalent:
                *		filterOperator: [ { name: "Equals" } ]
                *		filterOperator: [ "Equals" ]
                *		filterOperator: "Equals"
                *
                * Note: wijgrid built-in filter editors do not support multiple filter operators.
                *
                */
                this.filterOperator = "nofilter";
                /** A value set for filtering.
                * @example
                * $("#element").wijgrid({ columns: [{ dataType: "number", filterOperator: "Equals", filterValue: 0 }]});
                * @remarks
                * Full option value is:
                *		[filterValue1, ..., filterValueN]
                * where each item is a filter value for the corresponding filter operator. Example:
                *		filterValue: [0, "a", "b"]
                *
                * Built-in filter operators support array of values as an argument. Example:
                *		filterOperator: ["Equals", "BeginsWith"]
                *		filterValue: [[0, 1, 2], "a"]
                * As a result of filtering all the records having 0, 1, 2, or starting with "a" will be fetched.
                *
                * Shorthand notation allows omitting square brackets, the following statements are equivalent:
                *		filterValue: ["a"]
                *		filterValue: [["a"]]
                *		filterValue: "a"
                *
                * Note: wijgrid built-in filter editors do not support multiple filter values.
                */
                this.filterValue = undefined;
                /** Used to customize the appearance and position of groups.
                * @example
                * $("#element").wijgrid({ columns: [{ groupInfo: { position: "header" }}]});
                */
                this.groupInfo = {
                    expandInfo: /** @ignore */
                    [],
                    level: // infrastructure
                    /** @ignore */
                    undefined,
                    groupSingleRow: // infrastructure
                    true,
                    collapsedImageClass: undefined,
                    expandedImageClass: /*$.wijmo.wijCSS.iconArrowRight*/
                    undefined,
                    position: /*$.wijmo.wijCSS.iconArrowRightDown*/
                    "none",
                    outlineMode: "startExpanded",
                    headerText: undefined,
                    footerText: undefined
                };
                /**
                * Controls the state of the input method editor for text fields.
                * Possible values are: "auto", "active", "inactive", "disabled".
                * Please refer to https://developer.mozilla.org/en-US/docs/Web/CSS/ime-mode for more info.
                * @example
                * $("#element").wijgrid({ columns: [{ imeMode: "auto" }]});
                */
                this.imeMode = "auto";
                /**
                * Determines the type of html editor for filter and cells.
                * Possible values are: "number", "date", "datetime", "datetime-local", "month", "time", "text".
                * @example
                * $("#element").wijgrid({ columns: [{ inputType: "text" }]});
                * @remarks
                * If the value is set then input type element is used with "type" attribute set to the value. If the value is not set then:
                *  - in desktop environment a "text" input element is used as the editor.
                *  - in mobile environment a "number" input element is used for columns having "number" and "currency" dataType; for columns where dataType = "datetime" a "datetime" input element is used, otherwise a "text" input element is shown.
                */
                this.inputType = undefined;
                /** A value indicating whether the cells in the column can be edited.
                * @example
                * $("#element").wijgrid({ columns: [ { readOnly: false } ] });
                */
                this.readOnly = false;
                /** Determines whether rows are merged. Possible values are: "none", "free" and "restricted".
                * @example
                * $("#element").wijgrid({ columns: [{ rowMerge: "none" }]});
                * @remarks
                * Possible values are:
                * "none": no row merging.
                * "free": allows row with identical text to merge.
                * "restricted": keeps rows with identical text from merging if rows in the previous column are merged.
                */
                this.rowMerge = "none";
                /** A value indicating whether filter editor will be shown in the filter row.
                * @example
                * $("#element").wijgrid({ columns: [{ showFilter: true }]});
                */
                this.showFilter = true;
                /** Determines the sort direction. Possible values are: "none", "ascending" and "descending".
                * @example
                * $("#element").wijgrid({ columns: [{ sortDirection: "none" }]});
                * @remarks
                * Possible values are:
                * "none": no sorting.
                * "ascending": sort from smallest to largest.
                * "descending": sort from largest to smallest.
                */
                this.sortDirection = "none";
                /** A value indicating whether null value is allowed during editing.
                * @example
                * $("#element").wijgrid({ columns: [{ valueRequired: false }]});
                */
                this.valueRequired = false;
            }
            return c1field_options;
        })(grid.c1basefield_options);
        grid.c1field_options = c1field_options;        
        ;
        //c1field.prototype.options = $.extend(true, {}, c1basefield.prototype.options, new c1field_options());
        c1field.prototype.options = wijmo.grid.extendWidgetOptions(grid.c1basefield.prototype.options, new c1field_options());
        $.wijmo.registerWidget("c1field", $.wijmo.c1basefield, c1field.prototype);
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="c1field.ts"/>
    /// <reference path="c1basefield.ts"/>
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @widget */
        var c1band = (function (_super) {
            __extends(c1band, _super);
            function c1band() {
                _super.apply(this, arguments);

            }
            c1band.prototype._create = function () {
                _super.prototype._create.apply(this, arguments);
                var wijgrid = this._owner();
                this.element.addClass(wijgrid.options.wijCSS.widget + " " + wijmo.grid.wijgrid.CSS.c1band);
            };
            c1band.prototype._canDropTo = function (wijField) {
                if(_super.prototype._canDropTo.apply(this, arguments)) {
                    //band can't be dropped into group area
                    return !(wijField instanceof $.wijmo.c1groupedfield);
                }
                return false;
            };
            return c1band;
        })(grid.c1basefield);
        grid.c1band = c1band;        
        var c1band_options = (function (_super) {
            __extends(c1band_options, _super);
            function c1band_options() {
                _super.apply(this, arguments);

                /**
                * Gets a array of objects representing the band columns.
                * @example
                * $("#element").wijgrid({
                *   columns: [{
                *      headerText: "Band",
                *      columns: [
                *         { headerText: "ID" },
                *         { headerText: "Name" }
                *      ]
                *   }]
                * });
                */
                this.columns = [];
            }
            return c1band_options;
        })(grid.c1field_options);        
        ;
        //c1band.prototype.options = $.extend(true, {}, c1basefield.prototype.options, new c1band_options());
        c1band.prototype.options = wijmo.grid.extendWidgetOptions(grid.c1basefield.prototype.options, new c1band_options());
        $.wijmo.registerWidget("c1band", $.wijmo.c1basefield, c1band.prototype);
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="c1basefield.ts"/>
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var c1groupedfield = (function (_super) {
            __extends(c1groupedfield, _super);
            function c1groupedfield() {
                _super.apply(this, arguments);

            }
            c1groupedfield.prototype._create = function () {
                var wijgrid = $.data(this.element[0], "wijgridowner"), defCSS = wijmo.grid.wijgrid.CSS, wijCSS = wijgrid.options.wijCSS;
                this._field("owner", wijgrid);
                wijmo.grid.widgetName(this.element[0], this.widgetFullName);
                this._destroyed = false;
                this.element.addClass(defCSS.groupAreaButton + " " + wijCSS.wijgridGroupAreaButton + " " + wijCSS.stateDefault + " " + wijCSS.cornerAll);
                if(this.options.disabled) {
                    this.disable();
                }
                if(wijgrid.options.allowColMoving) {
                    wijgrid._UIDragndrop(true).attach(this);
                }
            };
            c1groupedfield.prototype._init = function () {
                this._refreshHeaderCell();
            };
            c1groupedfield.prototype.destroy = function () {
                try  {
                    _super.prototype.destroy.apply(this, arguments);
                }finally {
                    this._destroyed = true;
                }
            };
            c1groupedfield.prototype._destroy = function () {
                if(this._isDestroyed()) {
                    return;
                }
                this.element.find("*").unbind("." + this.widgetName);
                var wijgrid = this._owner();
                if(wijgrid && wijgrid._dragndrop(false)) {
                    wijgrid._dragndrop(false).detach(this);
                }
                wijmo.grid.remove$dataByPrefix(this.element, this._data$prefix);
            };
            c1groupedfield.prototype._field = function (name, value) {
                return wijmo.grid.dataPrefix(this.element, this._data$prefix, name, value);
            };
            c1groupedfield.prototype._removeField = function (name) {
                var internalDataName = this._data$prefix + name;
                this.element.removeData(internalDataName);
            };
            c1groupedfield.prototype._setOption = function (key, value) {
                var presetFunc = this["_preset_" + key], oldValue = this.options[key], optionChanged, postsetFunc;
                if(presetFunc !== undefined) {
                    value = presetFunc.apply(this, [
                        value, 
                        oldValue
                    ]);
                }
                optionChanged = (value !== oldValue);
                //$.Widget.prototype._setOption.apply(this, arguments);  note: there is no dynamic linkage between the arguments and the formal parameter values when strict mode is used
                _super.prototype._setOption.apply(this, [
                    key, 
                    value
                ]);
                if(optionChanged) {
                    postsetFunc = this["_postset_" + key];
                    if(postsetFunc !== undefined) {
                        postsetFunc.apply(this, [
                            value, 
                            oldValue
                        ]);
                    }
                }
            };
            c1groupedfield.prototype._postset_headerText = function (value, oldValue, isInvokedOutside) {
                this._refreshHeaderCell();
            };
            c1groupedfield.prototype._postset_allowSort = function (value, oldValue, isInvokedOutside) {
                this._refreshHeaderCell();
            };
            c1groupedfield.prototype._owner = function () {
                return this._field("owner");
            };
            c1groupedfield.prototype._canSize = function () {
                return this.options.allowSizing && this._owner().options.allowColSizing;
            };
            c1groupedfield.prototype._canDrag = // drag-n-drop
            function () {
                return this.options.allowMoving === true;
            };
            c1groupedfield.prototype._canDropTo = function (wijField) {
                //band can't be dropped into group area
                if(!(wijField instanceof $.wijmo.c1groupedfield)) {
                    return false;
                }
                // parent can't be dropped into a child
                if(wijmo.grid.isChildOf(this._owner().options.columns, wijField, this)) {
                    return false;
                }
                return true;
            };
            c1groupedfield.prototype._isSortable = function () {
                return wijmo.grid.validDataKey(this.options.dataKey);//return this.options.dataIndex >= 0;
                
            };
            c1groupedfield.prototype._isSortableUI = function () {
                var grid = this._owner();
                return grid && grid.options.allowSorting && this.options.allowSort && this._isSortable();
            };
            c1groupedfield.prototype._refreshHeaderCell = function () {
                var defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._owner().options.wijCSS, $closeButton = $("<span class=\"" + defCSS.groupAreaButtonClose + " " + wijCSS.wijgridGroupAreaButtonClose + " " + wijCSS.stateDefault + " " + wijCSS.cornerAll + "\"><span class=\"" + wijCSS.icon + " " + wijCSS.iconClose + "\"></span></span>").bind(//.css("cursor", "pointer") // always show pointer
                "click." + this.widgetName, this, this._onCloseClick);
                this.element.html(this.options.headerText || "").prepend(// html(value) returns "" if value is undefined
                $closeButton);
                if(this._isSortableUI()) {
                    this.element.bind("click." + this.widgetName, this, $.proxy(this._onHrefClick, this));
                } else {
                    //this.element.css("cursor", "default");
                                    }
                if(this._isSortable()) {
                    // sorting icon
                    var generalSortClass = defCSS.groupAreaButtonSort + " " + wijCSS.wijgridGroupAreaButtonSort + " " + wijCSS.icon;
                    switch(this.options.sortDirection) {
                        case "ascending":
                            this.element.append($("<span class=\"" + generalSortClass + " " + wijCSS.iconArrowUp + "\"></span>"));
                            break;
                        case "descending":
                            this.element.append($("<span class=\"" + generalSortClass + " " + wijCSS.iconArrowDown + "\"></span>"));
                            break;
                    }
                }
            };
            c1groupedfield.prototype._onCloseClick = function (args) {
                var options = args.data.options;
                if(!options.disabled) {
                    (args.data._owner())._handleUngroup(args.data.options.travIdx);
                }
                return false;
            };
            c1groupedfield.prototype._onHrefClick = function (args) {
                var wijgrid = args.data._owner(), options = args.data.options, column;
                if(!(options).disabled && options.allowSort) {
                    //find the column according to the c1groupedfield widget
                    column = wijmo.grid.search(wijgrid.columns(), function (test) {
                        return test.options.travIdx === options.travIdx;
                    });
                    column = (!column.found) ? // grouped column is invisible?
                    wijmo.grid.getColumnByTravIdx(wijgrid.options.columns, options.travIdx).found : column.found.options;
                    if(column) {
                        wijgrid._handleSort(column, args.ctrlKey);
                    }
                }
                return false;
            };
            c1groupedfield.prototype._isDestroyed = function () {
                return this._destroyed;
            };
            return c1groupedfield;
        })(wijmo.wijmoWidget);
        grid.c1groupedfield = c1groupedfield;        
        c1groupedfield.prototype._data$prefix = "c1groupedfield";
        c1groupedfield.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, {
            wijMobileCSS: {
                header: "ui-header ui-bar-a",
                content: "ui-body-c",
                stateDefault: "ui-btn ui-btn-b",
                stateHover: "ui-btn-down-c",
                stateActive: "ui-btn-down-c"
            },
            allowMoving: /// <summary>
            /// A value indicating whether the column can be moved.
            /// Default: true.
            /// Type: Boolean.
            /// Code example: $("#element").wijgrid({ columns: [ { allowMoving: true } ] });
            /// </summary>
            true,
            allowSort: /// <summary>
            /// A value indicating whether column can be sorted.
            /// Default: true.
            /// Type: Boolean.
            /// Code example: $("#element").wijgrid({ columns: [{ allowSort: true }] });
            /// </summary>
            true,
            headerText: /// <summary>
            /// Gets or sets the header text.
            /// Default: undefined.
            /// Type: String.
            /// Code example: $("#element").wijgrid({ columns: [ { headerText: "column0" } ] });
            /// </summary>
            /// <remarks>
            /// If the value is undefined the header text will be determined automatically depending on the type of the datasource:
            ///  DOM table - text in the header cell.
            ///  Array of hashes - dataKey (name of the field associated with column).
            ///  Two-dimensional array - dataKey (index of the field associated with column).
            /// </remarks>
            undefined,
            sortDirection: /// <summary>
            /// Determines the sort direction.
            /// Possible values are: "none", "ascending" and "descending".
            ///
            /// "none": no sorting.
            /// "ascending": sort from smallest to largest.
            /// "descending": sort from largest to smallest.
            ///
            /// Default: "none".
            /// Type: String.
            /// Code example: $("#element").wijgrid({ columns: [{ sortDirection: "none" }] });
            /// </summary>
            "none"
        });
        $.wijmo.registerWidget("c1groupedfield", c1groupedfield.prototype);
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../../../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var wijgridcommandbuttonbase = (function (_super) {
            __extends(wijgridcommandbuttonbase, _super);
            function wijgridcommandbuttonbase() {
                _super.apply(this, arguments);

            }
            wijgridcommandbuttonbase.prototype._create = function () {
                wijmo.grid.widgetName(this.element[0], this.widgetFullName);
                this.element.css("display", "inline").addClass((this.options).wijCSS.widget);
            };
            wijgridcommandbuttonbase.prototype._destroy = function () {
                this.mBtnElement = null;
            };
            wijgridcommandbuttonbase.prototype._init = function () {
                var _this = this;
                this.mBtnElement = this._createElement(this.options).addClass("wijmo-wijgrid-commandbutton").click(function (e) {
                    if(!_this.options.disabled && $.isFunction(_this.options.click)) {
                        _this.options.click.call(self, e);
                    }
                });
                this.element.append(this.mBtnElement);
                this._attachWidget(this.mBtnElement, this.options);
            };
            wijgridcommandbuttonbase.prototype._setOption = function (key, value) {
                var oldValue = this.options[key];
                _super.prototype._setOption.apply(this, [
                    key, 
                    value
                ]);
                if((oldValue !== value) && (key === "disabled")) {
                    this._onDisabledChanged(value === true);
                }
            };
            wijgridcommandbuttonbase.prototype._createElement = function (settings) {
                throw "not implemented";
            };
            wijgridcommandbuttonbase.prototype._attachWidget = function (element, settings) {
                throw "not implemented";
            };
            wijgridcommandbuttonbase.prototype._btnElement = function () {
                return this.mBtnElement;
            };
            wijgridcommandbuttonbase.prototype._onDisabledChanged = function (value) {
            };
            return wijgridcommandbuttonbase;
        })(wijmo.wijmoWidget);
        grid.wijgridcommandbuttonbase = wijgridcommandbuttonbase;        
        /** @ignore */
        var wijgridcommandbuttonbase_options = (function () {
            function wijgridcommandbuttonbase_options() {
                this.text = undefined;
                this.click = undefined;
                this.iconClass = undefined;
                this.disabled = false;
            }
            return wijgridcommandbuttonbase_options;
        })();
        grid.wijgridcommandbuttonbase_options = wijgridcommandbuttonbase_options;        
        wijgridcommandbuttonbase.prototype.options = wijmo.grid.extendWidgetOptions(wijmo.wijmoWidget.prototype.options, new wijgridcommandbuttonbase_options());
        $.wijmo.registerWidget("wijgridcommandbuttonbase", wijgridcommandbuttonbase.prototype);
        /** @ignore */
        var wijgridcommandlink = (function (_super) {
            __extends(wijgridcommandlink, _super);
            function wijgridcommandlink() {
                _super.apply(this, arguments);

            }
            wijgridcommandlink.prototype._createElement = function (settings) {
                var anchor = $("<a href=\"#\" />").text(settings.text || "");
                if(settings.disabled) {
                    anchor.prop("disabled", "disabled");
                }
                return anchor;
            };
            wijgridcommandlink.prototype._attachWidget = function (element, settings) {
            };
            wijgridcommandlink.prototype._onDisabledChanged = function (value) {
                var btn = this._btnElement();
                if(btn) {
                    btn.prop("disabled", value);
                }
            };
            return wijgridcommandlink;
        })(wijgridcommandbuttonbase);
        grid.wijgridcommandlink = wijgridcommandlink;        
        $.wijmo.registerWidget("wijgridcommandlink", $.wijmo.wijgridcommandbuttonbase, wijgridcommandlink.prototype);
        /** @ignore */
        var wijgridcommandbutton = (function (_super) {
            __extends(wijgridcommandbutton, _super);
            function wijgridcommandbutton() {
                _super.apply(this, arguments);

            }
            wijgridcommandbutton.prototype._createElement = function (settings) {
                return $("<input type=\"button\" />").val(settings.text);
            };
            wijgridcommandbutton.prototype._attachWidget = function (element, settings) {
                element.button({
                    disabled: settings.disabled
                });
            };
            wijgridcommandbutton.prototype._onDisabledChanged = function (value) {
                var btn = this._btnElement();
                if(btn) {
                    btn.button({
                        disabled: value
                    });
                }
            };
            return wijgridcommandbutton;
        })(wijgridcommandbuttonbase);
        grid.wijgridcommandbutton = wijgridcommandbutton;        
        $.wijmo.registerWidget("wijgridcommandbutton", $.wijmo.wijgridcommandbuttonbase, wijgridcommandbutton.prototype);
        /** @ignore */
        var wijgridcommandimagebutton = (function (_super) {
            __extends(wijgridcommandimagebutton, _super);
            function wijgridcommandimagebutton() {
                _super.apply(this, arguments);

            }
            wijgridcommandimagebutton.prototype._createElement = function (settings) {
                var button = $("<button />"), hasText = !!settings.text;
                if(hasText) {
                    button.text(settings.text);
                } else {
                    button.html("&nbsp;");
                }
                return button;
            };
            wijgridcommandimagebutton.prototype._attachWidget = function (element, settings) {
                var hasText = !!settings.text;
                element.button({
                    disabled: settings.disabled,
                    icons: {
                        primary: settings.iconClass
                    },
                    text: hasText
                });
            };
            wijgridcommandimagebutton.prototype._onDisabledChanged = function (value) {
                var btn = this._btnElement();
                if(btn) {
                    btn.button({
                        disabled: value
                    });
                }
            };
            return wijgridcommandimagebutton;
        })(wijgridcommandbuttonbase);
        grid.wijgridcommandimagebutton = wijgridcommandimagebutton;        
        $.wijmo.registerWidget("wijgridcommandimagebutton", $.wijmo.wijgridcommandbuttonbase, wijgridcommandimagebutton.prototype);
        /** @ignore */
        var wijgridcommandimage = (function (_super) {
            __extends(wijgridcommandimage, _super);
            function wijgridcommandimage() {
                _super.apply(this, arguments);

            }
            wijgridcommandimage.prototype._createElement = function (settings) {
                var button = $("<button />").html("&nbsp;");
                return button;
            };
            wijgridcommandimage.prototype._attachWidget = function (element, settings) {
                element.button({
                    disabled: settings.disabled,
                    icons: {
                        primary: settings.iconClass
                    },
                    text: false
                });
            };
            wijgridcommandimage.prototype._onDisabledChanged = function (value) {
                var btn = this._btnElement();
                if(btn) {
                    btn.button({
                        disabled: value
                    });
                }
            };
            return wijgridcommandimage;
        })(wijgridcommandbuttonbase);
        grid.wijgridcommandimage = wijgridcommandimage;        
        $.wijmo.registerWidget("wijgridcommandimage", $.wijmo.wijgridcommandbuttonbase, wijgridcommandimage.prototype);
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="c1basefield.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /*-- c1btnfieldbase --*/
        /** @widget */
        var c1btnfieldbase = (function (_super) {
            __extends(c1btnfieldbase, _super);
            function c1btnfieldbase() {
                _super.apply(this, arguments);

            }
            c1btnfieldbase.testC1GridViewCommandField = function testC1GridViewCommandField(options) {
                return options && options.innerState && (options.innerState.clientType || "").toLowerCase() === "c1commandfield";
            };
            c1btnfieldbase.testC1GridViewButtonField = function testC1GridViewButtonField(options) {
                return options && options.innerState && (options.innerState.clientType || "").toLowerCase() === "c1buttonfield";
            };
            c1btnfieldbase.test = function test(options) {
                return (options && options.buttonType) && !c1btnfieldbase.testC1GridViewCommandField(options) && !c1btnfieldbase.testC1GridViewButtonField(options);
            };
            return c1btnfieldbase;
        })(grid.c1basefield);
        grid.c1btnfieldbase = c1btnfieldbase;        
        var c1btnfieldbase_options = (function (_super) {
            __extends(c1btnfieldbase_options, _super);
            function c1btnfieldbase_options() {
                _super.apply(this, arguments);

                /** Gets or sets the type of the button in the column. Possible values are "link", "button", "imageButton", "image".
                * @example
                * $("#element").wijgrid({ columns: [{ buttonType: "button" }]});
                */
                this.buttonType = "button";
            }
            return c1btnfieldbase_options;
        })(grid.c1basefield_options);
        grid.c1btnfieldbase_options = c1btnfieldbase_options;        
        ;
        c1btnfieldbase.prototype.options = wijmo.grid.extendWidgetOptions(grid.c1basefield.prototype.options, new c1btnfieldbase_options());
        //$.wijmo.registerWidget("c1basefield", c1basefield.prototype);
        /*-- c1btnfield --*/
        // Important: The "c1buttonfield" name and appropriate clientType value are reserved by C1GridView.
        /** @widget */
        var c1btnfield = (function (_super) {
            __extends(c1btnfield, _super);
            function c1btnfield() {
                _super.apply(this, arguments);

            }
            c1btnfield.test = function test(options) {
                return c1btnfieldbase.test(options) || options.command;
            };
            return c1btnfield;
        })(c1btnfieldbase);
        grid.c1btnfield = c1btnfield;        
        var c1btnfield_options = (function (_super) {
            __extends(c1btnfield_options, _super);
            function c1btnfield_options() {
                _super.apply(this, arguments);

                /** Represents options of a command button.
                * @example
                * $("#element").wijgrid({
                *    columns: [{
                *       buttonType: "link",
                *       command: {
                *          text: "myCommand",
                *          click: function (e, args) {
                *             alert("clicked!");
                *          }
                *       }
                *    }]
                * });
                */
                this.command = undefined;
            }
            return c1btnfield_options;
        })(c1btnfieldbase_options);
        grid.c1btnfield_options = c1btnfield_options;        
        ;
        c1btnfield.prototype.options = wijmo.grid.extendWidgetOptions(c1btnfieldbase.prototype.options, new c1btnfield_options());
        $.wijmo.registerWidget("c1btnfield", c1btnfield.prototype);
        /*-- c1commandbtnfield --*/
        // Important: The "c1commandfield" name and appropriate clientType value are reserved by C1GridView.
        /** @widget */
        var c1commandbtnfield = (function (_super) {
            __extends(c1commandbtnfield, _super);
            function c1commandbtnfield() {
                _super.apply(this, arguments);

            }
            c1commandbtnfield.test = function test(options) {
                if(c1btnfieldbase.testC1GridViewCommandField(options) || c1btnfieldbase.testC1GridViewButtonField(options)) {
                    return false;
                }
                return ((options.showDeleteButton && options.showDeleteButton !== false) || // its better to use a ("propName" in options) statement here, but there is will be no static type checking.
                (options.showEditButton && options.showEditButton !== false) || options.cancelCommand || options.deleteCommand || options.editCommand || options.updateCommand);
            };
            return c1commandbtnfield;
        })(c1btnfieldbase);
        grid.c1commandbtnfield = c1commandbtnfield;        
        var c1commandbtnfield_options = (function (_super) {
            __extends(c1commandbtnfield_options, _super);
            function c1commandbtnfield_options() {
                _super.apply(this, arguments);

                /** Gets or sets a value indicating whether a Delete button is displayed in a command column.
                * @example
                * $("#element").wijgrid({
                *    columns: [{
                *       showDeleteButton: true
                *    }]
                * });
                */
                this.showDeleteButton = false;
                /** Gets or sets a value indicating whether an Edit button is displayed in a command column.
                * @example
                * $("#element").wijgrid({
                *    columns: [{
                *       showEditButton: true
                *    }]
                * });
                */
                this.showEditButton = false;
                /** Represents options of a Cancel command button.
                * @example
                * $("#element").wijgrid({
                *    columns: [{
                *       cancelCommand: {
                *          text: "Cancel!"
                *       }
                *    }]
                * });
                */
                this.cancelCommand = {
                    text: "Cancel",
                    iconClass: "ui-icon-close",
                    click: undefined
                };
                /** Represents options of a Delete command button.
                * @example
                * $("#element").wijgrid({
                *    columns: [{
                *       deleteCommand: {
                *          text: "Delete!"
                *       }
                *    }]
                * });
                */
                this.deleteCommand = {
                    text: "Delete",
                    iconClass: "ui-icon-trash",
                    click: undefined
                };
                /** Represents options of a Delete command button.
                * @example
                * $("#element").wijgrid({
                *    columns: [{
                *       deleteCommand: {
                *          text: "Edit!"
                *       }
                *    }]
                * });
                */
                this.editCommand = {
                    text: "Edit",
                    iconClass: "ui-icon-pencil",
                    click: undefined
                };
                /** Represents options of a Delete command button.
                * @example
                * $("#element").wijgrid({
                *    columns: [{
                *       deleteCommand: {
                *          text: "Update!"
                *       }
                *    }]
                * });
                */
                this.updateCommand = {
                    text: "Update",
                    iconClass: "ui-icon-disk",
                    click: undefined
                };
            }
            return c1commandbtnfield_options;
        })(c1btnfieldbase_options);
        grid.c1commandbtnfield_options = c1commandbtnfield_options;        
        ;
        c1commandbtnfield.prototype.options = wijmo.grid.extendWidgetOptions(c1btnfieldbase.prototype.options, new c1commandbtnfield_options());
        $.wijmo.registerWidget("c1commandbtnfield", c1commandbtnfield.prototype);
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var bandProcessor = (function () {
            function bandProcessor() { }
            bandProcessor.prototype.generateSpanTable = function (root, leaves) {
                this._height = this._width = this._inc = this._shift = 0;
                this._table = [];
                this._traverseList = [];
                this._savedXPos = [];
                var spanTable = this._generateSpanTable(root, leaves, true);
                return spanTable;
            };
            bandProcessor.prototype._generateSpanTable = function (root, leaves, parentVisibility) {
                var i, j, self = this;
                this._height = this.getVisibleHeight(root, parentVisibility);
                leaves = leaves || [];
                wijmo.grid.traverse(root, function (column) {
                    if(column.isLeaf) {
                        leaves.push(column);
                    }
                    self._traverseList.push(column);
                });
                this._width = leaves.length;
                for(i = 0; i < this._height; i++) {
                    this._table[i] = [];
                    for(j = 0; j < this._width; j++) {
                        this._table[i][j] = {
                            column: null,
                            colSpan: 0,
                            rowSpan: 0
                        };
                    }
                }
                this._setTableValues(root, 0, 0);
                return this._table;
            };
            bandProcessor.prototype.getVisibleHeight = function (root, parentVisibility) {
                var i, len, colVis, tmp, result = 0;
                if($.isArray(root)) {
                    // columns
                    for(i = 0 , len = root.length; i < len; i++) {
                        tmp = this.getVisibleHeight(root[i], parentVisibility);
                        result = Math.max(result, tmp);
                    }
                } else {
                    // column
                    colVis = (root.visible === undefined) ? true : root.visible;
                    root.parentVis = colVis && parentVisibility;
                    if(root.isBand) {
                        // band
                        for(i = 0 , len = root.columns.length; i < len; i++) {
                            tmp = this.getVisibleHeight(root.columns[i], root.parentVis);
                            result = Math.max(result, tmp);
                        }
                        if(!root.parentVis) {
                            return result;
                        }
                        root.isLeaf = (result === 0);
                        result++;
                    } else {
                        // general column
                        root.isLeaf = true;
                        if(root.parentVis) {
                            result = 1;
                        }
                    }
                }
                return result;
            };
            bandProcessor.prototype._getVisibleParent = function (column) {
                while(column) {
                    column = this._traverseList[column.parentIdx];
                    if(column && (column.parentVis || column.parentVis === undefined)) {
                        return column;
                    }
                }
                return null;
            };
            bandProcessor.prototype._setTableValues = function (root, y, x) {
                var i, len, tx, posX, parentIsLeaf, visibleParent;
                if($.isArray(root)) {
                    //
                    for(i = 0 , len = root.length; i < len; i++) {
                        this._setTableValues(root[i], y, x);
                    }
                } else {
                    // column
                    if(root.travIdx === undefined) {
                        throw "undefined travIdx";
                    }
                    tx = x + this._shift;
                    if(root.parentVis) {
                        posX = tx + this._inc;
                        this._table[y][posX].column = root;
                        this._savedXPos[root.travIdx] = posX;
                    }
                    if(root.isBand) {
                        // band
                        for(i = 0 , len = root.columns.length; i < len; i++) {
                            this._setTableValues(root.columns[i], y + 1, x);
                        }
                    }
                    if(root.parentVis) {
                        if(this._shift - tx === 0) {
                            //root is column or band without visible nodes
                            this._table[y][this._savedXPos[root.travIdx]].rowSpan = this._height - y;
                            this._shift++;
                        } else {
                            // band with visible nodes
                            this._table[y][this._savedXPos[root.travIdx]].colSpan = this._shift - tx;
                        }
                    } else {
                        if(!root.isBand && this._height > 0) {
                            visibleParent = this._getVisibleParent(root);
                            parentIsLeaf = (visibleParent) ? visibleParent.isLeaf : false;
                            if(parentIsLeaf) {
                                this._inc++;
                            }
                            if(y >= this._height) {
                                y = this._height - 1;
                            }
                            posX = x + this._shift + this._inc;
                            this._table[y][posX].column = root;
                            if(!parentIsLeaf) {
                                if(visibleParent && (this._savedXPos[visibleParent.travIdx] === posX)) {
                                    this._shiftTableElements(posX, y);
                                }
                                this._inc++;
                            }
                        }
                    }
                }
            };
            bandProcessor.prototype._shiftTableElements = function (x, untilY) {
                var i;
                for(i = 0; i < untilY; i++) {
                    this._table[i][x + 1] = this._table[i][x];
                    this._table[i][x] = {
                        column: null,
                        colSpan: 0,
                        rowSpan: 0
                    };
                    if(this._table[i][x + 1].column) {
                        this._savedXPos[this._table[i][x + 1].column.travIdx]++;
                    }
                }
            };
            return bandProcessor;
        })();
        grid.bandProcessor = bandProcessor;        
        /** @ignore */
        function flatten(columns) {
            var result = [];
            wijmo.grid.traverse(columns, function (column) {
                result.push(column);
            });
            return result;
        }
        grid.flatten = flatten;
        // returns both visible and invisible leaves.
        /** @ignore */
        function getAllLeaves(columns) {
            var leaves = [];
            _getAllLeaves(columns, leaves);
            return leaves;
        }
        grid.getAllLeaves = getAllLeaves;
        function _getAllLeaves(columns, leaves) {
            var i, len, column, subColumns;
            if(columns) {
                for(i = 0 , len = columns.length; i < len; i++) {
                    column = columns[i];
                    if(column.options) {
                        // widget
                        column = column.options;
                    }
                    subColumns = column.columns;
                    if(subColumns && subColumns.length) {
                        _getAllLeaves(subColumns, leaves);
                    } else {
                        leaves.push(column);
                    }
                }
            }
        }
        // returns null or { found (object), at (array) } object.
        /** @ignore */
        function getColumnByTravIdx(columns, travIdx) {
            var i, len, column, result = null;
            if(columns && travIdx >= 0) {
                for(i = 0 , len = columns.length; i < len && !result; i++) {
                    column = columns[i];
                    if(column.options) {
                        // widget
                        column = column.options;
                    }
                    if(column.travIdx === travIdx) {
                        return {
                            found: column,
                            at: columns
                        };
                    }
                    if(column.columns) {
                        result = this.getColumnByTravIdx(column.columns, travIdx);
                    }
                }
            }
            return result;
        }
        grid.getColumnByTravIdx = getColumnByTravIdx;
        /** @ignore */
        function getLeaves(columns) {
            var leaves = [];
            _getLeaves(columns, leaves);
            return leaves;
        }
        grid.getLeaves = getLeaves;
        function _getLeaves(columns, leaves) {
            var i, len, column;
            if(columns) {
                for(i = 0 , len = columns.length; i < len; i++) {
                    column = columns[i];
                    if(column.isLeaf) {
                        leaves.push(column);
                    }
                    if(column.columns) {
                        _getLeaves(column.columns, leaves);
                    }
                }
            }
        }
        /** @ignore */
        function getTompostParent(column, allColumnsTraverseList) {
            if(!column || !allColumnsTraverseList || (column.parentIdx === -1)) {
                return null;
            }
            var parent = allColumnsTraverseList[column.parentIdx];
            if(parent.parentIdx === -1) {
                return parent;
            }
            return wijmo.grid.getTompostParent(parent, allColumnsTraverseList);
        }
        grid.getTompostParent = getTompostParent;
        /** @ignore */
        function isChildOf(columns, child, parent) {
            if(child.options) {
                child = child.options;
            }
            if(parent.options) {
                parent = parent.options;
            }
            if(parent.isBand && child.parentIdx >= 0) {
                if(child.parentIdx === parent.travIdx) {
                    return true;
                }
                if(child.parentIdx > parent.travIdx) {
                    var traverse = this.flatten(columns);
                    while(true) {
                        child = traverse[child.parentIdx];
                        if(child.travIdx === parent.travIdx) {
                            return true;
                        }
                        if(child.parentIdx === -1) {
                            break;
                        }
                    }
                }
            }
            return false;
        }
        grid.isChildOf = isChildOf;
        /** @ignore */
        function setTraverseIndex(columns) {
            return _setTraverseIndex(columns, 0, -1);// -> columns length
            
        }
        grid.setTraverseIndex = setTraverseIndex;
        function _setTraverseIndex(columns, idx, parentIdx) {
            var i, len, column;
            if(columns) {
                for(i = 0 , len = columns.length; i < len; i++) {
                    column = columns[i];
                    if(column.options) {
                        // widget
                        column = column.options;
                    }
                    column.linearIdx = i;
                    column.travIdx = idx++;
                    column.parentIdx = parentIdx;
                    if(column.columns) {
                        idx = _setTraverseIndex(column.columns, idx, idx - 1);
                    }
                }
            }
            return idx;
        }
                        /** @ignore */
        function traverse(columns, callback) {
            var i, len, column;
            if(columns && ($.isFunction(callback))) {
                for(i = 0; i < columns.length; i++) {
                    column = columns[i];
                    if(column.options) {
                        // widget
                        column = column.options;
                    }
                    len = columns.length;
                    callback(column, columns);
                    if(columns.length !== len) {
                        // backoff
                        i--;
                        continue;
                    }
                    if(column.columns) {
                        // go deeper
                        wijmo.grid.traverse(column.columns, callback);
                    }
                }
            }
        }
        grid.traverse = traverse;
        //export function getAriaHeaders(visibleLeaves: wijmo.grid.IColumn[], traverseList): string[] {
        //	var i, len, leaf, value, result = [];
        //	for (i = 0, len = visibleLeaves.length; i < len; i++) {
        //		leaf = visibleLeaves[i];
        //		value = "";
        //		do {
        //			value += (<any>window).escape(leaf.headerText) + " ";
        //		} while ((leaf = traverseList[leaf.parentIdx])/*&& leaf.parentVis*/);
        //		result[i] = $.trim(value);
        //	}
        //	return result;
        //}
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="filterOperators.ts"/>
    /// <reference path="misc.ts"/>
    /// <reference path="../../../data/src/dataView.ts"/>
    /// <reference path="../../../data/src/filtering.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var settingsManager = (function () {
            function settingsManager(wijgrid) {
                this._dvFilteringSettings = undefined;
                this._dvPagingSettings = undefined;
                this._dvSortingSettings = undefined;
                this._wgFilteringSettings = undefined;
                this._wgPagingSettings = undefined;
                this._wgSortingSettings = undefined;
                if(!wijgrid) {
                    throw "exception";
                }
                this._wijgrid = wijgrid;
                this._dataView = wijgrid._dataViewWrapper.dataView();
                this._filterCache = new wijmo.grid.filterOperatorsCache(wijgrid);
            }
            settingsManager.prototype.compareSettings = function () {
                var result = true, a, b, i, len;
                // paging
                result = ((a = this.DVPagingSettings()) === (b = this.WGPagingSettings()));
                if(!result && a && b) {
                    result = (a.pageSize === b.pageSize && a.pageIndex === b.pageIndex);
                }
                // sorting
                if(result) {
                    result = ((a = this.DVSortingSettings()) === (b = this.WGSortingSettings()));
                    if(!result && a && b && ((len = a.length) === b.length)) {
                        result = true;
                        for(i = 0; i < len && result; i++) {
                            result = ((a[i].dataKey === b[i].dataKey) && (a[i].sortDirection === b[i].sortDirection));
                        }
                    }
                }
                // filtering
                if(result) {
                    a = this.DVFilteringSettings();
                    b = this.WGFilteringSettings();
                    result = wijmo.grid.compareObj(a, b);
                }
                return result;
            };
            settingsManager.prototype.DVFilteringSettings = function () {
                function traverse(filter, normalizedItem) {
                    var condition;
                    $.each(filter, function (i, item) {
                        if(typeof (item) === "string") {
                            // "or"\ "and"
                            condition = item;
                        } else {
                            if($.isArray(item)) {
                                traverse(item, normalizedItem);
                            } else {
                                // single filter object - { property, operator, value }
                                normalizedItem.filterValue.push(item.value);
                                normalizedItem.filterOperator.push({
                                    name: item.originalOperator || // unwrap proxy operator
                                    item.operator,
                                    condition: condition
                                });
                            }
                        }
                    });
                }
                if(this._dvFilteringSettings === undefined) {
                    var foo = [], filter = this._dataView.filter();
                    if(filter) {
                        $.each(filter, function (dataKey, item) {
                            var normalizedItem = {
                                dataKey: dataKey
                            };
                            if($.isArray(item)) {
                                normalizedItem.filterValue = [];
                                normalizedItem.filterOperator = [];
                                traverse(item, normalizedItem);
                            } else if($.isPlainObject(item)) {
                                normalizedItem.filterValue = item.value;
                                normalizedItem.filterOperator = item.originalOperator || // unwrap proxy operator
                                item.operator || "Equals";
                            } else {
                                normalizedItem.filterValue = item;
                                normalizedItem.filterOperator = "Equals";
                            }
                            foo.push(normalizedItem);
                        });
                    }
                    this._dvFilteringSettings = (foo.length) ? foo : null;
                }
                return this._dvFilteringSettings;
            };
            settingsManager.prototype.DVPagingSettings = function () {
                if(this._dvPagingSettings === undefined) {
                    var pageableDataView = wijmo.grid.asPagedDataView(this._dataView);
                    if(pageableDataView) {
                        var pageSize = pageableDataView.pageSize();
                        this._dvPagingSettings = (pageSize > 0) ? {
                            pageSize: pageableDataView.pageSize(),
                            pageIndex: pageableDataView.pageIndex()
                        } : null;
                    }
                }
                return this._dvPagingSettings;
            };
            settingsManager.prototype.DVSortingSettings = function () {
                if(this._dvSortingSettings === undefined) {
                    var foo = [];
                    if(true/*this._dataView.canSort()*/ ) {
                        var sortDescription = wijmo.data.sorting.compile(this._dataView.sort()).normalized;
                        if(sortDescription) {
                            $.each(sortDescription, function (key, prop) {
                                if(prop !== null) {
                                    foo.push({
                                        dataKey: (typeof (prop) === "string") ? prop : prop.property,
                                        sortDirection: prop.asc || prop.asc === undefined ? "ascending" : "descending"
                                    });
                                }
                            });
                        }
                    }
                    this._dvSortingSettings = (foo.length) ? foo : null;
                }
                return this._dvSortingSettings;
            };
            settingsManager.prototype.WGFilteringSettings = function () {
                if(this._wgFilteringSettings === undefined) {
                    var foo = [], leaves = this._wijgrid._field("leaves"), self = this;
                    if(leaves) {
                        $.each(leaves, function (key, leaf) {
                            if(wijmo.grid.validDataKey(leaf.dataKey) && leaf.filterOperator) {
                                var fvToVerify = (wijmo.grid.deepExtend({
                                }, {
                                    foo: leaf.filterValue
                                })).foo, fopToVerify = // to avoid string values reconstruction ("abc" -> ["a", "b", "c"])
                                (wijmo.grid.deepExtend({
                                }, {
                                    foo: leaf.filterOperator
                                })).foo, verifiedFop = wijmo.grid.filterHelper.verify(fopToVerify, fvToVerify, leaf.dataType, self._filterCache);
                                if(verifiedFop) {
                                    foo.push({
                                        owner: leaf,
                                        dataKey: leaf.dataKey,
                                        filterValue: verifiedFop.filterValue,
                                        filterOperator: verifiedFop.filterOperator
                                    });
                                }
                            }
                        });
                    }
                    this._wgFilteringSettings = (foo.length) ? foo : null;
                }
                return this._wgFilteringSettings;
            };
            settingsManager.prototype.WGPagingSettings = function () {
                if(this._wgPagingSettings === undefined) {
                    this._wgPagingSettings = this._wijgrid.options.allowPaging ? {
                        pageSize: this._wijgrid.options.pageSize,
                        pageIndex: this._wijgrid.options.pageIndex
                    } : null;
                }
                return this._wgPagingSettings;
            };
            settingsManager.prototype.WGSortingSettings = function () {
                if(this._wgSortingSettings === undefined) {
                    var sortDictionary = {
                    }, sortArray = [], groupedColumns = this._wijgrid._groupedColumns(true), leaves = // grouped columns ordered by the groupedIndex
                    this._wijgrid._field("leaves") || [], canSort = function (column) {
                        return (!column.isBand && wijmo.grid.validDataKey(column.dataKey));
                    }, sortOrder = 0;
                    // fill the sortedDictionary with the grouped columns first
                    $.each(groupedColumns, function (i, leaf) {
                        if(canSort(leaf)) {
                            if(leaf.sortDirection === "none") {
                                leaf.sortDirection = "ascending"// use "ascending" for grouped columns by default
                                ;
                            }
                            sortDictionary[leaf.dataKey] = {
                                dataKey: leaf.dataKey,
                                sortDirection: leaf.sortDirection,
                                sortOrder: sortOrder++
                            };
                        }
                    });
                    sortOrder++;
                    // add other columns
                    $.each(leaves, function (i, leaf) {
                        if(canSort(leaf)) {
                            if(leaf.sortDirection === "ascending" || leaf.sortDirection === "descending") {
                                if(!sortDictionary[leaf.dataKey]) {
                                    // skip grouped columns or columns with the same dataKey
                                    sortDictionary[leaf.dataKey] = {
                                        dataKey: leaf.dataKey,
                                        sortDirection: leaf.sortDirection,
                                        sortOrder: (leaf.sortOrder || 0) + sortOrder
                                    };
                                }
                            }
                        }
                    });
                    // convert {} to []
                    $.each(sortDictionary, function (key, value) {
                        sortArray.push(value);
                    });
                    // sort by sortOrder
                    sortArray.sort(function (a, b) {
                        return a.sortOrder - b.sortOrder;
                    });
                    $.each(sortArray, function (i, item) {
                        delete item.sortOrder;
                    });
                    this._wgSortingSettings = (sortArray.length) ? sortArray : null;
                }
                return this._wgSortingSettings;
            };
            settingsManager.prototype.MapWGToDV = function () {
                var _this = this;
                var result = {
                }, foo, newDVFilterOption;
                // * paging *
                if(this._mapPagingParams() && (foo = this.WGPagingSettings())) {
                    result.pageIndex = foo.pageIndex;
                    result.pageSize = foo.pageSize;
                } else {
                    result.pageSize = -1// cancel paging
                    ;
                }
                // ** sorting
                if(this._mapSortingParams()) {
                    result.sort = []// clear sorting
                    ;
                    if(foo = this.WGSortingSettings()) {
                        result.sort = [];
                        $.each(foo, function (key, o) {
                            result.sort.push({
                                property: o.dataKey,
                                asc: o.sortDirection === "ascending"
                            });
                        });
                    }
                }
                // sorting **
                this._wijgrid.deficientFilters = {
                };
                // ** filtering
                if(this._mapFilteringParams()) {
                    // fill the deficientFilters
                    $.each(this._wijgrid._field("leaves"), function (key, leaf) {
                        if(wijmo.grid.validDataKey(leaf.dataKey) && ((leaf.filterOperator === undefined) ^ (leaf.filterValue === undefined))) {
                            _this._wijgrid.deficientFilters[leaf.dataKey] = {
                                filterOperator: leaf.filterOperator,
                                filterValue: leaf.filterValue
                            };
                        }
                    });
                    result.filter = {
                    };
                    // set filtering
                    if(foo = this.WGFilteringSettings()) {
                        result.filter = this._convertFilterToDV(foo);
                    }
                    if($.isEmptyObject(result.filter)) {
                        result.filter = null// must be null to clear filtering.
                        ;
                    }
                }
                // filtering **
                return result;
            };
            settingsManager.prototype.MapDVToWG = function () {
                var foo, leavesByDataKey = {
                }, mapSortingParams = this._mapSortingParams(), mapPagingParams = this._mapPagingParams(), mapFilteringParams = this._mapFilteringParams(), pagedDataView = wijmo.grid.asPagedDataView(this._dataView), self = this;
                $.each(this._wijgrid._field("leaves"), function (key, leaf) {
                    // clear sorting
                    if(mapSortingParams) {
                        leaf.sortOrder = 0;
                        leaf.sortDirection = "none";
                    }
                    // clear filtering
                    if(mapFilteringParams) {
                        leaf.filterOperator = "nofilter";
                        leaf.filterValue = undefined;
                    }
                    leavesByDataKey[leaf.dataKey] = leaf;
                });
                if(mapPagingParams && pagedDataView) {
                    this._wijgrid.options.pageSize = pagedDataView.pageSize();
                    this._wijgrid.options.pageIndex = pagedDataView.pageIndex();
                }
                if(mapSortingParams && (foo = this.DVSortingSettings())) {
                    $.each(foo, function (idx, o) {
                        var leaf;
                        if((leaf = leavesByDataKey[o.dataKey])) {
                            leaf.sortDirection = o.sortDirection;
                            leaf.sortOrder = idx// restore sort order
                            ;
                        }
                    });
                }
                if(mapFilteringParams) {
                    if(foo = this.DVFilteringSettings()) {
                        $.each(foo, function (key, o) {
                            var leaf;
                            if((leaf = leavesByDataKey[o.dataKey])) {
                                leaf.filterValue = o.filterValue;
                                leaf.filterOperator = o.filterOperator;
                                if($.isPlainObject(leaf.filterOperator)) {
                                    // custom operator, convert operator object to operator name.
                                    leaf.filterOperator = leaf.filterOperator.name;
                                }
                                delete self._wijgrid.deficientFilters[leaf.dataKey]// unary operator?
                                ;
                            }
                        });
                    }
                    $.each(this._wijgrid.deficientFilters, function (dataKey, defFilter) {
                        leavesByDataKey[dataKey].filterOperator = defFilter.filterOperator;
                        leavesByDataKey[dataKey].filterValue = defFilter.filterValue;
                    });
                }
            };
            settingsManager.prototype._mapPagingParams = function () {
                return this._wijgrid.options.allowPaging && !this._wijgrid._customPagingEnabled() && !this._wijgrid._serverShaping();// used by c1gridview. Disable client paging because source data are paged already and contains items of the current page only.
                
            };
            settingsManager.prototype._mapSortingParams = function () {
                return !this._wijgrid._serverShaping();// used by c1gridview. Disable client sorting because source data are sorted already.
                
            };
            settingsManager.prototype._mapFilteringParams = function () {
                return !this._wijgrid._serverShaping();// used by c1gridview. Disable client filtering because source data are filtered already.
                
            };
            settingsManager.prototype.makeProxyFilter = function (owner, prop, name, value) {
                name = name.toLowerCase();
                var self = this, isDateColumn = (owner.dataType === "datetime"), result = {
                    originalOperator: undefined,
                    property: prop,
                    operator: name,
                    value: // name or filter object
                    value
                };
                var internalOp = this._filterCache.getByNameInt(name);
                var builtinOp = wijmo.data.filtering.ops[name];
                if((name !== "nofilter") && (internalOp.isCustom || isDateColumn)) {
                    // need to create a proxy filter
                    result.originalOperator = result.operator;
                    if(internalOp.isCustom) {
                        result.operator = $.extend(true, {
                        }, internalOp.op);
                        result.operator.apply = result.operator.operator// wijdata requires apply() function instead of operator().
                        ;
                    } else {
                        // date column
                        result.operator = $.extend(true, {
                        }, builtinOp);
                        var filterRequirements = owner.inputType ? wijmo.grid.TimeUnitConverter.convertInputType(owner.inputType) : // inputType takes precedence
                        wijmo.grid.TimeUnitConverter.convertFormatString(owner.dataFormatString || "d");
                        result.operator.apply = function (a, b) {
                            if(!(a instanceof Date)) {
                                a = self._wijgrid.parse(owner, a);
                            }
                            if(!(b instanceof Date)) {
                                b = self._wijgrid.parse(owner, b);
                            }
                            wijmo.grid.TimeUnitConverter.cutDate(a, filterRequirements);
                            wijmo.grid.TimeUnitConverter.cutDate(b, filterRequirements);
                            // compare formatted values
                            //a = self._wijgrid.toStr(owner, a);
                            //b = self._wijgrid.toStr(owner, b);
                            return builtinOp.apply(a, b);
                        };
                    }
                }
                return result;
            };
            settingsManager.prototype._convertFilterToDV = // conversion from wijgrid format
            function (normalizedFilter) {
                var result = {
                }, manager = this;
                $.each(normalizedFilter, function (i, group) {
                    var prop = group.dataKey, currConds = [], currConn = "and", conn, operators, values, conds;
                    if(!$.isPlainObject(group)) {
                        return;
                    }
                    operators = group.filterOperator;
                    values = group.filterValue;
                    if(operators == null) {
                        return;
                    }
                    if(!$.isArray(operators)) {
                        operators = [
                            operators
                        ];
                    }
                    if(!$.isArray(values)) {
                        values = [
                            values
                        ];
                    }
                    if(operators.length != values.length) {
                        throw "The number of filter operators must match the number of filter values";
                    }
                    if(operators.length == 0) {
                        return;
                    }
                    $.each(operators, function (i, operator) {
                        var value;
                        if(typeof operator === "string") {
                            operator = {
                                name: operator
                            };
                        }
                        if(!$.isPlainObject(operator) || !operator.name) {
                            throw "Invalid filter operator";
                        }
                        value = values[i];
                        if(!$.isArray(value)) {
                            value = [
                                value
                            ];
                        }
                        conds = $.map(value, function (operand) {
                            return manager.makeProxyFilter(group.owner, prop, operator.name, operand);
                        });
                        function adjustConds() {
                            if(conds.length > 1) {
                                conds.splice(0, 0, "or");
                            } else {
                                conds = conds[0];
                            }
                        }
                        function adjustCurrConds() {
                            if(currConn == null) {
                                currConn = conn;
                                currConds.splice(0, 0, conn);
                            }
                        }
                        currConn = null;
                        conn = operator.condition || "or";
                        if(currConds.length <= 1 || currConn == conn) {
                            if(conds.length == 1 || currConds.length <= 1 || currConn == "or") {
                                currConds = currConds.concat(conds);
                                adjustCurrConds();
                            } else {
                                adjustConds();
                                currConds.push(conds);
                                adjustCurrConds();
                            }
                        } else {
                            adjustConds();
                            currConds = [
                                currConds, 
                                conds
                            ];
                            adjustCurrConds();
                        }
                    });
                    $.each(currConds, function (j, cond) {
                        if($.isArray(cond) && cond.length == 2) {
                            currConds[j] = cond[1];
                        }
                    });
                    if(currConds.length == 2 && typeof (currConds[0] === "string")) {
                        currConds.shift();
                    }
                    if(currConds.length == 1) {
                        currConds = currConds[0]// unwrap single filter
                        ;
                    }
                    result[prop] = currConds;
                })// $.each(normalizedFilter)
                ;
                return result;
            };
            return settingsManager;
        })();
        grid.settingsManager = settingsManager;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="../../../data/src/dataView.ts"/>
    /// <reference path="../data/dataViewAdapter.ts"/>
    /// <reference path="../data/koDataView.ts"/>
    /// <reference path="interfaces.ts"/>
    /// <reference path="misc.ts"/>
    /// <reference path="wijgrid.ts"/>
    /// <reference path="settingsManager.ts"/>
    /// <reference path="htmlTableAccessor.ts"/>
    /// <reference path="tally.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var dataViewWrapper = (function () {
            function dataViewWrapper(wijgrid) {
                this._domSource = null;
                this._ignoreAllEvents = false;
                this._ignoreChangeEvent = false;
                this._ignoreCurrentChangedEvent = false;
                this._sharedDataItems = null;
                this._userData = null;
                this._totals = null;
                this._changeTimer = 0;
                this._toDispose = [];
                this._isOwnDataView = false;
                this._isWijdatasource = false;
                this._isKODataView = false;
                this._isDynamicWijdatasource = false;
                this._wijgrid = wijgrid;
                this._createDataViewWrapper()// set _dataView
                ;
            }
            dataViewWrapper.prototype.data = function () {
                var dataView = this._getDataViewInst(), pagedDataView = wijmo.grid.asPagedDataView(dataView);
                return {
                    data: this._getSharedDataItems(),
                    totalRows: // totalRows: dataView().length,
                    pagedDataView != null ? pagedDataView.totalItemCount() : (dataView.getSource() || []).length,
                    totals: this._getTotals(),
                    emptyData: this.isBoundedToDOM() ? this._domSource.emptyData : null
                };
            };
            dataViewWrapper.prototype.dataView = function () {
                return this._getDataViewInst();
            };
            dataViewWrapper.prototype.dispose = function () {
                var dataView = this._getDataViewInst();
                this._propChangeListener.dispose();
                $.each(this._toDispose, function (_, disposable) {
                    disposable.dispose();
                });
                if(dataView && this._isOwnDataView) {
                    dataView.dispose();
                }
                this._wijgrid._wijDataView = null;
            };
            dataViewWrapper.prototype.ignoreChangeEvent = function (value) {
                if(arguments.length) {
                    this._ignoreChangeEvent = (value === true);
                } else {
                    return this._ignoreChangeEvent;
                }
            };
            dataViewWrapper.prototype.ignoreCurrentChangedEvent = function (value) {
                if(arguments.length) {
                    this._ignoreCurrentChangedEvent = (value === true);
                } else {
                    return this._ignoreCurrentChangedEvent;
                }
            };
            dataViewWrapper.prototype.isDataLoaded = function () {
                var dataView = this._getDataViewInst();
                return dataView.isLoaded();
            };
            dataViewWrapper.prototype.isOwnDataView = function () {
                return this._isOwnDataView;
            };
            dataViewWrapper.prototype.getFieldsInfo = function () {
                var dataView = this._getDataViewInst();
                return this._propDescriptorsToFieldsInfo(dataView.getProperties());
            };
            dataViewWrapper.prototype._propDescriptorsToFieldsInfo = function (propDescriptors) {
                var result = {
                };
                if(propDescriptors) {
                    $.each(propDescriptors, function (_, prop) {
                        if(prop.name === "$$hash" || prop.name === "$$hashKey") {
                            // exclude $$hash property (Angular).
                            return;
                        }
                        result[prop.name] = {
                            name: prop.name,
                            type: prop.type || "string"
                        };
                    });
                }
                return result;
            };
            dataViewWrapper.prototype.isBoundedToDOM = function () {
                return this._domSource !== null;
            };
            dataViewWrapper.prototype.load = function (userData) {
                this._userData = userData;
                var dataView = this._getDataViewInst();
                if(!dataView) {
                    this._createDataViewWrapper();
                    dataView = this._getDataViewInst();
                }
                this._onDataViewLoading();
                var sm = new wijmo.grid.settingsManager(this._wijgrid);
                if((userData && userData.forceDataLoad) || this._needToLoad(sm)) {
                    var loadParams = sm.MapWGToDV(), local = false;
                    if(this._isWijdatasource && !this._isDynamicWijdatasource && dataView.isLoaded()) {
                        local = true;
                    }
                    // ** ensure pageIndex
                                        var pagedDataView = wijmo.grid.asPagedDataView(dataView), totalItems = -1;
                    // if paging is enabled and dataView provides totalItemCount then ensure that pageIndex is within[0; pageCount) range.
                    if(pagedDataView && (loadParams.pageSize >= 0) && ((totalItems = pagedDataView.totalItemCount()) >= 0)) {
                        // ** 47731: handle situation when underlying array was changed directly by user.
                        if(this._isOwnDataView && !this._isKODataView && (pagedDataView.pageSize() > 0)) {
                            // test if dataView is paged already
                            var source = pagedDataView.getSource();
                            if(source && (source.length < /*!==*/ totalItems)) {
                                totalItems = source.length;
                            }
                        }
                        // 47731 **
                                                var pageCount = Math.ceil(totalItems / loadParams.pageSize) || 1, pageIndex = loadParams.pageIndex;
                        if(pageIndex >= pageCount) {
                            pageIndex = Math.max(0, pageCount - 1);
                        }
                        loadParams.pageIndex = pageIndex;
                    }
                    // ensure pageIndex **
                    this.ignoreCurrentChangedEvent(true)// The currentPositionChanged event fires before the change event, stop listening. Listening will  be restored in the _onDataViewReset method.
                    ;
                    dataView.refresh(loadParams, local);
                } else {
                    if(this.isDataLoaded()) {
                        this._onDataViewLoaded();
                        this._onDataViewReset()// suppose that data is loaded, send notification to wijgrid.
                        ;
                    }
                }
            };
            dataViewWrapper.prototype.currentPosition = function (rowIndex) {
                var dataView = this._getDataViewInst();
                if(!arguments.length) {
                    return dataView.currentPosition();
                }
                this.ignoreCurrentChangedEvent(true);
                try  {
                    dataView.currentPosition(rowIndex);
                }finally {
                    this.ignoreCurrentChangedEvent(false);
                }
            };
            dataViewWrapper.prototype.getValue = function (indexOrItem, key) {
                var dataView = this._getDataViewInst();
                if(typeof (key) === "number") {
                    key = key + "";
                }
                return dataView.getProperty(indexOrItem, key);
            };
            dataViewWrapper.prototype.setValue = function (indexOrItem, key, value) {
                var dataView = this._getDataViewInst();
                this.ignoreChangeEvent(true);
                try  {
                    if(typeof (key) === "number") {
                        key = key + "";
                    }
                    dataView.setProperty(indexOrItem, key, value);
                }finally {
                    this.ignoreChangeEvent(false);
                }
            };
            dataViewWrapper.prototype.makeDirty = function () {
                this._propChangeListener.removeAll()// remove old subscriptions
                ;
                this._totals = null;
                this._sharedDataItems = null;
            };
            dataViewWrapper.prototype._createDataViewWrapper = function () {
                var dataItemToGetProperties, data = this._wijgrid.options.data, dataView = this._getDataViewInst(), isWijdatasource = false;
                if(dataView) {
                    return;
                }
                if(!data) {
                    // DOM
                    this._domSource = this._processDOM(this._wijgrid.element, this._wijgrid.options.readAttributesFromData);
                    data = this._domSource.items;
                }
                isWijdatasource = (typeof (wijdatasource) !== "undefined" && (data instanceof wijdatasource));
                this._isKODataView = data instanceof wijmo.grid.koDataView;
                this._isOwnDataView = ($.isArray(data) || isWijdatasource || this._isKODataView);
                this._isWijdatasource = !!(this._isOwnDataView && isWijdatasource);
                //this._isRemoteWijdatasource = !!(this._isOwnDataView && isWijdatasource && data.proxy);
                this._isDynamicWijdatasource = !!(this._isOwnDataView && isWijdatasource && data.dynamic);
                if(this._isOwnDataView && !this._isKODataView) {
                    if(!this._domSource && this._wijgrid.options.readAttributesFromData) {
                        this._moveAttributesToExpando(data);
                    }
                    var tBody = this.isBoundedToDOM() && wijmo.grid.getTableSection(this._wijgrid.element, wijmo.grid.rowScope.body);
                    dataView = wijmo.grid.GridDataView.create(wijmo.data.asDataView(this._parseOwnData(data, tBody)));
                } else {
                    dataView = data;
                }
                this._wijgrid._wijDataView = dataView;
                this._toDispose.push(dataView.isLoading.subscribe($.proxy(this._onDataViewLoadingInternal, this)));
                this._toDispose.push(dataView.isLoaded.subscribe($.proxy(this._onDataViewLoadedInternal, this)));
                this._toDispose.push(dataView.subscribe($.proxy(this._onDataViewChangeInternal, this)));
                this._toDispose.push(dataView.currentPosition.subscribe($.proxy(this._onDataViewCurrentChangedInternal, this)));
                this._propChangeListener = new wijmo.grid.propChangeListener($.proxy(this._onPropertyChanged, this));
            };
            dataViewWrapper.prototype._parseOwnData = function (data, tbody) {
                var self = this;
                if(data && data.length) {
                    var columns = $.extend(true, [], this._wijgrid.options.columns), props = wijmo.data.ArrayDataViewBase._getProps(data[0]) || [], fieldsInfo = this._propDescriptorsToFieldsInfo(props), dataLeaves = [];
                    this._wijgrid._prepareColumnOptions(columns, "merge", fieldsInfo, true, true);
                    wijmo.grid.traverse(columns, function (column) {
                        if(wijmo.grid.getDataType(column) !== "string" && wijmo.grid.validDataKey(column.dataKey)) {
                            dataLeaves.push(column);
                        }
                    });
                    if(dataLeaves.length && tbody) {
                        $.each(data, function (i, dataItem) {
                            wijmo.grid.dataViewWrapper._parseDataItem(self._wijgrid, dataItem, (tbody && tbody.rows[i]), dataLeaves);
                        });
                    }
                }
                return data;
            };
            dataViewWrapper._parseDataItem = function _parseDataItem(parseHandler, dataItem, domRow, leaves) {
                $.each(leaves, function (i, leaf) {
                    var value = dataItem[leaf.dataKey], newValue = parseHandler.parse(leaf, value);
                    if(isNaN(newValue)) {
                        // failed
                        var domCell = null;
                        if(domRow) {
                            domCell = domRow.cells[leaf.dataKey];
                        }
                        newValue = parseHandler.parseFailed(leaf, value, dataItem, domCell);
                    }
                    dataItem[leaf.dataKey] = newValue;
                });
                return dataItem;
            };
            dataViewWrapper.prototype._getDataViewInst = function () {
                return this._wijgrid._wijDataView;
            };
            dataViewWrapper.prototype._needToLoad = function (settingsManager) {
                var dataView = this._getDataViewInst();
                if(this._isDynamicWijdatasource || (this._isWijdatasource && !dataView.isLoaded())) {
                    return true;
                }
                if(this._isOwnDataView && !this._isWijdatasource && this.isDataLoaded()) {
                    // TFS Issue #36277
                    return true;
                }
                if(this.isDataLoaded() || dataView.isLoading()) {
                    // data is loaded already or loading, check reshaping settings
                    return !settingsManager.compareSettings();
                }
                return true;// data is not loaded yet or user want to load them manually
                
            };
            dataViewWrapper.prototype._validateSettings = function (settingsManager) {
                if(!this._isOwnDataView && this._wijgrid.options.allowPaging && ((settingsManager.DVPagingSettings() || {
                }).pageSize !== (settingsManager.WGPagingSettings() || {
                }).pageSize)) {
                    throw "The pageSize option of the external dataView can't be changed.";
                }
            };
            dataViewWrapper.prototype._onDataViewLoadingInternal = // ** dataView events handlers
            function (isLoading) {
                if(this._ignoreAllEvents) {
                    return;
                }
                if(isLoading) {
                    if(!this._userData) {
                        // triggered outside
                        this._onDataViewLoading();
                    }
                }
            };
            dataViewWrapper.prototype._onDataViewLoadedInternal = function (isLoaded) {
                if(this._ignoreAllEvents) {
                    return;
                }
                if(isLoaded) {
                    this._onDataViewLoaded();
                }
            };
            dataViewWrapper.prototype._onDataViewChangeInternal = function (args) {
                var self = this;
                if(this._ignoreAllEvents || this._ignoreChangeEvent) {
                    return;
                }
                if(args.changes) {
                    if(args.length && args[0].entityState() === "detached")// check first item only, suppose that other items have the same entityState.
                     {
                        return;// do not handle the detached items
                        
                    }
                    $.each(args.changes, function (_, change) {
                        switch(change.changeType) {
                            case "remove":
                                self._propChangeListener.remove(change.index);
                                break;
                            case "add":
                                self._propChangeListener.insert(change.index, change.element);
                                break;
                        }
                    });
                }
                this._onDataViewChange.apply(this, arguments);
            };
            dataViewWrapper.prototype._onDataViewCurrentChangedInternal = function () {
                if(this._ignoreAllEvents || this._ignoreCurrentChangedEvent) {
                    return;
                }
                this._onDataViewCurrentChanged.apply(this, arguments);
            };
            dataViewWrapper.prototype._onDataViewReset = // dataView events handlers **
            // ** event handlers
            function () {
                try  {
                    this.ignoreCurrentChangedEvent(false)// restore listening (see the load() method).
                    ;
                    this.makeDirty()// force to recreate  the _totals and _sharedDataItems fields when the this.data() method will be called.
                    ;
                    this._wijgrid._onDataViewReset(this._userData, this._isKODataView)// 47851: recreate columns each time if koDataView is used to handle situation when observable array value was changed completely: viewModel.property([]) -> viewModel.property([a, b, c]).
                    ;
                }finally {
                    this._userData = null;
                }
            };
            dataViewWrapper.prototype._onPropertyChanged = function (newValue) {
                var self = this;
                if(this._changeTimer > 0) {
                    window.clearTimeout(this._changeTimer);
                    this._changeTimer = 0;
                }
                if(this._changeTimer != -1) {
                    this._changeTimer = window.setTimeout(function () {
                        self._changeTimer = -1;
                        if(!self._wijgrid._destroyed) {
                            self._onDataViewChange();
                        }
                        self._changeTimer = 0;
                    }, 100);
                }
            };
            dataViewWrapper.prototype._onDataViewChange = // args can be empty
            function (args) {
                this._onDataViewReset()// force re-rendering. TODO: handle "add", "remove", "modify" etc.
                ;
            };
            dataViewWrapper.prototype._onDataViewCurrentChanged = function (e, args) {
                this._wijgrid._onDataViewCurrentPositionChanged(e, args);
            };
            dataViewWrapper.prototype._onDataViewLoading = function () {
                this._wijgrid._onDataViewLoading();
            };
            dataViewWrapper.prototype._onDataViewLoaded = function () {
                this._wijgrid._onDataViewLoaded();
            };
            dataViewWrapper.prototype._getSharedDataItems = // event handlers **
            function () {
                if(!this._sharedDataItems) {
                    var dataView = this._getDataViewInst(), len = dataView.count();
                    this._sharedDataItems = [];
                    var firstWiredSuccessfully = true;
                    for(var i = 0; i < len; i++) {
                        var dataItem = dataView.item(i);
                        // optimization: listen only if it is the first attempt or the first attempt was successful
                        if(firstWiredSuccessfully) {
                            if(!this._propChangeListener.insert(i, dataItem) && i === 0) {
                                firstWiredSuccessfully = false;
                            }
                        }
                        this._sharedDataItems.push(this._wrapDataItem(dataItem, i));
                    }
                }
                if(!this._sharedDataItems) {
                    this._sharedDataItems = [];
                }
                return this._sharedDataItems;
            };
            dataViewWrapper.prototype._getTotals = function () {
                if(!this._totals) {
                    var dataView = this._getDataViewInst();
                    this._totals = this._prepareTotals(dataView, this._wijgrid._prepareTotalsRequest(true));
                }
                if(!this._totals) {
                    this._totals = {
                    };
                }
                return this._totals;
            };
            dataViewWrapper.prototype._prepareTotals = function (dataView, request) {
                if(!request || request.length === 0) {
                    return {
                    };
                }
                var i, len, j, len2, tallies = [], result = {
                };
                for(i = 0 , len = request.length; i < len; i++) {
                    tallies.push(new wijmo.grid.tally());
                }
                for(i = 0 , len = dataView.count(); i < len; i++) {
                    for(j = 0 , len2 = tallies.length; j < len2; j++) {
                        tallies[j].add(this._wijgrid.parse(request[j].column, this.getValue(i, request[j].column.dataKey)));
                    }
                }
                for(i = 0 , len = tallies.length; i < len; i++) {
                    result[request[i].column.dataKey] = tallies[i].getValueString(request[i].column);
                }
                return result;
            };
            dataViewWrapper.prototype._processDOM = // ** DOM
            function ($obj, readAttributes) {
                var result = {
                    items: [],
                    emptyData: [],
                    header: wijmo.grid.readTableSection($obj, wijmo.grid.rowScope.head)
                };
                if(wijmo.grid.getTableSectionLength($obj, 2) === 1 && $(wijmo.grid.getTableSectionRow($obj, 2, 0)).hasClass(wijmo.grid.wijgrid.CSS.emptyDataRow)) {
                    // special case - empty data row
                    result.emptyData = wijmo.grid.readTableSection($obj, wijmo.grid.rowScope.body);
                } else {
                    // read data rows
                    result.items = wijmo.grid.readTableSection($obj, wijmo.grid.rowScope.body, readAttributes);
                }
                return result;
            };
            dataViewWrapper.prototype._moveAttributesToExpando = // DOM **
            function (rawData) {
                $.each(rawData, function (i, item) {
                    var expando = (wijmo).data.Expando.getFrom(item, true), rowMeta;
                    rowMeta = expando[wijmo.grid.EXPANDO] = {
                        cellsAttributes: {
                        },
                        rowAttributes: {
                        }
                    }// store attributes within the original item using Expando
                    ;
                    if(item.rowAttributes) {
                        rowMeta.rowAttributes = item.rowAttributes;
                        delete item.rowAttributes;
                    }
                    ;
                    $.each(item, function (dataKey, dataValue) {
                        if($.isArray(dataValue)) {
                            rowMeta.cellsAttributes[dataKey] = dataValue[1];
                            item[dataKey] = dataValue[0];
                        }
                    });
                });
            };
            dataViewWrapper.prototype._wrapDataItem = function (dataItem, dataItemIndex) {
                return {
                    values: dataItem,
                    originalRowIndex: dataItemIndex
                };
            };
            dataViewWrapper.prototype._refreshSilent = // ** used by c1gridview to update underlying data during callbacks.
            function () {
                // used by c1gridview to refresh underlying data during callbacks.
                var dataView = this._getDataViewInst();
                if(dataView) {
                    try  {
                        this._ignoreAllEvents = true;
                        dataView.refresh();
                    }finally {
                        this._ignoreAllEvents = false;
                    }
                }
            };
            dataViewWrapper.prototype._unsafeReplace = function (index, newItem) {
                var dataView = this._getDataViewInst();
                if(!(dataView instanceof wijmo.grid.GridDataView)) {
                    "operation is not supported";
                }
                dataView._unsafeReplace(index, newItem);
            };
            dataViewWrapper.prototype._unsafeSplice = function (index, count, item) {
                var dataView = this._getDataViewInst();
                if(!(dataView instanceof wijmo.grid.GridDataView)) {
                    "operation is not supported";
                }
                if(arguments.length === 2) {
                    dataView._unsafeSplice(index, count);
                } else {
                    dataView._unsafeSplice(index, count, item);
                }
            };
            dataViewWrapper.prototype._unsafePush = function (item) {
                var dataView = this._getDataViewInst();
                if(!(dataView instanceof wijmo.grid.GridDataView)) {
                    "operation is not supported";
                }
                dataView._unsafePush(item);
            };
            return dataViewWrapper;
        })();
        grid.dataViewWrapper = dataViewWrapper;        
        // used by c1gridview to refresh underlying data during callbacks **
        /** @ignore */
        function asPagedDataView(dataView) {
            return dataView && ("pageCount" in dataView) ? dataView : null;
        }
        grid.asPagedDataView = asPagedDataView;
        /** @ignore */
        function asEditableDataView(dataView) {
            return dataView && ("commitEdit" in dataView) ? dataView : null;
        }
        grid.asEditableDataView = asEditableDataView;
        /** @ignore */
        var propChangeListener = (function () {
            function propChangeListener(callback) {
                this._subscriptions = [];
                this._callback = callback;
            }
            propChangeListener.prototype.insert = function (index, dataViewItem) {
                var itemSubscrArray = null, self = this;
                $.each(dataViewItem, function (key, value) {
                    if(self._isValidPropName(key) && value && $.isFunction(value.subscribe)) {
                        itemSubscrArray = itemSubscrArray || [];
                        itemSubscrArray.push(value.subscribe(self._callback));
                    }
                });
                if(!itemSubscrArray) {
                    // we didn't subscribe in fact
                    return false;
                }
                if(this._subscriptions.length < index) {
                    // inflate the array before inserting
                    this._subscriptions.length = index;
                }
                this._subscriptions.splice(index, 0, itemSubscrArray);
                return true;
            };
            propChangeListener.prototype.remove = function (index) {
                var subscrArray = this._subscriptions[index];
                if(subscrArray) {
                    $.each(subscrArray, function (key, propSubscr) {
                        propSubscr.dispose();
                        subscrArray[key] = null;
                    });
                }
                this._subscriptions[index] = null;
                this._subscriptions.splice(index, 1);
            };
            propChangeListener.prototype.removeAll = function () {
                var len, subscr;
                while(len = this._subscriptions.length) {
                    this.remove(len - 1);
                }
                this._subscriptions = [];
            };
            propChangeListener.prototype.dispose = function () {
                this.removeAll();
            };
            propChangeListener.prototype._isValidPropName = function (name) {
                if(name && (typeof (name) === "string")) {
                    return name.match(/^entityState|jQuery/) === null;
                }
                return true;
            };
            return propChangeListener;
        })();
        grid.propChangeListener = propChangeListener;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="../../../wijutil/jquery.wijmo.wijutil.ts" />
    /// <reference path="interfaces.ts"/>
    /// <reference path="merger.ts"/>
    /// <reference path="wijgrid.ts"/>
    /// <reference path="groupHelper.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var groupRange = (function () {
            function groupRange(expanded, range, sum, position, hasHeaderOrFooter) {
                this.cr = new wijmo.grid.cellRange(-1, -1);
                this.isExpanded = false;
                this.position = "none";
                this._sum = -1;
                this._hasHeaderOrFooter = true;
                if(expanded !== undefined) {
                    this.isExpanded = expanded;
                }
                if(range !== undefined) {
                    this.cr = range;
                }
                if(sum !== undefined) {
                    this._sum = sum;
                }
                if(position !== undefined) {
                    this.position = position;
                }
                if(hasHeaderOrFooter !== undefined) {
                    this._hasHeaderOrFooter = hasHeaderOrFooter;
                }
            }
            groupRange.prototype.isSubRange = function (groupRange) {
                return ((this.cr.r1 >= groupRange.cr.r1) && (this.cr.r2 <= groupRange.cr.r2));
            };
            groupRange.prototype.toString = function () {
                return this.cr.r1 + "-" + this.cr.r2;
            };
            groupRange.prototype.collapse = function () {
                var groupInfo, column, grid, leaves, groupedColumnsCnt;
                if((groupInfo = this.owner) && (column = groupInfo.owner) && (grid = column.owner)) {
                    leaves = grid._field("leaves");
                    if(wijmo.grid.groupHelper.isParentExpanded(leaves, this.cr, groupInfo.level)) {
                        if((groupInfo.position !== "footer") && (groupInfo.outlineMode !== "none")) {
                            // do not collapse groups with .position == "footer"
                            groupedColumnsCnt = wijmo.grid.groupHelper.getGroupedColumnsCount(leaves);
                            this._collapse(grid, grid._rows(), leaves, this, groupedColumnsCnt, grid._allowVirtualScrolling());
                        }
                    }
                }
            };
            groupRange.prototype.expand = function (expandChildren) {
                var groupInfo, column, grid, leaves, groupedColumnsCnt;
                if((groupInfo = this.owner) && (column = groupInfo.owner) && (grid = column.owner)) {
                    leaves = grid._field("leaves");
                    if(wijmo.grid.groupHelper.isParentExpanded(leaves, this.cr, groupInfo.level)) {
                        groupedColumnsCnt = wijmo.grid.groupHelper.getGroupedColumnsCount(leaves);
                        /*var tbody = grid.$table.find("> tbody")[0];*/
                        this._expand(grid, grid._rows(), leaves, this, groupedColumnsCnt, expandChildren, true, grid._allowVirtualScrolling());
                    }
                }
            };
            groupRange.prototype._collapse = function (grid, rowAccessor, leaves, groupRange, groupedColumnsCnt, virtualScrollingEnabled) {
                var groupInfo = groupRange.owner, dataStart = groupRange.cr.r1, dataEnd = groupRange.cr.r2, i, len, childRanges, childRange, j;
                switch(groupInfo.position) {
                    case "header":
                    case "headerAndFooter":
                        this._toggleSketchRowVisibility(grid.sketchTable.row(groupRange.cr.r1), undefined, false);
                        if(!virtualScrollingEnabled) {
                            this._toggleRowVisibility(grid, rowAccessor.item(groupRange.cr.r1), undefined, false);
                        }
                        dataStart++;
                        break;
                }
                // hide child rows
                for(i = dataStart; i <= dataEnd; i++) {
                    this._toggleSketchRowVisibility(grid.sketchTable.row(i), false, undefined);
                    if(!virtualScrollingEnabled) {
                        this._toggleRowVisibility(grid, rowAccessor.item(i), false, undefined);
                    }
                }
                // update isExpanded property
                groupRange.isExpanded = false;
                for(i = groupInfo.level + 1; i <= groupedColumnsCnt; i++) {
                    childRanges = wijmo.grid.groupHelper.getChildGroupRanges(leaves, groupRange.cr, /*groupRange.owner.level*/ i - 1);
                    for(j = 0 , len = childRanges.length; j < len; j++) {
                        childRange = childRanges[j];
                        childRange.isExpanded = false;
                        // update groupHeader
                        switch(childRange.owner.position) {
                            case "header":
                            case "headerAndFooter":
                                this._toggleSketchRowVisibility(grid.sketchTable.row(childRange.cr.r1), false, false);
                                if(!virtualScrollingEnabled) {
                                    this._toggleRowVisibility(grid, rowAccessor.item(childRange.cr.r1), false, false);
                                }
                                break;
                        }
                    }
                }
            };
            groupRange.prototype._expand = function (grid, rowAccessor, leaves, groupRange, groupedColumnsCnt, expandChildren, isRoot, virtualScrollingEnabled) {
                var groupInfo = groupRange.owner, dataStart = groupRange.cr.r1, dataEnd = groupRange.cr.r2, i, len, childRanges, childRange, childIsRoot;
                switch(groupInfo.position) {
                    case "header":
                        this._toggleSketchRowVisibility(grid.sketchTable.row(dataStart), true, isRoot || expandChildren);
                        if(!virtualScrollingEnabled) {
                            this._toggleRowVisibility(grid, rowAccessor.item(dataStart), true, isRoot || expandChildren);
                        }
                        dataStart++;
                        break;
                    case "footer":
                        this._toggleSketchRowVisibility(grid.sketchTable.row(dataEnd), true, undefined);
                        if(!virtualScrollingEnabled) {
                            this._toggleRowVisibility(grid, rowAccessor.item(dataEnd), true, undefined);
                        }
                        dataEnd--;
                        break;
                    case "headerAndFooter":
                        this._toggleSketchRowVisibility(grid.sketchTable.row(dataStart), true, isRoot || expandChildren);
                        if(!virtualScrollingEnabled) {
                            this._toggleRowVisibility(grid, rowAccessor.item(dataStart), true, isRoot || expandChildren);
                        }
                        if(isRoot) {
                            this._toggleSketchRowVisibility(grid.sketchTable.row(dataEnd), true, undefined);
                            if(!virtualScrollingEnabled) {
                                this._toggleRowVisibility(grid, rowAccessor.item(dataEnd), true, undefined);
                            }
                        }
                        dataStart++;
                        dataEnd--;
                        break;
                }
                if(isRoot) {
                    groupRange.isExpanded = true;
                } else {
                    return;
                }
                if(groupRange.owner.level === groupedColumnsCnt) {
                    // show data rows
                    for(i = dataStart; i <= dataEnd; i++) {
                        this._toggleSketchRowVisibility(grid.sketchTable.row(i), true, undefined);
                        if(!virtualScrollingEnabled) {
                            this._toggleRowVisibility(grid, rowAccessor.item(i), true, undefined);
                        }
                    }
                } else {
                    childRanges = wijmo.grid.groupHelper.getChildGroupRanges(leaves, groupRange.cr, groupRange.owner.level);
                    if(childRanges.length && (dataStart !== childRanges[0].cr.r1)) {
                        //
                        // a space between parent groupHeader and first child range - show single rows (groupSingleRow = false)
                        for(i = dataStart; i < childRanges[0].cr.r1; i++) {
                            this._toggleSketchRowVisibility(grid.sketchTable.row(i), true, undefined);
                            if(!virtualScrollingEnabled) {
                                this._toggleRowVisibility(grid, rowAccessor.item(i), true, undefined);
                            }
                        }
                    }
                    if(expandChildren) {
                        // throw action deeper
                        for(i = 0 , len = childRanges.length; i < len; i++) {
                            childRange = childRanges[i];
                            this._expand(grid, rowAccessor, leaves, childRange, groupedColumnsCnt, expandChildren, true, virtualScrollingEnabled);
                        }
                    } else {
                        // show only headers of the child groups or fully expand child groups with .position == "footer"\ .outlineMode == "none"
                        for(i = 0 , len = childRanges.length; i < len; i++) {
                            childRange = childRanges[i];
                            childIsRoot = (childRange.owner.position === "footer" || childRange.owner.outlineMode === "none") ? true : false;
                            this._expand(grid, rowAccessor, leaves, childRange, groupedColumnsCnt, false, childIsRoot, virtualScrollingEnabled);
                        }
                    }
                }
            };
            groupRange.prototype._toggleRowVisibility = function (grid, rowObj, visible, expanded) {
                if(rowObj) {
                    var rse = wijmo.grid.renderStateEx, view = grid._view(), rowInfo = view._getRowInfo(rowObj, false);
                    if(visible !== undefined) {
                        if(visible) {
                            rowInfo._extInfo.state &= ~rse.hidden;
                        } else {
                            rowInfo._extInfo.state |= rse.hidden;
                        }
                    }
                    if(expanded !== undefined) {
                        if(expanded) {
                            rowInfo._extInfo.state &= ~rse.collapsed;
                        } else {
                            rowInfo._extInfo.state |= rse.collapsed;
                        }
                    }
                    view._setRowInfo(rowInfo.$rows, rowInfo);
                    grid.rowStyleFormatter._groupFormatter(rowInfo);
                }
            };
            groupRange.prototype._toggleSketchRowVisibility = function (sketchRow, visible, expanded) {
                if(sketchRow) {
                    var rse = wijmo.grid.renderStateEx;
                    if(visible !== undefined) {
                        if(visible) {
                            sketchRow.extInfo.state &= ~rse.hidden;
                        } else {
                            sketchRow.extInfo.state |= rse.hidden;
                        }
                    }
                    if(expanded !== undefined) {
                        if(expanded) {
                            sketchRow.extInfo.state &= ~rse.collapsed;
                        } else {
                            sketchRow.extInfo.state |= rse.collapsed;
                        }
                    }
                }
            };
            return groupRange;
        })();
        grid.groupRange = groupRange;        
        /** @ignore */
        var grouper = (function () {
            function grouper() {
                this._groupRowIdx = 0;
            }
            grouper.prototype.group = function (grid, data, leaves) {
                this._grid = grid;
                this._sketchTable = data;
                this._leaves = leaves;
                this._groupRowIdx = 0;
                try  {
                    this._group();
                }finally {
                    delete this._grid;
                    delete this._sketchTable;
                    delete this._leaves;
                }
            };
            grouper.prototype._group = function () {
                var _this = this;
                $.each(this._leaves, function (i, column) {
                    if(column.groupInfo) {
                        delete column.groupInfo.level;
                        delete column.groupInfo.expandInfo;
                    }
                });
                var groupedColumns = this._grid._groupedColumns(true), level = 1;
                if(groupedColumns.length == 0) {
                    return;
                }
                // make sure all rows are created
                this._sketchTable.ensureNotLazy();
                $.each(groupedColumns, function (i, column) {
                    _this._groupRowIdx = 0;
                    if(/*(leaf.dynamic !== true) && */ column.groupInfo && (column.groupInfo.position && (column.groupInfo.position !== "none")) && (column.dataIndex >= 0)) {
                        column.groupInfo.level = level;
                        column.groupInfo.expandInfo = [];
                        _this._processRowGroup(column, level++);
                    }
                });
            };
            grouper.prototype._processRowGroup = function (leaf, level) {
                var firstVisibleLeafIdx = 0, hasHeaderOrFooter = true, rse = wijmo.grid.renderStateEx;
                $.each(this._leaves, function (i, leaf) {
                    if(leaf.parentVis) {
                        firstVisibleLeafIdx = i;
                        return false;
                    }
                });
                for(var rowIndex = 0; rowIndex < this._sketchTable.count(); rowIndex++) {
                    var row = this._sketchTable.row(rowIndex);
                    if(!row.isDataRow()) {
                        continue;
                    }
                    var cellRange = this._getGroupCellRange(rowIndex, leaf, level), isExpanded = true, startCollapsed = (leaf.groupInfo.outlineMode === "startCollapsed"), header, footer, groupRange, isParentCollapsed;
                    if(startCollapsed || wijmo.grid.groupHelper.isParentCollapsed(this._leaves, cellRange, level)) {
                        if((leaf.groupInfo.groupSingleRow === false) && (cellRange.r1 === cellRange.r2)) {
                            continue;
                        }
                        isExpanded = false;
                    }
                    // indent
                    if(level && this._grid.options.groupIndent) {
                        for(var indentRow = cellRange.r1; indentRow <= cellRange.r2; indentRow++) {
                            this._addIndent(this._sketchTable.row(indentRow).cell(firstVisibleLeafIdx), level);
                        }
                    }
                    hasHeaderOrFooter = !(leaf.groupInfo.groupSingleRow === false && (cellRange.r1 === cellRange.r2));
                    // insert group header/ group footer
                    switch(leaf.groupInfo.position) {
                        case "header":
                            groupRange = this._addGroupRange(leaf.groupInfo, cellRange, isExpanded, hasHeaderOrFooter);
                            for(var i = cellRange.r1; i <= cellRange.r2; i++) {
                                row = this._sketchTable.row(i);
                                row.extInfo.groupLevel = level + 1;
                                if(!isExpanded) {
                                    row.extInfo.state |= rse.hidden;
                                }
                            }
                            if(!hasHeaderOrFooter) {
                                break;
                            }
                            this._updateByGroupRange(groupRange, level);
                            isParentCollapsed = wijmo.grid.groupHelper.isParentCollapsed(this._leaves, groupRange.cr, level);
                            header = this._buildGroupRow(groupRange, cellRange, true, isParentCollapsed);
                            this._sketchTable.insert(cellRange.r1, header)// insert group header
                            ;
                            header.extInfo.groupLevel = level;
                            if(!isExpanded) {
                                header.extInfo.state |= rse.collapsed;
                            }
                            if(isParentCollapsed) {
                                header.extInfo.state |= rse.hidden;
                            }
                            rowIndex = cellRange.r2 + 1;
                            break;
                        case "footer":
                            groupRange = this._addGroupRange(leaf.groupInfo, cellRange, true, hasHeaderOrFooter);
                            if(!hasHeaderOrFooter) {
                                break;
                            }
                            this._updateByGroupRange(groupRange, level);
                            footer = this._buildGroupRow(groupRange, cellRange, false, false);
                            footer.extInfo.groupLevel = level;
                            this._sketchTable.insert(cellRange.r2 + 1, footer);
                            rowIndex = cellRange.r2 + 1;
                            isParentCollapsed = wijmo.grid.groupHelper.isParentCollapsed(this._leaves, groupRange.cr, level);
                            if(isParentCollapsed) {
                                footer.extInfo.state |= rse.hidden;
                            }
                            break;
                        case "headerAndFooter":
                            groupRange = this._addGroupRange(leaf.groupInfo, cellRange, isExpanded, hasHeaderOrFooter);
                            for(i = cellRange.r1; i <= cellRange.r2; i++) {
                                row = this._sketchTable.row(i);
                                row.extInfo.groupLevel = level + 1;
                                if(!isExpanded) {
                                    row.extInfo.state |= rse.hidden;
                                }
                            }
                            if(!hasHeaderOrFooter) {
                                break;
                            }
                            this._updateByGroupRange(groupRange, level);
                            isParentCollapsed = wijmo.grid.groupHelper.isParentCollapsed(this._leaves, groupRange.cr, level);
                            header = this._buildGroupRow(groupRange, cellRange, true, isParentCollapsed);
                            footer = this._buildGroupRow(groupRange, cellRange, false, false);
                            this._sketchTable.insert(cellRange.r2 + 1, footer);
                            footer.extInfo.groupLevel = level;
                            if(isParentCollapsed || !isExpanded) {
                                footer.extInfo.state |= rse.hidden;
                            }
                            this._sketchTable.insert(cellRange.r1, header);
                            header.extInfo.groupLevel = level;
                            if(!isExpanded) {
                                header.extInfo.state |= rse.collapsed;
                            }
                            if(isParentCollapsed) {
                                header.extInfo.state |= rse.hidden;
                            }
                            rowIndex = cellRange.r2 + 2;
                            break;
                        default:
                            throw wijmo.grid.stringFormat("Unknown Position value: \"{0}\"", leaf.groupInfo.position);
                    }
                    this._groupRowIdx++;
                }
            };
            grouper.prototype._buildGroupRow = function (groupRange, cellRange, isHeader, isParentCollapsed) {
                //when some column is hidden, the group row is not correct.
                                var groupInfo = groupRange.owner, leaf = groupInfo.owner, gridView = leaf.owner, sketchRow = new grid.SketchGroupRow(isHeader, null), groupByValue = undefined, groupByText = "", aggregate = "", cell, tmp, cell, caption, args, span, col, bFirst, agg, defCSS = wijmo.grid.wijgrid.CSS;
                sketchRow.extInfo.groupIndex = this._groupRowIdx// to make a row ID.
                ;
                if((leaf.dataIndex >= 0) && ((groupByValue = this._sketchTable.valueAt(cellRange.r1, leaf.dataIndex)) !== null)) {
                    groupByText = gridView.toStr(leaf, groupByValue);
                }
                sketchRow.groupByValue = groupByValue;
                if(this._grid._showRowHeader()) {
                    sketchRow.add(grid.HtmlCell.nbsp());
                }
                // create the summary cell
                cell = new grid.HtmlCell("", null);
                sketchRow.add(cell);
                // add group header text
                if(leaf.aggregate && (leaf.aggregate !== "none")) {
                    //aggregate = this._getAggregate(cellRange, leaf, groupInfo.owner, isHeader, groupByText);
                    aggregate = this._getAggregate(cellRange, leaf, leaf, isHeader, groupByText);
                    //if (leaf.parentVis) {
                    //	headerOffset = 1;
                    //}
                                    }
                caption = (isHeader) ? groupInfo.headerText : groupInfo.footerText;
                // format caption
                // The text may include up to three placeholders:
                // "{0}" is replaced with the value being grouped on and
                // "{1}" is replaced with the group's column header
                // "{2}" is replaced with the aggregate
                if(caption === "custom") {
                    args = {
                        data: this._sketchTable.getRawTable(),
                        column: // data object.
                        leaf,
                        groupByColumn: // column that is being grouped.
                        groupInfo.owner,
                        groupText: // column initiated grouping.
                        groupByText,
                        text: // text that is being grouped.
                        "",
                        groupingStart: // text that will be displayed in the groupHeader or Footer.
                        cellRange.r1,
                        groupingEnd: // first index for the data being grouped.
                        cellRange.r2,
                        isGroupHeader: // last index for the data being grouped.
                        isHeader,
                        aggregate: aggregate
                    };
                    if(this._grid._trigger("groupText", null, args)) {
                        caption = args.text;
                    }
                } else {
                    if((caption === undefined) || (caption === null)) {
                        // use default formatting
                        if(isHeader) {
                            caption = "{1}: {0}";
                        }
                        if(aggregate || (aggregate === 0)) {
                            caption = caption ? caption + " {2}" : "{2}";
                        }
                    }
                    caption = wijmo.grid.stringFormat(caption, leaf && leaf.encodeHtml ? wijmo.htmlEncode(groupByText) : groupByText, // wijmo.htmlEncode is dangerious
                    leaf && leaf.headerText ? leaf.headerText : "", this._wrapAggregateValue(aggregate));
                }
                if(!caption) {
                    caption = "&nbsp;";
                }
                cell.html += "<span>" + caption + "</span>";
                this._addIndent(cell, groupInfo.level - 1);
                // summary cells span until the end of the row or the first aggregate
                //span = headerOffset;
                span = 1;
                col = (this._grid._showRowHeader()) ? 1 : 0;
                //for (; col < cellRange.c1; col++) { // c1 is an index of the leaf inside the this._leaves
                //	if (this._leaves[col].parentVis) {
                //		span++;
                //	}
                //}
                //col = cellRange.c1 + headerOffset;
                bFirst = true;
                for(; col < this._leaves.length; col++) {
                    tmp = this._leaves[col];
                    if(tmp.parentVis) {
                        if(bFirst) {
                            bFirst = false;
                            continue;
                        }
                        if((tmp.dynamic !== true) && tmp.aggregate && (tmp.aggregate !== "none")) {
                            break;
                        }
                        span++;
                    }
                }
                // add aggregates (or blanks) until the end of the row
                for(; col < this._leaves.length; col++) {
                    tmp = this._leaves[col];
                    if(tmp.parentVis) {
                        agg = this._getAggregate(cellRange, tmp, groupInfo.owner, isHeader, groupByText);
                        if(!agg && (agg !== 0)) {
                            agg = "&nbsp;";
                        }
                        sketchRow.add(new grid.HtmlCell(this._wrapAggregateValue(agg), {
                            groupInfo: {
                                leafIndex: // will be passed into the cellStyleFormatter
                                tmp.leavesIdx,
                                purpose: wijmo.grid.groupRowCellPurpose.aggregateCell
                            }
                        }));
                    }
                }
                cell.ensureAttr().colSpan = span;
                cell.ensureAttr().groupInfo = {
                    leafIndex: leaf.leavesIdx,
                    purpose: wijmo.grid.groupRowCellPurpose.groupCell
                }// will be passed into the cellStyleFormatter
                ;
                return sketchRow;
            };
            grouper.prototype._getAggregate = function (cellRange, column, groupByColumn, isGroupHeader, groupByText) {
                var aggregate = "", args, tally, row;
                if(!column.aggregate || (column.aggregate === "none")) {
                    return aggregate;
                }
                if(column.aggregate === "custom") {
                    args = {
                        data: this._sketchTable.getRawTable(),
                        column: // data object
                        column,
                        groupByColumn: // column that is being grouped.
                        groupByColumn,
                        groupText: // column initiated grouping.
                        groupByText,
                        text: // text that is being grouped.
                        "",
                        groupingStart: // text that will be displayed in the groupHeader or groupFooter.
                        cellRange.r1,
                        groupingEnd: // first index for the data being grouped.
                        cellRange.r2,
                        isGroupHeader: // last index for the data being grouped.
                        isGroupHeader
                    };
                    if(this._grid._trigger("groupAggregate", null, args)) {
                        aggregate = args.text;
                    }
                } else {
                    tally = new wijmo.grid.tally();
                    for(row = cellRange.r1; row <= cellRange.r2; row++) {
                        tally.add(this._sketchTable.valueAt(row, column.dataIndex));
                    }
                    aggregate = tally.getValueString(column);
                }
                return aggregate;
            };
            grouper.prototype._getGroupCellRange = function (rowIndex, leaf, level) {
                var idx = leaf.leavesIdx, row, range = // $.inArray(leaf, this._leaves);
                new wijmo.grid.cellRange(rowIndex, idx), parentRange = wijmo.grid.groupHelper.getParentGroupRange(this._leaves, range, level), value, nextValue, count;
                //if (this._sketchTable[row].rowType === "data") {
                row = this._sketchTable.row(rowIndex);
                if(row.isDataRow()) {
                    value = row.valueCell(leaf.dataIndex).value;
                    if(value instanceof Date) {
                        value = value.getTime();
                    }
                    for(range.r2 = rowIndex , count = this._sketchTable.count() - 1; range.r2 < count; range.r2++) {
                        //if ((this._sketchTable[range.r2 + 1].rowType !== "data") || (parentRange && (range.r2 + 1 > parentRange.r2))) {
                        if(!this._sketchTable.row(range.r2 + 1).isDataRow() || (parentRange && (range.r2 + 1 > parentRange.cr.r2))) {
                            break;
                        }
                        nextValue = this._sketchTable.valueAt(range.r2 + 1, leaf.dataIndex);
                        if(nextValue instanceof Date) {
                            nextValue = nextValue.getTime();
                        }
                        if(value !== nextValue) {
                            break;
                        }
                    }
                }
                return range;
            };
            grouper.prototype._addGroupRange = function (groupInfo, cellRange, isExpanded, hasHeaderOrFooter) {
                var result = null, idx = wijmo.grid.groupHelper.getChildGroupIndex(cellRange, groupInfo.expandInfo), range, expandState, r1, r2;
                if(idx >= 0 && idx < groupInfo.expandInfo.length) {
                    result = groupInfo.expandInfo[idx];
                } else {
                    range = new wijmo.grid.cellRange(cellRange.r1, cellRange.r1, cellRange.r2, cellRange.r2)// clone
                    ;
                    expandState = (groupInfo.position === "footer" || !hasHeaderOrFooter) ? true : isExpanded && (groupInfo.outlineMode !== "startCollapsed");
                    result = new wijmo.grid.groupRange(expandState, range, -1, groupInfo.position, hasHeaderOrFooter);
                    result.owner = groupInfo;
                    groupInfo.expandInfo.push(result);
                }
                if(result && hasHeaderOrFooter) {
                    r1 = cellRange.r1;
                    r2 = cellRange.r2;
                    if(groupInfo.position === "headerAndFooter") {
                        r2 += 2;
                    }
                    if(groupInfo.position !== "headerAndFooter") {
                        r2++;
                    }
                    result.cr.r2 = r2;
                }
                return result;
            };
            grouper.prototype._updateByGroupRange = function (groupRange, level) {
                var i, len, groupInfo, len2, j, cur, delta;
                for(i = 0 , len = this._leaves.length; i < len; i++) {
                    groupInfo = this._leaves[i].groupInfo;
                    if(groupInfo && (groupInfo.level < level)) {
                        len2 = (groupInfo.expandInfo) ? groupInfo.expandInfo.length : 0;
                        for(j = 0; j < len2; j++) {
                            cur = groupInfo.expandInfo[j];
                            delta = (groupRange.position === "headerAndFooter") ? 2 : 1;
                            if(cur.cr.r1 >= groupRange.cr.r1 && !((cur.cr.r1 === groupRange.cr.r1) && (cur.position === "footer"))) {
                                cur.cr.r1 += delta;
                            }
                            if(cur.cr.r2 >= groupRange.cr.r1) {
                                cur.cr.r2 += delta;
                            }
                        }
                    }
                }
            };
            grouper.prototype._addIndent = function (cellObj, level) {
                var indent;
                if(level > 0 && (indent = this._grid.options.groupIndent)) {
                    cellObj.ensureStyle().paddingLeft = (indent * level) + "px";
                }
            };
            grouper.prototype._wrapAggregateValue = function (value) {
                return "<span class='" + wijmo.grid.wijgrid.CSS.aggregateContainer + "'>" + value.toString() + "</span>";
                //return value.toString();
                            };
            return grouper;
        })();
        grid.grouper = grouper;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="merger.ts"/>
    /// <reference path="grouper.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var groupHelper = (function () {
            function groupHelper() { }
            groupHelper._getGroupInfoRegExp = new RegExp(".*G([HF]){1}(\\d+)-(\\d+)$");
            groupHelper.getGroupInfo = function getGroupInfo(row) {
                if(row) {
                    var info = wijmo.grid.groupHelper._getGroupInfoRegExp.exec(row.id), level, index, isHeader;
                    if(info) {
                        level = parseInt(info[3], 10);
                        index = parseInt(info[2], 10);
                        isHeader = (info[1] === "H");
                        return {
                            level: level,
                            index: index,
                            isHeader: isHeader,
                            toString: function () {
                                return (isHeader ? "GH" : "GF") + index + "-" + level;
                            }
                        };
                    }
                }
                return null;
            };
            groupHelper.getColumnByGroupLevel = function getColumnByGroupLevel(leaves, level) {
                var i, len, leaf;
                for(i = 0 , len = leaves.length; i < len; i++) {
                    leaf = leaves[i];
                    if(leaf.groupInfo && (leaf.groupInfo.level === level)) {
                        return leaf;
                    }
                }
                return null;
            };
            groupHelper.getGroupedColumnsCount = function getGroupedColumnsCount(leaves) {
                var result = 0, i, len, groupInfo;
                for(i = 0 , len = leaves.length; i < len; i++) {
                    groupInfo = leaves[i].groupInfo;
                    if(groupInfo && (groupInfo.position === "header" || groupInfo.position === "headerAndFooter" || groupInfo.position === "footer")) {
                        result++;
                    }
                }
                return result;
            };
            groupHelper.getChildGroupIndex = // cellRange cellRange
            // groupRange[] childExpandInfo
            function getChildGroupIndex(cellRange, childExpandInfo) {
                var left = 0, right = childExpandInfo.length - 1, median, cmp;
                while(left <= right) {
                    median = ((right - left) >> 1) + left;
                    cmp = childExpandInfo[median].cr.r1 - cellRange.r1;
                    if(cmp === 0) {
                        return median;
                    }
                    if(cmp < 0) {
                        left = median + 1;
                    } else {
                        right = median - 1;
                    }
                }
                return left;
                //return ~left;
                            };
            groupHelper.getParentGroupIndex = function getParentGroupIndex(cellRange, parentExpandInfo) {
                var idx = wijmo.grid.groupHelper.getChildGroupIndex(cellRange, parentExpandInfo);
                if(idx > 0) {
                    idx--;
                }
                return (idx < parentExpandInfo.length) ? idx : -1;
            };
            groupHelper.getChildGroupRanges = // level: 1-based level of the cellRange;
            function getChildGroupRanges(leaves, cellRange, level) {
                var result = [], childGroupedColumn = wijmo.grid.groupHelper.getColumnByGroupLevel(leaves, level + 1);
                if(childGroupedColumn) {
                    var childRanges = childGroupedColumn.groupInfo.expandInfo, firstChildIdx = wijmo.grid.groupHelper.getChildGroupIndex(cellRange, childRanges);
                    for(var i = firstChildIdx, len = childRanges.length; i < len; i++) {
                        var childRange = childRanges[i];
                        if(childRange.cr.r2 <= cellRange.r2) {
                            result.push(childRange);
                        } else {
                            break;
                        }
                    }
                }
                return result;
            };
            groupHelper.getParentGroupRange = // level: 1-based level of the cellRange; optional.
            function getParentGroupRange(leaves, cellRange, level) {
                if(level === undefined) {
                    level = 0xFFFF;
                }
                if(cellRange && (level - 2 >= 0)) {
                    for(var i = leaves.length - 1; i >= 0; i--) {
                        var groupInfo = leaves[i].groupInfo;
                        if(!groupInfo || !groupInfo.expandInfo || (groupInfo.level < 0) || (groupInfo.level !== level - 1)) {
                            continue;
                        }
                        var idx = wijmo.grid.groupHelper.getParentGroupIndex(cellRange, groupInfo.expandInfo);
                        if(idx >= 0) {
                            return groupInfo.expandInfo[idx];
                        }
                    }
                }
                return null;
            };
            groupHelper.isParentCollapsed = // level: 1-based level of the cellRange.
            function isParentCollapsed(leaves, cellRange, level) {
                if(level === 1) {
                    return false;
                }
                for(var i = level; i > 1; i--) {
                    var parentGroupRange = wijmo.grid.groupHelper.getParentGroupRange(leaves, cellRange, i);
                    if(!parentGroupRange) {
                        return false;
                    }
                    if(!parentGroupRange.isExpanded) {
                        return true;
                    }
                    cellRange = parentGroupRange.cr;
                }
                return false;
            };
            groupHelper.isParentExpanded = // level: 1-based level of the cellRange.
            function isParentExpanded(leaves, cellRange, level) {
                if(level === 1) {
                    return true;
                }
                for(var i = level; i > 1; i--) {
                    var parentGroupRange = wijmo.grid.groupHelper.getParentGroupRange(leaves, cellRange, i);
                    if(!parentGroupRange || (parentGroupRange && parentGroupRange.isExpanded)) {
                        return true;
                    }
                    cellRange = parentGroupRange.cr;
                }
                return false;
            };
            return groupHelper;
        })();
        grid.groupHelper = groupHelper;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var cellRange = (function () {
            function cellRange(row1, col1, row2, col2) {
                switch(arguments.length) {
                    case 2:
                        this.r1 = this.r2 = row1;
                        this.c1 = this.c2 = col1;
                        break;
                    case 4:
                        this.r1 = row1;
                        this.r2 = row2;
                        this.c1 = col1;
                        this.c2 = col2;
                        break;
                    default:
                        this.r1 = 0;
                        this.r2 = 0;
                        this.c1 = 0;
                        this.c2 = 0;
                }
            }
            cellRange.prototype.isSingleCell = function () {
                return ((this.r1 === this.r2) && (this.c1 === this.c2));
            };
            return cellRange;
        })();
        grid.cellRange = cellRange;        
        /** @ignore */
        var merger = (function () {
            function merger() {
            }
            merger.prototype.merge = function (data, visibleLeaves) {
                this._leaves = visibleLeaves;
                this._data = data;
                try  {
                    this._merge();
                }finally {
                    delete this._data;
                    delete this._leaves;
                }
            };
            merger.prototype._merge = function () {
                var i, len, leaf, firstLeaf = true;
                for(i = 0 , len = this._leaves.length; i < len; i++) {
                    leaf = this._leaves[i];
                    if((leaf.dataIndex >= 0) && !leaf.isBand && (leaf.rowMerge === "free" || leaf.rowMerge === "restricted")) {
                        if(firstLeaf) {
                            this._data.ensureNotLazy();
                            firstLeaf = false;
                        }
                        this._mergeColumn(leaf);
                    }
                }
            };
            merger.prototype._mergeColumn = function (column) {
                var dataIdx = column.dataIndex, row, i, len, range, span, spannedRow;
                for(i = 0 , len = this._data.count(); i < len; i++) {
                    row = this._data.row(i);
                    if(!row.isDataRow()) {
                        continue;
                    }
                    range = this._getCellRange(i, column);
                    if(range.r1 !== range.r2) {
                        span = range.r2 - range.r1 + 1;
                        //this.data[range.r1][dataIdx].rowSpan = span;
                        this._data.row(range.r1).cell(dataIdx).ensureAttr().rowSpan = span;
                        for(spannedRow = range.r1 + 1; spannedRow <= range.r2; spannedRow++) {
                            //this.data[spannedRow][dataIdx] = null;
                            this._data.row(spannedRow).cell(dataIdx).visible(false);
                        }
                    }
                    i = range.r2;
                }
            };
            merger.prototype._getCellRange = function (rowIdx, column) {
                var columnIdx = column.dataIndex, row, range = new wijmo.grid.cellRange(rowIdx, columnIdx), str = (this._data.valueAt(rowIdx, columnIdx) || "").toString(), dataLen = this._data.count(), leafIdx, prevLeaf, range2;
                for(range.r2 = rowIdx; range.r2 < dataLen - 1; range.r2++) {
                    row = this._data.row(range.r2 + 1);
                    //if ((dataItem.rowType !== "data") || (dataItem[columnIdx].value !== str)) {
                    if(!row.isDataRow() || ((row.valueCell(columnIdx).value || "").toString() !== str)) {
                        break;
                    }
                }
                leafIdx = column.leavesIdx// $.inArray(column, this.leaves);
                ;
                if(leafIdx > 0 && column.rowMerge === "restricted") {
                    prevLeaf = this._leaves[leafIdx - 1];
                    if(prevLeaf.dataIndex >= 0) {
                        range2 = this._getCellRange(rowIdx, prevLeaf);
                        range.r1 = Math.max(range.r1, range2.r1);
                        range.r2 = Math.min(range.r2, range2.r2);
                    }
                }
                return range;
            };
            return merger;
        })();
        grid.merger = merger;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="../../../wijutil/jquery.wijmo.wijutil.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        grid.EXPANDO = "__wijgrid";
        /**
        * Specifies the type of a row in the grid.
        */
        (function (rowType) {
            rowType._map = [];
            /** The header row. */
            rowType.header = 1;
            /** Data row. */
            rowType.data = 2;
            /** Alternating data row (used only as modifier of the rowType.data, not as an independent value). */
            rowType.dataAlt = 4;
            /** Filter row. */
            rowType.filter = 8;
            /** Group header row. */
            rowType.groupHeader = 16;
            /** Group footer row. */
            rowType.groupFooter = 32;
            /** Footer row. */
            rowType.footer = 64;
            /** Infrastructure. */
            rowType.emptyDataRow = 128;
        })(grid.rowType || (grid.rowType = {}));
        var rowType = grid.rowType;
        /**
        * Determines an object render state. This enumeration can be used with the cellStyleFormatter and rowStyleFormatter options to get a formatted object state.
        */
        (function (renderState) {
            renderState._map = [];
            /** This is the normal state. The object is rendered and not hovered, selected, or one of the elements determining the current position of the wijgrid. */
            renderState.none = 0;
            /** The object is being rendered. In the cellStyleFormatter, the rendered object is a table cell. In the rowStyleFormatter, the object is a table row. */
            renderState.rendering = 1;
            /** The object is one of the elements determining the current position of the wijgrid. */
            renderState.current = 2;
            /** The object is hovered over. */
            renderState.hovered = 4;
            /** The object is selected. */
            renderState.selected = 8;
            /** @ignore. */
            renderState.editing = 16;
        })(grid.renderState || (grid.renderState = {}));
        var renderState = grid.renderState;
        /**
        * Infrastructure.
        * @ignore
        */
        (function (renderStateEx) {
            renderStateEx._map = [];
            renderStateEx.none = 0;
            renderStateEx.hidden = 1;// row is hidden
            
            renderStateEx.collapsed = 2;
        })(grid.renderStateEx || (grid.renderStateEx = {}));
        var renderStateEx = grid.renderStateEx;
        // row is collapsed (groupHeaders only)
        /**
        * Infrastructure.
        * @ignore
        */
        (function (rowScope) {
            rowScope._map = [];
            rowScope.table = 0;
            rowScope.head = 1;
            rowScope.body = 2;
            rowScope.foot = 3;
        })(grid.rowScope || (grid.rowScope = {}));
        var rowScope = grid.rowScope;
        /**
        * Infrastructure.
        * @ignore
        */
        (function (cellRangeExtendMode) {
            cellRangeExtendMode._map = [];
            cellRangeExtendMode.none = 0;
            cellRangeExtendMode.column = 1;
            cellRangeExtendMode.row = 2;
        })(grid.cellRangeExtendMode || (grid.cellRangeExtendMode = {}));
        var cellRangeExtendMode = grid.cellRangeExtendMode;
        /**
        * Infrastructure.
        * @ignore
        */
        (function (objectMode) {
            objectMode._map = [];
            objectMode.createIfNull = 0;
            objectMode.createAlways = 1;
            objectMode.dispose = 2;
        })(grid.objectMode || (grid.objectMode = {}));
        var objectMode = grid.objectMode;
        /**
        * Determines purpose of the group row cells.
        * @ignore
        */
        (function (groupRowCellPurpose) {
            groupRowCellPurpose._map = [];
            groupRowCellPurpose.groupCell = 0;
            groupRowCellPurpose.aggregateCell = 1;
        })(grid.groupRowCellPurpose || (grid.groupRowCellPurpose = {}));
        var groupRowCellPurpose = grid.groupRowCellPurpose;
        /**
        * Infrastructure.
        * @ignore
        */
        (function (dataRowsRangeMode) {
            dataRowsRangeMode._map = [];
            dataRowsRangeMode.sketch = 0;
            dataRowsRangeMode.rendered = 1;
            dataRowsRangeMode.renderable = 2;
        })(grid.dataRowsRangeMode || (grid.dataRowsRangeMode = {}));
        var dataRowsRangeMode = grid.dataRowsRangeMode;
        /**
        * Infrastructure.
        * @ignore
        */
        (function (intersectionMode) {
            intersectionMode._map = [];
            intersectionMode.none = 0;
            intersectionMode.overlapTop = 1;
            intersectionMode.overlapBottom = 2;
            intersectionMode.reset = 3;
        })(grid.intersectionMode || (grid.intersectionMode = {}));
        var intersectionMode = grid.intersectionMode;
        /** @ignore */
        function compareObj(a, b) {
            var i, len, flag;
            if($.isArray(a) && $.isArray(b)) {
                if(a.length === b.length) {
                    flag = true;
                    for(i = 0 , len = a.length; i < len && flag; i++) {
                        flag = wijmo.grid.compareObj(a[i], b[i]);
                    }
                    return flag;
                }
            } else {
                if($.isPlainObject(a) && $.isPlainObject(b)) {
                    for(i in a) {
                        if(a.hasOwnProperty(i)) {
                            if(!wijmo.grid.compareObj(a[i], b[i])) {
                                return false;
                            }
                        }
                    }
                    for(i in b) {
                        if(b.hasOwnProperty(i)) {
                            if(!wijmo.grid.compareObj(a[i], b[i])) {
                                return false;
                            }
                        }
                    }
                    return true;
                } else {
                    if(a instanceof Date) {
                        a = a.getTime();
                    }
                    if(b instanceof Date) {
                        b = b.getTime();
                    }
                }
            }
            return a === b;
        }
        grid.compareObj = compareObj;
        /** @ignore */
        function stringFormat(pattern) {
            var params = [];
            for (var _i = 0; _i < (arguments.length - 1); _i++) {
                params[_i] = arguments[_i + 1];
            }
            var i, len;
            if(!pattern) {
                return "";
            }
            for(i = 0 , len = params.length; i < len; i++) {
                pattern = pattern.replace(new RegExp("\\{" + i + "\\}", "gm"), params[i]);
            }
            return pattern;
        }
        grid.stringFormat = stringFormat;
        /** @ignore */
        function validDataKey(dataKey) {
            return (dataKey && !(dataKey < 0)) || (dataKey === 0);
        }
        grid.validDataKey = validDataKey;
        /** @ignore */
        function validDate(date) {
            if(date && (date instanceof Date)) {
                return !isNaN(date.getTime());
            }
            return false;
        }
        grid.validDate = validDate;
        /** @ignore */
        function getDataType(column) {
            return column.dataType || column._underlyingDataType || "string";
        }
        grid.getDataType = getDataType;
        /** @ignore */
        function iterateChildrenWidgets(item, callback) {
            if(item && callback) {
                item.find(".ui-widget").each(function (index, dom) {
                    $.each($(dom).data(), function (dataKey, dataValue) {
                        if(dataValue.widgetName) {
                            callback(index, dataValue);
                        }
                    });
                    return true;
                });
            }
        }
        grid.iterateChildrenWidgets = iterateChildrenWidgets;
        /** @ignore */
        function remove$dataByPrefix(element, prefix) {
            var data$keys = [];
            $.each(element.data(), function (key) {
                if(key.indexOf(prefix) === 0) {
                    data$keys.push(key);
                }
            });
            $.each(data$keys, function (idx, key) {
                element.removeData(key);
            });
        }
        grid.remove$dataByPrefix = remove$dataByPrefix;
        /** @ignore */
        var domSelection = (function () {
            function domSelection(dom) {
                this._dom = dom;
            }
            domSelection.prototype.getSelection = // The 'dom' must be an input element
            function () {
                var start = 0, end = 0, textRange;
                if(this._dom.selectionStart !== undefined) {
                    // DOM3
                    start = this._dom.selectionStart;
                    end = this._dom.selectionEnd;
                } else {
                    if(document.selection) {
                        // IE
                        textRange = document.selection.createRange().duplicate();
                        end = textRange.text.length// selection length
                        ;
                        start = Math.abs(textRange.moveStart("character", -this._dom.value.length))// move selection to the beginning
                        ;
                        end += start;
                    }
                }
                return {
                    start: start,
                    end: end,
                    length: end - start
                };
            };
            domSelection.prototype.setSelection = // The 'dom' must be an input element
            function (range) {
                if(this._dom.selectionStart !== undefined) {
                    // DOM3
                    this._dom.setSelectionRange(range.start, range.end);
                } else {
                    // IE
                    var textRange = this._dom.createTextRange();
                    textRange.collapse(true);
                    textRange.moveStart("character", range.start);
                    textRange.moveEnd("character", range.end);
                    textRange.select();
                }
            };
            domSelection.prototype.toggleSelection = function (enable) {
                var $dom = $(this._dom), useSelectStart = "onselectstart" in this._dom;
                if(enable) {
                    if(useSelectStart) {
                        $dom.unbind(".wijgrid-disableSelection");
                    } else {
                        $dom.css({
                            "MozUserSelect": "",
                            "WebkitUserSelect": ""
                        });
                    }
                } else {
                    if(useSelectStart) {
                        $dom.bind("selectstart.wijgrid-disableSelection", function (e) {
                            e.preventDefault();
                        });
                    } else {
                        $dom.css({
                            "MozUserSelect": "-moz-none",
                            "WebkitUserSelect": "none"
                        });
                    }
                }
            };
            return domSelection;
        })();
        grid.domSelection = domSelection;        
        /** @ignore */
        function createDynamicField(options) {
            return $.extend(true, {
            }, grid.c1basefield.prototype.options, grid.c1field.prototype.options, {
                dynamic: true,
                isLeaf: true,
                isBand: false,
                parentIdx: -1
            }, options);
        }
        grid.createDynamicField = createDynamicField;
        /** @ignore */
        function bounds(element, client) {
            if(element) {
                var $dom = element.nodeType ? $(element) : element, offset = $dom.offset();
                if(offset) {
                    if(client) {
                        return {
                            top: offset.top,
                            left: offset.left,
                            width: $dom[0].clientWidth || 0,
                            height: $dom[0].clientHeight || 0
                        };
                    }
                    return {
                        top: offset.top,
                        left: offset.left,
                        width: $dom.outerWidth(),
                        height: $dom.outerHeight()
                    };
                }
            }
            return null;
        }
        grid.bounds = bounds;
        /** @ignore */
        function ensureBounds(bounds, max) {
            if(bounds) {
                if(bounds.start < 0) {
                    bounds.start = 0;
                }
                if(bounds.end < 0) {
                    bounds.end = 0;
                }
                bounds.start = Math.min(bounds.start, max);
                bounds.end = Math.min(bounds.end, max);
            }
            return bounds;
        }
        grid.ensureBounds = ensureBounds;
        // maxDepth = -1 --  iterate through all child elements
        // default value = 3
        /** @ignore */
        function _getDOMText(dom, maxDepth, ignoreTextNodes) {
            if(maxDepth === undefined) {
                maxDepth = 3// default value
                ;
            }
            if(dom && maxDepth !== 0) {
                if(!ignoreTextNodes && dom.nodeType === 3) {
                    // text node
                    return dom.nodeValue;
                }
                if(dom.nodeType === 1) {
                    // element
                    switch((dom).type) {
                        case "button":
                        case "text":
                        case "textarea":
                        case "select-one":
                            return (dom).value;
                        case "checkbox":
                            return (dom).checked.toString();
                    }
                    // go deeper
                                        var result = "", i = 0, child;
                    while(child = dom.childNodes[i++]) {
                        result += wijmo.grid._getDOMText(child, maxDepth - 1);
                    }
                    return result;
                }
            }
            return "";
        }
        grid._getDOMText = _getDOMText;
        // obj, prefix, name (opt), value (opt)
        /** @ignore */
        function dataPrefix(obj, prefix, name, value) {
            var treatAsArray = (obj.jquery || $.isArray(obj)), i, len, tmp, internalName = // arrays of jQuery objects is not supported
            prefix + name;
            if(arguments.length === 3) {
                // getter
                if(treatAsArray) {
                    return $.data(obj[0], internalName);// first item only
                    
                }
                return $.data(obj, internalName);
            } else {
                // setter
                if(treatAsArray) {
                    for(i = 0 , len = obj.length; i < len; i++) {
                        tmp = $.data(obj[i], internalName, value);
                    }
                    return tmp;
                }
                return $.data(obj, internalName, value);
            }
        }
        grid.dataPrefix = dataPrefix;
        /** @ignore */
        function shallowMerge(target, src) {
            if(src && target) {
                var name, value, typeOf;
                for(name in src) {
                    if(src.hasOwnProperty(name)) {
                        value = src[name];
                        typeOf = typeof (value);
                        if((typeOf === "string" || typeOf === "boolean" || typeOf === "number") && (target[name] === undefined)) {
                            target[name] = value;
                        }
                    }
                }
            }
        }
        grid.shallowMerge = shallowMerge;
        /** @ignore */
        function isCustomObject(value) {
            return (value && (typeof (value) === "object") && !(value instanceof Date));
        }
        grid.isCustomObject = isCustomObject;
        /** @ignore */
        function search(value, test) {
            var key, foo, isFunc = $.isFunction(test);
            for(key in value) {
                if(value.hasOwnProperty(key)) {
                    foo = isFunc ? test(value[key]) : (value[key] === test);
                    if(foo === true) {
                        return {
                            at: key,
                            found: value[key]
                        };
                    }
                }
            }
            return {
                at: null,
                found: null
            };
        }
        grid.search = search;
        /** @ignore */
        function getAttributes(dom, prevent) {
            if(dom) {
                var i, len, cnt = 0, result = {
                }, attrValue, attrName;
                for(i = 0 , len = dom.attributes.length; i < len; i++) {
                    attrName = dom.attributes[i].name;
                    if(attrName && (!prevent || !prevent(attrName))) {
                        attrValue = dom.getAttribute(attrName);
                        if(attrName === "style") {
                            attrValue = (typeof (attrValue) === "object") ? attrValue.cssText : attrValue;
                        }
                        if(!attrValue && attrName === "class") {
                            attrValue = dom.getAttribute("className");
                        }
                        if(attrValue && (typeof (attrValue) !== "function")) {
                            result[attrName] = attrValue;
                            cnt++;
                        }
                    }
                }
                if(cnt) {
                    return result;
                }
            }
            return null;
        }
        grid.getAttributes = getAttributes;
        // unlike the jQuery.extend(true) function the deepExtend() function doesn't skips undefined values.
        /** @ignore */
        function deepExtend(source, target) {
            var key, src, dst, isArray, clone;
            if(source) {
                if(typeof (target) !== "object" && !$.isFunction(target)) {
                    target = {
                    };
                }
                for(key in source) {
                    src = source[key];
                    dst = target[dst];
                    if(src === target) {
                        continue;
                    }
                    if(src && ($.isPlainObject(src) || (isArray = $.isArray(src)))) {
                        if(isArray) {
                            isArray = false;
                            clone = dst && $.isArray(dst) ? dst : [];
                        } else {
                            clone = dst && $.isPlainObject(dst) ? dst : {
                            };
                        }
                        target[key] = wijmo.grid.deepExtend(src, clone);
                    } else {
                        target[key] = src;
                    }
                }
            }
            return target;
        }
        grid.deepExtend = deepExtend;
                        /** @ignore */
        function widgetName(element, name) {
            if(element && element.jquery) {
                element = element[0];
            }
            if(element) {
                return (arguments.length === 1) ? $.data(element, "wijgridwidgetName") : $.data(element, "wijgridwidgetName", name);
            }
            return undefined;
        }
        grid.widgetName = widgetName;
        /** @ignore */
        var HTML5InputSupport = (function () {
            function HTML5InputSupport() { }
            HTML5InputSupport._requiresExtendedSupport = {
                "date": "",
                "datetime": "",
                "datetime-local": "",
                "month": "",
                "time": ""
            };
            HTML5InputSupport._supportedInputTypesCache = {
            };
            HTML5InputSupport.isExtendSupportRequired = function isExtendSupportRequired(inputType) {
                inputType = (inputType || "").toLowerCase();
                return (inputType in wijmo.grid.HTML5InputSupport._requiresExtendedSupport);
            };
            HTML5InputSupport.getDefaultInputType = function getDefaultInputType(mobileEnvironment, column) {
                var inputType = (column.inputType || "").toLowerCase();
                if(!inputType && mobileEnvironment) {
                    // provide input type automatically
                    switch(wijmo.grid.getDataType(column)) {
                        case "number":
                        case "currency":
                            inputType = "number";
                            break;
                        case "datetime":
                            inputType = "datetime";
                            break;
                    }
                }
                if(!inputType || ((inputType !== "text") && !HTML5InputSupport._isSupportedByBrowser(inputType))) {
                    inputType = "text"// fallback to "text"
                    ;
                }
                return inputType;
            };
            HTML5InputSupport.toStr = function toStr(value, inputType) {
                var result = value;
                inputType = (inputType || "").toLowerCase();
                if(wijmo.grid.HTML5InputSupport.isExtendSupportRequired(inputType)) {
                    switch(inputType) {
                        case "datetime":
                            result = (value) ? result = Globalize.format(value, "yyyy-MM-ddTHH:mm:ssZ") : "";
                            break;
                        case "datetime-local":
                            result = (value) ? result = Globalize.format(value, "yyyy-MM-ddTHH:mm:ss") : "";
                            break;
                        case "date":
                            result = (value) ? result = Globalize.format(value, "yyyy-MM-dd") : "";
                            break;
                        case "month":
                            result = (value) ? result = Globalize.format(value, "yyyy-MM") : "";
                            break;
                        case "time":
                            result = (value) ? result = Globalize.format(value, "HH:mm:ss") : "";
                            break;
                    }
                } else {
                    result = value + "";
                }
                return result;
            };
            HTML5InputSupport.parse = function parse(value, inputType) {
                var result, fallback = function (date) {
                    date = new Date(date);
                    if(!wijmo.grid.validDate(date)) {
                        date = null;
                    }
                    return date;
                };
                inputType = (inputType || "").toLowerCase();
                if(wijmo.grid.HTML5InputSupport.isExtendSupportRequired(inputType)) {
                    switch(inputType) {
                        case "datetime":
                            result = Globalize.parseDate(value, "yyyy-MM-ddTHH:mm:ssZ") || Globalize.parseDate(value, "yyyy-MM-ddTHH:mmZ") || fallback(value);
                            break;
                        case "datetime-local":
                            result = Globalize.parseDate(value, "yyyy-MM-ddTHH:mm:ss") || Globalize.parseDate(value, "yyyy-MM-ddTHH:mm") || fallback(value);
                            break;
                        case "date":
                            result = Globalize.parseDate(value, "yyyy-MM-dd") || fallback(value);
                            break;
                        case "month":
                            result = Globalize.parseDate(value, "yyyy-MM");
                            break;
                        case "time":
                            result = Globalize.parseDate(value, "HH:mm:ss") || Globalize.parseDate(value, "HH:mm");
                            ;
                            break;
                        case "number":
                            result = parseFloat(value);
                    }
                } else {
                    result = value;
                }
                return result;
            };
            HTML5InputSupport.extend = function extend(value, extendWith, inputType) {
                if(!value) {
                    value = extendWith;
                } else {
                    inputType = (inputType || "").toLowerCase();
                    switch(inputType) {
                        case "date":
                            value.setFullYear(extendWith.getFullYear(), extendWith.getMonth(), extendWith.getDate());
                            break;
                        case "month":
                            value.setFullYear(extendWith.getFullYear(), extendWith.getMonth());
                            break;
                        case "time":
                            value.setHours(extendWith.getHours());
                            value.setMinutes(extendWith.getMinutes());
                            value.setSeconds(extendWith.getSeconds());
                            break;
                        default:
                            value = extendWith;
                    }
                }
                return value;
            };
            HTML5InputSupport._isSupportedByBrowser = function _isSupportedByBrowser(inputType) {
                if(inputType) {
                    if(this._supportedInputTypesCache[inputType] === undefined) {
                        // value is not tested yet
                        var success;
                        try  {
                            var $element = $("<input type='" + inputType + "' style='display:none' />");
                            success = true;
                        } catch (e) {
                            success = false;
                        }
                        this._supportedInputTypesCache[inputType] = success && (($element[0]).type === inputType);
                    }
                    return this._supportedInputTypesCache[inputType];
                }
                return false;
            };
            return HTML5InputSupport;
        })();
        grid.HTML5InputSupport = HTML5InputSupport;        
        /** @ignore */
        function getZIndex(element, minValue) {
            if (typeof minValue === "undefined") { minValue = 99; }
            var zIndex = 0;
            if(element && $.ui && $.fn.zIndex) {
                zIndex = element.zIndex()// try to get zIndex of the first z-indexed ancestor.
                ;
                if(zIndex) {
                    zIndex++// get next value
                    ;
                }
            }
            return Math.max(zIndex, minValue);
        }
        grid.getZIndex = getZIndex;
        // * taken from jQuery UI
        /** @ignore */
        function isOverAxis(x, reference, size) {
            // Determines when x coordinate is over "b" element axis
            return (x > reference) && (x < (reference + size));
        }
        grid.isOverAxis = isOverAxis;
        /** @ignore */
        function isOver(y, x, top, left, height, width) {
            // Determines when x, y coordinates is over "b" element
            return wijmo.grid.isOverAxis(y, top, height) && wijmo.grid.isOverAxis(x, left, width);
        }
        grid.isOver = isOver;
        // taken from jQuery UI *
        // ** uid
        var __uid = 0;
        /** @ignore */
        function getUID() {
            return "uid" + __uid++;
        }
        grid.getUID = getUID;
        // uid **
        /** @ignore */
        function isMobileSafari() {
            return !!(navigator && navigator.userAgent && (navigator.userAgent.match(/Mobile.*Safari/)) !== null);
        }
        grid.isMobileSafari = isMobileSafari;
        var __scrollBarSize = 0;
        /** @ignore */
        function getSuperPanelScrollBarSize() {
            if(!(__scrollBarSize > 0)) {
                if(document && document.body && $.support.isTouchEnabled && $.support.isTouchEnabled()) {
                    // test for native wijsuperpanel mode
                    var $div;
                    try  {
                        $div = $("<div></div>").css({
                            overflow: "scroll",
                            width: 30,
                            height: 30,
                            position: "absolute",
                            visibility: "hidden"
                        }).append($("<div></div>").css({
                            width: 100,
                            height: 100
                        })).appendTo(// append a child
                        document.body);
                        __scrollBarSize = $div[0].offsetWidth - $div[0].clientWidth// measure
                        ;
                    } catch (ex) {
                    }finally {
                        if($div) {
                            $div.remove();
                        }
                    }
                }
                if(!(__scrollBarSize > 0)) {
                    __scrollBarSize = 18// use the default size of the wijsuperpanel' scrollbars
                    ;
                }
            }
            return __scrollBarSize;
        }
        grid.getSuperPanelScrollBarSize = getSuperPanelScrollBarSize;
        // * compatibility: export members to the $.wijmo.wijgrid "namespace" *
        $.extend($.wijmo.wijgrid, {
            rowType: wijmo.grid.rowType,
            renderState: wijmo.grid.renderState,
            bounds: wijmo.grid.bounds
        });
        // used by unit tests. TODO: remove
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));
var wijmo;
(function (wijmo) {
    (function (grid) {
        /** @ignore */
        (function (TimeUnit) {
            TimeUnit._map = [];
            TimeUnit.Millisecond = 1;
            TimeUnit.Second = 2;
            TimeUnit.Minute = 4;
            TimeUnit.Hour = 8;
            TimeUnit.Day = 16;
            TimeUnit.Month = 32;
            TimeUnit.Year = 64;
            TimeUnit.DATE = TimeUnit.Year | TimeUnit.Month | TimeUnit.Day;
            TimeUnit.TIME = TimeUnit.Hour | TimeUnit.Minute | TimeUnit.Second | TimeUnit.Millisecond;
            TimeUnit.ALL = TimeUnit.DATE | TimeUnit.TIME;
        })(grid.TimeUnit || (grid.TimeUnit = {}));
        var TimeUnit = grid.TimeUnit;
        ;
        /** @ignore */
        var TimeUnitConverter = (function () {
            function TimeUnitConverter() { }
            TimeUnitConverter.convertInputType = /**
            * @param inputType One of the HTML input type values (date-time).
            */
            function convertInputType(inputType) {
                var formatString = wijmo.grid.TimeUnitConverter.convertInputTypeToFormatString(inputType), result = wijmo.grid.TimeUnitConverter.convertFormatString(formatString);
                return result;
            };
            TimeUnitConverter.convertInputTypeToFormatString = function convertInputTypeToFormatString(inputType) {
                // specific format values are not important here.
                switch((inputType || "").toLowerCase()) {
                    case "datetime":
                    case "datetime-local":
                        return "f";// long date, short time
                        
                    case "date":
                        return "d";// short date
                        
                    case "month":
                        return "Y";// year-and-month
                        
                    case "time":
                        return "t";// short time
                        
                }
                return "";
            };
            TimeUnitConverter.convertFormatString = /**
            * @param dateFormatString
            */
            function convertFormatString(dateFormatString) {
                var result = 0;
                if(dateFormatString) {
                    // ** check one-char standard formats **
                    if(dateFormatString.length === 1) {
                        switch(dateFormatString[0]) {
                            case "t":
                                // short Time
                                return TimeUnit.Hour | TimeUnit.Minute;
                            case "T":
                                // long Time
                                return TimeUnit.TIME;
                            case "d":
                                // short Date
                                                            case "D":
                                // long Date
                                return TimeUnit.DATE;
                            case "Y":
                                // month/year
                                return TimeUnit.Month | TimeUnit.Year;
                            case "M":
                                // month/day
                                return TimeUnit.Month | TimeUnit.Day;
                            case "f" , "F" , "S":
                                return TimeUnit.ALL;
                        }
                    }
                    // ** check custom tokens **
                                        var quoteFirst, quoteLast;
                    // remove quoted text
                    if(((quoteFirst = dateFormatString.indexOf("'")) >= 0) && ((quoteLast = dateFormatString.lastIndexOf("'")) >= 0) && (quoteFirst !== quoteLast)) {
                        dateFormatString = dateFormatString.substr(0, quoteFirst) + dateFormatString.substring(quoteLast + 1, dateFormatString.length - 1);
                    }
                    // the validness of the string is not a subject to check
                    for(var i = 0, len = dateFormatString.length; i < len; i++) {
                        switch(dateFormatString[i]) {
                            case "d":
                                // day: d, dd, ddd, dddd
                                result |= TimeUnit.Day;
                                break;
                            case "M":
                                // month: M, MM, MMM, MMMM
                                result |= TimeUnit.Month;
                                break;
                            case "y":
                                // year: yy, yyyy
                                result |= TimeUnit.Year;
                                break;
                            case "m":
                                // minute: m, mm
                                result |= TimeUnit.Minute;
                                break;
                            case "h":
                                // hour: h, hh
                                                            case "H":
                                // hour: H, HH
                                result |= TimeUnit.Hour;
                                break;
                            case "s":
                                // second: s, ss
                                result |= TimeUnit.Second;
                                break;
                            case "f":
                                // milliseconds: f, ff, fff
                                result |= TimeUnit.Millisecond;
                                break;
                        }
                    }
                }
                return result || TimeUnit.ALL;
            };
            TimeUnitConverter.cutDate = function cutDate(date, timeUnit) {
                if(date) {
                    timeUnit = ~timeUnit;
                    if(timeUnit & TimeUnit.Millisecond) {
                        date.setMilliseconds(0);
                    }
                    if(timeUnit & TimeUnit.Second) {
                        date.setSeconds(0);
                    }
                    if(timeUnit & TimeUnit.Minute) {
                        date.setMinutes(0);
                    }
                    if(timeUnit & TimeUnit.Hour) {
                        date.setHours(0);
                    }
                    if(timeUnit & TimeUnit.Day) {
                        date.setDate(1);
                    }
                    if(timeUnit & TimeUnit.Month) {
                        date.setMonth(0);
                    }
                    if(timeUnit & TimeUnit.Year) {
                        date.setFullYear(0);
                    }
                }
                return date;
            };
            return TimeUnitConverter;
        })();
        grid.TimeUnitConverter = TimeUnitConverter;        
        /** @ignore */
        function lazy(eval, context) {
            var hasValue = false, value;
            return function () {
                if(!hasValue) {
                    value = context ? eval.call(context) : eval();
                    hasValue = true;
                }
                return value;
            };
        }
        grid.lazy = lazy;
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="wijgrid.ts"/>
    /// <reference path="interfaces.ts"/>
    /// <reference path="../../../data/src/dataView.ts"/>
    /// <reference path="../../../data/src/filtering.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var builtInFilterOperators = (function () {
            function builtInFilterOperators() { }
            builtInFilterOperators.NoFilterOp = {
                applicableTo: null,
                name: // any type
                "NoFilter",
                displayName: "No filter",
                arity: 1,
                operator: function () {
                    return true;
                }
            };
            return builtInFilterOperators;
        })();        
        /** @ignore */
        var filterOperatorsCache = (function () {
            function filterOperatorsCache(wijgrid) {
                this._cache = {
                };
                var self = this;
                this._wijgrid = wijgrid;
                this._addOperator(null, builtInFilterOperators.NoFilterOp);
                $.each(wijmo.data.filtering.ops, function (name, op) {
                    self._addOperator(name, op);
                });
                $.each(wijgrid.options.customFilterOperators, function (key, fop) {
                    self._addOperator(null, fop, true);
                });
            }
            filterOperatorsCache.prototype.getByName = function (name) {
                var fop = this.getByNameInt(name);
                return (fop) ? fop.op : null;
            };
            filterOperatorsCache.prototype.getByNameInt = function (name) {
                return this._cache[(name || "").toLowerCase()];
            };
            filterOperatorsCache.prototype.getByDataType = function (dataType) {
                var intResult = [], result;
                $.each(this._cache, function (key, val) {
                    var fop = val.op;
                    if(!fop.applicableTo/* NoFilter*/  || $.inArray(dataType, fop.applicableTo) >= 0) {
                        intResult.push(val);
                    }
                });
                switch(this._wijgrid.options.filterOperatorsSortMode.toLowerCase()) {
                    case "alphabetical":
                        intResult.sort(this._sortAlpha);
                        break;
                    case "alphabeticalcustomfirst":
                        intResult.sort(this._sortAlphaCustomFirst);
                        break;
                    case "alphabeticalembeddedFirst":
                        intResult.sort(this._sortAlphaEmbeddedFirst);
                        break;
                    case "none":
                        // do nothing
                        break;
                    default:
                        break;
                }
                result = $.map(intResult, function (val, key) {
                    return val.op;
                });
                return result;
            };
            filterOperatorsCache.prototype._addOperator = function (name, fop, isCustom) {
                if (typeof isCustom === "undefined") { isCustom = false; }
                if(name && !fop.name) {
                    fop.name = name;
                }
                name = (name || fop.name).toLowerCase();
                if(!this._cache[name]) {
                    this._cache[name] = {
                        op: fop,
                        isCustom: (isCustom === true)
                    };
                }
            };
            filterOperatorsCache.prototype._sortAlpha = function (a, b) {
                var n1 = a.op.name.toLowerCase(), n2 = b.op.name.toLowerCase();
                if(n1 !== n2) {
                    if(n1 === "nofilter") {
                        return -1;
                    }
                    if(n2 === "nofilter") {
                        return 1;
                    }
                }
                if(n1 === n2) {
                    return 0;
                }
                return (n1 < n2) ? -1 : 1;
            };
            filterOperatorsCache.prototype._sortAlphaEmbeddedFirst = function (a, b) {
                var n1 = a.op.name.toLowerCase(), n2 = b.op.name.toLowerCase();
                if(n1 !== n2) {
                    if(n1 === "nofilter") {
                        return -1;
                    }
                    if(n2 === "nofilter") {
                        return 1;
                    }
                }
                if(a.isCustom !== b.isCustom) {
                    if(a.isCustom) {
                        return 1;
                    }
                    if(b.isCustom) {
                        return -1;
                    }
                }
                if(n1 === n2) {
                    return 0;
                }
                return (n1 < n2) ? -1 : 1;
            };
            filterOperatorsCache.prototype._sortAlphaCustomFirst = function (a, b) {
                var n1 = a.op.name.toLowerCase(), n2 = b.op.name.toLowerCase();
                if(n1 !== n2) {
                    if(n1 === "nofilter") {
                        return -1;
                    }
                    if(n2 === "nofilter") {
                        return 1;
                    }
                }
                if(a.isCustom !== b.isCustom) {
                    if(a.isCustom) {
                        return -1;
                    }
                    if(b.isCustom) {
                        return 1;
                    }
                }
                if(n1 === n2) {
                    return 0;
                }
                return (n1 < n2) ? -1 : 1;
            };
            return filterOperatorsCache;
        })();
        grid.filterOperatorsCache = filterOperatorsCache;        
        /** @ignore */
        var filterHelper = (function () {
            function filterHelper() { }
            filterHelper.marker = "_wijgrid";
            filterHelper.getSingleValue = // filterValue
            // [filterValue, ..., filterValue]
            // [[filterValue, ..., filterValue], ..., [filterValue, ..., filterValue]]
            function getSingleValue(filterValue) {
                if($.isArray(filterValue)) {
                    filterValue = filterValue[0];
                    if($.isArray(filterValue)) {
                        filterValue = filterValue[0];
                    }
                }
                return filterValue;
            };
            filterHelper.getSingleOperatorName = // filterOperator -> name | { name, condition }
            // filterOperator -> filterOperator | [ filterOperator, ..., filterOperator]
            function getSingleOperatorName(filterOperator) {
                if($.isArray(filterOperator)) {
                    filterOperator = filterOperator[0];
                }
                return filterOperator.name || filterOperator || "";
            };
            filterHelper.verify = // filterOperator: opName | [opName, ..., opName] | [ { name, condition }, ..., { name, condition } ]
            // filterValue: filterValue | [filterValue, ... , filterValue] | [[], ..., []]
            function verify(filterOperator, filterValue, dataType, cache) {
                if(filterOperator) {
                    if($.isArray(filterOperator)) {
                        var i, len, fop = [], fval = [];
                        if(!$.isArray(filterValue)) {
                            filterValue = [
                                filterValue
                            ];
                        }
                        for(i = 0 , len = filterOperator.length; i < len; i++) {
                            if(wijmo.grid.filterHelper._verifySingleOp(filterOperator[i], filterValue[i], dataType, cache)) {
                                fop.push({
                                    name: filterOperator[i].name || filterOperator[i],
                                    condition: filterOperator[i].condition || "or"
                                });
                                fval.push(filterValue ? filterValue[i] : undefined);
                            }
                        }
                        if(fop.length) {
                            return {
                                filterOperator: fop,
                                filterValue: fval
                            };
                        }
                    } else {
                        if(wijmo.grid.filterHelper._verifySingleOp(filterOperator, filterValue, dataType, cache)) {
                            return {
                                filterOperator: // compatibility with old model
                                filterOperator,
                                filterValue: filterValue
                            };
                        }
                    }
                }
                return null;
            };
            filterHelper._verifySingleOp = // filterOpeator: name | { name, condition }
            function _verifySingleOp(filterOperator, filterValue, dataType, cache) {
                if(filterOperator && (filterOperator = (filterOperator.name || filterOperator))) {
                    var fop;
                    filterOperator = (filterOperator || "").toLowerCase();
                    if((filterOperator !== "nofilter" || filterValue !== undefined) && (fop = cache.getByName(filterOperator))) {
                        if(fop.applicableTo === null/*NoFilter*/  || $.inArray(dataType || "string", fop.applicableTo) >= 0) {
                            if(fop.arity === 1 || (fop.arity > 1 && wijmo.grid.filterHelper.getSingleValue(filterValue) !== undefined)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            };
            return filterHelper;
        })();
        grid.filterHelper = filterHelper;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="misc.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
                        /** @ignore */
        function getTableSection(table, scope) {
            if(table && !table.nodeType) {
                table = table[0];
            }
            if(table) {
                switch(scope) {
                    case wijmo.grid.rowScope.head:
                        return table.tHead;
                    case wijmo.grid.rowScope.body:
                        if(table.tBodies) {
                            return table.tBodies[0] || null;
                        }
                        break;
                    case wijmo.grid.rowScope.foot:
                        return table.tFoot;
                    default:
                        return table;
                }
            }
            return null;
        }
        grid.getTableSection = getTableSection;
                        /** @ignore */
        function getTableSectionLength(table, scope) {
            var section;
            if(table && !table.nodeType) {
                table = table[0]// jQuery
                ;
            }
            return (table && (section = this.getTableSection(table, scope))) ? section.rows.length : 0;
        }
        grid.getTableSectionLength = getTableSectionLength;
                        /** @ignore */
        function getTableSectionRow(table, scope, rowIndex) {
            var section;
            if(table && !table.nodeType) {
                table = table[0]// jQuery
                ;
            }
            return (table && (section = this.getTableSection(table, scope))) ? (section.rows[rowIndex] || null) : null;
        }
        grid.getTableSectionRow = getTableSectionRow;
                        /** @ignore */
        function readTableSection(table, scope, readAttributes) {
            var ri, rowLen, ci, celLen, domRow, row, expando, rowAttributes, result = [], prevent = function (attrName) {
                attrName = attrName.toLowerCase();
                return attrName === "rowspan" || attrName === "colspan";
            }, section;
            if(table && !table.nodeType) {
                table = table[0]// jQuery
                ;
            }
            if(table && (section = this.getTableSection(table, scope))) {
                for(ri = 0 , rowLen = section.rows.length; ri < rowLen; ri++) {
                    domRow = section.rows[ri];
                    row = [];
                    if(readAttributes) {
                        expando = (wijmo).data.Expando.getFrom(row, true);
                        rowAttributes = expando[wijmo.grid.EXPANDO] = {
                            cellsAttributes: {
                            },
                            rowAttributes: wijmo.grid.getAttributes(domRow) || {
                            }
                        };
                    }
                    for(ci = 0 , celLen = domRow.cells.length; ci < celLen; ci++) {
                        var value = $.trim((domRow.cells[ci]).innerHTML);
                        if(value == "&nbsp;") {
                            value = "";
                        }
                        row[ci] = value;
                        if(readAttributes) {
                            rowAttributes.cellsAttributes[ci] = wijmo.grid.getAttributes(domRow.cells[ci], prevent) || {
                            };
                        }
                    }
                    result[ri] = row;
                }
            }
            return result;
        }
        grid.readTableSection = readTableSection;
        /** @ignore */
        function determineSection(cell) {
            var element = cell.parentNode.parentNode;
            switch(element.tagName.toLowerCase()) {
                case "thead":
                    return wijmo.grid.rowScope.head;
                case "tbody":
                    return wijmo.grid.rowScope.body;
                case "tfoot":
                    return wijmo.grid.rowScope.foot;
            }
            return null;
        }
        grid.determineSection = determineSection;
        /** @ignore */
        var htmlTableAccessor = (function () {
            function htmlTableAccessor(domTable, skipOffsets, ensureTBody, ensureColgroup) {
                this._width = 0;
                this._table = domTable;
                this._offsets = [];
                if(ensureColgroup) {
                    // important: colGroup must preceed tBody in a table
                    this.ensureColGroup();
                }
                if(ensureTBody) {
                    this.ensureTBody();
                }
                if(!skipOffsets) {
                    this._buildOffsets();
                }
            }
            htmlTableAccessor.prototype.element = function () {
                return this._table;
            };
            htmlTableAccessor.prototype.width = function () {
                return this._width;
            };
            htmlTableAccessor.prototype.getCellIdx = function (colIdx, rowIdx) {
                return (colIdx < this._width && rowIdx >= 0 && rowIdx < this._offsets.length) ? this._offsets[rowIdx][colIdx].cellIdx : -1;
            };
            htmlTableAccessor.prototype.getColumnIdx = function (cellIdx, rowIdx) {
                if(typeof (cellIdx) !== "number") {
                    // domCell
                    var domCell = cellIdx;
                    cellIdx = domCell.cellIndex;
                    rowIdx = domCell.parentNode.rowIndex;
                }
                return (cellIdx < this._width) ? this._offsets[rowIdx][cellIdx].colIdx : -1;
            };
            htmlTableAccessor.prototype.clearSection = function (scope) {
                var start, end, section = wijmo.grid.getTableSection(this._table, scope);
                switch(scope) {
                    case wijmo.grid.rowScope.body:
                        start = this.getSectionLength(wijmo.grid.rowScope.table);
                        end = start + this.getSectionLength(scope) - 1;
                        break;
                    case wijmo.grid.rowScope.foot:
                        start = this.getSectionLength(wijmo.grid.rowScope.table) + this.getSectionLength(wijmo.grid.rowScope.head);
                        end = start + this.getSectionLength(scope) - 1;
                        break;
                    default:
                        // header or whole table
                        start = 0;
                        end = this.getSectionLength(scope) - 1;
                }
                // update DOM
                while(section.rows.length) {
                    section.deleteRow(0);
                }
                // update offsets
                this._offsets.splice(start, end - start + 1);
            };
            htmlTableAccessor.prototype.getSectionLength = function (scope) {
                return wijmo.grid.getTableSectionLength(this._table, scope);
            };
            htmlTableAccessor.prototype.getSectionRow = function (rowIndex, scope) {
                return wijmo.grid.getTableSectionRow(this._table, scope, rowIndex);
            };
            htmlTableAccessor.prototype.forEachColumnCellNatural = // iterates through the table rows using natural cells order
            function (columnIdx, callback, param) {
                var i, rowLen, row, result;
                for(i = 0 , rowLen = this._table.rows.length; i < rowLen; i++) {
                    row = this._table.rows[i];
                    if(columnIdx < row.cells.length) {
                        result = callback(row.cells[columnIdx], i, param);
                        if(result !== true) {
                            return result;
                        }
                    }
                }
                return true;
            };
            htmlTableAccessor.prototype.forEachColumnCell = // iterates through the table rows using colSpan\rowSpan offsets
            function (columnIdx, callback, param) {
                var i, rowLen, row, offsetCellIdx, result;
                for(i = 0 , rowLen = this._offsets.length; i < rowLen; i++) {
                    row = this._table.rows[i];
                    offsetCellIdx = this.getCellIdx(columnIdx, i);
                    if(offsetCellIdx >= 0) {
                        result = callback(row.cells[offsetCellIdx], i, param);
                        if(result !== true) {
                            return result;
                        }
                    }
                }
                return true;
            };
            htmlTableAccessor.prototype.forEachRowCell = // iterates throw the cells of a table row
            function (rowIndex, callback, param) {
                var row = this._table.rows[rowIndex], i, celLen, result;
                for(i = 0 , celLen = row.cells.length; i < celLen; i++) {
                    result = callback(row.cells[i], i, param);
                    if(result !== true) {
                        return result;
                    }
                }
                return true;
            };
            htmlTableAccessor.prototype.colGroupTag = function () {
                var cgs = this._table.getElementsByTagName("colgroup");
                return ((cgs && cgs[0])) || null;
            };
            htmlTableAccessor.prototype.colTags = function () {
                var colGroup = this.colGroupTag();
                return (colGroup && colGroup.getElementsByTagName("col")) || [];
            };
            htmlTableAccessor.prototype.ensureTBody = function () {
                return ((this._table.tBodies && this._table.tBodies[0]) || this._table.appendChild(document.createElement("tbody")));
            };
            htmlTableAccessor.prototype.ensureTHead = function () {
                return (this._table.tHead && this._table.tHead[0]) || this._table.createTHead();
            };
            htmlTableAccessor.prototype.ensureTFoot = function () {
                return (this._table.tFoot && this._table.tFoot[0]) || this._table.createTFoot();
            };
            htmlTableAccessor.prototype.ensureColGroup = function () {
                var colGroup = this._table.getElementsByTagName("colgroup");
                return ((colGroup && colGroup[0]) || this._table.appendChild(document.createElement("colgroup")));
            };
            htmlTableAccessor.prototype.appendCol = function (domCol/*opt*/ ) {
                var colGroup = this.ensureColGroup();
                return ((domCol && colGroup.appendChild(domCol)) || colGroup.appendChild(document.createElement("col")));
            };
            htmlTableAccessor.prototype.removeOffset = function (idx) {
                if(idx >= 0 && idx < this._offsets.length) {
                    if(idx < 0 || (!idx && idx !== 0)) {
                        idx = this._offsets.length - 1// last row
                        ;
                    }
                    this._offsets.splice(idx, 1);
                }
            };
            htmlTableAccessor.prototype.insertOffset = function (idx) {
                var row, i;
                if(this._width > 0) {
                    row = [];
                    for(i = 0; i < this._width; i++) {
                        row.push({
                            cellIdx: i,
                            colIdx: i
                        });
                    }
                    if(idx < 0 || (!idx && idx !== 0)) {
                        idx = this._offsets.length// append row
                        ;
                    }
                    this._offsets.splice(idx, 0, row);
                }
            };
            htmlTableAccessor.prototype.rebuildOffsets = function () {
                this._offsets = [];
                this._width = 0;
                this._buildOffsets();
            };
            htmlTableAccessor.prototype._buildOffsets = function () {
                var rowSpan = [], rowOffsets, i, rowLen, row, j, jOffset, celLen, cell, cs, rowSpanLen;
                for(i = 0 , rowLen = this._table.rows.length; i < rowLen; i++) {
                    rowOffsets = [];
                    this._offsets[i] = rowOffsets;
                    row = this._table.rows[i];
                    for(j = 0 , jOffset = 0 , celLen = row.cells.length; j < celLen; j++ , jOffset++) {
                        cell = row.cells[j];
                        // process rowspan
                        for(; rowSpan[jOffset] > 1; jOffset++) {
                            rowSpan[jOffset]--;
                            rowOffsets[jOffset] = {
                                cellIdx: -1,
                                colIdx: -1
                            };
                        }
                        if(!(rowSpan[jOffset] > 1)) {
                            rowSpan[jOffset] = cell.rowSpan;
                        }
                        rowOffsets[jOffset] = {
                            cellIdx: j,
                            colIdx: -1
                        };
                        rowOffsets[j].colIdx = jOffset;
                        // process colspan
                        cs = cell.colSpan;
                        for(; cs > 1; cs--) {
                            rowOffsets[++jOffset] = {
                                cellIdx: -1,
                                colIdx: -1
                            };
                        }
                    }
                    rowSpanLen = rowSpan.length;
                    for(; jOffset < rowSpanLen; jOffset++) {
                        rowSpan[jOffset]--;
                        rowOffsets[jOffset] = {
                            cellIdx: -1,
                            colIdx: -1
                        };
                    }
                    this._width = Math.max(this._width, rowSpanLen);
                }
            };
            return htmlTableAccessor;
        })();
        grid.htmlTableAccessor = htmlTableAccessor;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** An object that represents a single cell. */
        var cellInfo = (function () {
            /** Creates an object that represents a single cell. Normally you do not need to use this method.
            * @example
            * var cell = new wijmo.grid.cellInfo(0, 0, $("#demo").data("wijmo-wijgrid"));
            * @param {Number} cellIndex The zero-based index of the required cell inside the corresponding row.
            * @param {Number} rowIndex The zero-based index of the row that contains required cell.
            * @param {Object} wijgrid The wijgrid instance.
            * @returns {wijmo.grid.cellInfo} Object that represents a single cell.
            */
            function cellInfo(cellIndex, rowIndex, wijgrid, absolute, virtualize) {
                if (typeof wijgrid === "undefined") { wijgrid = null; }
                if (typeof absolute === "undefined") { absolute = false; }
                if (typeof virtualize === "undefined") { virtualize = true; }
                this.__isEdit = false;
                this._wijgrid = wijgrid;
                this._virtualize = virtualize;
                if(absolute) {
                    this._ci = cellIndex - this._wijgrid._getDataToAbsOffset().x;
                    this._ri = rowIndex - this._wijgrid._getDataToAbsOffset().y;
                    if(this._virtualize) {
                        this._ri = this._wijgrid._renderableBoundsCollection().getAbsIndex(this._ri + this._wijgrid._viewPortBounds().start);
                    }
                } else {
                    this._ci = cellIndex;
                    this._ri = rowIndex;
                }
            }
            cellInfo.outsideValue = new cellInfo(-1, -1, null);
            cellInfo.prototype.cellIndexAbs = // public
            /** @ignore */
            function () {
                return this._ci + this._wijgrid._getDataToAbsOffset().x;
            };
            cellInfo.prototype.rowIndexAbs = /** @ignore */
            function () {
                var value = this._virtualize ? this._wijgrid._renderableBoundsCollection().getRenderedIndex(this._ri) - this._wijgrid._viewPortBounds().start : this._ri;
                value += this._wijgrid._getDataToAbsOffset().y;
                return value;
            };
            cellInfo.prototype.cellIndex = /** @ignore */
            function (value) {
                if(!arguments.length) {
                    return this._ci;
                }
                this._ci = value;
            };
            cellInfo.prototype.column = /** Gets the associated column object.
            * @example
            * var column = cellInfoObj.column();
            * @returns {wijmo.grid.IColumn} The associated column object.
            */
            function () {
                if(this._wijgrid && this._isValid()) {
                    return this._wijgrid._field("visibleLeaves")[this.cellIndexAbs()];
                }
                return null;
            };
            cellInfo.prototype.container = /** Returns the jQuery object containing a cell content.
            * @example
            * var $container = cellInfoObj.container();
            * @returns {Object} The jQuery object containing a cell content.
            */
            function () {
                var tableCell = this.tableCell(), $innerDiv;
                if(tableCell) {
                    $innerDiv = $(tableCell).children("div." + wijmo.grid.wijgrid.CSS.cellContainer);
                    if($innerDiv) {
                        return $innerDiv;
                    }
                }
                return null;
            };
            cellInfo.prototype.isEqual = /** Compares the current object with an object you have specified and indicates whether they are identical
            * @example
            * var isEqual = cellInfoObj1.isEqual(cellInfoObj2);
            * @param {wijmo.grid.cellInfo} value The object to compare
            * @returns {Boolean} True if the objects are identical, otherwise false.
            */
            function (value) {
                return (value && (value.rowIndex() === this.rowIndex()) && (value.cellIndex() === this.cellIndex()));
            };
            cellInfo.prototype.row = /** Gets the accociated row's information.
            * @example
            * var row = cellInfoObj.row();
            * @returns {wijmo.grid.IRowInfo} Information about associated row.
            */
            function () {
                var rowObj = null, result = null;
                if(this._wijgrid) {
                    if(this._virtualize) {
                        result = this._wijgrid._view()._getRowInfoBySketchRowIndex(this.rowIndex());
                    } else {
                        rowObj = this._wijgrid._view().rows().item(this.rowIndexAbs());
                        if(rowObj && rowObj.length) {
                            result = this._wijgrid._view()._getRowInfo(rowObj);
                        }
                    }
                }
                return result;
            };
            cellInfo.prototype.rowIndex = /** @ignore */
            function (value) {
                if(!arguments.length) {
                    return this._ri;
                }
                this._ri = value;
            };
            cellInfo.prototype.tableCell = /** Returns the table cell element corresponding to this object.
            * @example
            * var domCell = cellInfoObj.tableCell();
            * @returns {HTMLTableCellElement} The table cell element corresponding to this object.
            */
            function () {
                if(this._wijgrid && this._isValid()) {
                    if(!this._virtualize || this._isRendered()) {
                        return this._wijgrid._view().getCell(this.cellIndexAbs(), this.rowIndexAbs());
                    }
                }
                return null;
            };
            cellInfo.prototype.value = /** @ignore */
            function (value/*opt*/ ) {
                var column, rowInfo, colVal;
                if(this._wijgrid && this._isValid()) {
                    rowInfo = this.row();
                    if(rowInfo.type & wijmo.grid.rowType.data) {
                        column = this.column();
                        if(arguments.length === 0) {
                            // getter
                            colVal = this._wijgrid._dataViewWrapper.getValue(rowInfo.data, column.dataKey);
                            return this._wijgrid.parse(column, colVal);
                        } else {
                            // setter
                            // validation
                            value = this._wijgrid.parse(column, value);
                            if((value === null && column.valueRequired) || ((wijmo.grid.getDataType(column) !== "string") && isNaN(value))) {
                                throw "invalid value";
                            }
                            // update dataView
                            this._wijgrid._dataViewWrapper.setValue(rowInfo.dataItemIndex, column.dataKey, value);
                            // keep sketchTable values in sync (to avoid issues during virtual scrolling)
                            var sketchRow = this._wijgrid.sketchTable.row(this.rowIndex());
                            var sketchCell = sketchRow.cell(column.dataIndex);
                            sketchCell.value = value;
                        }
                    }
                }
            };
            cellInfo.prototype.toString = /** @ignore */
            function () {
                return this.cellIndex() + ":" + this.rowIndex();
            };
            cellInfo.prototype._clip = // internal
            function (range, absolute) {
                if (typeof absolute === "undefined") { absolute = false; }
                var flag = false, val;
                if(absolute) {
                    if(this.cellIndexAbs() < (val = range.topLeft().cellIndexAbs())) {
                        flag = true;
                        this._ci = range.topLeft().cellIndex();
                    }
                    if(this.cellIndexAbs() > (val = range.bottomRight().cellIndexAbs())) {
                        flag = true;
                        this._ci = range.bottomRight().cellIndex();
                    }
                    if(this.rowIndexAbs() < (val = range.topLeft().rowIndexAbs())) {
                        flag = true;
                        this._ri = range.topLeft().rowIndex();
                    }
                    if(this.rowIndexAbs() > (val = range.bottomRight().rowIndexAbs())) {
                        flag = true;
                        this._ri = range.bottomRight().rowIndex();
                    }
                } else {
                    if(this.cellIndex() < (val = range.topLeft().cellIndex())) {
                        flag = true;
                        this._ci = val;
                    }
                    if(this.cellIndex() > (val = range.bottomRight().cellIndex())) {
                        flag = true;
                        this._ci = val;
                    }
                    if(this.rowIndex() < (val = range.topLeft().rowIndex())) {
                        flag = true;
                        this._ri = val;
                    }
                    if(this.rowIndex() > (val = range.bottomRight().rowIndex())) {
                        flag = true;
                        this._ri = val;
                    }
                }
                return flag;
            };
            cellInfo.prototype._clone = function () {
                return new wijmo.grid.cellInfo(this.cellIndex(), this.rowIndex(), this._wijgrid, false, this._virtualize);
            };
            cellInfo.prototype._isValid = function () {
                return this.cellIndex() >= 0 && this.rowIndex() >= 0;
            };
            cellInfo.prototype._isRendered = function () {
                var view;
                if(this._wijgrid && (view = this._wijgrid._view()) && this._isValid()) {
                    var bodyIndex = view._isRowRendered(this.rowIndex());
                    return bodyIndex >= 0;
                }
                return false;
            };
            cellInfo.prototype._isEdit = function (value) {
                var tableCell = null, marker = wijmo.grid.wijgrid.CSS.editedCellMarker;
                if(this._isValid()) {
                    try  {
                        tableCell = this.tableCell();
                    } catch (e) {
                    }
                }
                if(!arguments.length) {
                    if(tableCell) {
                        return $(tableCell).hasClass(marker);
                    }
                    return this.__isEdit;
                } else {
                    if(tableCell) {
                        $(tableCell)[value ? "addClass" : "removeClass"](marker);
                    }
                    this.__isEdit = value;
                }
            };
            cellInfo.prototype._setGridView = function (value) {
                this._wijgrid = value;
            };
            return cellInfo;
        })();
        grid.cellInfo = cellInfo;        
        // internal *
        // * private
        // private *
        /** An object that specifies a range of cells determined by two cells. */
        var cellInfoRange = (function () {
            /** Creates an object that specifies a range of cells determined by two cells. Normally you do not need to use this method.
            * @example
            * var range = wijmo.grid.cellInfoRange(new wijmo.grid.cellInfo(0, 0), new wijmo.grid.cellInfo(0, 0));
            * @param {wijmo.grid.cellInfo} topLeft Object that represents the top left cell of the range.
            * @param {wijmo.grid.cellInfo} bottomRight Object that represents the bottom right cell of the range.
            * @returns {wijmo.grid.cellInfoRange} Object that specifies a range of cells determined by two cells.
            */
            function cellInfoRange(topLeft, bottomRight) {
                if(!topLeft || !bottomRight) {
                    throw "invalid arguments";
                }
                this._topLeft = topLeft._clone();
                this._bottomRight = bottomRight._clone();
            }
            cellInfoRange.prototype.bottomRight = /** Gets the object that represents the bottom right cell of the range.
            * @example
            * var cellInfoObj = range.bottomRight();
            * @returns {wijmo.grid.cellInfo} The object that represents the bottom right cell of the range.
            */
            function () {
                return this._bottomRight;
            };
            cellInfoRange.prototype.isEqual = /** Compares the current range with a specified range and indicates whether they are identical.
            * @example
            * var isEqual = range1.isEqual(range2);
            * @param {wijmo.grid.cellInfoRange} range Range to compare.
            * @returns True if the ranges are identical, otherwise false.
            */
            function (range) {
                return (range && this._topLeft.isEqual(range.topLeft()) && this._bottomRight.isEqual(range.bottomRight()));
            };
            cellInfoRange.prototype.topLeft = /** Gets the object that represents the top left cell of the range.
            * @example
            * var cellInfoObj = range.topLeft();
            * @returns {wijmo.grid.cellInfo} The object that represents the top left cell of the range.
            */
            function () {
                return this._topLeft;
            };
            cellInfoRange.prototype.toString = /** @ignore */
            function () {
                return this._topLeft.toString() + " - " + this._bottomRight.toString();
            };
            cellInfoRange.prototype._isIntersect = // public *
            // internal
            function (range) {
                var rangeH, thisH, rangeW, thisW;
                if(range) {
                    rangeH = range.bottomRight().rowIndex() - range.topLeft().rowIndex() + 1;
                    thisH = this._bottomRight.rowIndex() - this._topLeft.rowIndex() + 1;
                    if((range.topLeft().rowIndex() + rangeH) - this._topLeft.rowIndex() < rangeH + thisH) {
                        rangeW = range.bottomRight().cellIndex() - range.topLeft().cellIndex() + 1;
                        thisW = this._bottomRight.cellIndex() - this._topLeft.cellIndex() + 1;
                        return ((range.topLeft().cellIndex() + rangeW) - this._topLeft.cellIndex() < rangeW + thisW);
                    }
                }
                return false;
            };
            cellInfoRange.prototype._isValid = function () {
                return this._topLeft._isValid() && this._bottomRight._isValid();
            };
            cellInfoRange.prototype._clip = function (clipBy, absolute) {
                if (typeof absolute === "undefined") { absolute = false; }
                var a = this._topLeft._clip(clipBy, absolute);
                var b = this._bottomRight._clip(clipBy, absolute);
                return a || b;
            };
            cellInfoRange.prototype._clone = function () {
                return new cellInfoRange(this._topLeft._clone(), this._bottomRight._clone());
            };
            cellInfoRange.prototype._containsCellInfo = function (info) {
                return (info && info.cellIndex() >= this._topLeft.cellIndex() && info.cellIndex() <= this._bottomRight.cellIndex() && info.rowIndex() >= this._topLeft.rowIndex() && info.rowIndex() <= this._bottomRight.rowIndex());
            };
            cellInfoRange.prototype._containsCellRange = function (range) {
                return (range && this._containsCellInfo(range.topLeft()) && this._containsCellInfo(range.bottomRight()));
            };
            cellInfoRange.prototype._extend = function (mode, borders) {
                if(mode === wijmo.grid.cellRangeExtendMode.column) {
                    this._topLeft.rowIndex(borders.topLeft().rowIndex());
                    this._bottomRight.rowIndex(borders.bottomRight().rowIndex());
                } else {
                    if(mode === wijmo.grid.cellRangeExtendMode.row) {
                        this._topLeft.cellIndex(borders.topLeft().cellIndex());
                        this._bottomRight.cellIndex(borders.bottomRight().cellIndex());
                    }
                }
                return this;
            };
            cellInfoRange.prototype._normalize = function () {
                var x0 = this._topLeft.cellIndex(), y0 = this._topLeft.rowIndex(), x1 = this._bottomRight.cellIndex(), y1 = this._bottomRight.rowIndex();
                this._topLeft.cellIndex(Math.min(x0, x1));
                this._topLeft.rowIndex(Math.min(y0, y1));
                this._bottomRight.cellIndex(Math.max(x0, x1));
                this._bottomRight.rowIndex(Math.max(y0, y1));
            };
            cellInfoRange.prototype._height = function () {
                return this._bottomRight.rowIndex() - this._topLeft.rowIndex();
            };
            cellInfoRange.prototype._width = function () {
                return this._bottomRight.cellIndex() - this._topLeft.cellIndex();
            };
            return cellInfoRange;
        })();
        grid.cellInfoRange = cellInfoRange;        
        // internal *
        // * compatibility: export members to the $.wijmo.wijgrid "namespace" *
        $.extend($.wijmo.wijgrid, {
            cellInfo: wijmo.grid.cellInfo,
            cellInfoRange: wijmo.grid.cellInfoRange
        });
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    /// <reference path="rowAccessor.ts" />
    /// <reference path="filterOperators.ts" />
    /// <reference path="htmlTableAccessor.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var baseView = (function () {
            function baseView(wijgrid, renderBounds) {
                this._rowHeaderSize = 22;
                this.mIsRendered = false;
                this._sizesAdjCache = {
                    th: 0,
                    col: 0,
                    subTable: 0
                };
                if(!wijgrid) {
                    throw "'wijgrid' must be specified";
                }
                this._wijgrid = wijgrid;
                this._bounds = renderBounds;
                this._wijgrid.element.addClass(wijmo.grid.wijgrid.CSS.table).addClass(this._wijgrid.options.wijCSS.wijgridTable);
            }
            baseView.prototype.dispose = function () {
                this.toggleDOMSelection(true);
                this._wijgrid.element.removeClass(wijmo.grid.wijgrid.CSS.table).removeClass(this._wijgrid.options.wijCSS.wijgridTable);
            };
            baseView.prototype.ensureDisabledState = function () {
                var disabledClass = "wijmo-wijgrid" + "-disabled " + this._wijgrid.options.wijCSS.stateDisabled, disabled = this._wijgrid.options.disabled, self = this;
                $.each(this.subTables(), function (key, table) {
                    if(table) {
                        var $table = $(table.element());
                        if(disabled) {
                            $table.addClass(disabledClass);
                            self._wijgrid._setAttr($table, "aria-disabled", true);
                        } else {
                            $table.removeClass(disabledClass);
                            self._wijgrid._setAttr($table, "aria-disabled", false);
                        }
                    }
                });
            };
            baseView.prototype.ensureWidth = function (index, value, oldValue) {
                this._setColumnWidth(index, value);
            };
            baseView.prototype.ensureHeight = function (rowIndex) {
            };
            baseView.prototype.getScrollValue = function () {
                return null;
            };
            baseView.prototype.getVisibleAreaBounds = function (client) {
                throw "not implemented";
            };
            baseView.prototype.getVisibleContentAreaBounds = function () {
                throw "not implemented";
            };
            baseView.prototype.getFixedAreaVisibleBounds = function () {
                throw "not implemented";
            };
            baseView.prototype.isRendered = function () {
                return this.mIsRendered;
            };
            baseView.prototype.render = function () {
                this._ensureRenderBounds();
                this._preRender();
                //var display = this._wijgrid.outerDiv.css("display"); // hide outer element to improve performance.
                //this._wijgrid.outerDiv.css("display", "none");
                this._renderContent();
                //this._wijgrid.outerDiv.css("display", display);
                this._postRender();
                //if (this._wijgrid.outerDiv.is(":visible")) {
                //	this._wijgrid.outerDiv.wijTriggerVisibility(); // notify children widgets
                //}
                            };
            baseView.prototype.toggleDOMSelection = function (enable) {
                $.each(this.subTables(), function (index, htmlTableAccessor) {
                    (new wijmo.grid.domSelection(htmlTableAccessor.element())).toggleSelection(enable);
                });
                (new wijmo.grid.domSelection(this._wijgrid.outerDiv)).toggleSelection(enable);
            };
            baseView.prototype.updateSplits = function (scrollValue) {
                throw "not implemented";
            };
            baseView.prototype.getInlineTotalWidth = function () {
                throw "not implemented";
            };
            baseView.prototype.bodyRows = // public **
            // ** DOMTable abstraction
            // ** rows accessors
            function () {
                if(!this._bodyRowsAccessor) {
                    if(!this.isRendered()) {
                        throw "not rendered yet";
                    }
                    this._bodyRowsAccessor = new wijmo.grid.rowAccessor(this, wijmo.grid.rowScope.body, 0, 0);
                }
                return this._bodyRowsAccessor;
            };
            baseView.prototype.filterRow = function () {
                if(this._wijgrid.options.showFilter) {
                    if(!this.isRendered()) {
                        throw "not rendered yet";
                    }
                    var accessor = new wijmo.grid.rowAccessor(this, wijmo.grid.rowScope.head, 0, 0);
                    return accessor.item(accessor.length() - 1);// filter is the last row in the tHead section
                    
                }
                return null;
            };
            baseView.prototype.footerRow = function () {
                if(this._wijgrid.options.showFooter) {
                    if(!this.isRendered()) {
                        throw "not rendered yet";
                    }
                    var accessor = new wijmo.grid.rowAccessor(this, wijmo.grid.rowScope.foot, 0, 0);
                    return accessor.item(0);
                }
            };
            baseView.prototype.headerRows = function () {
                var bottomOffset;
                if(!this._headerRowsAccessor) {
                    if(!this.isRendered()) {
                        throw "not rendered yet";
                    }
                    bottomOffset = this._wijgrid.options.showFilter ? 1 : 0;
                    this._headerRowsAccessor = new wijmo.grid.rowAccessor(this, wijmo.grid.rowScope.head, 0, bottomOffset);
                }
                return this._headerRowsAccessor;
            };
            baseView.prototype.rows = function () {
                if(!this._rowsAccessor) {
                    if(!this.isRendered()) {
                        throw "not rendered yet";
                    }
                    this._rowsAccessor = new wijmo.grid.rowAccessor(this, wijmo.grid.rowScope.table, 0, 0);
                }
                return this._rowsAccessor;
            };
            baseView.prototype.focusableElement = // rows accessors **
            function () {
                return this._wijgrid.outerDiv;
            };
            baseView.prototype.forEachColumnCell = function (columnIndex, callback, param) {
                throw "not implemented";
            };
            baseView.prototype.forEachRowCell = function (rowIndex, callback, param) {
                throw "not implemented";
            };
            baseView.prototype.getAbsoluteCellInfo = // important: only body cells can be virtualized
            function (domCell, virtualize) {
                throw "not implemented";
            };
            baseView.prototype.getAbsoluteRowIndex = function (domRow) {
                throw "not implemented";
            };
            baseView.prototype.getCell = function (absColIdx, absRowIdx) {
                throw "not implemented";
            };
            baseView.prototype.getColumnIndex = function (domCell) {
                throw "not implemented";
            };
            baseView.prototype.getHeaderCell = function (absColIdx) {
                throw "not implemented";
            };
            baseView.prototype.getJoinedCols = // [col, col]
            function (columnIndex) {
                throw "not implemented";
            };
            baseView.prototype.getJoinedRows = // [row, row]
            function (rowIndex, rowScope) {
                throw "not implemented";
            };
            baseView.prototype.getJoinedTables = // [table, table, offset:number]
            function (byColumn, index) {
                throw "not implemented";
            };
            baseView.prototype.subTables = function () {
                throw "not implemented";
            };
            baseView.prototype._getMappedScrollMode = // DOMTable abstraction **
            // ** private abstract
            function () {
                var scrollMode = this._wijgrid.options.scrollMode, vScrollBarVisibility = "auto", hScrollBarVisibility = "auto";
                switch(scrollMode) {
                    case "horizontal":
                        vScrollBarVisibility = "hidden";
                        hScrollBarVisibility = "visible";
                        break;
                    case "vertical":
                        vScrollBarVisibility = "visible";
                        hScrollBarVisibility = "hidden";
                        break;
                    case "both":
                        vScrollBarVisibility = "visible";
                        hScrollBarVisibility = "visible";
                        break;
                }
                return {
                    vScrollBarVisibility: vScrollBarVisibility,
                    hScrollBarVisibility: hScrollBarVisibility
                };
            };
            baseView.prototype._postRender = // ** rendering
            function () {
                this.mIsRendered = true;
                this.ensureDisabledState();
                // ** cache some values to speedup sizes manipulation (using IE especially) **
                // reset
                this._sizesAdjCache.col = 0;
                this._sizesAdjCache.th = 0;
                this._sizesAdjCache.subTable = 0;
                // set a new values
                var leaves = this._wijgrid._field("visibleLeaves");
                if(leaves.length > 0) {
                    // note: we assume that the margins, paddings and borders are common to all of the th\ col elements.
                                        var th = this.getHeaderCell(0), cols = this.getJoinedCols(0);
                    if(th) {
                        this._sizesAdjCache.th = $(th).leftBorderWidth() + $(th).rightBorderWidth();
                    }
                    if(cols && cols.length) {
                        this._sizesAdjCache.col = $(cols[0]).leftBorderWidth() + $(cols[0]).rightBorderWidth();
                    }
                }
                var subTable = this.subTables()[0];
                this._sizesAdjCache.subTable = $(subTable.element()).leftBorderWidth() + $(subTable.element()).rightBorderWidth();
            };
            baseView.prototype._preRender = function () {
                this.mIsRendered = false;
            };
            baseView.prototype._ensureRenderBounds = function () {
                var dataRange = this._wijgrid._getDataCellsRange(grid.dataRowsRangeMode.sketch);
                // render all items of the sketchTable
                this._bounds.start = 0;
                this._bounds.end = dataRange.bottomRight().rowIndex();
            };
            baseView.prototype._renderContent = function () {
                this._renderCOLS();
                this._renderHeader();
                if(this._wijgrid.options.showFilter) {
                    this._renderFilter();
                }
                this._renderBody();
                if(this._wijgrid.options.showFooter) {
                    this._renderFooter();
                }
            };
            baseView.prototype._renderCOLS = function () {
                var visibleLeaves = this._wijgrid._field("visibleLeaves"), leaf, domCol, i, len;
                for(i = 0 , len = visibleLeaves.length; i < len; i++) {
                    leaf = visibleLeaves[i];
                    domCol = this._createCol(leaf, i);
                    this._appendCol(domCol, leaf, i);
                }
            };
            baseView.prototype._renderHeader = function () {
                var rt = wijmo.grid.rowType, rs = wijmo.grid.renderState, cht = this._wijgrid._columnsHeadersTable(), i, height, rowInfo;
                if(cht && (height = cht.length)) {
                    for(i = 0; i < height; i++) {
                        rowInfo = this._insertEmptyRow(rt.header, rs.rendering, i, -1, -1, -1, undefined, {
                        });
                        this._renderRow(rowInfo, null, cht[i]);
                    }
                }
            };
            baseView.prototype._renderFilter = function () {
                var rowInfo = this._insertEmptyRow(wijmo.grid.rowType.filter, wijmo.grid.renderState.rendering, -1, -1, -1, -1, undefined, {
                });
                this._renderRow(rowInfo, this._wijgrid._field("visibleLeaves"), null);
            };
            baseView.prototype._renderBody = function () {
                var rs = wijmo.grid.renderState, visibleLeaves = this._wijgrid._field("visibleLeaves"), sketch = this._wijgrid.sketchTable, dataRowIndex = -1, virtualDataItemIndexBase = 0, cnt = 0, dataOffset = this._wijgrid._dataOffset;
                // >= 0 when server-side virtual scrolling is used.
                                // render rows
                var self = this;
                if(this._bounds.start >= 0 && this._bounds.end >= 0) {
                    this._wijgrid._renderableBoundsCollection().forEachIndex(this._bounds.start, this._bounds.end - this._bounds.start + 1, function (idx) {
                        var sketchRow = sketch.row(idx - dataOffset), isDataRow = sketchRow.isDataRow(), groupKey = (sketchRow).groupByValue, rowInfo = self._insertEmptyRow(sketchRow.rowType, rs.rendering, cnt++, // sectionRowIndex
                        isDataRow ? ++dataRowIndex : -1, sketchRow.dataItemIndex(), sketchRow.dataItemIndex(virtualDataItemIndexBase), groupKey, sketchRow.extInfo);
                        self._renderRow(rowInfo, visibleLeaves, sketchRow);
                    });
                }
            };
            baseView.prototype._renderFooter = function () {
                var rowInfo = this._insertEmptyRow(wijmo.grid.rowType.footer, wijmo.grid.renderState.rendering, -1, -1, -1, -1, undefined, {
                });
                this._renderRow(rowInfo, this._wijgrid._field("visibleLeaves"), null);
            };
            baseView.prototype._insertEmptyRow = function (rowType, renderState, sectionRowIndex, dataRowIndex, dataItemIndex, virtualDataItemIndex, groupByValue, extInfo) {
                var domRow = this._wijgrid._onViewInsertEmptyRow.apply(this._wijgrid, arguments), domRowArr = this._insertRow(rowType, sectionRowIndex, domRow);
                if(renderState === undefined) {
                    renderState = wijmo.grid.renderState.rendering;
                }
                return this._createRowInfo(domRowArr, rowType, renderState, sectionRowIndex, dataRowIndex, dataItemIndex, virtualDataItemIndex, groupByValue, extInfo);
            };
            baseView.prototype._createEmptyCell = function (rowInfo, dataCellIndex, column) {
                var rt = wijmo.grid.rowType, domCell = this._wijgrid._onViewCreateEmptyCell.apply(this._wijgrid, arguments);
                return this._createCell(rowInfo.type, domCell);
            };
            baseView.prototype._insertRow = // override
            function (rowType, sectionRowIndex, domRow/* optional, used by c1gridview to clone rows of the original table */ ) {
                throw "not implemented";
            };
            baseView.prototype._createCell = function (rowType, domCell/* optional, used by c1gridview to clone cells of the original table */ ) {
                var rt = wijmo.grid.rowType, innerContainer;
                if(!domCell) {
                    if(rowType === rt.header) {
                        domCell = document.createElement("th");
                    } else {
                        domCell = document.createElement("td");
                    }
                }
                if(rowType !== rt.filter) {
                    // * analogue of domCell.wrapInner("<div class=\"wijmo-wijgrid-innercell\"></div>")
                    innerContainer = document.createElement("div");
                    innerContainer.className = wijmo.grid.wijgrid.CSS.cellContainer + " " + this._wijgrid.options.wijCSS.wijgridCellContainer;
                    if(domCell.firstChild) {
                        // move nodes from domCell to innerContainer
                        while(domCell.firstChild) {
                            innerContainer.appendChild(domCell.firstChild);
                        }
                    }
                    domCell.appendChild(innerContainer);
                }
                return $(domCell);
            };
            baseView.prototype._appendCell = function (rowInfo, cellIndex, $cell) {
                throw "not implemented";
            };
            baseView.prototype._createCol = function (column, visibleIdx) {
                throw "not implemented";
            };
            baseView.prototype._appendCol = function (domCol, column, visibleIdx) {
                throw "not implemented";
            };
            baseView.prototype._renderRow = // item is a sketchRow or IColumnHeaderInfo[] if row is the header row.
            function (rowInfo, visibleLeaves, item) {
                var $rt = wijmo.grid.rowType, rowAttr, rowStyle;
                switch(rowInfo.type) {
                    case $rt.filter:
                        this._renderFilterRow(rowInfo, visibleLeaves);
                        break;
                    case $rt.footer:
                        this._renderFooterRow(rowInfo, visibleLeaves);
                        break;
                    case $rt.header:
                        this._renderHeaderRow(rowInfo, item);
                        break;
                    case $rt.data:
                    case $rt.data | $rt.dataAlt:
                        this._renderDataRow(rowInfo, visibleLeaves, item);
                        rowAttr = item.attr();
                        rowStyle = item.style();
                        break;
                    case $rt.emptyDataRow:
                    case $rt.groupHeader:
                    case $rt.groupFooter:
                        this._renderSpannedRow(rowInfo, visibleLeaves, item);
                        rowAttr = item.attr();
                        rowStyle = item.style();
                        break;
                    default:
                        throw "unknown rowType";
                }
                this._rowRendered(rowInfo, rowAttr, rowStyle);
            };
            baseView.prototype._renderCell = function (rowInfo, cellIndex, value, useHtml, leaf, state, attr, style) {
                var $cell = this._createEmptyCell(rowInfo, leaf.dataIndex, leaf);
                var $container = (rowInfo.type === wijmo.grid.rowType.filter) ? $cell : $($cell[0].firstChild);// $cell.children("div"); -- slow
                
                this._appendCell(rowInfo, cellIndex, $cell);
                if(useHtml) {
                    $container.html(value);
                } else {
                    this._wijgrid.cellFormatter.format($cell, $container, leaf, value, rowInfo);
                }
                this._cellRendered(rowInfo, $cell, cellIndex, leaf, state, attr, style);
            };
            baseView.prototype._renderDataRow = function (rowInfo, visibleLeaves, sketchRow) {
                var i, len, column, dataIndex, cellValue, cellAttr, cellStyle, cellState;
                for(i = 0 , len = visibleLeaves.length; i < len; i++) {
                    column = visibleLeaves[i];
                    dataIndex = column.dataIndex;
                    if(dataIndex < 0) {
                        // unbound column
                        cellAttr = null;
                        cellStyle = null;
                        cellValue = null;
                    } else {
                        var cell = sketchRow.cell(dataIndex);
                        if(!cell || !cell.visible()) {
                            continue;
                        }
                        cellValue = this._wijgrid.toStr(column, cell.value);
                        cellAttr = cell.attr();
                        cellStyle = cell.style();
                    }
                    cellState = rowInfo.state;
                    if(column.readOnly) {
                        cellState &= ~wijmo.grid.renderState.editing;
                    }
                    this._renderCell(rowInfo, i, cellValue, false, column, cellState, cellAttr, cellStyle);
                }
            };
            baseView.prototype._renderFilterRow = function (rowInfo, visibleLeaves) {
                var i, len, leaf;
                for(i = 0 , len = visibleLeaves.length; i < len; i++) {
                    leaf = visibleLeaves[i];
                    this._renderCell(rowInfo, i, wijmo.grid.filterHelper.getSingleValue(leaf.filterValue), false, leaf, rowInfo.state);
                }
            };
            baseView.prototype._renderFooterRow = function (rowInfo, visibleLeaves) {
                var i, len;
                for(i = 0 , len = visibleLeaves.length; i < len; i++) {
                    this._renderCell(rowInfo, i, "", false, visibleLeaves[i], rowInfo.state);
                }
            };
            baseView.prototype._renderHeaderRow = function (rowInfo, item) {
                var i, len, thX = 0, headerInfo;
                for(i = 0 , len = item.length; i < len; i++) {
                    headerInfo = item[i];
                    if(headerInfo.column && headerInfo.column.parentVis) {
                        headerInfo.column.thX = thX++;
                        headerInfo.column.thY = rowInfo.sectionRowIndex;
                        this._renderCell(rowInfo, i, headerInfo.column.headerText, false, headerInfo.column, rowInfo.state, {
                            colSpan: headerInfo.colSpan,
                            rowSpan: headerInfo.rowSpan
                        });
                    }
                }
            };
            baseView.prototype._renderSpannedRow = function (rowInfo, visibleLeaves, sketchRow) {
                var i, leaf, len = Math.min(visibleLeaves.length, sketchRow.cellCount());
                for(i = 0; i < len; i++) {
                    var useHTML = rowInfo.type === wijmo.grid.rowType.emptyDataRow;// ignore cellFormatter and set content directly
                    
                    var cell = sketchRow.cell(i);
                    this._renderCell(rowInfo, i, cell.html, useHTML, visibleLeaves[i], rowInfo.state, cell.attr(), cell.style());
                }
            };
            baseView.prototype._cellRendered = function (rowInfo, $cell, cellIndex, leaf, cellState, attr, style) {
                this._wijgrid.cellStyleFormatter.format($cell, cellIndex, leaf, rowInfo, cellState, attr, style);
                this._changeCellRenderState($cell, cellState, false);
                this._wijgrid._onViewCellRendered(rowInfo, $cell, cellIndex, leaf);
            };
            baseView.prototype._rowRendered = function (rowInfo, rowAttr, rowStyle) {
                this._wijgrid.rowStyleFormatter.format(rowInfo, rowAttr, rowStyle);
                // change renderState AND associate rowInfo object with DOMRow
                //this._changeRowRenderState(rowInfo, $.wijmo.wijgrid.renderState.rendering, false);
                rowInfo.state &= ~wijmo.grid.renderState.rendering;
                this._setRowInfo(rowInfo.$rows, rowInfo);
                this._wijgrid._onViewRowRendered(rowInfo, rowAttr, rowStyle);
            };
            baseView.prototype._makeRowEditable = function (rowInfo) {
                var leaves = this._wijgrid._field("visibleLeaves"), cellEditor = new wijmo.grid.cellEditorHelper();
                if(leaves) {
                    for(var i = 0; i < leaves.length; i++) {
                        var column = leaves[i];
                        if(!column.readOnly && wijmo.grid.validDataKey(column.dataKey)) {
                            var $cell = rowInfo.$rows.children("td, th").eq(i);
                            if($cell.length) {
                                var cellInfo = this.getAbsoluteCellInfo($cell[0], true);
                                this._changeCellRenderState($cell, wijmo.grid.renderState.editing, cellEditor.cellEditStart(this._wijgrid, cellInfo, null))// add or remove editing state depends on cellEditStart result.
                                ;
                            }
                        }
                    }
                }
            };
            baseView.prototype._isBodyRow = function (rowInfo) {
                var $rt = wijmo.grid.rowType, type = rowInfo.type;
                return ((type & $rt.data) || (type === $rt.groupHeader) || (type === $rt.groupFooter) || (type === $rt.emptyDataRow));
            };
            baseView.prototype._changeRowRenderState = function (rowInfo, state, combine) {
                if(combine) {
                    // combine
                    rowInfo.state |= state;
                } else {
                    // clear
                    rowInfo.state &= ~state;
                }
                this._setRowInfo(rowInfo.$rows, rowInfo);
            };
            baseView.prototype._changeCellRenderState = function ($obj, state, combine) {
                var $dp = wijmo.grid.dataPrefix, prefix = this._wijgrid._data$prefix, prevState = $dp($obj, prefix, "renderState");
                if(combine) {
                    // combine
                    state = prevState | state;
                    $dp($obj, prefix, "renderState", state);
                } else {
                    // clear
                    state = prevState & ~state;
                    $dp($obj, prefix, "renderState", state);
                }
                return state;
            };
            baseView.prototype._adjustWidthArray = // rendering **
            // ** sizing
            function (maxWidthArray, minWidthArray, expectedWidth, ensureColumnsPxWidth) {
                var maxWidth = this._sumWidthArray(maxWidthArray), minWidth = this._sumWidthArray(minWidthArray), widthArray = [], adjustWidth, expandCount = 0, expandWidth, remainingWidth, bFirst = true;
                if(maxWidth <= expectedWidth) {
                    $.extend(true, widthArray, maxWidthArray);
                    if(maxWidth === expectedWidth || ensureColumnsPxWidth) {
                        return widthArray;
                    } else {
                        adjustWidth = expectedWidth - maxWidth;
                    }
                } else {
                    $.extend(true, widthArray, minWidthArray);
                    if(minWidth >= expectedWidth) {
                        return widthArray;
                    } else {
                        adjustWidth = expectedWidth - minWidth;
                    }
                }
                $.each(widthArray, function (index, colWidth) {
                    if(!colWidth.real) {
                        expandCount++;
                    }
                });
                if(expandCount !== 0) {
                    expandWidth = Math.floor(adjustWidth / expandCount);
                    remainingWidth = adjustWidth - expandWidth * expandCount;
                    $.each(widthArray, function (index, colWidth) {
                        if(!colWidth.real) {
                            colWidth.width += expandWidth;
                            if(bFirst) {
                                colWidth.width += remainingWidth;
                                bFirst = false;
                            }
                        }
                    });
                }
                return widthArray;
            };
            baseView.prototype._getColumnWidth = function (index) {
                var result, leaf = this._wijgrid._field("visibleLeaves")[index];
                if(leaf._realWidth !== undefined) {
                    result = {
                        width: leaf._realWidth,
                        real: true
                    };
                } else if(leaf.isRowHeader) {
                    result = {
                        width: this._rowHeaderSize,
                        real: true
                    };
                } else {
                    var maxW = 0, joinedTables = this.getJoinedTables(true, index), relIdx = joinedTables[2];
                    for(var i = 0; i < 2; i++) {
                        var table = joinedTables[i];
                        if(table !== null) {
                            var rows = table.element().rows, row, len = rows.length;
                            if(len > 0) {
                                // try to find a row which doesn't contains a spanned cells
                                for(var j = len - 1, row = null; j >= 0; j--) {
                                    if((rows[j]).cells.length === table.width()) {
                                        row = rows[j];
                                        if(row.style.display !== "none") {
                                            break;// break on first visible row, skip invisible rows
                                            
                                        }
                                    }
                                }
                                if(row) {
                                    // can be invisible
                                    var cell = row.cells[relIdx];
                                    maxW = Math.max(maxW, $(cell).outerWidth());
                                }
                            }
                        }
                    }
                    result = {
                        width: maxW,
                        real: false
                    };
                }
                return result;
            };
            baseView.prototype._setColumnWidth = function (index, px) {
                var th = this.getHeaderCell(index), cols = this.getJoinedCols(index), value;
                if(px) {
                    var self = this;
                    // $(th).setOutWidth(px); // very slow in IE9
                    if(th) {
                        value = px - this._sizesAdjCache.th;
                        if(value < 0) {
                            value = 0;
                        }
                        th.style.width = value + "px";
                    }
                    $.each(cols, function (i, col) {
                        if(col) {
                            // $(col).setOutWidth(px); // very slow in IE9
                            value = px - self._sizesAdjCache.col;
                            if(value < 0) {
                                value = 0;
                            }
                            col.style.width = value + "px";
                        }
                    });
                }
            };
            baseView.prototype._setTableWidth = function (subTables, expectedWidth, expandColumnWidth, expandIndex) {
                var after, diff, self = this;
                $.each(subTables, function (index, table) {
                    //table.css("table-layout", "fixed").setOutWidth(expectedWidth); // very slow in IE9
                    table[0].style.tableLayout = "fixed";
                    table[0].style.width = (expectedWidth - self._sizesAdjCache.subTable) + "px";
                });
                after = subTables[0].outerWidth();
                diff = after - expectedWidth;
                if(diff !== 0) {
                    this._setColumnWidth(expandIndex, expandColumnWidth - diff);
                }
            };
            baseView.prototype._sumWidthArray = function (widthArray, startIndex, endIndex) {
                var result = 0;
                $.each(widthArray, function (index, colWidth) {
                    if(startIndex !== undefined && endIndex !== undefined && (index < startIndex || index > endIndex)) {
                        return true;
                    }
                    result += colWidth.width;
                });
                return result;
            };
            baseView.prototype._clearBody = // sizing **
            // private abstract **
            function () {
                $.each(this.subTables(), function (key, table) {
                    table.clearSection(2);
                });
            };
            baseView.prototype._rebuildOffsets = function () {
                $.each(this.subTables(), function (key, table) {
                    table.rebuildOffsets();
                });
            };
            baseView.prototype._removeBodyRow = function (sectionRowIndex, changeOffsets) {
                if (typeof changeOffsets === "undefined") { changeOffsets = true; }
                var $rt = wijmo.grid.rowType, rows = this._wijgrid._rows(), i, len, rowInfo, absRowIdx;
                if((sectionRowIndex >= 0) && (sectionRowIndex < (len = rows.length()))) {
                    // remove DOMRows
                    rowInfo = this._getRowInfo(rows.item(sectionRowIndex), false);
                    absRowIdx = this.getAbsoluteRowIndex(rowInfo.$rows[0]);
                    rowInfo.$rows.remove();
                    // ** update offsets
                    if(changeOffsets) {
                        var joinedTables = this.getJoinedTables(false, absRowIdx), ta;
                        if(ta = joinedTables[0]) {
                            ta.removeOffset(joinedTables[2]);
                        }
                        if(ta = joinedTables[1]) {
                            ta.removeOffset(joinedTables[2]);
                        }
                    }
                    // update offsets **
                                    }
            };
            baseView.prototype._insertBodyRow = function (sketchRow, sectionRowIndex, dataItemIndex, virtualDataItemIndex) {
                var visibleLeaves = this._wijgrid._field("visibleLeaves"), $rt = wijmo.grid.rowType, view = this._wijgrid._view(), rows = this._wijgrid._rows(), len = rows.length(), isDataRow = sketchRow.isDataRow(), rowInfo, absRowIdx;
                if(sectionRowIndex < 0 || sectionRowIndex >= len || (!sectionRowIndex && sectionRowIndex !== 0)) {
                    sectionRowIndex = len// append
                    ;
                }
                rowInfo = this._insertEmptyRow(sketchRow.rowType, sketchRow.renderState, sectionRowIndex, -1, // TODO: dataRowIndex
                dataItemIndex, virtualDataItemIndex, (sketchRow).groupByValue, sketchRow.extInfo);
                this._renderRow(rowInfo, visibleLeaves, sketchRow);
                // ** update offsets
                absRowIdx = this.getAbsoluteRowIndex(rowInfo.$rows[0]);
                var joinedTables = this.getJoinedTables(false, absRowIdx), ta;
                if(ta = joinedTables[0]) {
                    ta.insertOffset(absRowIdx);
                }
                if(ta = joinedTables[1]) {
                    ta.insertOffset(absRowIdx);
                }
                // update offsets **
                return rowInfo;
            };
            baseView.prototype._findRowInfo = function (callback) {
                var rowsAccessor = this.bodyRows(), i = 0, len = rowsAccessor.length(), rowInfo;
                if($.isFunction(callback)) {
                    for(i = 0; i < len; i++) {
                        rowInfo = this._getRowInfo(rowsAccessor.item(i));
                        if(callback(rowInfo) === true) {
                            return rowInfo;
                        }
                    }
                }
                return null;
            };
            baseView.prototype._setRowInfo = function (obj, rowInfo) {
                var hasRows = "$rows" in rowInfo, hasData = "data" in rowInfo, tmpRows, tmpData;
                if(hasRows) {
                    tmpRows = rowInfo.$rows;
                    delete rowInfo.$rows;
                }
                if(hasData) {
                    tmpData = rowInfo.data;
                    delete rowInfo.data;
                }
                wijmo.grid.dataPrefix(obj, this._wijgrid._data$prefix, "rowInfo", rowInfo);
                if(hasRows) {
                    rowInfo.$rows = tmpRows;
                }
                if(hasData) {
                    rowInfo.data = tmpData;
                }
            };
            baseView.prototype._getRowInfo = function (rowObj, retrieveDataItem) {
                if (typeof retrieveDataItem === "undefined") { retrieveDataItem = true; }
                var wijgrid = this._wijgrid, $rows = rowObj[1] ? $(rowObj) : $(rowObj[0]), rowInfo = wijmo.grid.dataPrefix($rows, wijgrid._data$prefix, "rowInfo"), tmp;
                // add $rows property
                rowInfo.$rows = $rows;
                // set data property
                if(retrieveDataItem && (rowInfo.dataItemIndex >= 0) && (rowInfo.type & wijmo.grid.rowType.data)) {
                    try  {
                        rowInfo.data = wijgrid._getDataItem(rowInfo.dataItemIndex);
                    } catch (ex) {
                        rowInfo.data = null// underlying data item was removed?
                        ;
                    }
                }
                return rowInfo;
            };
            baseView.prototype._getRowInfoBySketchRowIndex = function (sketchIndex, retrieveDataItem) {
                if (typeof retrieveDataItem === "undefined") { retrieveDataItem = true; }
                if(sketchIndex >= 0) {
                    var renderedRowIndex = this._isRowRendered(sketchIndex);
                    if(renderedRowIndex >= 0) {
                        var rowObj = this.bodyRows().item(renderedRowIndex);
                        if(rowObj) {
                            return this._getRowInfo(rowObj, retrieveDataItem);
                        }
                    } else {
                        // detached row
                                                var sketchRow = this._wijgrid.sketchTable.row(sketchIndex), rowInfo = null;
                        if(sketchRow) {
                            rowInfo = sketchRow.getRowInfo();
                            // set data property
                            if(retrieveDataItem && (rowInfo.dataItemIndex >= 0) && sketchRow.isDataRow()) {
                                try  {
                                    rowInfo.data = this._wijgrid._getDataItem(rowInfo.dataItemIndex);
                                } catch (ex) {
                                    rowInfo.data = null// underlying data item was removed?
                                    ;
                                }
                            }
                        }
                        return rowInfo;
                    }
                }
                return null;
            };
            baseView.prototype._createRowInfo = function (row, type, state, sectionRowIndex, dataRowIndex, dataItemIndex, virtualDataItemIndex, groupByValue, extInfo) {
                var tmp, rowInfo = {
                    type: type,
                    state: state,
                    sectionRowIndex: sectionRowIndex,
                    dataRowIndex: dataRowIndex,
                    dataItemIndex: dataItemIndex,
                    virtualDataItemIndex: virtualDataItemIndex,
                    $rows: row ? $(row) : null,
                    _extInfo: extInfo
                };
                if(groupByValue !== undefined) {
                    rowInfo.groupByValue = groupByValue;
                }
                // set data property
                if((dataItemIndex >= 0) && (type & wijmo.grid.rowType.data)) {
                    rowInfo.data = this._wijgrid._getDataItem(dataItemIndex);
                }
                return rowInfo;
            };
            baseView.prototype._isRowRendered = // returns tbody row index or -1
            function (sketchRowIndex) {
                var visibleIndex = this._wijgrid._renderableBoundsCollection().getRenderedIndex(sketchRowIndex);
                if(visibleIndex >= 0) {
                    if(visibleIndex >= this._bounds.start && visibleIndex <= this._bounds.end) {
                        return visibleIndex - this._bounds.start;
                    }
                }
                return -1;
            };
            return baseView;
        })();
        grid.baseView = baseView;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    /// <reference path="baseView.ts" />
    /// <reference path="htmlTableAccessor.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var flatView = (function (_super) {
            __extends(flatView, _super);
            function flatView(wijgrid, renderBounds) {
                        _super.call(this, wijgrid, renderBounds);
                this._dataTable = null;
                this._contentArea = null;
            }
            flatView.prototype.ensureWidth = function (index, value, oldValue) {
                var $table = $(this._dataTable.element()), tableWidth = $table.width() + value - oldValue;
                _super.prototype.ensureWidth.call(this, index, value, oldValue);
                this._setTableWidth([
                    $table
                ], tableWidth, value, index);
            };
            flatView.prototype.getVisibleAreaBounds = function (client) {
                var bounds = wijmo.grid.bounds(this._dataTable.element(), client);
                return bounds;
            };
            flatView.prototype.getVisibleContentAreaBounds = function () {
                return this.getVisibleAreaBounds();
            };
            flatView.prototype.updateSplits = function (scrollValue) {
                var self = this, wijgrid = this._wijgrid, o = wijgrid.options, gridElement = wijgrid.element, maxWidthArray = [], minWidthArray = [], resultWidthArray = [], visibleLeaves = wijgrid._field("visibleLeaves"), outerDiv = wijgrid.outerDiv, outerWidth, expandIndex;
                gridElement.css({
                    "table-layout": "",
                    "width": "auto"
                });
                $.each(visibleLeaves, function (index, leaf) {
                    var isPercentage, w = leaf.width;
                    if(w || (w === 0)) {
                        isPercentage = ((typeof (w) === "string") && (w.length > 1) && (w[w.length - 1] === "%"));
                        //convert percent to value
                        if(isPercentage) {
                            w = outerDiv.width() * parseFloat(w) / 100;
                        } else {
                            w = parseFloat(w);
                        }
                        if(leaf.ensurePxWidth || (leaf.ensurePxWidth === undefined && o.ensureColumnsPxWidth)) {
                            leaf._realWidth = w;
                        }
                        self._setColumnWidth(index, w);
                    }
                });
                // read column widths.
                $.each(visibleLeaves, function (index, leaf) {
                    maxWidthArray.push(self._getColumnWidth(index));
                });
                gridElement.css("width", "1px");
                $.each(visibleLeaves, function (index, leaf) {
                    minWidthArray.push(self._getColumnWidth(index));
                });
                outerWidth = outerDiv.width()// using width() instead of innerWidth() to exclude padding.
                ;
                resultWidthArray = this._adjustWidthArray(maxWidthArray, minWidthArray, outerWidth, o.ensureColumnsPxWidth);
                $.each(resultWidthArray, function (index, colWidth) {
                    var leaf = visibleLeaves[index];
                    if(leaf._realWidth !== undefined) {
                        delete leaf._realWidth;
                        return;
                    }
                    self._setColumnWidth(index, colWidth.width);
                });
                gridElement.css("table-layout", "fixed")// <-- The outerDiv width can change after that
                ;
                expandIndex = resultWidthArray.length - 1;
                if(expandIndex !== -1) {
                    var delta = outerDiv.width() - outerWidth;// test changes
                    
                    resultWidthArray[expandIndex].width += delta;
                    this._setTableWidth([
                        gridElement
                    ], this._sumWidthArray(resultWidthArray, 0, expandIndex), resultWidthArray[expandIndex].width, expandIndex);
                }
            };
            flatView.prototype.getInlineTotalWidth = function () {
                var table = this._dataTable.element(), width = table.style.width;
                if(width && (width !== "auto")) {
                    return width;
                }
                return "";
            };
            flatView.prototype.forEachColumnCell = // public **
            // ** DOMTable abstraction
            function (columnIndex, callback, param) {
                return this._dataTable.forEachColumnCell(columnIndex, callback, param);
            };
            flatView.prototype.forEachRowCell = function (rowIndex, callback, param) {
                return this._dataTable.forEachRowCell(rowIndex, callback, param);
            };
            flatView.prototype.getAbsoluteCellInfo = function (domCell, virtualize) {
                return new wijmo.grid.cellInfo(this.getColumnIndex(domCell), (domCell.parentNode).rowIndex, this._wijgrid, true, virtualize);
            };
            flatView.prototype.getAbsoluteRowIndex = function (domRow) {
                return domRow.rowIndex;
            };
            flatView.prototype.getCell = function (absColIdx, absRowIdx) {
                var cellIdx = this._dataTable.getCellIdx(absColIdx, absRowIdx), rowObj;
                if(cellIdx >= 0) {
                    rowObj = this.getJoinedRows(absRowIdx, 0);
                    if(rowObj[0]) {
                        return rowObj[0].cells[cellIdx];
                    }
                }
                return null;
            };
            flatView.prototype.getColumnIndex = function (domCell) {
                return this._dataTable.getColumnIdx(domCell);
            };
            flatView.prototype.getHeaderCell = function (absColIdx) {
                var leaf = this._wijgrid._field("visibleLeaves")[absColIdx], headerRow;
                if(leaf && (headerRow = this._wijgrid._headerRows())) {
                    return wijmo.grid.rowAccessor.getCell(headerRow.item(leaf.thY), leaf.thX);
                }
                return null;
            };
            flatView.prototype.getJoinedCols = function (columnIndex) {
                var $colGroup = $(this._dataTable.element()).find("> colgroup");
                if($colGroup.length) {
                    if(columnIndex < $colGroup[0].childNodes.length) {
                        return [
                            $colGroup[0].childNodes[columnIndex], 
                            null
                        ];
                    }
                }
                return [
                    null, 
                    null
                ];
            };
            flatView.prototype.getJoinedRows = function (rowIndex, rowScope) {
                return [
                    this._dataTable.getSectionRow(rowIndex, rowScope), 
                    null
                ];
            };
            flatView.prototype.getJoinedTables = function (byColumn, index) {
                return [
                    this._dataTable, 
                    null, 
                    index
                ];
            };
            flatView.prototype.subTables = function () {
                return [
                    this._dataTable
                ];
            };
            flatView.prototype._preRender = // DOMTable abstraction **
            // ** private abstract
            //  ** render
            function () {
                _super.prototype._preRender.call(this);
                this._dataTable = new wijmo.grid.htmlTableAccessor(this._wijgrid.element[0], true, true, true)// skip offsets, ensure tbody + colgroup
                ;
            };
            flatView.prototype._postRender = function () {
                this._wijgrid.element.find("> tbody").addClass(this._wijgrid.options.wijCSS.content);
                this._dataTable = new wijmo.grid.htmlTableAccessor(this._wijgrid.element[0])// create with offsets
                ;
                this._wijgrid._setAttr(this._wijgrid.element, {
                    role: "grid",
                    cellpadding: "0",
                    border: "0",
                    cellspacing: "0"
                });
                this._wijgrid.element.css("border-collapse", "separate");
                _super.prototype._postRender.call(this);
            };
            flatView.prototype._insertRow = function (rowType, sectionRowIndex, domRow/* optional, used by c1gridview to clone rows of the original table */ ) {
                var $rt = wijmo.grid.rowType, tableSection;
                switch(rowType) {
                    case $rt.header:
                    case $rt.filter:
                        tableSection = this._dataTable.ensureTHead();
                        break;
                    case $rt.footer:
                        tableSection = this._dataTable.ensureTFoot();
                        break;
                    default:
                        // tbody
                        tableSection = this._dataTable.ensureTBody();
                }
                if(domRow) {
                    // append only
                    return [
                        tableSection.appendChild(domRow)
                    ];
                } else {
                    if(sectionRowIndex > tableSection.rows.length) {
                        sectionRowIndex = -1;
                    }
                    return [
                        tableSection.insertRow(sectionRowIndex)
                    ];
                }
            };
            flatView.prototype._rowRendered = function (rowInfo, rowAttr, rowStyle) {
                var domRow = rowInfo.$rows[0];
                if(!domRow.cells.length && this._isBodyRow(rowInfo)) {
                    domRow.parentNode.removeChild(domRow);
                } else {
                    _super.prototype._rowRendered.call(this, rowInfo, rowAttr, rowStyle);
                }
            };
            flatView.prototype._appendCell = function (rowInfo, cellIndex, $cell) {
                rowInfo.$rows[0].appendChild($cell[0]);
                //rowInfo.$rows.append($cell);
                            };
            flatView.prototype._createCol = function (column, visibleIdx) {
                return [
                    document.createElement("col")
                ];
            };
            flatView.prototype._appendCol = function (domCol, column, visibleIdx) {
                this._dataTable.appendCol(domCol[0]);
            };
            return flatView;
        })(grid.baseView);
        grid.flatView = flatView;        
        // render **
        // private abstract **
        // ** private specific
        // private specific **
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../../../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts" />
    /// <reference path="../../../wijlist/jquery.wijmo.wijlist.ts" />
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    /// <reference path="baseView.ts" />
    /// <reference path="uiVirtualScroller.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var fixedView = (function (_super) {
            __extends(fixedView, _super);
            function fixedView(wijgrid, renderBounds) {
                        _super.call(this, wijgrid, renderBounds);
                this._verScrollBarSize = wijmo.grid.getSuperPanelScrollBarSize();
                this._viewTables = {
                };
                // rendered DOM tables
                this._splitAreas = {
                };
                // scrolling div
                this._superPanelElementsCache = {
                };
                this.element = wijgrid.element// table element
                ;
                this._staticDataRowIndex = wijgrid._getStaticIndex(true);
                this._staticRowIndex = wijgrid._getRealStaticRowIndex();
                this._staticColumnIndex = wijgrid._getRealStaticColumnIndex();
                this._staticAllColumnIndex = (this._staticColumnIndex === -1) ? -1 : wijgrid._field("visibleLeaves")[this._staticColumnIndex].leavesIdx;
                this._mouseWheelHandler = $.proxy(this._onMouseWheel, this);
            }
            fixedView.DEFAULT_ROW_HEIGHT_VIRTUAL = 19;
            fixedView.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this._wijgrid.outerDiv.unbind("mousewheel", this._mouseWheelHandler);
            };
            fixedView.prototype.ensureWidth = function (index, value, oldValue) {
                var wijgrid = this._wijgrid, o = wijgrid.options, staticColumnIndex = this._staticColumnIndex, bWest = index <= staticColumnIndex, $tableNW = $(this._viewTables.nw.element()), $tableNE = $(this._viewTables.ne.element()), $tableSW = $(this._viewTables.sw.element()), $tableSE = $(this._viewTables.se.element()), tableArray = bWest ? [
                    $tableNW, 
                    $tableSW
                ] : [
                    $tableNE, 
                    $tableSE
                ], tableWidth = (bWest ? $tableNW.width() : $tableNE.width()) + value - oldValue, scrollValue = this.getScrollValue();
                this._destroySuperPanel();
                _super.prototype.ensureWidth.call(this, index, value, oldValue);
                this._setTableWidth(tableArray, tableWidth, value, index);
                try  {
                    if(staticColumnIndex >= 0) {
                        o.splitDistanceX = $tableNW[0].offsetWidth;
                    } else {
                        o.splitDistanceX = 0;
                    }
                } catch (ex) {
                }
                this._updateSplitAreaBounds(0);
                this._adjustRowsHeights();
                try  {
                    if(this._staticRowIndex >= 0) {
                        o.splitDistanceY = Math.max($tableNW[0].offsetHeight, $tableNE[0].offsetHeight);
                    } else {
                        o.splitDistanceY = 0;
                    }
                } catch (ex) {
                }
                this._updateSplitAreaBounds(1);
                this.refreshPanel(scrollValue);
                var frozener = wijgrid._UIFrozener();
                if(frozener) {
                    frozener.refresh();
                }
            };
            fixedView.prototype.ensureHeight = function (rowIndex) {
                var rowObjsArray, wijgrid = this._wijgrid, o = wijgrid.options, $tableNW = $(this._viewTables.nw.element()), $tableNE = $(this._viewTables.ne.element()), $tableSW = $(this._viewTables.sw.element()), $tableSE = $(this._viewTables.se.element()), scrollValue = this.getScrollValue(), maxHeight;
                this._destroySuperPanel();
                if(arguments.length > 0) {
                    rowObjsArray = this.getJoinedRows(rowIndex, 2);
                    this._setRowHeight(rowObjsArray, this._getRowHeight(rowObjsArray));
                }
                $tableSE.css("height", "");
                $tableSW.css("height", "");
                maxHeight = Math.max($tableSE.height(), $tableSW.height());
                $tableSE.height(maxHeight);
                $tableSW.height(maxHeight);
                try  {
                    if(this._staticRowIndex >= 0) {
                        o.splitDistanceY = Math.max($tableNW[0].offsetHeight, $tableNE[0].offsetHeight);
                    } else {
                        o.splitDistanceY = 0;
                    }
                } catch (ex) {
                }
                this._updateSplitAreaBounds(1);
                this.refreshPanel(scrollValue);
                var frozener = wijgrid._UIFrozener();
                if(frozener) {
                    frozener.refresh();
                }
            };
            fixedView.prototype.getScrollValue = // {x, y} or null
            function () {
                var superPanelObj = this._getSuperPanel();
                return superPanelObj ? {
                    x: superPanelObj.options.hScroller.scrollValue,
                    y: superPanelObj.options.vScroller.scrollValue
                } : null;
            };
            fixedView.prototype.getVisibleAreaBounds = function (client) {
                var bounds = this._isNativeSuperPanel() ? wijmo.grid.bounds(this._getSuperPanelStateContainer(), client) : wijmo.grid.bounds(this._getSuperPanelContentWrapper(), client);
                if(!bounds) {
                    // .wijmo-wijsuperpanel-contentwrapper is not available -- grid is invisible.
                    bounds = wijmo.grid.bounds(this._wijgrid.outerDiv, client);
                }
                return bounds;
            };
            fixedView.prototype.getVisibleContentAreaBounds = function () {
                var visibleBounds = this.getVisibleAreaBounds(true), b00 = // scrollable area
                wijmo.grid.bounds(this._viewTables.nw.element()) || {
                }, b01 = wijmo.grid.bounds(this._viewTables.ne.element()) || {
                }, b10 = wijmo.grid.bounds(this._viewTables.sw.element()) || {
                }, b11 = wijmo.grid.bounds(this._viewTables.se.element()) || {
                }, contentBounds = {
                    top: // tables area
                    visibleBounds.top,
                    left: visibleBounds.left,
                    width: Math.max(b00.width + b01.width, b10.width + b11.width),
                    height: Math.max(b00.height + b10.height, b01.height + b11.height)
                };
                // truncate
                contentBounds.width = Math.min(visibleBounds.width, contentBounds.width);
                contentBounds.height = Math.min(visibleBounds.height, contentBounds.height);
                return contentBounds;
            };
            fixedView.prototype.getRowAreaHeight = function () {
                var container = this._getSuperPanelContentWrapper();
                if(container.length == 0) {
                    container = this._wijgrid.outerDiv;
                }
                var height = container.height();
                // subtract top fixed area
                var topFixedAreaHeight = this._wijgrid.options.splitDistanceY;
                if(topFixedAreaHeight) {
                    height -= topFixedAreaHeight;
                }
                // subtract footer height
                if(this._wijgrid.options.showFooter) {
                    var footer, footerHeight = (this.isRendered() && (footer = this.footerRow())) ? $(footer).height() : this.getDefaultRowHeight();
                    // An assumption. Or we really need to link the footer height with the wijgrid.rowHeight?
                                        height -= footerHeight;
                }
                return height;
            };
            fixedView.prototype.getVirtualPageSize = function (upper) {
                if (typeof upper === "undefined") { upper = true; }
                var rowHeight = this._wijgrid.rowOuterHeight && (this._wijgrid.rowOuterHeight > 0) ? this._wijgrid.rowOuterHeight : this.getDefaultRowHeight();
                var vPageSize = this.getRowAreaHeight() / rowHeight;
                return upper ? Math.ceil(vPageSize) : Math.floor(vPageSize);
            };
            fixedView.prototype.getFixedAreaVisibleBounds = function () {
                var bounds = this.getVisibleAreaBounds(), neBounds = wijmo.grid.bounds(this._splitAreas.ne), nwBounds = wijmo.grid.bounds(this._splitAreas.nw), horBounds = null, verBounds = null;
                if(neBounds.height || nwBounds.height) {
                    horBounds = {
                        left: bounds.left,
                        top: bounds.top,
                        width: bounds.width,
                        height: Math.min(neBounds.height || nwBounds.height, bounds.height)
                    };
                }
                if(nwBounds.width) {
                    verBounds = {
                        left: //left: bounds.left,
                        nwBounds.left,
                        top: bounds.top,
                        width: Math.min(nwBounds.width, bounds.width),
                        height: bounds.height
                    };
                }
                return [
                    horBounds, 
                    verBounds
                ];
            };
            fixedView.prototype.getDefaultRowHeight = function () {
                return (this._wijgrid.options.rowHeight >= 0) ? this._wijgrid.options.rowHeight : fixedView.DEFAULT_ROW_HEIGHT_VIRTUAL;
            };
            fixedView.prototype.refreshPanel = function (scrollValue) {
                var self = this, wijgrid = this._wijgrid, options = wijgrid.options, panelModes = this._getMappedScrollMode(), hScrollValue = scrollValue ? scrollValue.x : null, vScrollValue = scrollValue ? scrollValue.y : null, firstRow = wijgrid._rows().item(0), recreateSuperPanel = false;
                wijgrid.rowOuterHeight = firstRow && firstRow[0] ? $(firstRow[0]).outerHeight() : // use a real height
                this.getDefaultRowHeight();
                if(!this._scroller.data("wijmo-wijsuperpanel")) {
                    recreateSuperPanel = true;
                    if(this._wijgrid._allowVirtualScrolling()) {
                        this.vsUI = new wijmo.grid.uiVirtualScroller(wijgrid, this._splitAreas.se, // content to scroll
                        options.splitDistanceY, // fixed area height
                        wijgrid.rowOuterHeight);
                    }
                    this._scroller.wijsuperpanel({
                        disabled: wijgrid.options.disabled,
                        scroll: $.proxy(this._onScroll, this),
                        bubbleScrollingEvent: true,
                        customScrolling: this._wijgrid._allowVirtualScrolling(),
                        vScroller: {
                            scrollBarVisibility: panelModes.vScrollBarVisibility,
                            "scrollValue": scrollValue ? scrollValue.y : null
                        },
                        hScroller: {
                            scrollBarVisibility: panelModes.hScrollBarVisibility,
                            "scrollValue": scrollValue ? scrollValue.x : null
                        },
                        hScrollerActivating: $.proxy(this._onHScrollerActivating, this)
                    });
                    // wijsuperpanel.hScrollerActivating event is not raised if touch environment is used, simulate it.
                    if(this._isNativeSuperPanel()) {
                        var container = this._getSuperPanelStateContainer();
                        if(container.length && (container[0].offsetHeight !== container[0].clientHeight)) {
                            this._onHScrollerActivating(null, {
                                contentLength: container[0].clientHeight
                            });
                        }
                    }
                    if(!this._isNativeSuperPanel()) {
                        this._getSuperPanelContentWrapper().bind("scroll", function (e) {
                            // #50496: when a overflowing div contains focusable elements it will be scrolled automatically to fit the focused element into view.
                            // Prevent native scrolling to avoid disalignment of the fixed and unfixed areas in IE\ Chrome when partially visible cell gets focus.
                            (e.target).scrollLeft = 0;
                            (e.target).scrollTop = 0;
                            e.preventDefault();
                        });
                    }
                    if(this._wijgrid._allowVirtualScrolling()) {
                        this.vsUI.attach(this._scroller);
                    }
                } else {
                    this._scroller.wijsuperpanel("paintPanel");
                }
                var needVBar = this._testNeedVBar(wijgrid.outerDiv, wijgrid.element, $(this._viewTables.ne.element()), options.scrollMode, wijgrid._autoHeight), excludeVBarWidth = needVBar && !this._testAutohiddenScrollbars();
                var contentWidth = this.getVisibleContentAreaBounds().width;
                this._splitAreas.ne.width(contentWidth - options.splitDistanceX);
                if(recreateSuperPanel && (scrollValue && scrollValue.x)) {
                    // synchronize unfixed areas: NE and SE (#47277)
                    var hPxValue = this._scroller.wijsuperpanel("scrollValueToPx", scrollValue.x, "h");
                    this._setFixedAreaPosition(this._splitAreas.ne, "h", hPxValue, null, true);
                }
                if(options.staticColumnsAlignment === "right") {
                    this._splitAreas.nw.css({
                        "left": "",
                        "right": excludeVBarWidth ? this._verScrollBarSize : 0
                    });
                    this._splitAreas.sw.css({
                        "left": "",
                        "right": excludeVBarWidth ? this._verScrollBarSize : 0
                    });
                }
                this._scroller.find(".wijmo-wijsuperpanel-hbarcontainer, .wijmo-wijsuperpanel-vbarcontainer").css("zIndex", 5);
                if(this._wijgrid._allowVirtualScrolling()) {
                    // re-render
                    this._wijgrid._handleVirtualScrolling(this._bounds.start);
                }
            };
            fixedView.prototype.scrollTo = function (cell, callback, info) {
                var grid = this._wijgrid, virtualScrollToIndex = null;
                if(grid._allowVirtualScrolling()) {
                    var rowIndex = grid._renderableBoundsCollection().getRenderedIndex(cell.rowIndex());
                    var vab, rowsLen = grid._rows().length(), $rows, handleLastRow = (rowIndex - grid._viewPortBounds().start >= rowsLen - 1);
                    // the last row in the current view port
                                        // determine whether virtual scrolling is needed or not
                    if(!cell._isRendered() || (handleLastRow && (vab = this.getVisibleAreaBounds(true)) && ($rows = cell.row().$rows) && ($rows.offset().top + $rows.outerHeight() > vab.top + vab.height))) {
                        // exceeded wijgrid bounds
                        virtualScrollToIndex = rowIndex;
                        if(cell.rowIndex() > info.changingEventArgs.oldRowIndex) {
                            virtualScrollToIndex -= rowsLen - 1;
                            virtualScrollToIndex += 1;
                        }
                    }
                }
                var superPanelObj = this._getSuperPanel();
                if(virtualScrollToIndex !== null) {
                    info.setFocus = true// to listen key events
                    ;
                    info.hasFocusedChild = false;
                    if(superPanelObj) {
                        (this).vsUI.scrollTo(virtualScrollToIndex, function () {
                            callback();
                        });
                    } else {
                        callback();
                    }
                } else {
                    var o = grid.options, $tableCell = $(cell.tableCell()), resultLeft = null, resultTop = null;
                    if(superPanelObj && $tableCell.is(":visible")) {
                        var contentElement = (superPanelObj).getContentElement(), wrapperElement = contentElement.parent(), visibleLeft = parseInt((contentElement.css("left") + "").replace("px", ""), 10) * -1, visibleTop = parseInt((contentElement.css("top") + "").replace("px", ""), 10) * -1, visibleWidth = wrapperElement.outerWidth() - o.splitDistanceX, visibleHeight = wrapperElement.outerHeight() - o.splitDistanceY, elementPosition = $tableCell.position(), elementLeft = elementPosition.left, elementTop = elementPosition.top, elementWidth = $tableCell.outerWidth(), elementHeight = $tableCell.outerHeight(), staticRowIndex = grid._getStaticIndex(true), staticColumnIndex = grid._getStaticIndex(false), currentRowIndex = cell.rowIndex(), currentCellIndex = cell.cellIndex();
                        if(currentRowIndex <= staticRowIndex) {
                            if(currentCellIndex <= staticColumnIndex) {
                                resultLeft = 0;
                                resultTop = 0;
                            } else {
                                elementLeft += visibleLeft;
                                if(elementLeft + elementWidth > visibleLeft + visibleWidth) {
                                    visibleLeft = resultLeft = elementLeft + elementWidth - visibleWidth;
                                }
                                if(elementLeft < visibleLeft) {
                                    resultLeft = elementLeft;
                                }
                                resultTop = 0;
                            }
                        } else {
                            if(currentCellIndex <= staticColumnIndex) {
                                // elementTop += visibleTop;
                                elementTop += this._splitAreas.sw.scrollTop();
                                if(elementTop + elementHeight > visibleTop + visibleHeight) {
                                    visibleTop = resultTop = elementTop + elementHeight - visibleHeight;
                                }
                                if(elementTop < visibleTop) {
                                    resultTop = elementTop;
                                }
                                resultLeft = 0;
                            } else {
                                elementLeft -= o.splitDistanceX;
                                if(elementTop + elementHeight > visibleTop + visibleHeight) {
                                    visibleTop = resultTop = elementTop + elementHeight - visibleHeight;
                                }
                                if(elementLeft + elementWidth > visibleLeft + visibleWidth) {
                                    visibleLeft = resultLeft = elementLeft + elementWidth - visibleWidth;
                                }
                                if(elementTop < visibleTop) {
                                    resultTop = elementTop;
                                }
                                if(elementLeft < visibleLeft) {
                                    resultLeft = elementLeft;
                                }
                            }
                        }
                        if(resultLeft !== null) {
                            (superPanelObj).hScrollTo(resultLeft);
                        }
                        if(resultTop !== null) {
                            (superPanelObj).vScrollTo(resultTop);
                        }
                    }
                    callback();
                }
            };
            fixedView.prototype.updateSplits = function (scrollValue) {
                var wijgrid = this._wijgrid, o = wijgrid.options, headerWidth, self = this, resultWidthArray = [], minWidthArray = [], maxWidthArray = [], staticColumnIndex = // set width to top table th and bottom table td in first row.
                this._staticColumnIndex, expandIndex, mode = o.scrollMode, visibleLeaves = wijgrid._field("visibleLeaves"), $tableSE = $(this._viewTables.se.element()), $tableNE = $(this._viewTables.ne.element()), $tableSW = $(this._viewTables.sw.element()), $tableNW = $(this._viewTables.nw.element()), outerDiv = wijgrid.outerDiv, tmp, i, hasDataRows;
                this._destroySuperPanel();
                outerDiv.unbind("mousewheel", this._mouseWheelHandler);
                // * if there is no data in a table, we must enlarge the table to prevent the width from being 0
                if((tmp = self._viewTables.se.element().tBodies) && (tmp = tmp[0])) {
                    // tmp = tBodies[0]
                    hasDataRows = false;
                    for(i = 0; i < tmp.rows.length; i++) {
                        if(!$(tmp.rows[i]).hasClass(wijmo.grid.wijgrid.CSS.groupHeaderRow)) {
                            hasDataRows = true;
                            break;
                        }
                    }
                    if(!hasDataRows) {
                        wijgrid.element.css("width", "100%");
                    }
                }
                $.each([
                    $tableSE, 
                    $tableNE, 
                    $tableSW, 
                    $tableNW
                ], function (index, table) {
                    table.css({
                        "table-layout": "",
                        "width": ""
                    });
                });
                // if any column has width option, we will set the width for inner cells.
                $.each(visibleLeaves, function (index, leaf) {
                    var isPercentage, w = leaf.width;
                    if(w || (w === 0)) {
                        isPercentage = ((typeof (w) === "string") && (w.length > 1) && (w[w.length - 1] === "%"));
                        //convert percent to value
                        if(isPercentage) {
                            w = outerDiv.width() * parseFloat(w) / 100;
                        } else {
                            w = parseFloat(w);
                        }
                        if(leaf.ensurePxWidth || (leaf.ensurePxWidth === undefined && o.ensureColumnsPxWidth)) {
                            leaf._realWidth = w;
                        }
                        self._setColumnWidth(index, w);
                    }
                });
                $.each(visibleLeaves, function (index, leaf) {
                    maxWidthArray.push(self._getColumnWidth(index));
                });
                $.each([
                    $tableNW, 
                    $tableNE, 
                    $tableSW, 
                    $tableSE
                ], function (index, table) {
                    table.css({
                        "width": "1px"
                    });
                });
                $.each(visibleLeaves, function (index, leaf) {
                    minWidthArray.push(self._getColumnWidth(index));
                });
                headerWidth = outerDiv.width()// using width() instead of innerWidth() to exclude padding.
                ;
                resultWidthArray = this._adjustWidthArray(maxWidthArray, minWidthArray, headerWidth, o.ensureColumnsPxWidth);
                $.each(resultWidthArray, function (index, colWidth) {
                    var leaf = visibleLeaves[index];
                    if(leaf._realWidth !== undefined) {
                        delete leaf._realWidth;
                        return;
                    }
                    self._setColumnWidth(index, colWidth.width);
                });
                //$.each([$tableSE, $tableNE, $tableSW, $tableNW], function (index, table) { // <-- The outerDiv width can change after that
                //	table.css({
                //		"table-layout": "fixed"
                //	});
                //});
                if(staticColumnIndex >= 0) {
                    expandIndex = staticColumnIndex;
                    this._setTableWidth([
                        $tableNW, 
                        $tableSW
                    ], this._sumWidthArray(resultWidthArray, 0, expandIndex), resultWidthArray[expandIndex].width, expandIndex);
                }
                //set the size of area after setting the width of column
                try  {
                    if(staticColumnIndex >= 0) {
                        o.splitDistanceX = $tableNW[0].offsetWidth;
                    } else {
                        o.splitDistanceX = 0;
                    }
                } catch (ex) {
                }
                this._updateSplitAreaBounds(0)//width
                ;
                if(!o.ensureColumnsPxWidth) {
                    $tableNE.parent().width(headerWidth - o.splitDistanceX);
                }
                expandIndex = resultWidthArray.length - 1;
                if(expandIndex !== -1) {
                    this._setTableWidth([
                        $tableNE, 
                        $tableSE
                    ], this._sumWidthArray(resultWidthArray, staticColumnIndex + 1, expandIndex), resultWidthArray[expandIndex].width, expandIndex);
                }
                this._adjustRowsHeights();
                //set the size of area after setting the width of column
                try  {
                    if(this._staticRowIndex >= 0) {
                        o.splitDistanceY = Math.max($tableNW[0].offsetHeight, $tableNE[0].offsetHeight);
                    } else {
                        o.splitDistanceY = 0;
                    }
                } catch (ex) {
                }
                this._updateSplitAreaBounds(1)//height
                ;
                //adjust width if showing vertical scrollbar
                if(!o.ensureColumnsPxWidth) {
                    if(this._testNeedVBar(wijgrid.outerDiv, $tableSE, $tableNE, mode, wijgrid._autoHeight)) {
                        headerWidth -= this._verScrollBarSize;
                        resultWidthArray = this._adjustWidthArray(maxWidthArray, minWidthArray, headerWidth, o.ensureColumnsPxWidth);
                        $.each(resultWidthArray, function (index, colWidth) {
                            if(!colWidth.real) {
                                self._setColumnWidth(index, colWidth.width);
                            }
                        });
                        if(staticColumnIndex >= 0) {
                            expandIndex = staticColumnIndex;
                            this._setTableWidth([
                                $tableNW, 
                                $tableSW
                            ], this._sumWidthArray(resultWidthArray, 0, expandIndex), resultWidthArray[expandIndex].width, expandIndex);
                        }
                        //set the size of area after setting the width of column
                        try  {
                            if(staticColumnIndex >= 0) {
                                o.splitDistanceX = $tableNW[0].offsetWidth;
                            } else {
                                o.splitDistanceX = 0;
                            }
                        } catch (ex) {
                        }
                        this._updateSplitAreaBounds(0)//width
                        ;
                        $tableNE.parent().width(headerWidth - o.splitDistanceX);
                        expandIndex = resultWidthArray.length - 1;
                        if(expandIndex !== -1) {
                            this._setTableWidth([
                                $tableNE, 
                                $tableSE
                            ], this._sumWidthArray(resultWidthArray, staticColumnIndex + 1, expandIndex), resultWidthArray[expandIndex].width, expandIndex);
                        }
                        this._adjustRowsHeights();
                        //set the size of area after setting the width of column
                        try  {
                            if(this._staticRowIndex >= 0) {
                                o.splitDistanceY = Math.max($tableNW[0].offsetHeight, $tableNE[0].offsetHeight);
                            } else {
                                o.splitDistanceY = 0;
                            }
                        } catch (ex) {
                        }
                        this._updateSplitAreaBounds(1)//height
                        ;
                    }
                }
                this.refreshPanel(scrollValue)// refresh super panel after width is set.
                ;
                outerDiv.bind("mousewheel", $.proxy(this._mouseWheelHandler, this));
            };
            fixedView.prototype.getInlineTotalWidth = function () {
                if(this._scroller) {
                    var stateContainer = this._getSuperPanelStateContainer();
                    if(stateContainer.length) {
                        var width = stateContainer[0].style.width;
                        if(width && (width !== "auto")) {
                            return width;
                        }
                    }
                }
                return "";
            };
            fixedView.prototype._clearBody = // public **
            // ** DOMTable abstraction
            function () {
                _super.prototype._clearBody.call(this);
            };
            fixedView.prototype.bodyRows = function () {
                var accessor = _super.prototype.bodyRows.call(this);
                return accessor;
            };
            fixedView.prototype.forEachColumnCell = function (columnIndex, callback, param) {
                var joinedTables = this.getJoinedTables(true, columnIndex), relIdx, callbackRes;
                if(joinedTables[0] !== null) {
                    relIdx = joinedTables[2];
                    callbackRes = joinedTables[0].forEachColumnCell(relIdx, callback, param);
                    if(callbackRes !== true) {
                        return callbackRes;
                    }
                    if(joinedTables[1] !== null) {
                        callbackRes = joinedTables[1].forEachColumnCell(relIdx, callback, param);
                        if(callbackRes !== true) {
                            return callbackRes;
                        }
                    }
                }
                return true;
            };
            fixedView.prototype.forEachRowCell = function (rowIndex, callback, param) {
                var joinedTables = this.getJoinedTables(false, rowIndex), table0 = joinedTables[0], table1 = joinedTables[1], relIdx, callbackResult;
                if(table0 !== null) {
                    relIdx = joinedTables[2];
                    if(relIdx < table0.element().rows.length) {
                        callbackResult = table0.forEachRowCell(relIdx, callback, param);
                        if(callbackResult !== true) {
                            return callbackResult;
                        }
                    }
                    if((table1 !== null) && (relIdx < table1.element().rows.length)) {
                        callbackResult = table1.forEachRowCell(relIdx, callback, param);
                        if(callbackResult !== true) {
                            return callbackResult;
                        }
                    }
                }
                return true;
            };
            fixedView.prototype.getAbsoluteCellInfo = function (domCell, virtualize) {
                return new wijmo.grid.cellInfo(this.getColumnIndex(domCell), this.getAbsoluteRowIndex(domCell.parentNode), this._wijgrid, true, virtualize);
            };
            fixedView.prototype.getAbsoluteRowIndex = function (domRow) {
                var index = domRow.rowIndex, table = domRow.parentNode;
                while(table && table.tagName && table.tagName.toLowerCase() !== "table") {
                    table = table.parentNode;
                }
                return (table === this._viewTables.nw.element() || table === this._viewTables.ne.element()) ? index : index + this._staticRowIndex + 1;
            };
            fixedView.prototype.getCell = function (absColIdx, absRowIdx) {
                var joinedTablesRow = this.getJoinedTables(false, absRowIdx), joinedTablesCol, relRowIdx, relColIdx, table, cellIdx;
                if(joinedTablesRow[0] !== null) {
                    joinedTablesCol = this.getJoinedTables(true, absColIdx);
                    if(joinedTablesCol[0] !== null) {
                        relRowIdx = joinedTablesRow[2];
                        relColIdx = joinedTablesCol[2];
                        table = null;
                        if(joinedTablesRow[1] !== null) {
                            table = (absColIdx === relColIdx) ? joinedTablesRow[0] : joinedTablesRow[1];
                        } else {
                            table = joinedTablesRow[0];
                        }
                        cellIdx = table.getCellIdx(relColIdx, relRowIdx);
                        if(cellIdx >= 0) {
                            return (table.element().rows[relRowIdx]).cells[cellIdx];
                        }
                    }
                }
                return null;
            };
            fixedView.prototype.getColumnIndex = function (domCell) {
                var owner = null, htmlTable = null, flag = false, colIdx;
                for(owner = domCell.parentNode; owner.tagName.toLowerCase() !== "table"; owner = owner.parentNode) {
                }
                if(owner !== null) {
                    if(owner === this._viewTables.nw.element()) {
                        htmlTable = this._viewTables.nw;
                    } else {
                        if(owner === this._viewTables.ne.element()) {
                            htmlTable = this._viewTables.ne;
                            flag = true;
                        } else {
                            if(owner === this._viewTables.sw.element()) {
                                htmlTable = this._viewTables.sw;
                            } else {
                                if(owner === this._viewTables.se.element()) {
                                    htmlTable = this._viewTables.se;
                                    flag = true;
                                }
                            }
                        }
                    }
                    if(htmlTable !== null) {
                        colIdx = htmlTable.getColumnIdx(domCell);
                        if(flag) {
                            colIdx += this._staticColumnIndex + 1;
                        }
                        return colIdx;
                    }
                }
                return -1;
            };
            fixedView.prototype.getHeaderCell = function (absColIdx) {
                var leaf = this._wijgrid._field("visibleLeaves")[absColIdx], headerRow;
                if(leaf && (headerRow = this._wijgrid._headerRows())) {
                    return wijmo.grid.rowAccessor.getCell(headerRow.item(leaf.thY), leaf.thX);
                }
                return null;
            };
            fixedView.prototype.getJoinedCols = function (columnIndex) {
                var result = [], joinedTables = this.getJoinedTables(true, columnIndex), relIndex = joinedTables[2];
                joinedTables.splice(joinedTables.length - 1, 1);
                $.each(joinedTables, function (index, table) {
                    result.push(table ? $(table.element()).find("col")[relIndex] : null);
                });
                return result;
            };
            fixedView.prototype.getJoinedRows = function (rowIndex, rowScope) {
                var row0 = null, row1 = null, table0 = null, table1 = null, fixedRowIdx = this._staticRowIndex, fixedColIdx = this._staticColumnIndex, lastColIdx = this._wijgrid._field("visibleLeaves").length - 1, lastRowIdx = this._rowsCountRaw() - 1, allRowsFixed = (fixedRowIdx === lastRowIdx), allsRowUnfixed = (fixedRowIdx < 0), rowsFixedSlice = !allRowsFixed && !allsRowUnfixed, sectionLength = 0;
                if(allRowsFixed || rowsFixedSlice) {
                    if(fixedColIdx >= 0 && fixedColIdx < lastColIdx) {
                        table0 = this._viewTables.nw;
                        table1 = this._viewTables.ne;
                    } else {
                        table0 = (fixedColIdx < 0) ? this._viewTables.ne : this._viewTables.nw;
                    }
                    sectionLength = table0.getSectionLength(rowScope);
                    if(rowIndex < sectionLength) {
                        row0 = table0.getSectionRow(rowIndex, rowScope);
                        if(table1 !== null) {
                            row1 = table1.getSectionRow(rowIndex, rowScope);
                        }
                    }
                }
                if(allsRowUnfixed || (rowsFixedSlice && (row0 === null))) {
                    if(!allsRowUnfixed) {
                        rowIndex -= sectionLength;
                    }
                    if(fixedColIdx >= 0 && fixedColIdx < lastColIdx) {
                        table0 = this._viewTables.sw;
                        table1 = this._viewTables.se;
                    } else {
                        table0 = (fixedColIdx < 0) ? this._viewTables.se : this._viewTables.sw;
                    }
                    row0 = table0.getSectionRow(rowIndex, rowScope);
                    if(table1 !== null) {
                        row1 = table1.getSectionRow(rowIndex, rowScope);
                    }
                }
                return (row0 === null && row1 === null) ? null : [
                    row0, 
                    row1
                ];
            };
            fixedView.prototype.getJoinedTables = function (byColumn, index) {
                var t0 = null, t1 = null, idx = index, wijgrid = this._wijgrid, fixedRowIdx = this._staticRowIndex, fixedColIdx = this._staticColumnIndex;
                if(byColumn) {
                    if(index <= fixedColIdx) {
                        t0 = this._viewTables.nw;
                        t1 = this._viewTables.sw;
                    } else {
                        t0 = this._viewTables.ne;
                        t1 = this._viewTables.se;
                        idx = idx - (fixedColIdx + 1);
                    }
                    if(fixedRowIdx < 0) {
                        t0 = null;
                    }
                    if(fixedRowIdx === this._rowsCountRaw() - 1)// fixed row is the last row
                     {
                        t1 = null;
                    }
                } else {
                    if(index <= fixedRowIdx) {
                        t0 = this._viewTables.nw;
                        t1 = this._viewTables.ne;
                    } else {
                        t0 = this._viewTables.sw;
                        t1 = this._viewTables.se;
                        idx = idx - (fixedRowIdx + 1);
                    }
                    if(fixedColIdx < 0) {
                        t0 = null;
                    }
                    if(fixedColIdx === wijgrid._field("leaves").length - 1) {
                        t1 = null;
                    }
                }
                if(t0 === null) {
                    t0 = t1;
                    t1 = null;
                }
                return [
                    t0, 
                    t1, 
                    idx
                ];
            };
            fixedView.prototype.subTables = function () {
                return [
                    this._viewTables.nw, 
                    this._viewTables.ne, 
                    this._viewTables.sw, 
                    this._viewTables.se
                ];
            };
            fixedView.prototype._getSuperPanel = // DOMTable abstraction **
            // ** private abstract
            function () {
                return this._scroller ? this._scroller.data("wijmo-wijsuperpanel") : null;
            };
            fixedView.prototype._ensureRenderBounds = // ** render
            function () {
                if(this._wijgrid._allowVirtualScrolling()) {
                    var virtualPageSize = this.getVirtualPageSize();
                    this._wijgrid._ensureRenderableBounds(this._bounds);
                    this._bounds.end = this._bounds.start + virtualPageSize - 1;
                    if(this._wijgrid._serverSideVirtualScrolling()) {
                        var delta = (this._bounds.end - this._bounds.start + 1) - this._wijgrid.sketchTable.count();
                        if(delta > 0) {
                            this._bounds.end -= delta;
                        }
                    }
                    this._wijgrid._ensureRenderableBounds(this._bounds);
                    if((this._bounds.start > 0) && (this._bounds.end === this._wijgrid.sketchTable.count() - 1)) {
                        // the very last items will be rendered
                        virtualPageSize = this.getVirtualPageSize(false)// use floor, don't overlap a visible area
                        ;
                        var itemsToRender = this._bounds.end - this._bounds.start + 1;
                        if(itemsToRender < virtualPageSize) {
                            // can render more items?
                            this._bounds.start = this._bounds.end - virtualPageSize + 1// adjust the start position to stick the items to the bottom
                            ;
                        }
                        this._wijgrid._ensureRenderableBounds(this._bounds);
                        if(this._bounds.start !== this._wijgrid._scrollingState.index) {
                            // the bounds.start was changed, synchronize with the scrollingState
                            this._wijgrid._scrollingState.index = this._wijgrid._scrollingState.y = this._bounds.start//
                            ;
                        }
                    }
                } else {
                    _super.prototype._ensureRenderBounds.call(this)// render all items
                    ;
                }
            };
            fixedView.prototype._renderContent = function () {
                _super.prototype._renderContent.call(this);
            };
            fixedView.prototype._preRender = function () {
                _super.prototype._preRender.call(this);
                var docFragment = document.createDocumentFragment(), HTA = wijmo.grid.htmlTableAccessor, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS;
                this._wijgrid.outerDiv.wrapInner("<div class=\"" + defCSS.fixedView + " " + wijCSS.wijgridFixedView + "\"><div class=\"" + defCSS.scroller + " " + wijCSS.wijgridScroller + "\"><div class=\"wijmo-wijgrid-split-area-se wijmo-wijgrid-content-area\"></div></div></div>");
                this._scroller = this._wijgrid.outerDiv.find("." + defCSS.scroller);
                this._scroller.css("padding", 0)// disable padding (inherited)
                ;
                this._scroller.after(this._splitAreas.nw = $("<div class=\"wijmo-wijgrid-split-area wijmo-wijgrid-split-area-nw\" style=\"overflow:hidden;position:absolute;z-index:4;top:0px;left:0px;\"></div>"));
                this._scroller.after(this._splitAreas.ne = $("<div class=\"wijmo-wijgrid-split-area wijmo-wijgrid-split-area-ne\" style=\"overflow:hidden;position:absolute;z-index:4;top:0px;left:0px;\"></div>"));
                this._scroller.after(this._splitAreas.sw = $("<div class=\"wijmo-wijgrid-split-area wijmo-wijgrid-split-area-sw\" style=\"overflow:hidden;position:absolute;z-index:4;top:0px;left:0px;\"></div>"));
                this._splitAreas.se = this._scroller.find(".wijmo-wijgrid-split-area-se:first");
                this._viewTables = {
                    nw: // skip offsets, ensure tbody + colgroup
                    new HTA(docFragment.appendChild(document.createElement("table")), true, true, true),
                    ne: new HTA(docFragment.appendChild(document.createElement("table")), true, true, true),
                    sw: new HTA(docFragment.appendChild(document.createElement("table")), true, true, true),
                    se: new HTA(docFragment.appendChild(this._wijgrid.element[0]), true, true, true)
                };
            };
            fixedView.prototype._postRender = function () {
                var t00, t01, t10, t11, HTA = wijmo.grid.htmlTableAccessor, self = this;
                this._viewTables = {
                    nw: // rebuild with offsets
                    new HTA(t00 = this._viewTables.nw.element()),
                    ne: new HTA(t01 = this._viewTables.ne.element()),
                    sw: new HTA(t10 = this._viewTables.sw.element()),
                    se: new HTA(t11 = this._viewTables.se.element())
                };
                this._splitAreas.nw.empty().append(t00);
                this._splitAreas.ne.empty().append(t01);
                this._splitAreas.sw.empty().append(t10);
                this._splitAreas.se.empty().append(t11);
                $.each(this._viewTables, function (idx, hta) {
                    var $element = $(hta.element());
                    self._wijgrid._setAttr($element, {
                        role: "grid",
                        border: "0",
                        cellpadding: "0",
                        cellspacing: "0"
                    });
                    $element.addClass(wijmo.grid.wijgrid.CSS.table).addClass(self._wijgrid.options.wijCSS.wijgridTable).css("border-collapse", "separate").find(// use separate instead of collapse to avoid a disalignment issue in chrome.
                    "> tbody").addClass(self._wijgrid.options.wijCSS.content);
                });
                _super.prototype._postRender.call(this);
            };
            fixedView.prototype._rowsCountRaw = function () {
                var t00 = this._viewTables.nw.element(), t01 = this._viewTables.ne.element(), t10 = this._viewTables.sw.element(), t11 = this._viewTables.se.element(), res;
                res = Math.max(t00.rows.length, t01.rows.length) + Math.max(t10.rows.length, t11.rows.length);
                return res;
            };
            fixedView.prototype._createCol = function (column, visibleIdx) {
                return [
                    document.createElement("col"), 
                    document.createElement("col")
                ];
            };
            fixedView.prototype._appendCol = function (domCol, column, visibleIdx) {
                if(visibleIdx <= this._staticColumnIndex) {
                    this._viewTables.nw.appendCol(domCol[0]);
                    this._viewTables.sw.appendCol(domCol[1]);
                } else {
                    this._viewTables.ne.appendCol(domCol[0]);
                    this._viewTables.se.appendCol(domCol[1]);
                }
            };
            fixedView.prototype._insertRow = function (rowType, sectionRowIndex, domRow/* optional, used by c1gridview to clone rows of the original table */ ) {
                var $rt = wijmo.grid.rowType, leftSection, rightSection, vt = this._viewTables;
                switch(rowType) {
                    case $rt.header:
                    case $rt.filter:
                        leftSection = vt.nw.ensureTHead();
                        rightSection = vt.ne.ensureTHead();
                        break;
                    case $rt.footer:
                        leftSection = vt.sw.ensureTFoot();
                        rightSection = vt.se.ensureTFoot();
                        break;
                    default:
                        // tbody
                        if(sectionRowIndex <= this._staticDataRowIndex) {
                            leftSection = vt.nw.ensureTBody();
                            rightSection = vt.ne.ensureTBody();
                        } else {
                            sectionRowIndex -= this._staticDataRowIndex + 1// subtracts fixed offset
                            ;
                            leftSection = vt.sw.ensureTBody();
                            rightSection = vt.se.ensureTBody();
                        }
                }
                if(domRow) {
                    // append only
                    return [
                        leftSection.appendChild(domRow), 
                        rightSection.appendChild(domRow.cloneNode(false))
                    ];
                } else {
                    return [
                        leftSection.insertRow(sectionRowIndex > leftSection.rows.length ? -1 : sectionRowIndex), 
                        rightSection.insertRow(sectionRowIndex > rightSection.rows.length ? -1 : sectionRowIndex)
                    ];
                }
            };
            fixedView.prototype._rowRendered = function (rowInfo, rowAttr, rowStyle) {
                var leftRow = rowInfo.$rows[0], rightRow = rowInfo.$rows[1];
                // Do not remove empty rows from header. The number of header rows in the fixed and unfixed tables should be empty to handle unbanded columns headers correctly when the staticSolumnIndex option is used:
                //
                // row0 |   band  | |  col2  | (rowSpan = 2)
                //      |---------| |--------|
                // row1 |col0|col1| |        | <- empty row
                if(!leftRow.cells.length && this._isBodyRow(rowInfo)) {
                    leftRow.parentNode.removeChild(leftRow);
                    leftRow = null;
                }
                if(!rightRow.cells.length && this._isBodyRow(rowInfo)) {
                    rightRow.parentNode.removeChild(rightRow);
                    rightRow = null;
                }
                if(leftRow || rightRow) {
                    if(!leftRow || !rightRow) {
                        // handle changes
                        rowInfo.$rows = leftRow ? $(leftRow) : $(rightRow);
                    }
                    _super.prototype._rowRendered.call(this, rowInfo, rowAttr, rowStyle);
                }
            };
            fixedView.prototype._appendCell = function (rowInfo, cellIndex, $cell) {
                var staticColIndex = (rowInfo.type !== wijmo.grid.rowType.header) ? this._staticColumnIndex : this._staticAllColumnIndex;
                if(cellIndex <= staticColIndex) {
                    rowInfo.$rows[0].appendChild($cell[0]);
                } else {
                    rowInfo.$rows[1].appendChild($cell[0]);
                }
            };
            fixedView.prototype._getRowHeight = // render **
            function (rowObj, ignoreSpannedCells) {
                if(rowObj[0] && rowObj[1]) {
                    // static columns are used
                                        var lRow = rowObj[0], rRow = rowObj[1], $lRow = $(lRow), $rRow = $(rRow), lRowH, rRowH, customHeight, getRowHeightUsingUnspannedCells = function ($row) {
                        var i, domRow = $row[0], domCell;
                        for(i = 0; i < domRow.cells.length; i++) {
                            domCell = domRow.cells[i];
                            if(!domCell.rowSpan || domCell.rowSpan === 1) {
                                return $(domCell).outerHeight();
                            }
                        }
                        ;
                        return $row.height();
                    };
                    if(customHeight = $.data(lRow, "customHeight")) {
                        // user-defined (inline) height
                        lRowH = rRowH = parseInt(customHeight);
                    } else {
                        $lRow.css("height", "");
                        $rRow.css("height", "");
                        if(ignoreSpannedCells) {
                            // used for header rows
                            lRowH = getRowHeightUsingUnspannedCells($lRow);
                            rRowH = getRowHeightUsingUnspannedCells($rRow);
                        } else {
                            lRowH = $lRow.height();
                            rRowH = $rRow.height();
                        }
                    }
                    return Math.max(lRowH, rRowH);
                }
                return null;
            };
            fixedView.prototype._setRowHeight = function (rowObj, maxHeight) {
                if(rowObj[0] && rowObj[1]) {
                    var $rowObj = [
                        $(rowObj[0]), 
                        $(rowObj[1])
                    ], dif;
                    if(maxHeight === null) {
                        return;
                    }
                    maxHeight += 1;
                    $.each($rowObj, function (index, $el) {
                        $el.height(maxHeight);
                        dif = maxHeight - $el.height();
                        if(dif) {
                            $el.height(maxHeight + dif);
                        }
                    });
                }
            };
            fixedView.prototype._adjustRowHeight = function () {
                var wijgrid = this._wijgrid, fixedColIdx = this._staticColumnIndex, lastColIdx = wijgrid._field("visibleLeaves").length - 1, fixedRowIdx, lastRowIdx, tables, tableNE, tableNEParent, tableNW, tableNWParent, tableSE, tableSEParent, tableSW, tableSWParent, rowCount, i, j, leftRows, rightRows, heightArray = [];
                // setting row height only if grid is divided into leftern and rightern parts
                if(fixedColIdx > -1 && fixedColIdx < lastColIdx) {
                    fixedRowIdx = this._staticRowIndex;
                    lastRowIdx = this._rowsCountRaw() - 1;
                    tables = this._viewTables;
                    // getting the height of northern tables
                    if(fixedRowIdx > -1 && fixedRowIdx <= lastRowIdx) {
                        tableNE = tables.ne.element();
                        tableNEParent = tableNE.parentNode;
                        tableNW = tables.nw.element();
                        tableNWParent = tableNW.parentNode;
                        leftRows = tableNW.rows;
                        rightRows = tableNE.rows;
                        rowCount = leftRows.length;
                        for(i = 0; i < rowCount; i++) {
                            heightArray.push(this._getRowHeight([
                                leftRows[i], 
                                rightRows[i]
                            ], true))// row height will be calculated using unspanned cells (TFS issue #33399).
                            ;
                        }
                    }
                    // getting the height of southern tables
                    if(fixedRowIdx >= -1 && fixedRowIdx < lastRowIdx) {
                        tableSE = tables.se.element();
                        tableSEParent = tableSE.parentNode;
                        tableSW = tables.sw.element();
                        tableSWParent = tableSW.parentNode;
                        leftRows = tableSW.rows;
                        rightRows = tableSE.rows;
                        rowCount = leftRows.length;
                        for(i = 0; i < rowCount; i++) {
                            heightArray.push(this._getRowHeight([
                                leftRows[i], 
                                rightRows[i]
                            ]));
                        }
                    }
                    // removing elments from dom to improve performance
                    if(fixedRowIdx > -1 && fixedRowIdx <= lastRowIdx) {
                        tableNWParent.removeChild(tableNW);
                        tableNEParent.removeChild(tableNE);
                    }
                    if(fixedRowIdx >= -1 && fixedRowIdx < lastRowIdx) {
                        tableSWParent.removeChild(tableSW);
                        tableSEParent.removeChild(tableSE);
                    }
                    // setting the height of northern tables
                    if(fixedRowIdx > -1 && fixedRowIdx <= lastRowIdx) {
                        leftRows = tableNW.rows;
                        rightRows = tableNE.rows;
                        rowCount = leftRows.length;
                        for(i = 0 , j = 0; i < rowCount; i++) {
                            this._setRowHeight([
                                leftRows[i], 
                                rightRows[i]
                            ], heightArray[j++]);
                        }
                    }
                    // setting the height of southern tables
                    if(fixedRowIdx >= -1 && fixedRowIdx < lastRowIdx) {
                        leftRows = tableSW.rows;
                        rightRows = tableSE.rows;
                        rowCount = leftRows.length;
                        for(i = 0; i < rowCount; i++) {
                            this._setRowHeight([
                                leftRows[i], 
                                rightRows[i]
                            ], heightArray[j++]);
                        }
                    }
                    // adding elments back to dom to improve performance
                    if(fixedRowIdx > -1 && fixedRowIdx <= lastRowIdx) {
                        tableNWParent.appendChild(tableNW);
                        tableNEParent.appendChild(tableNE);
                    }
                    if(fixedRowIdx >= -1 && fixedRowIdx < lastRowIdx) {
                        tableSWParent.appendChild(tableSW);
                        tableSEParent.appendChild(tableSE);
                    }
                }
            };
            fixedView.prototype._adjustRowsHeights = // private abstract **
            // ** private specific
            function () {
                var $tableSW = $(this._viewTables.sw.element()), $tableSE = $(this._viewTables.se.element()), height;
                $tableSE.css("height", "");
                $tableSW.css("height", "");
                this._adjustRowHeight();
                height = Math.max($tableSE.height(), $tableSW.height());
                $tableSW.height(height);
                $tableSE.height(height);
            };
            fixedView.prototype._destroySuperPanel = function () {
                if(this._scroller.data("wijmo-wijsuperpanel")) {
                    if(this.vsUI) {
                        this.vsUI.dispose();
                    }
                    this._superPanelElementsCache = {
                    };
                    this._scroller.wijsuperpanel("destroy");
                }
            };
            fixedView.prototype._onScroll = function (e, data) {
                var spInstance = this._getSuperPanel();
                if(this._wijgrid._allowVirtualScrolling()) {
                    if(data.dir === "h") {
                        // do horizontal scrolling
                        this._setFixedAreaPosition((spInstance).getContentElement(), data.dir, data.position, data.animationOptions, false);
                        this._setFixedAreaPosition(this._splitAreas.ne, data.dir, data.position, data.animationOptions, true);
                    }
                } else {
                    this._setFixedAreaPosition(data.dir === "h" ? this._splitAreas.ne : this._splitAreas.sw, data.dir, data.position, data.animationOptions, true);
                }
                this._wijgrid._trackScrollingPosition(spInstance.options.hScroller.scrollValue, spInstance.options.vScroller.scrollValue);
            };
            fixedView.prototype._onHScrollerActivating = function (e, args) {
                // auto adjusting height with hscrollbar shown
                if(this._wijgrid._autoHeight) {
                    var diff = this._wijgrid.element.height() + this._wijgrid.options.splitDistanceY - args.contentLength;
                    if(diff > 0) {
                        this._scroller.height(this._scroller.height() + diff);
                        this._scroller.wijsuperpanel("paintPanel");
                        return false;
                    }
                }
                this._splitAreas.sw.height(args.contentLength - this._wijgrid.options.splitDistanceY);
            };
            fixedView.prototype._onMouseWheel = function (e, delta) {
                // force superpanel to do scrolling when cursor is placed over then non-scrollable (fixed) areas of the wijgrid.
                                var bounds, dir = (delta > 0) ? "top" : "bottom", isOverFixedArea = false, vPos;
                if(this._wijgrid._canInteract()) {
                    bounds = this.getFixedAreaVisibleBounds()// an array (horizonta area, verticalw area)
                    ;
                    $.each(bounds, function (i, o) {
                        if(o && wijmo.grid.isOver(e.pageY, e.pageX, o.top, o.left, o.height, o.width)) {
                            isOverFixedArea = true;
                            return false;// break
                            
                        }
                    });
                    if(isOverFixedArea && this._scroller.data("wijmo-wijsuperpanel")) {
                        vPos = this._scroller.wijsuperpanel("option", "vScroller").scrollValue;
                        this._scroller.wijsuperpanel("doScrolling", dir);
                        // simulate wijsuperpanel behaviour: prevent window scrolling until superpanel is not scrolled to the end.
                        if(vPos !== this._scroller.wijsuperpanel("option", "vScroller").scrollValue) {
                            e.stopPropagation();
                            e.preventDefault();
                        }
                    }
                }
            };
            fixedView.prototype._setFixedAreaPosition = function (element, direction, position, animation, useScrollProp) {
                var prop = {
                }, key;
                if(direction === "h") {
                    key = useScrollProp ? "scrollLeft" : "left";
                } else {
                    key = useScrollProp ? "scrollTop" : "top";
                }
                if(!useScrollProp) {
                    position = -position// invert
                    ;
                }
                if(animation) {
                    prop[key] = position;
                    element.animate(prop, animation);
                } else {
                    if(useScrollProp) {
                        element[0][key] = position;
                    } else {
                        element.css(key, position);
                    }
                }
            };
            fixedView.prototype._testNeedVBar = function (outerDiv, gridElement, tableNE, mode, autoHeight) {
                var excludeVBarWidth = false, wijgrid = this._wijgrid, gridWidth = tableNE.width() + wijgrid.options.splitDistanceX, gridHeight = gridElement.height() + wijgrid.options.splitDistanceY, outerWidth = outerDiv.width(), outerHeight = outerDiv.height(), contentHeight, topHeight = 0, bottomHeight = 0;
                if(wijgrid.$superPanelHeader !== null) {
                    topHeight = wijgrid.$superPanelHeader.outerHeight(true);
                }
                if(wijgrid.$bottomPagerDiv !== null) {
                    bottomHeight = wijgrid.$bottomPagerDiv.outerHeight(true);
                }
                contentHeight = outerHeight - topHeight - bottomHeight;
                switch(mode) {
                    case "both":
                    case "vertical":
                        excludeVBarWidth = true;
                        break;
                    case "auto":
                        // When the height needs to be auto adjusted, the vertical scrollbar should not be shown
                        excludeVBarWidth = (gridHeight > contentHeight) || (!autoHeight && gridWidth > outerWidth && gridHeight > contentHeight - this._verScrollBarSize);
                        if(!excludeVBarWidth && this._wijgrid._allowVirtualScrolling()) {
                            // test virtual scrolling bounds (#45894)
                            var itemsToRender = (wijgrid._view()).getVirtualPageSize();
                            //itemsToRender = this._bounds.end - this._bounds.start;
                            excludeVBarWidth = (itemsToRender > 0 && itemsToRender < wijgrid._totalRowsCount());
                        }
                        break;
                }
                return excludeVBarWidth;
            };
            fixedView.prototype._updateSplitAreaBounds = //bSet: 0-width, 1-height, 2-all
            function (bSet) {
                var wijgrid = this._wijgrid, o = wijgrid.options, controlHeight, contentHeight, topHeight = 0, bottomHeight = 0;
                if(bSet === 0 || bSet === 2) {
                    this._splitAreas.nw.width(o.splitDistanceX);
                    this._splitAreas.sw.width(o.splitDistanceX);
                    if(wijgrid.options.staticColumnsAlignment === "right") {
                        this._splitAreas.se.css("marginRight", o.splitDistanceX);
                        this._splitAreas.ne.css("marginRight", o.splitDistanceX);
                    } else {
                        this._splitAreas.se.css("marginLeft", o.splitDistanceX);
                        this._splitAreas.ne.css("marginLeft", o.splitDistanceX);
                    }
                }
                if(bSet === 1 || bSet === 2) {
                    this._scroller.css("height", "");
                    this._splitAreas.se.css("marginTop", 0);
                    controlHeight = wijgrid.outerDiv.height();
                    if(!wijgrid._autoHeight) {
                        this._scroller.height(controlHeight);
                    } else {
                        // no height is set for outer div, we need to expand the grid.
                        this._scroller.height(controlHeight + o.splitDistanceY);
                        //this._noHeight = true;
                                            }
                    this._splitAreas.nw.height(o.splitDistanceY);
                    this._splitAreas.ne.height(o.splitDistanceY);
                    if(wijgrid.$superPanelHeader !== null) {
                        topHeight = wijgrid.$superPanelHeader.outerHeight(true);
                    }
                    if(wijgrid.$bottomPagerDiv !== null) {
                        bottomHeight = wijgrid.$bottomPagerDiv.outerHeight(true);
                    }
                    contentHeight = controlHeight - topHeight - bottomHeight;
                    if(wijgrid.$superPanelHeader !== null) {
                        this._splitAreas.nw.css("top", topHeight + "px");
                        this._splitAreas.ne.css("top", topHeight + "px");
                    }
                    if(!wijgrid._autoHeight) {
                        this._splitAreas.sw.height(contentHeight - o.splitDistanceY);
                    } else {
                        this._splitAreas.sw.height(contentHeight);
                    }
                    this._splitAreas.sw.css("top", o.splitDistanceY + topHeight);
                    this._splitAreas.se.css("marginTop", o.splitDistanceY);
                }
            };
            fixedView.prototype._getSuperPanelContentWrapper = // private specific **
            // ** wijsuperpanel specific
            function () {
                if(!this._superPanelElementsCache.contentWrapper || !this._superPanelElementsCache.contentWrapper.length) {
                    this._superPanelElementsCache.contentWrapper = this._wijgrid.outerDiv.find(".wijmo-wijsuperpanel-contentwrapper:first")// not available in native mode?
                    ;
                }
                return this._superPanelElementsCache.contentWrapper;
            };
            fixedView.prototype._getSuperPanelStateContainer = function () {
                if(!this._superPanelElementsCache.stateContainer || !this._superPanelElementsCache.stateContainer.length) {
                    this._superPanelElementsCache.stateContainer = this._wijgrid.outerDiv.find(".wijmo-wijsuperpanel-statecontainer:first");
                }
                return this._superPanelElementsCache.stateContainer;
            };
            fixedView.prototype._isNativeSuperPanel = function () {
                return this._wijgrid._isTouchEnv();
            };
            fixedView.prototype._testAutohiddenScrollbars = function () {
                if(this._isNativeSuperPanel()) {
                    var container = this._getSuperPanelStateContainer();
                    if(container.length) {
                        return container[0].offsetWidth === container[0].clientWidth;// no scrollbar or scrollbar is hidden (-ms-autohiding-scrollbar)
                        
                    }
                }
                return false;
            };
            return fixedView;
        })(grid.baseView);
        grid.fixedView = fixedView;        
        // wijsuperpanel specific **
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** An object that represents selection in the grid. You do not need to create instances of this class. */
        var selection = (function () {
            /** Creates an object that represents selection in the grid. Normally you do not need to use this method.
            * @example
            * var selection = new wijmo.grid.selection(wijgrid);
            * @param {wijmo.wijgrid} wijgrid wijgrid
            * @returns {wijmo.grid.selection} Object that represents selection in the grid
            */
            function selection(wijgrid) {
                this._updates = 0;
                this._selectedColumns = null;
                // ?
                this._selectedRows = null;
                // ?
                // n: none (0), c: extendToColumn (1), r: extendToRow (2)
                //
                //              extendMode
                // selectionMode| n | c | r
                // ------------------------
                // singlecell   | n | n | n
                // singlecolumn | c | c | c
                // singlerow    | r | r | r
                // singlerange  | n | c | r
                // multicolumn  | c | c | c
                // multirow     | r | r | r
                // multirange   | n | c | r
                this._extend_rules = {
                    "singlecell": [
                        0, 
                        0, 
                        0
                    ],
                    "singlecolumn": [
                        1, 
                        1, 
                        1
                    ],
                    "singlerow": [
                        2, 
                        2, 
                        2
                    ],
                    "singlerange": [
                        0, 
                        1, 
                        2
                    ],
                    "multicolumn": [
                        1, 
                        1, 
                        1
                    ],
                    "multirow": [
                        2, 
                        2, 
                        2
                    ],
                    "multirange": [
                        0, 
                        1, 
                        2
                    ]
                };
                if(!wijgrid) {
                    throw "invalid arguments";
                }
                this._wijgrid = wijgrid;
                this._addedCells = new cellInfoOrderedCollection(wijgrid);
                this._removedCells = new cellInfoOrderedCollection(wijgrid);
                this._selectedCells = new cellInfoOrderedCollection(wijgrid);
                this._addedDuringCurTransactionCells = new cellInfoOrderedCollection(wijgrid);
            }
            selection.prototype.selectedCells = /** Gets a read-only collection of the selected cells.
            * @example
            * var selectedCells = selectionObj.selectedCells();
            * for (var i = 0, len = selectedCells.length(); i < len; i++) {
            *	alert(selectedCells.item(i).value().toString());
            * }
            * @returns {wijmo.grid.cellInfoOrderedCollection} A read-only collection of the selected cells.
            */
            function () {
                return this._selectedCells;
            };
            selection.prototype.addColumns = /** Adds a column range to the current selection.
            * Usage:
            * 1. addColumns(0)
            * 2. addColumns(0, 2)
            * @example
            * // Add the first column to the current selection.
            * selectionObj.addColumns(0);
            * @remarks
            * The result depends upon the chosen selection mode in the grid. For example, if current selection mode does not allow multiple selection the previous selection will be removed.
            * @param {Number} start The index of the first column to select.
            * @param {Number} end The index of the last column to select.
            */
            function (start, end/* opt */ ) {
                if(!end && end !== 0) {
                    end = start;
                }
                this.addRange(start, 0, end, 0xFFFFFF);
            };
            selection.prototype.addRange = /** @ignore */
            function (cellRange/* x0 */ , y0/* opt */ , x1/* opt */ , y1/* opt */ ) {
                if(!cellRange && (arguments.length === 1)) {
                    throw "invalid argument";
                }
                var range = (arguments.length === 4) ? new wijmo.grid.cellInfoRange(new wijmo.grid.cellInfo(cellRange/* ie x0 */ , y0), new wijmo.grid.cellInfo(x1, y1)) : cellRange._clone();
                range._normalize();
                if(!range._isValid()) {
                    throw "invalid argument";
                }
                this.beginUpdate();
                this._startNewTransaction(this._wijgrid._field("currentCell"));
                this._selectRange(range, false, true, wijmo.grid.cellRangeExtendMode.none, null);
                this.endUpdate();
            };
            selection.prototype.addRows = /** Adds a row range to the current selection.
            * Usage:
            * 1. addRows(0)
            * 2. addRows(0, 2)
            * @example
            * // Add the first row to the selection.
            * selectionObj.addRows(0);
            * @remarks
            * The result depends upon the chosen selection mode in the grid. For example, if current selection mode does not allow multiple selection the previous selection will be removed.
            * @param {Number} start The index of the first row to select.
            * @param {Number} end The index of the last row to select.
            */
            function (start, end/* opt */ ) {
                if(!end && end !== 0) {
                    end = start;
                }
                this.addRange(0, start, 0xFFFFFF, end);
            };
            selection.prototype.removeRange = /** @ignore */
            function (cellRange/* x0 */ , y0/* opt */ , x1/* opt */ , y1/* opt */ ) {
                if(!cellRange && (arguments.length === 1)) {
                    throw "invalid argument";
                }
                var range = (arguments.length === 4) ? new wijmo.grid.cellInfoRange(new wijmo.grid.cellInfo(cellRange, y0), new wijmo.grid.cellInfo(x1, y1)) : cellRange._clone();
                range._normalize();
                if(!range._isValid()) {
                    throw "invalid argument";
                }
                this.beginUpdate();
                this._startNewTransaction(this._wijgrid._field("currentCell"));
                this._clearRange(range, wijmo.grid.cellRangeExtendMode.none);
                this.endUpdate();
            };
            selection.prototype.removeColumns = /**
            * Removes a range of columns from the current selection.
            * Usage:
            * 1. removeColumns(0)
            * 2. removeColumns(0, 2)
            * @example
            * // Remove the first columm from the selection.
            * selectionObj.removeColumns(0);
            * @remarks
            * The result depends upon the chosen selection mode in the grid.
            * @param {Number} start The index of the first column to remove.
            * @param {Number} end The index of the last column to remove.
            */
            function (start, end/* opt */ ) {
                if(!end && end !== 0) {
                    end = start;
                }
                this.removeRange(start, 0, end, 0xFFFFFF);
            };
            selection.prototype.removeRows = /** Removes a range of rows from the current selection.
            * Usage:
            * 1. removeRows(0)
            * 2. removeRows(0, 2)
            * @example
            * // Remove the first row from the selection.
            * selectionObj.removeRows(0);
            * @remarks
            * The result depends upon the chosen selection mode in the grid.
            * @param {Number} start The index of the first row to remove.
            * @param {Number} end The index of the last row to remove.
            */
            function (start, end/* opt */ ) {
                if(!end && end !== 0) {
                    end = start;
                }
                this.removeRange(0, start, 0xFFFFFF, end);
            };
            selection.prototype.clear = /**
            * Clears the selection.
            * @example
            * // Clear the selection.
            * selectionObj.clear();
            */
            function () {
                this.beginUpdate();
                this._removedCells._clear();
                this._removedCells._addFrom(this._selectedCells);
                this.endUpdate();
            };
            selection.prototype.selectAll = /**
            * Selects all the cells in a grid.
            * @example
            * selectionObj.selectAll();
            * @remarks
            * The result depends upon the chosen selection mode in the grid. For example, if the selection mode is set to "singleCell", then only the top left cell will be selected.
            */
            function () {
                this.beginUpdate();
                this._selectRange(this._wijgrid._getDataCellsRange(grid.dataRowsRangeMode.sketch), false, false, wijmo.grid.cellRangeExtendMode.none, null);
                this.endUpdate();
            };
            selection.prototype.beginUpdate = /**
            * Begins the update. Any changes won't take effect until endUpdate() is called.
            * @example
            * selectionObj.beginUpdate();
            */
            function () {
                this._updates++;
            };
            selection.prototype.endUpdate = /**
            * Ends the update. The pending changes are executed and the selectionChanged event is raised.
            * @example
            * selectionObj.endUpdate();
            */
            function () {
                if(this._updates > 0) {
                    this._updates--;
                    if(this._updates === 0) {
                        this.doSelection()// values must be clipped before this step
                        ;
                        if(this._addedCells.length() || this._removedCells.length()) {
                            if(this._selectedColumns !== null) {
                                this._selectedColumns.UnderlyingDataChanged()// notify
                                ;
                            }
                            if(this._selectedRows !== null) {
                                this._selectedRows.UnderlyingDataChanged()// notify
                                ;
                            }
                            this._wijgrid._trigger("selectionChanged", null, {
                                addedCells: this._addedCells,
                                removedCells: this._removedCells
                            });
                        }
                        this._addedCells = new wijmo.grid.cellInfoOrderedCollection(this._wijgrid);
                        this._removedCells._clear();
                    }
                }
            };
            selection.prototype._multipleRangesAllowed = // * internal
            function () {
                var mode = this._wijgrid.options.selectionMode;
                return (mode && ((mode = mode.toLowerCase()) === "multicolumn" || mode === "multirow" || mode === "multirange"));
            };
            selection.prototype._anchorCell = function () {
                return this.__anchorCell;
            };
            selection.prototype._startNewTransaction = function (dataCellInfo) {
                if(dataCellInfo) {
                    this.__anchorCell = dataCellInfo._clone();
                    this._addedDuringCurTransactionCells = new wijmo.grid.cellInfoOrderedCollection(this._wijgrid);
                }
            };
            selection.prototype._clearRange = function (range, extendMode) {
                var selectionMode = this._wijgrid.options.selectionMode.toLowerCase(), rangeToClear, rowsLen, cellsLen, flag, row, cell, i, len, cellInfo, dataRange = this._wijgrid._getDataCellsRange(grid.dataRowsRangeMode.sketch);
                if(range._isValid() && (selectionMode !== "none") && (this._selectedCells.length() > 0)) {
                    rangeToClear = range._clone();
                    rangeToClear._normalize();
                    rangeToClear._clip(dataRange);
                    if(!range._isValid()) {
                        return;
                    }
                    // extend
                    rangeToClear._extend(this._extend_rules[selectionMode][extendMode], dataRange);
                    this.beginUpdate();
                    // remove selected cells only, do not use doRange(rangeToClear, false) here.
                    for(i = 0 , len = this._selectedCells.length(); i < len; i++) {
                        cellInfo = this._selectedCells.item(i);
                        if(rangeToClear._containsCellInfo(cellInfo)) {
                            this._removedCells._add(cellInfo);
                        }
                    }
                    this.endUpdate();
                }
            };
            selection.prototype._selectRange = function (range, ctrlKey, shiftKey, extendMode, endPoint) {
                var selectionMode = this._wijgrid.options.selectionMode.toLowerCase(), rangeToSelect, dataRange = this._wijgrid._getDataCellsRange(grid.dataRowsRangeMode.sketch);
                if((selectionMode !== "none") && range._isValid()) {
                    rangeToSelect = range._clone();
                    rangeToSelect._normalize();
                    rangeToSelect._clip(dataRange);
                    if(!rangeToSelect._isValid()) {
                        return;
                    }
                    this.beginUpdate();
                    if(!this._multipleRangesAllowed()) {
                        this.clear();
                    } else {
                        if(ctrlKey || shiftKey) {
                            if(shiftKey) {
                                this._removedCells._clear();
                                this._removedCells._addFrom(this._addedDuringCurTransactionCells);
                            }
                        } else {
                            this.clear();
                        }
                    }
                    // truncate range by selectionMode
                    switch(selectionMode) {
                        case "singlecell":
                        case "singlecolumn":
                        case "singlerow":
                            rangeToSelect = (endPoint === null) ? new wijmo.grid.cellInfoRange(rangeToSelect.topLeft(), rangeToSelect.topLeft()) : // top-left cell only is taken into consideration.
                            new wijmo.grid.cellInfoRange(endPoint, endPoint);
                            break;
                    }
                    // extend
                    rangeToSelect._extend(this._extend_rules[selectionMode][extendMode], dataRange);
                    // do selection
                    this.doRange(rangeToSelect, true);
                    this.endUpdate();
                }
            };
            selection.prototype._ensureSelection = function () {
                var view = this._wijgrid._view(), prevRowIndex = -2, rowInfo;
                for(var i = 0; i < this._selectedCells.length(); i++) {
                    var cellInfo = this._selectedCells.item(i);
                    if(cellInfo._isRendered()) {
                        if(prevRowIndex !== cellInfo.rowIndex()) {
                            rowInfo = cellInfo.row();
                            prevRowIndex = cellInfo.rowIndex();
                        }
                        this.selectCell(cellInfo, rowInfo, view, true);
                    }
                }
            };
            selection.prototype._ensureSelectionInRow = function (sketchRowIndex) {
                var _this = this;
                var view = this._wijgrid._view();
                if(view._isRowRendered(sketchRowIndex) >= 0) {
                    var rowInfo = view._getRowInfoBySketchRowIndex(sketchRowIndex, false), selectedCells = this.selectedCells();
                    if(rowInfo && selectedCells && (selectedCells.length() > 0)) {
                        rowInfo.$rows.children("td, th").each(function (i, cell) {
                            var idx = selectedCells.indexOf(i, sketchRowIndex);
                            if(idx >= 0) {
                                _this.selectCell(selectedCells.item(idx), rowInfo, view, true);
                            }
                        });
                    }
                }
            };
            selection.prototype.doSelection = // * internal
            // * private
            function () {
                var view = this._wijgrid._view(), i, len, cellInfo, cell, $cell, index, $rs = wijmo.grid.renderState, rowInfo, state, prevRowIndex = -1;
                for(i = 0 , len = this._removedCells.length(); i < len; i++) {
                    cellInfo = this._removedCells.item(i);
                    if(this._addedCells.indexOf(cellInfo) < 0) {
                        if(prevRowIndex !== cellInfo.rowIndex()) {
                            rowInfo = cellInfo.row();
                            prevRowIndex = cellInfo.rowIndex();
                        }
                        this.selectCell(cellInfo, rowInfo, view, false);
                        this._selectedCells._remove(cellInfo);
                        this._addedDuringCurTransactionCells._remove(cellInfo);
                    } else {
                        this._removedCells._removeAt(i);
                        i--;
                        len--;
                    }
                }
                prevRowIndex = -1;
                for(i = 0 , len = this._addedCells.length(); i < len; i++) {
                    cellInfo = this._addedCells.item(i);
                    index = this._selectedCells.indexOf(cellInfo);
                    if(index < 0) {
                        if(prevRowIndex !== cellInfo.rowIndex()) {
                            rowInfo = cellInfo.row();
                            prevRowIndex = cellInfo.rowIndex();
                        }
                        this.selectCell(cellInfo, rowInfo, view, true);
                        this._selectedCells._insertUnsafe(cellInfo, ~index);
                        this._addedDuringCurTransactionCells._add(cellInfo);
                    } else {
                        this._addedCells._removeAt(i);
                        i--;
                        len--;
                    }
                }
            };
            selection.prototype.selectCell = function (cellInfo, rowInfo, view, select) {
                if(cellInfo._isRendered()) {
                    var bounds = this._wijgrid._viewPortBounds();
                    var cell = view.getCell(cellInfo.cellIndexAbs(), cellInfo.rowIndexAbs());
                    if(cell) {
                        var $cell = $(cell), state = view._changeCellRenderState($cell, wijmo.grid.renderState.selected, select === true);
                        this._wijgrid.cellStyleFormatter.format($cell, cellInfo.cellIndex(), cellInfo.column(), rowInfo, state);
                    }
                }
            };
            selection.prototype.doRange = function (range, add) {
                var x0 = range.topLeft().cellIndex(), y0 = range.topLeft().rowIndex(), x1 = range.bottomRight().cellIndex(), y1 = range.bottomRight().rowIndex(), cnt, row, col, cell, view = this._wijgrid._view(), rowInfo, rows, renderBounds = this._wijgrid._viewPortBounds();
                if(add) {
                    cnt = this._addedCells.length();
                    rows = this._wijgrid._rows();
                    for(row = y0; row <= y1; row++) {
                        rowInfo = view._getRowInfoBySketchRowIndex(row);
                        if(rowInfo.type & wijmo.grid.rowType.data) {
                            for(col = x0; col <= x1; col++) {
                                cell = new wijmo.grid.cellInfo(col, row);
                                if(cnt === 0) {
                                    this._addedCells._appendUnsafe(cell);
                                } else {
                                    this._addedCells._add(cell);
                                }
                            }
                        }
                    }
                } else {
                    cnt = this._removedCells.length();
                    for(row = y0; row <= y1; row++) {
                        for(col = x0; col <= x1; col++) {
                            cell = new wijmo.grid.cellInfo(col, row);
                            if(cnt === 0) {
                                this._removedCells._appendUnsafe(cell);
                            } else {
                                this._removedCells._add(cell);
                            }
                        }
                    }
                }
            };
            return selection;
        })();
        grid.selection = selection;        
        // * private
        /** An ordered read-only collection of wijmo.grid.cellInfo objects */
        var cellInfoOrderedCollection = (function () {
            /**
            * Creates an ordered read-only collection of wijmo.grid.cellInfo objects. Normally you do not need to use this method.
            * @example
            * var collection = new wijmo.grid.cellInfoOrderedCollection(wijgrid);
            * @param {wijmo.wijgrid} wijgrid wijgrid
            * @returns {wijmo.grid.cellInfoOrderedCollection}  An ordered read-only collection of wijmo.grid.cellInfo objects
            */
            function cellInfoOrderedCollection(wijgrid) {
                this._clear = function () {
                    this._list.length = 0;
                };
                if(!wijgrid) {
                    throw "invalid arguments";
                }
                this._wijgrid = wijgrid;
                this._list = [];
            }
            cellInfoOrderedCollection.prototype.item = // public
            /** Gets an item at the specified index.
            * @example
            * var cellInfoObj = collection.item(0);
            * @param {Number} index The zero-based index of the item to get.
            * @returns {wijmo.grid.cellInfo} The wijmo.grid.cellInfo object at the specified index.
            */
            function (index) {
                return this._list[index];
            };
            cellInfoOrderedCollection.prototype.length = /** Gets the total number of the items in the collection.
            * @example
            * var len = collection.length();
            * @returns {Number} The total number of the items in the collection.
            */
            function () {
                return this._list.length;
            };
            cellInfoOrderedCollection.prototype.indexOf = /** @ignore */
            function (cellIndex, rowIndex) {
                if(arguments.length === 1) {
                    rowIndex = cellIndex.rowIndex();
                    cellIndex = cellIndex.cellIndex();
                }
                var lo = 0, hi = this._list.length - 1, med, current, cmp;
                while(lo <= hi) {
                    med = lo + ((hi - lo) >> 1);
                    current = this._list[med];
                    cmp = current.rowIndex() - rowIndex;
                    if(cmp === 0) {
                        cmp = current.cellIndex() - cellIndex;
                    }
                    if(cmp < 0) {
                        lo = med + 1;
                    } else {
                        if(cmp > 0) {
                            hi = med - 1;
                        } else {
                            return med;
                        }
                    }
                }
                return ~lo;
            };
            cellInfoOrderedCollection.prototype.toString = /** @ignore */
            function () {
                var val = "", i, len;
                for(i = 0 , len = this._list.length; i < len; i++) {
                    val += this._list[i].toString() + "\n";
                }
                return val;
            };
            cellInfoOrderedCollection.prototype._add = // public *
            // internal
            function (value) {
                var idx = this.indexOf(value);
                if(idx < 0) {
                    this._list.splice(~idx, 0, value);
                    value._setGridView(this._wijgrid);
                    return true;
                }
                return false;
            };
            cellInfoOrderedCollection.prototype._addFrom = function (addFrom) {
                if(addFrom) {
                    var fromLen = addFrom.length(), thisLen = this._list.length, i;
                    if(thisLen === 0) {
                        this._list.length = fromLen;
                        for(i = 0; i < fromLen; i++) {
                            this._list[i] = addFrom.item(i);
                            this._list[i]._setGridView(this._wijgrid);
                        }
                    } else {
                        for(i = 0; i < fromLen; i++) {
                            this._add(addFrom.item(i));
                        }
                    }
                }
            };
            cellInfoOrderedCollection.prototype._appendUnsafe = function (value) {
                this._list[this._list.length] = value;
                value._setGridView(this._wijgrid);
            };
            cellInfoOrderedCollection.prototype._insertUnsafe = function (value, index) {
                this._list.splice(index, 0, value);
            };
            cellInfoOrderedCollection.prototype._remove = function (value) {
                var idx = this.indexOf(value);
                if(idx >= 0) {
                    this._list.splice(idx, 1);
                    return true;
                }
                return false;
            };
            cellInfoOrderedCollection.prototype._removeAt = function (index) {
                this._list.splice(index, 1);
            };
            cellInfoOrderedCollection.prototype._getColumnsIndicies = function () {
                var columns = [], len = this._list.length, tmpColumns, i, len2;
                if(len) {
                    tmpColumns = [];
                    for(i = 0; i < len; i++) {
                        tmpColumns[this._list[i].cellIndex()] = 1;
                    }
                    len = tmpColumns.length;
                    len2 = 0;
                    for(i = 0; i < len; i++) {
                        if(tmpColumns[i]) {
                            columns[len2++] = i;
                        }
                    }
                }
                return columns;
            };
            cellInfoOrderedCollection.prototype._getSelectedRowsIndicies = function () {
                var rows = [], len = this._list.length, tmpRows, i, len2;
                if(len) {
                    tmpRows = [];
                    for(i = 0; i < len; i++) {
                        tmpRows[this._list[i].rowIndex()] = 1;
                    }
                    len = tmpRows.length;
                    len2 = 0;
                    for(i = 0; i < len; i++) {
                        if(tmpRows[i]) {
                            rows[len2++] = i;
                        }
                    }
                }
                return rows;
            };
            cellInfoOrderedCollection.prototype._rectangulate = function () {
                var len = this._list.length, x0 = 0xFFFFFFFF, y0 = 0xFFFFFFFF, x1 = 0, y1 = 0, i, cellInfo;
                if(len) {
                    for(i = 0; i < len; i++) {
                        cellInfo = this._list[i];
                        x0 = Math.min(x0, cellInfo.cellIndex());
                        y0 = Math.min(y0, cellInfo.rowIndex());
                        x1 = Math.max(x1, cellInfo.cellIndex());
                        y1 = Math.max(y1, cellInfo.rowIndex());
                    }
                    return new wijmo.grid.cellInfoRange(new wijmo.grid.cellInfo(x0, y0), new wijmo.grid.cellInfo(x1, y1));
                }
                return null;
            };
            return cellInfoOrderedCollection;
        })();
        grid.cellInfoOrderedCollection = cellInfoOrderedCollection;        
        // internal *
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="wijgrid.ts"/>
    /// <reference path="cellInfo.ts"/>
    /// <reference path="rowAccessor.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var uiSelection = (function () {
            function uiSelection(wijgrid) {
                this._gap_to_start = 10;
                this._inProgress = false;
                this._additionalEventsAttached = false;
                this._wijgrid = wijgrid;
                this._evntFormat = "{0}." + this._wijgrid.widgetName + ".selectionui";
                this._addedCells = new wijmo.grid.cellInfoOrderedCollection(this._wijgrid);
                this._view = this._wijgrid._view();
                this._rootElement = this._view.focusableElement();
                this._visLeavesLen = this._wijgrid._field("visibleLeaves").length;
                this._rootElement.bind(this._eventKey("mousedown"), $.proxy(this._onGridMouseDown, this));
            }
            uiSelection.prototype.dispose = function () {
                this._rootElement.unbind(this._eventKey("mousedown"), this._onGridMouseDown);
                this._detachAdditionalEvents();
            };
            uiSelection.prototype._onGridMouseDown = function (args) {
                if(!this._wijgrid._canInteract() || this._wijgrid.options.selectionMode.toLowerCase() === "none") {
                    return;
                }
                var visibleBounds = this._view.getVisibleContentAreaBounds(), mouse = //.getVisibleAreaBounds(),
                {
                    x: args.pageX,
                    y: args.pageY
                }, tag = ((args.target && (args.target).tagName !== undefined) ? (args.target).tagName.toLowerCase() : undefined), $target = $(args.target), defCSS = wijmo.grid.wijgrid.CSS;
                if((!tag || $target.is("td." + defCSS.TD + ", th." + defCSS.TD + ", div." + defCSS.cellContainer)) && (mouse.x > visibleBounds.left && mouse.x < visibleBounds.left + visibleBounds.width) && (mouse.y > visibleBounds.top && mouse.y < visibleBounds.top + visibleBounds.height)) {
                    this._attachAdditionalEvents();
                    this._startPos = mouse;
                    this._startCellInfo = this._coordToDataCellInfo(this._startPos);
                }
            };
            uiSelection.prototype._onDocumentMouseMove = function (args) {
                if(!this._startCellInfo || !this._startCellInfo._isValid()) {
                    return;
                }
                var mouse = {
                    x: args.pageX,
                    y: args.pageY
                }, tmp, cellInfo, range, desiredCells, rowsLen, cellsLen, row, cell, i, len, $cell, rowInfo, prevRowIndex, state, view = this._wijgrid._view(), rows = this._wijgrid._rows(), $rs = wijmo.grid.renderState;
                if(!this._inProgress) {
                    this._inProgress = (Math.abs(this._startPos.x - mouse.x) > this._gap_to_start) || (Math.abs(this._startPos.y - mouse.y) > this._gap_to_start);
                }
                if(this._inProgress) {
                    tmp = this._coordToDataCellInfo(mouse);
                    if(!tmp._isValid()) {
                        return;
                    }
                    this._endCellInfo = tmp;
                    range = new wijmo.grid.cellInfoRange(this._startCellInfo, this._endCellInfo);
                    range._normalize();
                    range._clip(this._wijgrid._getDataCellsRange(grid.dataRowsRangeMode.sketch));
                    if(range._isValid() && !range.isEqual(this._prevMouseMoveRange)) {
                        this._prevMouseMoveRange = range;
                        desiredCells = new wijmo.grid.cellInfoOrderedCollection(this._wijgrid);
                        rowsLen = range.bottomRight().rowIndex();
                        cellsLen = range.bottomRight().cellIndex();
                        for(row = range.topLeft().rowIndex(); row <= rowsLen; row++) {
                            rowInfo = view._getRowInfoBySketchRowIndex(row);
                            if(rowInfo.type & wijmo.grid.rowType.data) {
                                for(cell = range.topLeft().cellIndex(); cell <= cellsLen; cell++) {
                                    desiredCells._appendUnsafe(new wijmo.grid.cellInfo(cell, row));
                                }
                            }
                        }
                        prevRowIndex = -1;
                        for(i = 0 , len = this._addedCells.length(); i < len; i++) {
                            cellInfo = this._addedCells.item(i);
                            if(desiredCells.indexOf(cellInfo) < 0)// remove css
                             {
                                if(this._wijgrid.selection().selectedCells().indexOf(cellInfo) < 0) {
                                    cell = this._view.getCell(cellInfo.cellIndexAbs(), cellInfo.rowIndexAbs());
                                    if(cell) {
                                        if(prevRowIndex !== cellInfo.rowIndex()) {
                                            rowInfo = cellInfo.row();
                                            prevRowIndex = cellInfo.rowIndex();
                                        }
                                        $cell = $(cell);
                                        state = view._changeCellRenderState($cell, $rs.selected, false);
                                        this._wijgrid.cellStyleFormatter.format($cell, cellInfo.cellIndex(), cellInfo.column(), rowInfo, state);
                                    }
                                }
                                this._addedCells._removeAt(i);
                                i--;
                                len--;
                            }
                        }
                        prevRowIndex = -1;
                        for(i = 0 , len = desiredCells.length(); i < len; i++) {
                            cellInfo = desiredCells.item(i);
                            if(this._addedCells.indexOf(cellInfo) < 0 && this._wijgrid.selection().selectedCells().indexOf(cellInfo) < 0) {
                                if(this._addedCells._add(cellInfo)) {
                                    cell = this._view.getCell(cellInfo.cellIndexAbs(), cellInfo.rowIndexAbs());
                                    if(cell) {
                                        if(prevRowIndex !== cellInfo.rowIndex()) {
                                            rowInfo = cellInfo.row();
                                            prevRowIndex = cellInfo.rowIndex();
                                        }
                                        $cell = $(cell);
                                        state = view._changeCellRenderState($cell, $rs.selected, true);
                                        this._wijgrid.cellStyleFormatter.format($cell, cellInfo.cellIndex(), cellInfo.column(), rowInfo, state);
                                    }
                                }
                            }
                        }
                    }// end if
                    
                }
            };
            uiSelection.prototype._onDocumentMouseUp = function (args) {
                this._detachAdditionalEvents();
                if(this._inProgress) {
                    this._inProgress = false;
                    if(this._prevMouseMoveRange && this._prevMouseMoveRange._isValid()) {
                        this._wijgrid._changeCurrentCell(args, this._endCellInfo, {
                            changeSelection: false,
                            setFocus: false
                        });
                        if(!args.shiftKey || (!this._wijgrid.selection()._multipleRangesAllowed() && this._wijgrid.options.selectionMode.toLowerCase() !== "singleRange")) {
                            this._wijgrid.selection()._startNewTransaction(this._startCellInfo);
                        }
                        this._wijgrid.selection().beginUpdate();
                        this._wijgrid.selection()._selectRange(this._prevMouseMoveRange, args.shiftKey, args.ctrlKey, wijmo.grid.cellRangeExtendMode.none, this._endCellInfo);
                        this._wijgrid.selection().endUpdate();
                        var view = this._wijgrid._view(), prevRowIndex = -1, rowInfo, $rs = wijmo.grid.renderState;
                        // clear remained cells
                        for(var i = 0, len = this._addedCells.length(); i < len; i++) {
                            var cellInfo = this._addedCells.item(i);
                            if(this._wijgrid.selection().selectedCells().indexOf(cellInfo) < 0) {
                                var cell = view.getCell(cellInfo.cellIndexAbs(), cellInfo.rowIndexAbs());
                                if(cell !== null) {
                                    if(prevRowIndex !== cellInfo.rowIndex()) {
                                        rowInfo = cellInfo.row();
                                        prevRowIndex = cellInfo.rowIndex();
                                    }
                                    var $cell = $(cell), state = view._changeCellRenderState($cell, $rs.selected, false);
                                    this._wijgrid.cellStyleFormatter.format($cell, cellInfo.cellIndex(), cellInfo.column(), rowInfo, state);
                                }
                            }
                        }
                        this._addedCells._clear();
                        this._startCellInfo = this._endCellInfo = this._prevMouseMoveRange = null;
                        return false;// cancel bubbling
                        
                    }
                }
            };
            uiSelection.prototype._attachAdditionalEvents = function () {
                if(!this._additionalEventsAttached) {
                    try  {
                        this._view.toggleDOMSelection(false)// disable selection
                        ;
                        $(document).bind(this._eventKey("mousemove"), $.proxy(this._onDocumentMouseMove, this)).bind(this._eventKey("mouseup"), $.proxy(this._onDocumentMouseUp, this));
                    }finally {
                        this._additionalEventsAttached = true;
                    }
                }
            };
            uiSelection.prototype._detachAdditionalEvents = function () {
                if(this._additionalEventsAttached) {
                    try  {
                        this._view.toggleDOMSelection(true)// enable selection
                        ;
                        $(document).unbind(this._eventKey("mousemove"), this._onDocumentMouseMove).unbind(this._eventKey("mouseup"), this._onDocumentMouseUp);
                    }finally {
                        this._additionalEventsAttached = false;
                    }
                }
            };
            uiSelection.prototype._eventKey = function (eventType) {
                return wijmo.grid.stringFormat(this._evntFormat, eventType);
            };
            uiSelection.prototype._coordToDataCellInfo = function (pnt) {
                var left = 0, right = this._visLeavesLen - 1, median = 0, cellIdx = -1, bounds, gridRowsAccessor = new wijmo.grid.rowAccessor(this._view, 2/* tbody */ , 0, 0), rowIdx, rowObj, dataOffset, result;
                // get cell index
                while(left <= right) {
                    median = ((right - left) >> 1) + left;
                    bounds = wijmo.grid.bounds(this._view.getHeaderCell(median))// get header cell
                    ;
                    if(!bounds) {
                        // no header?
                        rowObj = gridRowsAccessor.item(0);
                        bounds = wijmo.grid.bounds(wijmo.grid.rowAccessor.getCell(rowObj, median))// get data cell
                        ;
                    }
                    if(!bounds) {
                        break;
                    }
                    if(pnt.x < bounds.left) {
                        // -1
                        right = median - 1;
                    } else if(pnt.x > bounds.left + bounds.width) {
                        // 1
                        left = median + 1;
                    } else {
                        // 0
                        cellIdx = median;
                        break;
                    }
                }
                if(cellIdx === -1) {
                    return wijmo.grid.cellInfo.outsideValue;
                }
                gridRowsAccessor = new wijmo.grid.rowAccessor(this._view, 0/* all */ , 0, 0);
                rowIdx = -1;
                left = 0;
                right = gridRowsAccessor.length() - 1;
                median = 0;
                // get row index
                while(left <= right) {
                    median = ((right - left) >> 1) + left;
                    rowObj = gridRowsAccessor.item(median);
                    bounds = wijmo.grid.bounds(wijmo.grid.rowAccessor.getCell(rowObj, 0));
                    if(pnt.y < bounds.top) {
                        // -1
                        right = median - 1;
                    } else if(pnt.y > bounds.top + bounds.height) {
                        // 1
                        left = median + 1;
                    } else {
                        // 0
                        rowIdx = median;
                        break;
                    }
                }// end while { }
                
                if(rowIdx === -1) {
                    return wijmo.grid.cellInfo.outsideValue;
                }
                result = new wijmo.grid.cellInfo(cellIdx, rowIdx, this._wijgrid, true);
                return result;
            };
            return uiSelection;
        })();
        grid.uiSelection = uiSelection;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="baseView.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /**
        * Class for convenient access to rows of a wijgrid.
        * @ignore
        */
        var rowAccessor = (function () {
            function rowAccessor(view, scope, offsetTop, offsetBottom) {
                this._view = view;
                this._scope = scope;
                this._offsetBottom = offsetBottom;
                this._offsetTop = offsetTop;
            }
            rowAccessor.prototype.item = /** Gets an array of the table row elements that represents a wijgrid widget row at the specified index.
            * size of returning array is always two.
            * @param {Number} index The zero-based index of the row to retrieve.
            * @returns {Object[]} The array of the table row elements at the specified index.
            * @remarks
            */
            function (index) {
                var len = this.length();
                return (index >= 0 && index < len) ? this._view.getJoinedRows(index + this._offsetTop, this._scope) : null;
            };
            rowAccessor.prototype.length = /**
            * Gets the total number of elements.
            * @returns {Number} The total number of elements.
            */
            function () {
                var joinedTables = this._view.getJoinedTables(true, 0), len = 0, htmlAccessor;
                if(htmlAccessor = joinedTables[0]) {
                    len = htmlAccessor.getSectionLength(this._scope);
                }
                if(htmlAccessor = joinedTables[1]) {
                    len += htmlAccessor.getSectionLength(this._scope);
                }
                len -= this._offsetTop + this._offsetBottom;
                if(len < 0) {
                    len = 0;
                }
                return len;
            };
            rowAccessor.iterateCells = /** Sequentially iterates the cells in a rowObj argument.
            * @param {Array} rowObj Array of rows to be iterated.
            * @param {Function} callback Function that will be called each time a new cell is reached.
            * @param {Object} param Parameter that can be handled within the callback function.
            */
            function iterateCells(rowObj, callback, param) {
                if(rowObj && callback) {
                    var globCellIdx = 0, i, len, domRow, j, cellLen, result;
                    for(i = 0 , len = rowObj.length; i < len; i++) {
                        domRow = rowObj[i];
                        if(domRow) {
                            for(j = 0 , cellLen = domRow.cells.length; j < cellLen; j++) {
                                result = callback(domRow.cells[j], globCellIdx++, param);
                                if(result !== true) {
                                    return;
                                }
                            }
                        }
                    }
                }
            };
            rowAccessor.getCell = /** Gets a cell by its global index in a row's array passed in rowObj.
            * @example:
            * Suppose rows is an array containing the following data: [ ["a", "b"], ["c", "d", "e"] ]
            * "a" symbol has a global index 0.
            * "c" symbol has a global index 2.
            * @param {Array} rowObj Array of table row elements.
            * @param {Number} index Zero-based global index of a cell.
            * @returns {HTMLTableCellElement} A cell or null if a cell with provided index is not found.
            */
            function getCell(rowObj, globCellIndex) {
                var domRow, cellLen;
                if(rowObj && (domRow = rowObj[0])) {
                    cellLen = domRow.cells.length;
                    if(globCellIndex < cellLen) {
                        return domRow.cells[globCellIndex];
                    }
                    globCellIndex -= cellLen;
                    if(domRow = rowObj[1]) {
                        cellLen = domRow.cells.length;
                        if(globCellIndex < cellLen) {
                            return domRow.cells[globCellIndex];
                        }
                    }
                }
                return null;
            };
            rowAccessor.getCell$ = /** @ignore */
            function getCell$(row, globCellIndex) {
                var domCell = wijmo.grid.rowAccessor.getCell(row, globCellIndex);
                return (domCell) ? $(domCell) : $([]);// an empty set
                
            };
            rowAccessor.cellsCount = /** Gets the number of cells in a array of table row elements.
            * @param {Array} rowObj Array of table row elements.
            * @returns {Number} The number of cells in a array of table row elements.
            */
            function cellsCount(rowObj) {
                var res = 0, domRow;
                if(rowObj && (domRow = rowObj[0])) {
                    res = domRow.cells.length;
                    if(domRow = rowObj[1]) {
                        res += domRow.cells.length;
                    }
                }
                return res;
            };
            return rowAccessor;
        })();
        grid.rowAccessor = rowAccessor;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        (function (updateCellResult) {
            updateCellResult._map = [];
            updateCellResult.error = 0;
            updateCellResult.continueEditing = 1;
            updateCellResult.success = 2;
            // ESC key is pressed or cell in not rendered.
            updateCellResult.cancel = 4;// used only as modifier of the success value, not as an independent value).
            
            updateCellResult.notEdited = 8;
        })(grid.updateCellResult || (grid.updateCellResult = {}));
        var updateCellResult = grid.updateCellResult;
        ;
        /** @ignore */
        var cellEditorHelper = (function () {
            function cellEditorHelper() {
                this._timeout = 25;
            }
            cellEditorHelper.prototype.cellEditStart = function (grid, cell, e) {
                var result = false, view = grid._view(), rowInfo, args, $innerDiv, rowType;
                if(cell._isValid() && !cell._isEdit() && (cell.column().dataIndex >= 0)) {
                    rowInfo = cell.row();
                    if(rowInfo) {
                        rowType = rowInfo.type;
                        if(rowType & wijmo.grid.rowType.data) {
                            args = {
                                cell: cell,
                                event: e,
                                handled: false
                            };
                            if(result = (grid._trigger("beforeCellEdit", null, args) || (grid.options.editingMode === "row"))) {
                                // cancellable only if editingMode is "cell"
                                if(!args.handled) {
                                    result = this._defaultBeforeCellEdit(grid, args);
                                }
                            }
                            if(result) {
                                cell._isEdit(true);
                                if(grid._showRowHeader()) {
                                    $innerDiv = $((rowInfo.$rows[0]).cells[0]).children("div." + wijmo.grid.wijgrid.CSS.cellContainer);
                                    if($innerDiv.length) {
                                        $innerDiv.empty();
                                        $innerDiv.append($("<div>&nbsp;</div>").addClass(grid.options.wijCSS.icon + " " + grid.options.wijCSS.iconPencil));
                                    }
                                }
                            }
                        }
                    }
                }
                return result;
            };
            cellEditorHelper.prototype.updateCell = function (grid, cell, e) {
                var row;
                if(cell && !cell._isEdit()) {
                    return updateCellResult.success | updateCellResult.notEdited;
                }
                if(!cell || !cell._isValid() || !(row = cell.row()) || !(row.type & wijmo.grid.rowType.data)) {
                    return updateCellResult.error;
                }
                if((e && (e.which === wijmo.getKeyCodeEnum().ESCAPE)) || (!cell._isRendered())) {
                    return updateCellResult.success | updateCellResult.cancel;
                }
                var result = updateCellResult.success, column = cell.column();
                var bcuArgs = {
                    cell: cell,
                    value: undefined
                };
                if(grid._trigger("beforeCellUpdate", null, bcuArgs) || (grid.options.editingMode === "row")) {
                    // cancellable only if editingMode is "cell"
                    if(bcuArgs.value === undefined) {
                        // user doesn't provide a new value
                        bcuArgs.value = this._getCellValue(grid, cell)// get raw value from editor using  default implementation
                        ;
                    }
                    var a = bcuArgs.value, b = // new value
                    cell.value();
                    // old value
                                        try  {
                        var inputType = this._getHTMLInputElementType(cell);
                        if(wijmo.grid.HTML5InputSupport.isExtendSupportRequired(inputType)) {
                            bcuArgs.value = wijmo.grid.HTML5InputSupport.parse(bcuArgs.value, inputType);
                            bcuArgs.value = wijmo.grid.HTML5InputSupport.extend(b, bcuArgs.value, inputType);
                        } else {
                            bcuArgs.value = grid.parse(cell.column(), bcuArgs.value)// try to parse raw value
                            ;
                        }
                        a = bcuArgs.value;
                    } catch (ex) {
                        bcuArgs.value = a// restore raw value
                        ;
                    }
                    if(wijmo.grid.getDataType(column) === "datetime") {
                        if(a instanceof Date) {
                            a = a.getTime();
                        }
                        if(b instanceof Date) {
                            b = b.getTime();
                        }
                    }
                    if(a !== b) {
                        // value is changed
                        // update datasource
                        try  {
                            cell.value(bcuArgs.value);
                        } catch (ex) {
                            var icvArgs = {
                                cell: cell,
                                value: bcuArgs.value
                            };
                            result = updateCellResult.error;
                            grid._trigger("invalidCellValue", null, icvArgs);
                        }
                        if(result & updateCellResult.success) {
                            var acuArgs = {
                                cell: cell
                            };
                            grid._trigger("afterCellUpdate", null, acuArgs);
                        }
                    }
                } else {
                    return updateCellResult.continueEditing;
                }
                return result;
            };
            cellEditorHelper.prototype.cellEditEnd = // must be called only after the updateCell().
            function (grid, cell, e) {
                var rowInfo = cell.row(), aceArgs = {
                    cell: cell,
                    event: e,
                    handled: false
                };
                cell._isEdit(false);
                if(cell._isRendered()) {
                    grid._trigger("afterCellEdit", null, aceArgs);
                    if(!aceArgs.handled) {
                        this._defaultAfterCellEdit(grid, aceArgs);
                    }
                    if(grid._showRowHeader()) {
                        $((rowInfo.$rows[0]).cells[0]).children("div." + wijmo.grid.wijgrid.CSS.cellContainer).html("&nbsp;")// remove icon-pencil
                        ;
                    }
                }
            };
            cellEditorHelper.prototype._defaultBeforeCellEdit = // private
            function (grid, args) {
                var column = args.cell.column(), result = false, $container, $input;
                if(column.dataIndex >= 0) {
                    var value = args.cell.value(), keyCodeEnum = wijmo.getKeyCodeEnum(), inputType = wijmo.grid.HTML5InputSupport.getDefaultInputType(grid._isMobileEnv(), column), allowCellEditing = grid._allowCellEditing(), serverSideCheckbox = false;
                    result = true;
                    try  {
                        $container = args.cell.container();
                        if(wijmo.grid.getDataType(column) === "boolean") {
                            var $span = $container.children("span");
                            if(serverSideCheckbox = !!($span.length && $span.prop("disabled"))) {
                                // C1GridView support
                                $.data($span[0], "serverSideCheckbox", true);
                                $span.prop("disabled", false);
                            }
                            $input = $container.find(":checkbox");
                            if(serverSideCheckbox || !allowCellEditing) {
                                // c1gridview or editingMode="row"
                                $input.prop("disabled", false);
                            }
                            if(args.event && args.event.type === "keypress") {
                                $input.one("keyup", function (e) {
                                    if(e.which === keyCodeEnum.SPACE) {
                                        e.preventDefault();
                                        ($input[0]).checked = !value;
                                    }
                                });
                            }
                        } else {
                            $input = $("<input type='" + inputType + "' />").css("ime-mode", column.imeMode || "auto").addClass(wijmo.grid.wijgrid.CSS.inputMarker).addClass("wijmo-wijinput " + grid.options.wijCSS.stateFocus).bind("keydown", grid, $.proxy(this._checkBoxOrInputKeyDown, this));
                            //the problem of inputing
                            $input.bind((($.support).selectstart ? "selectstart" : "mousedown"), function (event) {
                                event.stopPropagation();
                            });
                            if(args.event && (args.event.type === "keydown") && (args.event.which !== 113)) {
                                // 113 = F2
                                // "edit on keypress", leave the editor empty.
                                                            } else {
                                switch(wijmo.grid.getDataType(column)) {
                                    case "currency":
                                    case "number":
                                        if(value !== null) {
                                            $input.val(value)// ignore formatting
                                            ;
                                            break;
                                        }
                                    case "datetime":
                                        if(wijmo.grid.HTML5InputSupport.isExtendSupportRequired(inputType)) {
                                            $input.val(wijmo.grid.HTML5InputSupport.toStr(value, inputType));
                                            break;
                                        }
                                        // fall through
                                                                            default:
                                        $input.val(grid.toStr(column, value));
                                        break;
                                }
                            }
                            $container.empty().append($input);
                            if(allowCellEditing) {
                                // don't change the focus on row editing.
                                var len = $input.val().length;
                                if(inputType === "text") {
                                    // move caret to the end of the text
                                    new wijmo.grid.domSelection($input[0]).setSelection({
                                        start: len,
                                        end: len
                                    });
                                }
                            }
                        }
                        if(allowCellEditing) {
                            // don't change the focus on row editing.
                            $input.focus();
                            setTimeout(function () {
                                // IE fix
                                $input.focus();
                            }, this._timeout * 2);
                        }
                    } catch (ex) {
                        alert(ex.message);
                        result = false;
                    }
                }
                return result;
            };
            cellEditorHelper.prototype._defaultAfterCellEdit = function (grid, args) {
                var leafOpt = args.cell.column(), result = false, $container, cellValue, $input, rowInfo, view;
                if(leafOpt.dataIndex >= 0) {
                    result = true;
                    view = grid._view();
                    try  {
                        $container = args.cell.container();
                        cellValue = grid.toStr(leafOpt, args.cell.value());
                        rowInfo = view._getRowInfoBySketchRowIndex(args.cell.rowIndex());
                        if(wijmo.grid.getDataType(leafOpt) === "boolean") {
                            var $span = $container.children("span"), disable = $span.length && $.data($span[0], "serverSideCheckbox");
                            $input = $container.find(":checkbox");
                            $input.prop("checked", cellValue === "true");
                            /*if (cellValue === "true") {
                            $input.attr("checked", "checked");
                            }
                            else {
                            $input.removeAttr("checked");
                            }*/
                            if(disable) {
                                $span.prop("disabled", true);
                                $input.prop("disabled", true);
                            }
                        } else {
                            grid.cellFormatter.format($(args.cell.tableCell()), $container, leafOpt, cellValue, rowInfo);
                        }
                    } catch (ex) {
                        alert("defaultAfterCellEdit: " + ex.message);
                        result = false;
                    }
                }
                return result;
            };
            cellEditorHelper.prototype._checkBoxOrInputKeyDown = function (args) {
                var keyCodeEnum = wijmo.getKeyCodeEnum();
                if(args.which === keyCodeEnum.ENTER) {
                    // stop editing when Enter key is pressed
                    var grid = args.data;
                    if(grid) {
                        grid._endEditInternal(args);
                        return false;// prevent submit behaviour.
                        
                    }
                }
            };
            cellEditorHelper.prototype._getCellValue = function (grid, currentCell) {
                var $input = currentCell.container().find(":input:first"), result = null;
                if($input.length) {
                    result = ($input.attr("type") === "checkbox") ? ($input[0]).checked : $input.val();
                }
                return result;
            };
            cellEditorHelper.prototype._getHTMLInputElementType = function (currentCell) {
                return currentCell.container().find(":input:first").attr("type");
            };
            return cellEditorHelper;
        })();
        grid.cellEditorHelper = cellEditorHelper;        
        // private *
        // IME support.
        /** @ignore */
        var keyDownEventListener = (function () {
            function keyDownEventListener(grid, container) {
                this.mGrid = grid;
                this.mWrapper = $("<div />");
                if(this.mGrid._allowCellEditing()) {
                    this.mHiddenElement = $("<input type=\"text\" />").keydown($.proxy(this._onKeyDown, this));
                } else {
                    this.mHiddenElement = $("<input type=\"button\" />")// use any focusable element other than textbox (to avoid keyboard popup in mobile).
                    ;
                }
                this.mHiddenElement.css({
                    position: "relative",
                    border: 0,
                    padding: 0,
                    margin: 0,
                    width: 1,
                    height: // if zero-dimension element is used then 1) a ghost caret will be displayed after editing in IE9. 2) IME is disabled in Chrome.
                    1,
                    "font-size": wijmo.grid.isMobileSafari() ? "0em" : // hide caret in MobileSafari.
                    "1px"
                });
                // don't use zero value otherwise the IME will be disabled in Chrome.
                this.mFakeFocusable = $("<input type=\"button\" />").css(// special element to resolve an issue with changing the IME in IE11 .
                {
                    position: "relative",
                    width: 1,
                    height: 1,
                    border: 0,
                    padding: 0,
                    margin: 0
                });
                this.mWrapper.append(this.mHiddenElement).append(this.mFakeFocusable).css({
                    position: "absolute",
                    width: "0px",
                    height: "0px",
                    overflow: "hidden",
                    "z-index": 999999
                });
                // TFS issue #45934 (an element with absolute positioning affects the superpanel layout in IE).
                container.append(this.mWrapper);
            }
            keyDownEventListener.prototype.dispose = function () {
                if(this.mWrapper) {
                    try  {
                        this.mWrapper.remove();
                    } catch (ex) {
                    }finally {
                        this.mWrapper = null;
                        this.mHiddenElement = null;
                        this.mGrid = null;
                    }
                }
            };
            keyDownEventListener.prototype.focus = function (coord, column) {
                if(coord && coord.length) {
                    var offset = coord.offset();
                    this.mWrapper.offset({
                        top: offset.top,
                        left: offset.left
                    });
                    this.mFakeFocusable.focus()// move focus out of the mHiddenElement first to resolve an issue with changing the IME in IE11
                    ;
                    this.mHiddenElement.css("ime-mode", (column && column.imeMode) || "auto").focus();
                }
            };
            keyDownEventListener.prototype.isHiddenInput = function (element) {
                return element && ((element[0] === this.mHiddenElement[0]) || (element[0] === this.mFakeFocusable[0]));
            };
            keyDownEventListener.prototype.canHandle = function (e) {
                return (this.mGrid._allowCellEditing() && this.isPrintableKeyCode(e));
            };
            keyDownEventListener.prototype.isPrintableKeyCode = function (e) {
                var k = e.keyCode;
                /* ported from the SpeadJS */
                return !e.ctrlKey && !e.altKey && ((k >= 65 && k <= 90) || // A~Z a~z
                ((k >= 48 && k <= 57) || (k >= 96 && k <= 105)) || // 0~9
                (k >= 186 && k <= 192) || // Key for ; = , - . / `
                (k >= 220 && k <= 222 || k === 219) || // Key for \ ] ' [
                (k >= 106 && k <= 111) || // Num keyboard for * + KP_Separator - . /
                (k === 32) || // space
                (k === 61) || // "=" key (Firefox and Opera)
                (k === 173) || // "-" key (Firefox)
                (k === 229 || e.keyCode === 0));// IME key. 229 for IE and Chrome, 0 for Firefox.
                
            };
            keyDownEventListener.prototype._onKeyDown = function (e) {
                if(this.canHandle(e)) {
                    //if (targetOuterDiv.length && (targetOuterDiv[0] === this.outerDiv[0])) {
                    this.mGrid._beginEditInternal(e)// pass input (onKeyUp event) to the editor.
                    ;
                } else {
                    var keyCodeEnum = wijmo.getKeyCodeEnum();
                    // #47873. IE workaround: if input element is inside form element then after double pressing the Esc key the whole form will be cleared.
                    if(e.keyCode === keyCodeEnum.ESCAPE) {
                        e.preventDefault();
                    }
                }
            };
            return keyDownEventListener;
        })();
        grid.keyDownEventListener = keyDownEventListener;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="c1commandbutton.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var cellFormatterHelper = (function () {
            function cellFormatterHelper() { }
            cellFormatterHelper._div = document.createElement("div");
            cellFormatterHelper.prototype.format = function ($cell, $container, column, formattedValue, rowInfo) {
                var grid = column.owner, rt = wijmo.grid.rowType, rse = wijmo.grid.renderStateEx;
                if(rowInfo.type & rt.footer) {
                    if(column.aggregate && (column.aggregate !== "none")) {
                        formattedValue = wijmo.grid.stringFormat(column.footerText || "{0}", column._totalsValue || "");
                    } else {
                        formattedValue = column.footerText || column._footerTextDOM || "";
                    }
                }
                // provide a toggle icon for the first cell of the groupHeader row
                if((rowInfo.type & rt.groupHeader) && (column.visLeavesIdx == (grid.options.showRowHeader ? 1 : 0))) {
                    // Provide a toggle icon
                    // if grouped column is hidden then groupedColumn != column.
                                        var groupedColumn = grid._groupedColumns()[rowInfo._extInfo.groupLevel - 1], gi;
                    // groupLevel is 1-based
                    if(groupedColumn && (gi = groupedColumn.groupInfo) && (gi.outlineMode !== "none")) {
                        var defCSS = wijmo.grid.wijgrid.CSS, wijCSS = grid.options.wijCSS, icon = (rowInfo._extInfo.state & rse.collapsed) ? gi.collapsedImageClass || wijCSS.iconArrowRight : // collapsed
                        gi.expandedImageClass || wijCSS.iconArrowRightDown;
                        // expanded
                                                formattedValue = "<div class=\"" + wijCSS.icon + " " + icon + " " + defCSS.groupToggleVisibilityButton + " " + wijCSS.wijgridGroupToggleVisibilityButton + "\">&nbsp;</div>" + formattedValue;
                    }
                }
                var useDefault = true, defaultFormatter = null, args = {
                    $cell: $cell,
                    $container: $container,
                    column: column,
                    formattedValue: formattedValue,
                    row: rowInfo,
                    afterDefaultCallback: null
                }, result = true;
                // apply rowHeight option to all tbody rows if virtual scrolling is used.
                if(((rowInfo.type & rt.data) || (rowInfo.type === rt.groupFooter || rowInfo.type === rt.groupHeader)) && grid._allowVirtualScrolling()) {
                    var height = (grid._view()).getDefaultRowHeight();
                    $container.css({
                        "overflow": "hidden",
                        "height": height
                    });
                    // apply default height if the rowHeight is not set.
                                    }
                if($.isFunction(column.cellFormatter)) {
                    useDefault = !column.cellFormatter(args);
                }
                if(useDefault) {
                    switch(rowInfo.type & ~rt.dataAlt) {
                        case rt.filter:
                            defaultFormatter = this._formatFilterRowCell;
                            break;
                        case rt.data:
                            defaultFormatter = this._formatDataRowCell;
                            break;
                        default:
                            // groupHeader, groupFooter, footer
                            defaultFormatter = this._formatDefRowCell;
                    }
                    if(defaultFormatter) {
                        result = defaultFormatter.call(this, args);
                        if($.isFunction(args.afterDefaultCallback)) {
                            args.afterDefaultCallback(args);
                        }
                    }
                }
                return (result === false) ? // translate the result value (which can be undefined) to bool
                false : true;
            };
            cellFormatterHelper.prototype._formatFilterRowCell = // * private
            // ** row formatters
            function (args) {
                var grid = args.column.owner, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = grid.options.wijCSS;
                args.$container.addClass(wijCSS.widget + " " + wijCSS.stateDefault);
                if((args.column.dataIndex >= 0) && !args.column.isBand && args.column.showFilter) {
                    args.$container.html("<table cellPadding=\"0\" cellSpacing=\"0\" class=\"" + defCSS.filter + " " + wijCSS.wijgridFilter + " " + wijCSS.cornerAll + "\">" + "<tr>" + "<td style=\"width:100%\">" + "<input type=\"text\" class=\"" + defCSS.filterInput + " " + wijCSS.wijgridFilterInput + "\" style=\"width:100%\" />" + "</td>" + "<td class=\"" + defCSS.filterTrigger + " " + wijCSS.wijgridFilterTrigger + " " + wijCSS.cornerRight + " " + wijCSS.stateDefault + "\">" + "<span class=\"" + wijCSS.icon + " " + wijCSS.iconArrowDown + "\"></span>" + "</td>" + "</tr>" + "</table>");
                } else {
                    args.$container.html("&nbsp;");
                }
            };
            cellFormatterHelper.prototype._formatDataRowCell = function (args) {
                var column = args.column, grid = column.owner, dataType = wijmo.grid.getDataType(column), result = true;
                if(column.clientType === "c1btnfield") {
                    this._c1btnFieldCellFormatter(args);
                } else {
                    if(column.clientType === "c1commandbtnfield") {
                        this._c1commandBtnFieldCellFormatter(args);
                    } else {
                        this._defFieldCellFormatter(args);
                    }
                }
                return result;
            };
            cellFormatterHelper.prototype._formatDefRowCell = function (args) {
                this._updateHTML(args);
            };
            cellFormatterHelper.prototype._defFieldCellFormatter = // row formatters **
            // ** column formatters
            function (args) {
                if(wijmo.grid.getDataType(args.column) === "boolean") {
                    this._boolCellFormatter(args);
                } else {
                    this._dataCellFormatter(args);
                }
            };
            cellFormatterHelper.prototype._boolCellFormatter = function (args) {
                var grid = args.column.owner, allowClickEditing = grid._allowCellEditing() && (args.column.readOnly !== true), targetElement, currentCell, $rt = wijmo.grid.rowType, keyCodeEnum = wijmo.getKeyCodeEnum(), $input = $("<input class=\"" + wijmo.grid.wijgrid.CSS.inputMarker + "\" type=\"checkbox\" />");
                if(!allowClickEditing) {
                    $input.prop("disabled", true);
                }
                if(grid.parse(args.column, grid._dataViewWrapper.getValue(args.row.data, args.column.dataKey)) === true) {
                    $input.prop("checked", "checked");
                }
                args.$container.empty().append($input);
                if(allowClickEditing) {
                    args.$container.children("input").bind("mousedown", function (e) {
                        targetElement = args.$container.parent()[0] , currentCell = grid.currentCell();
                        if(currentCell.tableCell() !== targetElement) {
                            grid._onClick({
                                target: targetElement
                            });
                        }
                        if(!currentCell._isEdit()) {
                            grid.beginEdit();
                        }
                    }).bind("keydown", function (e) {
                        if(e.which === keyCodeEnum.ENTER) {
                            grid._endEditInternal(e);
                            return false;
                        }
                    });
                }
            };
            cellFormatterHelper.prototype._dataCellFormatter = function (args) {
                this._updateHTML(args);
            };
            cellFormatterHelper.prototype._c1btnFieldCellFormatter = function (args) {
                var column = args.column, cmdArgs = {
                    column: args.column,
                    row: args.row
                };
                this._buttonFactory(args.$container, column.command, cmdArgs, null);
            };
            cellFormatterHelper.prototype._c1commandBtnFieldCellFormatter = function (args) {
                var column = args.column, grid = column.owner, cmdArgs = {
                    column: args.column,
                    row: args.row
                }, self = this;
                if(args.row.state & wijmo.grid.renderState.editing) {
                    if(column.showEditButton) {
                        this._buttonFactory(args.$container, column.updateCommand, cmdArgs, function (e, args) {
                            grid.updateRow();
                        });
                        args.$container.append(document.createTextNode("\u00A0"));
                        this._buttonFactory(args.$container, column.cancelCommand, cmdArgs, function (e, args) {
                            grid.cancelRowEditing();
                        });
                    }
                } else {
                    if(column.showEditButton) {
                        this._buttonFactory(args.$container, column.editCommand, cmdArgs, function (e, args) {
                            grid.editRow(cmdArgs.row.dataItemIndex);
                        });
                    }
                    if(column.showDeleteButton) {
                        if(column.showEditButton) {
                            args.$container.append(document.createTextNode("\u00A0"));
                        }
                        this._buttonFactory(args.$container, column.deleteCommand, cmdArgs, function (e, args) {
                            grid.deleteRow(cmdArgs.row.dataItemIndex);
                        });
                    }
                }
                args.$container.addClass("wijmo-wijgrid-innercell-command");
            };
            cellFormatterHelper.prototype._updateHTML = // column formatters **
            function (args) {
                // args.$container.html(args.formattedValue || "&nbsp;"); // -- very slow in IE when table content is recreated more than once (after paging, sorting etc, especially in flat mode).
                var domContainer = args.$container[0];
                // reset content
                if(domContainer.firstChild) {
                    while(domContainer.firstChild) {
                        domContainer.removeChild(domContainer.firstChild);
                    }
                }
                if(args.column.encodeHtml) {
                    if(wijmo.grid.cellFormatterHelper._div.textContent != undefined) {
                        wijmo.grid.cellFormatterHelper._div.textContent = args.formattedValue || "";
                    } else {
                        wijmo.grid.cellFormatterHelper._div.innerText = args.formattedValue || ""// IE <= 8
                        ;
                    }
                } else {
                    wijmo.grid.cellFormatterHelper._div.innerHTML = args.formattedValue || "&nbsp;";
                }
                while(wijmo.grid.cellFormatterHelper._div.firstChild) {
                    domContainer.appendChild(wijmo.grid.cellFormatterHelper._div.firstChild);
                }
            };
            cellFormatterHelper.prototype._buttonFactory = function (container, cmd, args, clickCallback) {
                var btnOptions = $.extend({
                }, {
                    text: cmd.text,
                    iconClass: cmd.iconClass,
                    disabled: args.column.owner.options.disabled,
                    click: function (e) {
                        var processDefault = true;
                        if($.isFunction(cmd.click)) {
                            var res = cmd.click.apply(this, [
                                e, 
                                args
                            ]);
                            processDefault = (res !== false) && !e.isDefaultPrevented()// let user to cancel the action
                            ;
                        }
                        if(processDefault && clickCallback) {
                            clickCallback.apply(this, [
                                e, 
                                args
                            ]);
                        }
                        e.preventDefault()// prevent # beging added to url.
                        ;
                    }
                });
                var btnContainer = $("<div />");
                container.append(btnContainer);
                switch(args.column.buttonType) {
                    case "link":
                        btnContainer.wijgridcommandlink(btnOptions);
                        break;
                    case "imageButton":
                        btnContainer.wijgridcommandimagebutton(btnOptions);
                        break;
                    case "button":
                        btnContainer.wijgridcommandbutton(btnOptions);
                        break;
                    case "image":
                        btnContainer.wijgridcommandimage(btnOptions);
                        break;
                    default:
                        throw "Unknown buttonType";
                }
            };
            return cellFormatterHelper;
        })();
        grid.cellFormatterHelper = cellFormatterHelper;        
        // * private
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="wijgrid.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var uiResizer = (function () {
            function uiResizer(wijgrid) {
                this.MIN_WIDTH = 5;
                this._elements = [];
                this._gap = 10;
                this._step = 1;
                this._inProgress = false;
                this._hoveredField = null;
                this._startLocation = null;
                this._lastLocation = null;
                this._proxy = null;
                this._wijgrid = wijgrid;
                this._evntFormat = "{0}." + this._wijgrid.widgetName + ".resizer";
            }
            uiResizer.prototype.addElement = function (c1basefield) {
                if(c1basefield && c1basefield.element) {
                    c1basefield.element.bind(this._eventKey("mousemove"), $.proxy(this._onMouseMove, this)).bind(this._eventKey("mousedown"), $.proxy(this._onMouseDown, this)).bind(this._eventKey("mouseout"), $.proxy(this._onMouseOut, this));
                    this._elements.push(c1basefield);
                }
            };
            uiResizer.prototype.dispose = function () {
                var _this = this;
                $.each(this._elements, function (index, c1basefield) {
                    c1basefield.element.unbind(_this._eventKey("mousemove"), _this._onMouseMove).unbind(_this._eventKey("mousedown"), _this._onMouseDown).unbind(_this._eventKey("mouseout"), _this._onMouseOut);
                });
                this._detachDocEvents();
            };
            uiResizer.prototype.inProgress = function () {
                return this._inProgress;
            };
            
            uiResizer.prototype._onMouseMove = function (e) {
                if(!this._inProgress) {
                    var hoveredField = this._getFieldByPos({
                        x: e.pageX,
                        y: e.pageY
                    });
                    if(hoveredField && hoveredField._canSize() && this._wijgrid._canInteract()) {
                        hoveredField.element.css("cursor", "e-resize");
                        //hoveredField.element.find("> a").css("cursor", "e-resize");
                        this._hoveredField = hoveredField;
                        // prevent frozener from taking effect
                        e.stopPropagation();
                    } else {
                        this._onMouseOut(e);
                    }
                }
            };
            uiResizer.prototype._onMouseOut = function (e) {
                if(!this._inProgress) {
                    if(this._hoveredField) {
                        this._hoveredField.element.css("cursor", "");
                        //_hoveredField.element.find("> a").css("cursor", "");
                        this._hoveredField = null;
                    }
                }
            };
            uiResizer.prototype._onMouseDown = function (e) {
                this._hoveredField = this._getFieldByPos({
                    x: e.pageX,
                    y: e.pageY
                });
                if(this._hoveredField && (this._hoveredField)._canSize() && this._wijgrid._canInteract()) {
                    try  {
                        var wijCSS = this._wijgrid.options.wijCSS, defCSS = wijmo.grid.wijgrid.CSS;
                        this._hoveredField.element.css("cursor", "");
                        // _hoveredField.element.find("> a").css("cursor", "");
                        this._docCursor = document.body.style.cursor;
                        document.body.style.cursor = "e-resize";
                        this._startLocation = this._lastLocation = wijmo.grid.bounds(this._hoveredField.element);
                        this._proxy = $("<div class=\"" + defCSS.resizingHandle + " " + wijCSS.wijgridResizingHandle + " " + wijCSS.stateHighlight + "\">&nbsp;</div>");
                        var visibleAreaBounds = this._wijgrid._view().getVisibleAreaBounds(true);
                        this._proxy.css({
                            "left": e.pageX,
                            "top": this._startLocation.top,
                            "height": visibleAreaBounds.height + visibleAreaBounds.top - this._startLocation.top
                        });
                        $(document.body).append(this._proxy);
                    }finally {
                        this._attachDocEvents();
                        this._inProgress = true;
                        // prevent frozener from taking effect
                        e.stopPropagation();
                    }
                }
            };
            uiResizer.prototype._onDocumentMouseMove = function (e) {
                var deltaX = this._step * Math.round((e.pageX - this._lastLocation.left) / this._step);
                this._lastLocation = {
                    left: this._lastLocation.left + deltaX,
                    top: e.pageY,
                    width: undefined,
                    height: undefined
                };
                this._proxy.css("left", this._lastLocation.left);
            };
            uiResizer.prototype._onDocumentMouseUp = function (e) {
                try  {
                    document.body.style.cursor = this._docCursor;
                    // destroy proxy object
                    this._proxy.remove();
                    if(this._startLocation !== this._lastLocation) {
                        this._wijgrid._fieldResized(this._hoveredField, this._startLocation.width, Math.max(this._lastLocation.left - this._startLocation.left, this.MIN_WIDTH));
                    }
                }finally {
                    this._hoveredField = null;
                    this._proxy = null;
                    this._detachDocEvents();
                    this._inProgress = false;
                }
            };
            uiResizer.prototype._onSelectStart = function (e) {
                e.preventDefault();
            };
            uiResizer.prototype._attachDocEvents = function () {
                if(!this._inProgress) {
                    $(document).bind(this._eventKey("mousemove"), $.proxy(this._onDocumentMouseMove, this)).bind(this._eventKey("mouseup"), $.proxy(this._onDocumentMouseUp, this));
                    if($.fn.disableSelection) {
                        $(document.body).disableSelection();
                    }
                    if("onselectstart" in document) {
                        // $.support.selectstart ?
                        $(document.body).bind("selectstart", this._onSelectStart);
                    }
                }
            };
            uiResizer.prototype._detachDocEvents = function () {
                if(this._inProgress) {
                    $(document).unbind(this._eventKey("mousemove"), this._onDocumentMouseMove).unbind(this._eventKey("mouseup"), this._onDocumentMouseUp);
                    if($.fn.enableSelection) {
                        $(document.body).enableSelection();
                    }
                    if("onselectstart" in document) {
                        // $.support.selectstart ?
                        $(document.body).unbind("selectstart", this._onSelectStart);
                    }
                }
            };
            uiResizer.prototype._getFieldByPos = function (mouse) {
                var i, len, c1basefield, bounds, res;
                for(i = 0 , len = this._elements.length; i < len; i++) {
                    c1basefield = this._elements[i];
                    bounds = wijmo.grid.bounds(c1basefield.element);
                    res = wijmo.grid.isOver(mouse.y, mouse.x, bounds.top, bounds.left + bounds.width - this._gap, bounds.height, this._gap);
                    if(res) {
                        return c1basefield;
                    }
                }
                return null;
            };
            uiResizer.prototype._eventKey = function (eventType) {
                var prefix = (this._wijgrid._isTouchEnv()) ? "wij" : // 48214 [Win8.1, IE11] Column moving is performed instead of column sizing when resize a column.
                "";
                return prefix + wijmo.grid.stringFormat(this._evntFormat, eventType);
            };
            return uiResizer;
        })();
        grid.uiResizer = uiResizer;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="wijgrid.ts" />
    /// <reference path="c1groupedfield.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var uiDragndrop = (function () {
            function uiDragndrop(wijgrid) {
                this._scope_guid = "scope_" + wijmo.grid.getUID();
                // to use inside the draggable.drag event.
                this._dragEnd = false;
                this.mZIndex = 1000;
                var defCSS = wijmo.grid.wijgrid.CSS;
                this._wijgrid = wijgrid;
                this._wijCSS = this._wijgrid.options.wijCSS;
                this._wrapHtml = "<div class=\"" + this._wijCSS.widget + " " + defCSS.wijgrid + " " + this._wijCSS.wijgrid + " " + this._wijCSS.content + " " + this._wijCSS.cornerAll + "\">" + "<table class=\"" + defCSS.root + " " + defCSS.table + " " + this._wijCSS.wijgridTable + "\">" + "<tr class=\"" + defCSS.headerRow + " " + this._wijCSS.wijgridHeaderRow + "\">" + "</tr>" + "</table>" + "</div>";
            }
            uiDragndrop.prototype.attachGroupArea = function (element) {
                var draggedWijField, self = this;
                if(!$.ui || !($.ui).droppable || !($.ui).draggable) {
                    return;
                }
                element.droppable({
                    scope: this._scope_guid,
                    tolerance: "pointer",
                    greedy: true,
                    accept: function (draggable) {
                        if(self._wijgrid.options.allowColMoving) {
                            draggedWijField = self._getWijFieldInstance(draggable);
                            if(draggedWijField) {
                                // The rightmost column header in the the group area can't be dragged to the end of the group area again.
                                if((draggedWijField instanceof $.wijmo.c1groupedfield) && (draggedWijField.options.groupedIndex === self._wijgrid._groupedColumns().length - 1)) {
                                    return false;
                                }
                                return !draggedWijField.options.isBand && (draggedWijField.options.groupedIndex === undefined || (draggedWijField instanceof $.wijmo.c1groupedfield));
                            }
                        }
                        return false;
                    },
                    drop: function (e, ui) {
                        if(!self._isInElement(e, ui.draggable) && (draggedWijField = self._getWijFieldInstance(ui.draggable))) {
                            self._dragEnd = true;
                        }
                    },
                    over: function (e, ui) {
                        var cnt = self._wijgrid._field("groupedWidgets").length;
                        self._dropTargetRedirected = (cnt > 0);
                        self._droppableWijField = (cnt > 0) ? self._wijgrid._field("groupedWidgets")[cnt - 1] : // use the rightmost header as a drop target
                        element// special case, the drop target is the group area itself
                        ;
                        element.data("thisDroppableWijField", self._droppableWijField);
                    },
                    out: function (e, ui) {
                        if(self._droppableWijField === element.data("thisDroppableWijField")) {
                            self._droppableWijField = null;
                        }
                        //if (draggedWijField = _getWijFieldInstance(ui.draggable)) {
                        //	_hideArrows();
                        //}
                                            }
                });
            };
            uiDragndrop.prototype.attach = function (wijField) {
                var element, draggedWijField, defCSS = wijmo.grid.wijgrid.CSS, self = this;
                if(!($.ui).droppable || !($.ui).draggable) {
                    return;
                }
                if(!wijField || !(element = wijField.element)) {
                    return;
                }
                element.draggable({
                    helper: function (e) {
                        var result;
                        if(wijField instanceof $.wijmo.c1groupedfield) {
                            result = element.clone();
                        } else {
                            result = element.clone().wrap(self._wrapHtml).width(element.width()).height(element.height()).closest("." + defCSS.wijgrid);
                        }
                        result.addClass(defCSS.dndHelper + " " + self._wijCSS.wijgridDndHelper).css("z-index", self.mZIndex = wijmo.grid.getZIndex(self._wijgrid.outerDiv, 1000))// Update the z-index property. wijdialog increases its z-index property every time when the dialog position is changed.
                        ;
                        return result;
                    },
                    appendTo: "body",
                    scope: //cursor: "pointer",
                    self._scope_guid,
                    drag: function (e, ui) {
                        self._hideArrows();
                        if(self._droppableWijField && !self._isInElement(e, element)) {
                            // indicate insertion position
                            var $arrowsTarget = self._droppableWijField.element;
                            if(!$arrowsTarget) {
                                // _droppableWijField is the group area element
                                $arrowsTarget = (self._droppableWijField);
                            }
                            self._showArrows($arrowsTarget, self._getPosition(wijField, self._droppableWijField, e, ui));
                        }
                    },
                    start: function (e, ui) {
                        if(self._wijgrid._canInteract() && self._wijgrid.options.allowColMoving && (self._wijgrid._UIResizer() == null || !self._wijgrid._UIResizer().inProgress())) {
                            //return (wijField._canDrag() === true);
                                                        var column = wijField.options, travIdx = wijField.options.travIdx, dragInGroup = (wijField instanceof $.wijmo.c1groupedfield), dragSource = dragInGroup ? "groupArea" : "columns";
                            if(dragInGroup) {
                                column = wijmo.grid.search(self._wijgrid.columns(), function (test) {
                                    return test.options.travIdx === travIdx;
                                });
                                column = (!column.found) ? // grouped column is invisible?
                                wijmo.grid.getColumnByTravIdx(self._wijgrid.options.columns, travIdx).found : column.found.options;
                            }
                            if(wijField._canDrag() && self._wijgrid._trigger("columnDragging", null, {
                                drag: column,
                                dragSource: dragSource
                            })) {
                                self._wijgrid._trigger("columnDragged", null, {
                                    drag: column,
                                    dragSource: dragSource
                                });
                                return true;
                            }
                        }
                        return false;
                    },
                    stop: function (e, ui) {
                        self._hideArrows();
                        try  {
                            if(self._dragEnd) {
                                if(!self._droppableWijField.element) {
                                    // _droppableWijField is the group area element
                                    self._wijgrid._handleDragnDrop(wijField.options.travIdx, -1, "left", wijField instanceof $.wijmo.c1groupedfield, true);
                                } else {
                                    self._wijgrid._handleDragnDrop(wijField.options.travIdx, self._droppableWijField.options.travIdx, self._getPosition(wijField, self._droppableWijField, e, ui), wijField instanceof $.wijmo.c1groupedfield, self._droppableWijField instanceof $.wijmo.c1groupedfield);
                                }
                            }
                        }finally {
                            self._droppableWijField = null;
                            self._dragEnd = false;
                        }
                    }
                }).droppable(// ~draggable
                {
                    hoverClass: self._wijCSS.stateHover,
                    scope: self._scope_guid,
                    tolerance: "pointer",
                    greedy: true,
                    accept: function (draggable) {
                        if(self._wijgrid.options.allowColMoving) {
                            if(element[0] !== draggable[0]) {
                                // different DOM elements
                                draggedWijField = self._getWijFieldInstance(draggable)// dragged column
                                ;
                                if(draggedWijField) {
                                    return draggedWijField._canDropTo(wijField);
                                }
                            }
                        }
                        return false;
                    },
                    drop: function (e, ui) {
                        if(draggedWijField = self._getWijFieldInstance(ui.draggable)) {
                            // As droppable.drop fires before draggable.stop, let draggable to finish action.
                            // Otherwise exception is thrown as during re-rendering element bound to draggable will be already deleted.
                            self._dragEnd = true;
                            // an alternative:
                            //window.setTimeout(function () {
                            //wijgrid._handleDragnDrop(draggedWijField, wijField, _getPosition(draggedWijField, wijField, e, ui));
                            //}, 100);
                                                    }
                    },
                    over: function (e, ui) {
                        self._dropTargetRedirected = false;
                        self._droppableWijField = wijField;
                        // to track when droppable.over event of other element fires before droppable.out of that element.
                        element.data("thisDroppableWijField", self._droppableWijField);
                    },
                    out: function (e, ui) {
                        if(self._droppableWijField === wijField.element.data("thisDroppableWijField")) {
                            self._droppableWijField = null;
                        }
                        //if (draggedWijField = _getWijFieldInstance(ui.draggable)) {
                        //	_hideArrows();
                        //}
                                            }
                })// ~droppable
                ;
            };
            uiDragndrop.prototype.detach = function (wijField) {
                var element;
                if(wijField && (element = wijField.element)) {
                    if(element.data("ui-draggable")) {
                        element.draggable("destroy");
                    }
                    if(element.data("ui-droppable")) {
                        element.droppable("destroy");
                    }
                }
            };
            uiDragndrop.prototype.dispose = function () {
                if(this._$topArrow) {
                    this._$topArrow.remove();
                    this._$topArrow = null;
                }
                if(this._$bottomArrow) {
                    this._$bottomArrow.remove();
                    this._$bottomArrow = null;
                }
            };
            uiDragndrop.prototype._getWijFieldInstance = // private
            function (draggable) {
                var widgetName = wijmo.grid.widgetName(draggable);
                if(!widgetName) {
                    throw "widgetName is undedined";
                }
                return draggable.data(widgetName);
            };
            uiDragndrop.prototype._showArrows = // position: "left", "right", "center"
            function (element, position) {
                this._topArrow().css("z-index", this.mZIndex).show().position({
                    my: "center",
                    at: position + " top",
                    of: element,
                    collision: "none"
                });
                this._bottomArrow().css("z-index", this.mZIndex).show().position({
                    my: "center",
                    at: position + " bottom",
                    of: element,
                    collision: "none"
                });
            };
            uiDragndrop.prototype._hideArrows = function () {
                this._topArrow().hide();
                this._bottomArrow().hide();
            };
            uiDragndrop.prototype._topArrow = function () {
                if(!this._$topArrow) {
                    this._$topArrow = $("<div />").addClass(wijmo.grid.wijgrid.CSS.dndArrowTopContainer + " " + this._wijCSS.wijgridDndArrowTopContainer).append($("<span />").addClass(this._wijCSS.icon + " " + this._wijCSS.iconArrowThickDown)).hide().appendTo(document.body);
                }
                return this._$topArrow;
            };
            uiDragndrop.prototype._bottomArrow = function () {
                if(!this._$bottomArrow) {
                    this._$bottomArrow = $("<div />").addClass(wijmo.grid.wijgrid.CSS.dndArrowBottomContainer + " " + this._wijCSS.wijgridDndArrowBottomContainer).append($("<span />").addClass(this._wijCSS.icon + " " + this._wijCSS.iconArrowThickUp)).hide().appendTo(document.body);
                }
                return this._$bottomArrow;
            };
            uiDragndrop.prototype._isInElement = function (e, element) {
                var bounds = wijmo.grid.bounds(element, false);
                return ((e.pageX > bounds.left && e.pageX < bounds.left + bounds.width) && (e.pageY > bounds.top && e.pageY < bounds.top + bounds.height));
            };
            uiDragndrop.prototype._getPosition = function (drag, drop, e, dragui) {
                if(!drop.element) {
                    // drop is the group area element
                    return "left";
                }
                if(this._dropTargetRedirected) {
                    return "right";
                }
                var bounds = wijmo.grid.bounds(drop.element, false), sixth = bounds.width / 6, centerX = bounds.left + (bounds.width / 2), result = "right", distance;
                if(e.pageX < centerX) {
                    result = "left";
                }
                if(drop instanceof $.wijmo.c1groupedfield) {
                    // drag is moved over a grouped column
                    if(drag instanceof $.wijmo.c1groupedfield) {
                        // drag is a grouped column too
                        distance = drop.options.groupedIndex - drag.options.groupedIndex;
                        if(Math.abs(distance) === 1) {
                            result = (distance < 0) ? "left" : "right";
                        }
                    }
                    return result;
                }
                // both drag and drop are non-grouped columns
                distance = drop.options.linearIdx - drag.options.linearIdx;
                if(drop.options.isBand && (drag.options.parentIdx !== drop.options.travIdx) && // drag is not an immediate child of drop
                (Math.abs(e.pageX - centerX) < sixth)) {
                    return "center";
                }
                // drag and drop are contiguous items of the same level
                if(drag.options.parentIdx === drop.options.parentIdx && Math.abs(distance) === 1) {
                    result = (distance < 0) ? "left" : "right";
                }
                return result;
            };
            return uiDragndrop;
        })();
        grid.uiDragndrop = uiDragndrop;        
        // ~private
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var cellStyleFormatterHelper = (function () {
            function cellStyleFormatterHelper(wijgrid) {
                if(!wijgrid) {
                    throw "invalid arguments";
                }
                this._wijgrid = wijgrid;
            }
            cellStyleFormatterHelper.prototype.format = function ($cell, cellIndex, column, rowInfo, state, cellAttr, cellStyle) {
                var $rs = wijmo.grid.renderState, $rt = wijmo.grid.rowType, rowType = rowInfo.type, args, groupRowCellInfo = null;
                if(cellIndex === 0 && this._wijgrid._showRowHeader()) {
                    column = null;
                }
                if(rowType === $rt.groupHeader || rowType === $rt.groupFooter) {
                    column = null;
                    if(cellAttr && (groupRowCellInfo = cellAttr.groupInfo)) {
                        column = this._wijgrid._field("leaves")[groupRowCellInfo.leafIndex]// replace "column" with the one associated with the $cell's content
                        ;
                        //delete cellAttr.groupInfo;
                                            }
                }
                args = {
                    $cell: $cell,
                    state: state,
                    row: rowInfo,
                    column: column,
                    _cellIndex: cellIndex,
                    _purpose: groupRowCellInfo ? groupRowCellInfo.purpose : undefined
                };
                if(state & $rs.rendering) {
                    this._renderingStateFormatter(args, cellAttr, cellStyle);
                } else {
                    this._currentStateFormatter(args, state & $rs.current);
                    //hoveredStateFormatter(args, state & $rs.hovered);
                    this._selectedStateFormatter(args, state & $rs.selected);
                    if(rowType !== $rt.header) {
                        if((state & $rs.current) || (state & $rs.selected)) {
                            args.$cell.addClass(this._wijgrid.options.wijCSS.stateDefault)// make bootstrap happy
                            ;
                        } else {
                            args.$cell.removeClass(this._wijgrid.options.wijCSS.stateDefault);
                        }
                    }
                }
                if($.isFunction(this._wijgrid.options.cellStyleFormatter)) {
                    this._wijgrid.options.cellStyleFormatter(args);
                }
            };
            cellStyleFormatterHelper.prototype._renderingStateFormatter = // private ---
            function (args, cellAttr, cellStyles) {
                var $rt = wijmo.grid.rowType, key, value, leaf = args.column, rowType = args.row.type, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS;
                switch(rowType) {
                    case $rt.header:
                        args.$cell.addClass(defCSS.TH + " " + wijCSS.wijgridTH);
                        break;
                    default:
                        args.$cell.addClass(defCSS.TD + " " + wijCSS.wijgridTD);
                }
                if((rowType & $rt.data) && leaf && leaf.textAlignment) {
                    // set text alignment
                    switch(leaf.textAlignment.toLowerCase()) {
                        case "left":
                            args.$cell.addClass(defCSS.cellAlignLeft + " " + wijCSS.wijgridCellAlignLeft);
                            break;
                        case "right":
                            args.$cell.addClass(defCSS.cellAlignRight + " " + wijCSS.wijgridCellAlignRight);
                            break;
                        case "center":
                            args.$cell.addClass(defCSS.cellAlignCenter + " " + wijCSS.wijgridCellAlignCenter);
                            break;
                    }
                }
                // copy attributes
                if(cellAttr) {
                    for(key in cellAttr) {
                        if(cellAttr.hasOwnProperty(key)) {
                            value = cellAttr[key];
                            if((key === "groupInfo" || key === "colSpan" || key === "rowSpan") && !(value > 1)) {
                                continue;
                            }
                            if(key === "class") {
                                args.$cell.addClass(value);
                            } else {
                                args.$cell.attr(key, value);
                            }
                        }
                    }
                }
                // copy inline css
                if(cellStyles) {
                    for(key in cellStyles) {
                        if(cellStyles.hasOwnProperty(key)) {
                            if(key === "paddingLeft") {
                                // groupIndent
                                args.$cell.children("." + defCSS.cellContainer).css(key, cellStyles[key]);
                                continue;
                            }
                            args.$cell.css(key, cellStyles[key]);
                        }
                    }
                }
                if(args._cellIndex === 0 && this._wijgrid._showRowHeader()) {
                    args.$cell.attr({
                        "role": "rowheader",
                        "scope": "row"
                    }).addClass(wijCSS.stateDefault + " " + wijCSS.content + " " + defCSS.rowHeader + " " + wijCSS.wijgridRowHeader);
                } else {
                    switch(rowType) {
                        case ($rt.header):
                            args.$cell.attr({
                                "role": "columnheader",
                                "scope": "col"
                            });
                            break;
                        case ($rt.footer):
                            args.$cell.attr({
                                "role": "columnfooter",
                                "scope": "col"
                            });
                            break;
                        default:
                            args.$cell.attr("role", "gridcell");
                    }
                }
                //if ((rowType & $rt.data) === $rt.data) {
                if(rowType & $rt.data) {
                    if(args._cellIndex >= 0 && leaf/* && leaf.dataParser*/ ) {
                        args.$cell.attr("headers", (window).escape(leaf.headerText));
                        if(leaf.readOnly) {
                            args.$cell.attr("aria-readonly", true);
                        }
                        if(leaf.dataIndex >= 0) {
                            args.$cell.addClass("wijdata-type-" + wijmo.grid.getDataType(leaf));
                        }
                    }
                }
                if(rowType === $rt.groupHeader || rowType === $rt.groupFooter) {
                    // append wijdata-type class only to the aggregate cells of the group row, not grouped cells.
                    if(leaf && args._purpose === wijmo.grid.groupRowCellPurpose.aggregateCell) {
                        args.$cell.addClass("wijdata-type-" + wijmo.grid.getDataType(leaf));
                    }
                }
            };
            cellStyleFormatterHelper.prototype._currentStateFormatter = function (args, add) {
                var $rt = wijmo.grid.rowType, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS;
                if(add) {
                    args.$cell.addClass(wijCSS.stateActive);
                    if(args.row.type === $rt.header) {
                        args.$cell.addClass(defCSS.currentHeaderCell + " " + wijCSS.wijgridCurrentHeaderCell);
                    } else {
                        args.$cell.addClass(defCSS.currentCell + " " + wijCSS.wijgridCurrentCell);
                    }
                } else {
                    args.$cell.removeClass(wijCSS.stateActive);
                    if(args.row.type === $rt.header) {
                        args.$cell.removeClass(defCSS.currentHeaderCell + " " + wijCSS.wijgridCurrentHeaderCell);
                    } else {
                        args.$cell.removeClass(defCSS.currentCell + " " + wijCSS.wijgridCurrentCell);
                    }
                }
            };
            cellStyleFormatterHelper.prototype._hoveredStateFormatter = function (args, add) {
                if(add) {
                } else {
                }
            };
            cellStyleFormatterHelper.prototype._selectedStateFormatter = function (args, add) {
                var wijCSS = this._wijgrid.options.wijCSS;
                if(add) {
                    args.$cell.addClass(wijCSS.stateHighlight).attr("aria-selected", "true");
                } else {
                    args.$cell.removeClass(wijCSS.stateHighlight).removeAttr("aria-selected");
                }
            };
            return cellStyleFormatterHelper;
        })();
        grid.cellStyleFormatterHelper = cellStyleFormatterHelper;        
        // --- private
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    /// <reference path="wijgrid.ts" />
    /// <reference path="misc.ts" />
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var rowStyleFormatterHelper = (function () {
            function rowStyleFormatterHelper(wijgrid) {
                if(!wijgrid) {
                    throw "invalid arguments";
                }
                this._wijgrid = wijgrid;
            }
            rowStyleFormatterHelper.prototype.format = function (rowInfo, rowAttr, rowStyle) {
                var $rs = wijmo.grid.renderState, $rt = wijmo.grid.rowType, state = rowInfo.state, args = rowInfo;
                if(state & $rs.rendering) {
                    this._renderingStateFormatter(args, rowAttr, rowStyle);
                } else {
                    this._currentStateFormatter(args, (state & $rs.current) !== 0);
                    this._hoveredStateFormatter(args, (state & $rs.hovered) !== 0);
                    this._selectedStateFormatter(args, (state & $rs.selected) !== 0);
                }
                if($.isFunction(this._wijgrid.options.rowStyleFormatter)) {
                    this._wijgrid.options.rowStyleFormatter(args);
                }
            };
            rowStyleFormatterHelper.prototype._groupFormatter = function (rowInfo) {
                var rse = wijmo.grid.renderStateEx, extInfo = rowInfo._extInfo, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS;
                if(extInfo.state & rse.hidden) {
                    rowInfo.$rows.css("display", "none");
                    //rowInfo.$rows.attr("aria-hidden", true);
                                    } else {
                    rowInfo.$rows.css("display", "");
                    //rowInfo.$rows.removeAttr("aria-hidden");
                                    }
                if(rowInfo.type & wijmo.grid.rowType.groupHeader) {
                    var gi = this._wijgrid._groupedColumns()[rowInfo._extInfo.groupLevel - 1].groupInfo, expandedIcon = //1-based
                    gi.expandedImageClass || wijCSS.iconArrowRightDown, collapsedIcon = gi.collapsedImageClass || wijCSS.iconArrowRight, toggleBtn = //toggleBtn = rowInfo.$rows.children("td, th").eq(this._wijgrid.options.showRowHeader ? 1 : 0).find("." + defCSS.groupToggleVisibilityButton);
                    wijmo.grid.rowAccessor.getCell$(rowInfo.$rows, this._wijgrid.options.showRowHeader ? 1 : 0).find("." + defCSS.groupToggleVisibilityButton);
                    if(extInfo.state & rse.collapsed) {
                        rowInfo.$rows.attr("aria-expanded", false);
                        rowInfo.$rows.removeClass(defCSS.groupHeaderRowExpanded + " " + wijCSS.wijgridGroupHeaderRowExpanded).addClass(defCSS.groupHeaderRowCollapsed + " " + wijCSS.wijgridGroupHeaderRowCollapsed);
                        toggleBtn.removeClass(expandedIcon).addClass(collapsedIcon);
                    } else {
                        rowInfo.$rows.attr("aria-expanded", true);
                        rowInfo.$rows.removeClass(defCSS.groupHeaderRowCollapsed + " " + wijCSS.wijgridGroupHeaderRowCollapsed).addClass(defCSS.groupHeaderRowExpanded + " " + wijCSS.wijgridGroupHeaderRowExpanded);
                        toggleBtn.removeClass(collapsedIcon).addClass(expandedIcon);
                    }
                }
            };
            rowStyleFormatterHelper.prototype._renderingStateFormatter = // * private
            function (args, rowAttr, rowStyle) {
                var defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS, className, contentClass = defCSS.row + " " + wijCSS.wijgridRow + " " + wijCSS.content, $rt = wijmo.grid.rowType, rse = wijmo.grid.renderStateEx, key;
                args.$rows.attr("role", "row");
                // copy attributes
                if(rowAttr) {
                    for(key in rowAttr) {
                        if(rowAttr.hasOwnProperty(key)) {
                            if(key === "class") {
                                args.$rows.addClass(rowAttr[key]);
                            } else {
                                args.$rows.attr(key, rowAttr[key]);
                                if(args.$rows[0].style.height) {
                                    args.$rows.each(function () {
                                        $.data(this, "customHeight", this.style.height);
                                        return true;
                                    });
                                }
                            }
                        }
                    }
                }
                // copy inline css
                if(rowStyle) {
                    for(key in rowStyle) {
                        if(rowStyle.hasOwnProperty(key)) {
                            args.$rows.css(key, rowStyle[key]);
                        }
                    }
                }
                if(args._extInfo.groupLevel) {
                    args.$rows.attr("aria-level", args._extInfo.groupLevel);
                }
                // hide collapsed row
                if(args._extInfo.state & rse.hidden) {
                    args.$rows.css("display", "none");
                    // args.$rows.attr("aria-hidden", true);
                                    }
                switch(args.type & ~$rt.dataAlt) {
                    case // clear dataAlt modifier
                    ($rt.header):
                        className = defCSS.headerRow + " " + wijCSS.wijgridHeaderRow;
                        break;
                    case ($rt.data):
                        className = contentClass + " " + defCSS.dataRow + " " + wijCSS.wijgridDataRow;
                        if(args.type & $rt.dataAlt) {
                            className += " " + defCSS.altRow + " " + wijCSS.wijgridAltRow;
                        }
                        break;
                    case ($rt.emptyDataRow):
                        className = contentClass + " " + defCSS.emptyDataRow + " " + wijCSS.wijgridEmptyDataRow;
                        break;
                    case ($rt.filter):
                        className = defCSS.filterRow + " " + wijCSS.wijgridFilterRow;
                        break;
                    case ($rt.groupHeader):
                        args.$rows.attr({
                            "id": "GH" + args._extInfo.groupIndex + "-" + args._extInfo.groupLevel,
                            "aria-expanded": ((args._extInfo.state & rse.collapsed) === 0)
                        });
                        className = contentClass + " " + defCSS.groupHeaderRow + " " + wijCSS.wijgridGroupHeaderRow + " ";
                        className += (args._extInfo.state & rse.collapsed) ? defCSS.groupHeaderRowCollapsed + " " + wijCSS.wijgridGroupHeaderRowCollapsed : defCSS.groupHeaderRowExpanded + " " + wijCSS.wijgridGroupHeaderRowExpanded;
                        break;
                    case ($rt.groupFooter):
                        args.$rows.attr("id", "GF" + args._extInfo.groupIndex + "-" + args._extInfo.groupLevel);
                        className = contentClass + " " + defCSS.groupFooterRow + " " + wijCSS.wijgridGroupFooterRow;
                        break;
                    case ($rt.footer):
                        className = defCSS.footerRow + " " + wijCSS.wijgridFooterRow + " " + wijCSS.stateDefault + " " + wijCSS.stateHighlight;
                        break;
                    default:
                        throw wijmo.grid.stringFormat("unknown rowType: {0}", args.type);
                }
                args.$rows.addClass(className);
            };
            rowStyleFormatterHelper.prototype._currentStateFormatter = function (args, flag) {
                if(this._wijgrid._showRowHeader()) {
                    var wijCSS = this._wijgrid.options.wijCSS, defCSS = wijmo.grid.wijgrid.CSS;
                    // make deal with the row header cell
                    if(flag) {
                        // add formatting
                        $((args.$rows[0]).cells[0]).addClass(wijCSS.stateActive + " " + defCSS.currentRowHeaderCell + " " + wijCSS.wijgridCurrentRowHeaderCell);
                    } else {
                        // remove formatting
                        $((args.$rows[0]).cells[0]).removeClass(wijCSS.stateActive + " " + defCSS.currentRowHeaderCell + " " + wijCSS.wijgridCurrentRowHeaderCell);
                    }
                }
            };
            rowStyleFormatterHelper.prototype._hoveredStateFormatter = function (args, flag) {
                var wijCSS = this._wijgrid.options.wijCSS;
                if(flag) {
                    // add formatting
                    args.$rows.addClass(wijCSS.stateDefault + " " + wijCSS.stateHover);
                } else {
                    // remove formatting
                    args.$rows.removeClass(wijCSS.stateDefault + " " + wijCSS.stateHover);
                }
            };
            rowStyleFormatterHelper.prototype._selectedStateFormatter = function (args, flag) {
                if(flag) {
                    // add formatting
                                    } else {
                    // remove formatting
                                    }
            };
            return rowStyleFormatterHelper;
        })();
        grid.rowStyleFormatterHelper = rowStyleFormatterHelper;        
        // private *
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var tally = (function () {
            function tally() {
                this._sum = 0;
                this._sum2 = 0;
                this._cntNumbers = 0;
                this._cntStrings = 0;
                this._cntDates = 0;
                this._max = 0;
                this._min = 0;
                this._minDate = 0;
                this._maxDate = 0;
            }
            tally.prototype.add = function (value) {
                if(value === null || value === "") {
                    return;
                }
                var foo, typeOf = (value instanceof Date) ? "datetime" : typeof (value);
                // * count strings *
                foo = value.toString()// value = _parseValue(value);
                ;
                if(this._cntStrings++ === 0) {
                    this._minString = this._maxString = foo;
                }
                if(foo < this._minString) {
                    this._minString = foo;
                }
                if(foo > this._maxString) {
                    this._maxString = foo;
                }
                // * count numbers *
                if(typeOf === "number") {
                    if(this._cntNumbers++ === 0) {
                        this._min = this._max = value;
                    }
                    this._sum += value;
                    this._sum2 += value * value;
                    if(value < this._min) {
                        this._min = value;
                    }
                    if(value > this._max) {
                        this._max = value;
                    }
                } else {
                    // * count dates *
                    if(typeOf === "datetime") {
                        foo = value.getTime();
                        if(this._cntDates++ === 0) {
                            this._minDate = this._maxDate = foo;
                        }
                        if(foo < this._minDate) {
                            this._minDate = foo;
                        }
                        if(foo > this._maxDate) {
                            this._maxDate = foo;
                        }
                    }
                }
            };
            tally.prototype.getValueString = function (column) {
                var wijgrid = column.owner;
                if(this._cntNumbers && (column.dataType === "number" || column.dataType === "currency")) {
                    var value = this._getValue(column.aggregate);
                    return wijgrid.toStr(column, value);
                }
                // we only support max/min and count for dates
                if(this._cntDates && (column.dataType === "datetime")) {
                    // we only support max/min and count for dates
                    switch(column.aggregate) {
                        case "max":
                            return wijgrid.toStr(column, new Date(this._maxDate));
                        case "min":
                            return wijgrid.toStr(column, new Date(this._minDate));
                        case "count":
                            return this._cntStrings + "";
                    }
                }
                // we only support max/min and count for strings
                if(this._cntStrings) {
                    switch(column.aggregate) {
                        case "max":
                            return this._maxString;
                        case "min":
                            return this._minString;
                        case "count":
                            return this._cntStrings + "";
                    }
                }
                return "";
            };
            tally.prototype._getValue = function (aggregate) {
                switch(aggregate) {
                    case "average":
                        return (this._cntNumbers === 0) ? 0 : this._sum / this._cntNumbers;
                    case "count":
                        return this._cntStrings;
                    case "max":
                        return this._max;
                    case "min":
                        return this._min;
                    case "sum":
                        return this._sum;
                    case "std":
                        if(this._cntNumbers <= 1) {
                            return 0;
                        }
                        return Math.sqrt(this._getValue("var"));
                    case "stdPop":
                        if(this._cntNumbers <= 1) {
                            return 0;
                        }
                        return Math.sqrt(this._getValue("varPop"));
                    case "var":
                        if(this._cntNumbers <= 1) {
                            return 0;
                        }
                        return this._getValue("varPop") * this._cntNumbers / (this._cntNumbers - 1);
                    case "vapPop":
                        if(this._cntNumbers <= 1) {
                            return 0;
                        }
                        var tmp = this._sum / this._cntNumbers;
                        return this._sum2 / this._cntNumbers - tmp * tmp;
                }
                return 0;
            };
            return tally;
        })();
        grid.tally = tally;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="wijgrid.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var uiFrozener = (function () {
            function uiFrozener(wijgrid) {
                this._docEventsUID = "wijgridfrozener" + wijmo.grid.getUID();
                this._docEventsAttached = false;
                this._newStaticIndex = -1;
                // depends on e.data value (staticRowIndex or staticColumnIndex)
                this._staticColumnIndex = -1;
                this._staticRowIndex = -1;
                this._staticOffsetH = 0;
                this._staticOffsetV = 0;
                this._inProgress = false;
                this._wijgrid = wijgrid;
                this.refresh();
            }
            uiFrozener.prototype.inProgress = function () {
                return this._inProgress;
            };
            uiFrozener.prototype.refresh = function () {
                this.dispose();
                var freezingMode = this._wijgrid.options.freezingMode;
                if(freezingMode !== "none") {
                    this._$outerDiv = this._wijgrid.outerDiv.find("." + wijmo.grid.wijgrid.CSS.fixedView);
                    this._superPanel = (this._wijgrid._view())._getSuperPanel();
                    this._staticOffsetH = this._wijgrid._getStaticOffsetIndex(false);
                    this._staticOffsetV = this._wijgrid._getStaticOffsetIndex(true);
                    this._staticColumnIndex = this._wijgrid._getStaticIndex(false);
                    this._staticRowIndex = this._wijgrid._getStaticIndex(true);
                    this._visibleBounds = this._wijgrid._view().getVisibleContentAreaBounds()//.getVisibleAreaBounds();
                    ;
                    var allFixedAreaBounds = wijmo.grid.bounds(this._$outerDiv.find(".wijmo-wijgrid-split-area-nw")), containerBounds = wijmo.grid.bounds(this._$outerDiv);
                    // if staticColumnsAlignment is "right" then create vbar only when staticColumnIndex is set (vbar dragging ability is disabled in this case)
                    if((freezingMode === "both" || freezingMode === "columns") && (this._wijgrid.options.staticColumnsAlignment !== "right" || this._staticColumnIndex >= 0)) {
                        this._createVBar(this._visibleBounds, allFixedAreaBounds, containerBounds);
                    }
                    if((freezingMode === "both" || freezingMode === "rows") && !this._wijgrid._serverSideVirtualScrolling()) {
                        this._createHBar(this._visibleBounds, allFixedAreaBounds, containerBounds);
                    }
                }
            };
            uiFrozener.prototype.dispose = function () {
                if(this._$hBar) {
                    this._$hBar.remove();
                    this._$hBar = null;
                }
                if(this._$vBar) {
                    this._$vBar.remove();
                    this._$vBar = null;
                }
                if(this._$proxy) {
                    this._$proxy.remove();
                    this._$proxy = null;
                }
                this._$outerDiv = null;
                this._superPanel = null;
                this._detachDocEvents();
            };
            uiFrozener.prototype._createVBar = function (visibleBounds, allFixedAreaBounds, containerBounds) {
                var lAlign = (this._wijgrid.options.staticColumnsAlignment !== "right"), leftPos = lAlign ? allFixedAreaBounds.width + allFixedAreaBounds.left : allFixedAreaBounds.left - 2, self = this, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS;
                if(leftPos <= visibleBounds.left + visibleBounds.width) {
                    this._$vBar = $("<div><div></div></div>").addClass(defCSS.freezingHandleV + " " + wijCSS.wijgridFreezingHandleV).addClass(lAlign ? "" : "not-allowed").css(// remove "pointer" cursor (vbar dragging ability is disabled when staticColumnsAlignment == "right" is used)
                    {
                        left: leftPos - containerBounds.left,
                        top: allFixedAreaBounds.top - containerBounds.top,
                        height: visibleBounds.height + visibleBounds.top - allFixedAreaBounds.top
                    }).bind("mousedown", function (e) {
                        e.data = true// vertical bar
                        ;
                        self._onBarMouseDown.apply(self, arguments);
                    }).appendTo(this._$outerDiv);
                    // content
                    this._$vBar.find("div").addClass(defCSS.freezingHandleContent + " " + wijCSS.header);
                }
            };
            uiFrozener.prototype._createHBar = function (visibleBounds, allFixedAreaBounds, containerBounds) {
                var topPos = allFixedAreaBounds.top + allFixedAreaBounds.height, lAlign = (this._wijgrid.options.staticColumnsAlignment !== "right"), self = this, defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS;
                if(topPos <= visibleBounds.top + visibleBounds.height) {
                    this._$hBar = $("<div><div></div></div>").addClass(defCSS.freezingHandleH + " " + wijCSS.wijgridFreezingHandleH).css({
                        left: lAlign ? allFixedAreaBounds.left - containerBounds.left : // 0?
                        0,
                        top: topPos - containerBounds.top,
                        width: lAlign ? visibleBounds.width + visibleBounds.left - allFixedAreaBounds.left : // visibleBounds.width?
                        visibleBounds.width
                    }).bind("mousedown", function (e) {
                        e.data = false// horizontal bar
                        ;
                        self._onBarMouseDown.apply(self, arguments);
                    }).appendTo(this._$outerDiv);
                    // content
                    this._$hBar.find("div").addClass(defCSS.freezingHandleContent + " " + wijCSS.header);
                }
            };
            uiFrozener.prototype._onBarMouseDown = // e.data: true = vertical, false = horizontal
            function (e) {
                if(this._wijgrid.options.disabled || (this._wijgrid.options.staticColumnsAlignment === "right" && e.data)) {
                    return false;
                }
                var defCSS = wijmo.grid.wijgrid.CSS, wijCSS = this._wijgrid.options.wijCSS;
                this._visibleBounds = this._wijgrid._view().getVisibleContentAreaBounds()//.getVisibleAreaBounds();
                ;
                this._newStaticIndex = e.data ? this._staticColumnIndex : this._staticRowIndex;
                this._$proxy = $("<div class=\"" + defCSS.resizingHandle + " " + wijCSS.wijgridResizingHandle + " " + wijCSS.header + "\"></div>").appendTo(document.body);
                this._attachDocEvents(e.data);
                this._inProgress = true;
                // prevent selectionUI from taking effect
                e.stopPropagation();
            };
            uiFrozener.prototype._onDocumentMouseMove = function (e) {
                if(e.data && this._superPanel.options.hScroller.scrollValue) {
                    (this._superPanel).hScrollTo(0);
                } else if(!e.data && this._superPanel.options.vScroller.scrollValue) {
                    (this._superPanel).vScrollTo(0);
                }
                this._showPosition(e);
            };
            uiFrozener.prototype._onDocumentMouseUp = function (e) {
                try  {
                    if(this._$proxy) {
                        this._$proxy.remove();
                    }
                    this._detachDocEvents();
                    if(e.data) {
                        // vertical bar
                        if(this._newStaticIndex !== this._staticColumnIndex) {
                            this._wijgrid.option("staticColumnIndex", this._newStaticIndex);
                        }
                    } else {
                        // horizontal bar
                        if(this._newStaticIndex !== this._staticRowIndex) {
                            this._wijgrid.option("staticRowIndex", this._newStaticIndex);
                        }
                    }
                }finally {
                    this._$proxy = null;
                    this._inProgress = false;
                }
            };
            uiFrozener.prototype._attachDocEvents = function (verticalBarTouched) {
                if(!this._docEventsAttached) {
                    try  {
                        if($.fn.disableSelection) {
                            $(document.body).disableSelection();
                        }
                        this._wijgrid._view().toggleDOMSelection(false);
                        $(document).bind(this._docEventKey("mousemove"), verticalBarTouched, $.proxy(this._onDocumentMouseMove, this)).bind(this._docEventKey("mouseup"), verticalBarTouched, $.proxy(this._onDocumentMouseUp, this));
                    }finally {
                        this._docEventsAttached = true;
                    }
                }
            };
            uiFrozener.prototype._detachDocEvents = function () {
                if(this._docEventsAttached) {
                    try  {
                        if($.fn.enableSelection) {
                            $(document.body).enableSelection();
                        }
                        this._wijgrid._view().toggleDOMSelection(true);
                        $(document).unbind("." + this._docEventsUID);
                    }finally {
                        this._docEventsAttached = false;
                    }
                }
            };
            uiFrozener.prototype._docEventKey = function (eventName) {
                return wijmo.grid.stringFormat("{0}.{1}", eventName, this._docEventsUID);
            };
            uiFrozener.prototype._showPosition = function (e) {
                var element, elementBounds, centerXOrY, currentIdx, prevIdx, leftOrTop, position, barBounds, lAlign = (this._wijgrid.options.staticColumnsAlignment !== "right");
                if(e.data) {
                    // vertical
                    barBounds = wijmo.grid.bounds(this._$vBar);
                    if(Math.abs(e.pageX - (barBounds.left + barBounds.width / 2)) < barBounds.width) {
                        this._$proxy.hide();
                        return;
                    }
                    if((element = this._getFieldByPos({
                        x: e.pageX,
                        y: e.pageY
                    }))) {
                        // get column widget
                        elementBounds = wijmo.grid.bounds(element.element);
                        centerXOrY = elementBounds.left + elementBounds.width / 2;
                        currentIdx = element.options.visLeavesIdx - this._staticOffsetV;
                        prevIdx = Math.max(currentIdx - 1, -1);
                        leftOrTop = e.pageX < centerXOrY ? (prevIdx !== this._staticColumnIndex) : (currentIdx === this._staticColumnIndex);
                        position = leftOrTop ? elementBounds.left : elementBounds.left + elementBounds.width;
                        if(!wijmo.grid.isOverAxis(position, this._visibleBounds.left - 1, this._visibleBounds.width + 2)) {
                            return;
                        }
                        this._newStaticIndex = leftOrTop ? prevIdx : currentIdx;
                        this._$proxy.show().css({
                            left: position,
                            top: elementBounds.top,
                            width: 3,
                            height: this._visibleBounds.height + this._visibleBounds.top - elementBounds.top
                        });
                    }
                } else {
                    // horizontal
                    barBounds = wijmo.grid.bounds(this._$hBar);
                    if(Math.abs(e.pageY - (barBounds.top + barBounds.height / 2)) < barBounds.height) {
                        this._$proxy.hide();
                        return;
                    }
                    if((element = this._getRowByPos({
                        x: e.pageX,
                        y: e.pageY
                    }))) {
                        elementBounds = wijmo.grid.bounds(element);
                        centerXOrY = elementBounds.top + elementBounds.height / 2;
                        currentIdx = this._wijgrid._view().getAbsoluteRowIndex(element) - this._staticOffsetH;
                        prevIdx = Math.max(currentIdx - 1, -1);
                        leftOrTop = e.pageY < centerXOrY ? (prevIdx !== this._staticRowIndex) : (currentIdx === this._staticRowIndex);
                        position = leftOrTop ? elementBounds.top : elementBounds.top + elementBounds.height;
                        if(!wijmo.grid.isOverAxis(position, this._visibleBounds.top - 1, this._visibleBounds.height + 2)) {
                            return;
                        }
                        this._newStaticIndex = leftOrTop ? prevIdx : currentIdx;
                        this._$proxy.show().css({
                            left: lAlign ? elementBounds.left : // this._visibleBounds.left?
                            this._visibleBounds.left,
                            top: position,
                            width: lAlign ? this._visibleBounds.width + this._visibleBounds.left - elementBounds.left : // this._visibleBounds.width?
                            this._visibleBounds.width,
                            height: 3
                        });
                    }
                }
            };
            uiFrozener.prototype._getFieldByPos = function (pos) {
                var columns = this._wijgrid.columns(), i, len, colWidget, o, bounds;
                for(i = 0 , len = columns.length; i < len; i++) {
                    colWidget = columns[i];
                    o = colWidget.options;
                    if(o.isLeaf) {
                        bounds = wijmo.grid.bounds(colWidget.element);
                        if(wijmo.grid.isOverAxis(pos.x, bounds.left, bounds.width)) {
                            return colWidget;
                        }
                    }
                }
                return null;
            };
            uiFrozener.prototype._getRowByPos = function (pos) {
                var rows = this._wijgrid._rows(), i, len, row, bounds;
                for(i = 0 , len = rows.length(); i < len; i++) {
                    row = rows.item(i)[0];
                    bounds = wijmo.grid.bounds($(row));
                    if(wijmo.grid.isOverAxis(pos.y, bounds.top, bounds.height)) {
                        return row;
                    }
                }
                return null;
            };
            return uiFrozener;
        })();
        grid.uiFrozener = uiFrozener;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    /// <reference path="bands_traversing.ts"/>
    /// <reference path="misc.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var columnsGenerator = (function () {
            function columnsGenerator() { }
            columnsGenerator.generate = function generate(mode, fieldsInfo, columns) {
                switch(mode) {
                    case "append":
                        columnsGenerator._processAppendMode(fieldsInfo, columns);
                        break;
                    case "merge":
                        columnsGenerator._processMergeMode(fieldsInfo, columns);
                        break;
                    case "none":
                        break;
                    default:
                        throw wijmo.grid.stringFormat("Unsupported value: \"{0}\"", mode);
                }
            };
            columnsGenerator._processAppendMode = function _processAppendMode(fieldsInfo, columns) {
                var autoColumns = {
                };
                wijmo.grid.traverse(columns, function (column) {
                    if(column.dynamic && wijmo.grid.validDataKey(column.dataKey)) {
                        autoColumns[column.dataKey] = true;
                    }
                });
                $.each(fieldsInfo, function (key, fieldInfo) {
                    if(("name" in fieldInfo) && !autoColumns[fieldInfo.name]) {
                        var leaf = columnsGenerator._createAutoField(fieldInfo);
                        columns.push(leaf);
                    }
                });
            };
            columnsGenerator._processMergeMode = function _processMergeMode(fieldsInfo, columns) {
                var columnsHasNoDataKey = [], i;
                wijmo.grid.traverse(columns, function (column) {
                    if(column.isLeaf && !column.isBand) {
                        var dataKey = column.dataKey;
                        if(wijmo.grid.validDataKey(dataKey)) {
                            if(fieldsInfo[dataKey] !== undefined) {
                                delete fieldsInfo[dataKey];
                            }
                        } else {
                            if(dataKey !== null) {
                                // don't linkup with any data field if dataKey is null
                                columnsHasNoDataKey.push(column);
                            }
                        }
                    }
                });
                if(columnsHasNoDataKey.length) {
                    i = 0;
                    $.each(fieldsInfo, function (key, info) {
                        var leaf = columnsHasNoDataKey[i++];
                        if(leaf) {
                            leaf.dataKey = info.name;
                            delete fieldsInfo[key];
                        }
                    });
                }
                $.each(fieldsInfo, function (key, info) {
                    var leaf = columnsGenerator._createAutoField(info);
                    columns.push(leaf);
                });
            };
            columnsGenerator._createAutoField = function _createAutoField(fieldInfo) {
                return wijmo.grid.createDynamicField({
                    dataKey: fieldInfo.name
                });
            };
            return columnsGenerator;
        })();
        grid.columnsGenerator = columnsGenerator;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts"/>
    (function (grid) {
        "use strict";
        var $ = jQuery;
        /** @ignore */
        var uiVirtualScroller = (function () {
            function uiVirtualScroller(wijgrid, $content, fixedAreaHeight, rowOuterHeight) {
                //private _fixedAreaHeight: number;
                this._timer = 0;
                this._timeout = 50;
                // msec
                this._ignoreScrollEvents = false;
                this._debounceScrolledEvent = true;
                this._wijgrid = wijgrid;
                //this._fixedAreaHeight = fixedAreaHeight;
                this._$content = $content;
                this._view = this._wijgrid._view();
                this._N = this._wijgrid._renderableRowsCount();
                this._rowOuterHeight = rowOuterHeight;
                this._updateContentHeight();
                var height = this._wijgrid.outerDiv.height() + this._N * this._rowOuterHeight;// total height
                
                this._view._splitAreas.sw.height(height);
            }
            uiVirtualScroller.prototype.scrollTo = function (rowIndex, callback) {
                this._debounceScrolledEvent = false// otherwise sequential method calls will be blocked by timer
                ;
                this._completeListener = callback;
                (this._panelInst).vScrollTo(rowIndex * (this._panelInst).options.vScroller.scrollSmallChange, true);
            };
            uiVirtualScroller.prototype._updateContentHeight = /** calculate content height from row number, row height and fixed area */
            function () {
                // subtract _fixedAreaHeight, otherwise dummy rows will be hanging "under" the grid
                this._$content.height(this._rowOuterHeight * this._N/*- this._fixedAreaHeight*/ );
            };
            uiVirtualScroller.prototype.attach = function ($scroller) {
                this._$scroller = $scroller;
                this._panelInst = $scroller.data("wijmo-wijsuperpanel");
                this._updateContentHeight();
                this._updateVerticalScroller();
                $scroller.bind("wijsuperpanelscrolled.wijgrid", $.proxy(this._onSuperpanelScrolled, this));
                $scroller.bind("wijsuperpanelscrolling.wijgrid", $.proxy(this._onSuperpanelScrolling, this));
                $scroller.bind("wijsuperpanelscrolled.wijgrid", $.proxy(this._onSuperpanelPostScrolled, this))// manipulate with the _ignoreScrollEvents property.
                ;
            };
            uiVirtualScroller.prototype._updateVerticalScroller = function () {
                // if vScroll.scrollValue was an y-offset of the content, rather than a percentage of the offset,
                // smallChange and max would be in pixels
                var max = Math.max(0, this._N - (this._view.getVirtualPageSize() - 1));
                // scrollValue is the index of the first row to show
                this._setVerticalScrollerOptions(1, max);
            };
            uiVirtualScroller.prototype._setVerticalScrollerOptions = function (smallChange, max) {
                var vScroller = this._panelInst.options.vScroller;
                vScroller.scrollSmallChange = smallChange;
                vScroller.scrollLargeChange = smallChange * 4;
                // temporary workaround for superpanel bug
                max += vScroller.scrollLargeChange - 1;
                vScroller.scrollMax = max;
                this._panelInst.option("vScroller", vScroller);
                // TODO: rewrite!!
                if(!this._view._isNativeSuperPanel() && ((this._panelInst)._scrollDrag != undefined)) {
                    var f = (this._panelInst)._fields(), vbarContainer = f.vbarContainer, vbarDrag = f.vbarDrag;
                    (this._panelInst)._scrollDrag("v", vbarContainer, vbarDrag, false);
                }
            };
            uiVirtualScroller.prototype._changeVisibleRowsCount = function (visibleRowsCount) {
                this._N = visibleRowsCount;
                this._updateContentHeight();
                this._updateVerticalScroller();
            };
            uiVirtualScroller.prototype.dispose = function () {
                this._$scroller.unbind(".wijgrid");
                this._clearTimer();
            };
            uiVirtualScroller.prototype._clearTimer = function () {
                window.clearTimeout(this._timer);
                this._timer = 0;
            };
            uiVirtualScroller.prototype._onSuperpanelScrolling = function (e, args) {
                if(this._ignoreScrollEvents || (args.dir !== "v")) {
                    return;
                }
                if(this._timer === -1) {
                    return false;// cancel while scrolling will not be handled.
                    
                }
            };
            uiVirtualScroller.prototype._onSuperpanelScrolled = function (e, args) {
                var self = this;
                if(this._ignoreScrollEvents || (args.dir !== "v")) {
                    return;
                }
                if(this._timer > 0) {
                    this._clearTimer();
                }
                if(this._timer !== -1) {
                    this._timer = window.setTimeout(function () {
                        self._timer = -1// lock
                        ;
                        var scrollToIndex = Math.floor(args.newValue / self._panelInst.options.vScroller.scrollSmallChange), oldScrollIndex = self._view._bounds.start;
                        if(scrollToIndex < 0) {
                            scrollToIndex = 0;
                        }
                        if(scrollToIndex >= self._N) {
                            scrollToIndex = self._N - 1;
                        }
                        if(scrollToIndex !== oldScrollIndex) {
                            self._debounceScrolledEvent = true;
                            self._wijgrid._handleVirtualScrolling(scrollToIndex, null, $.proxy(self._scrollingCompleted, self));
                        } else {
                            self._debounceScrolledEvent = true;
                            self._log();
                            self._clearTimer()// unlock
                            ;
                        }
                    }, this._debounceScrolledEvent ? this._timeout : 0);
                }
            };
            uiVirtualScroller.prototype._scrollingCompleted = function (scrollIndex) {
                this._wijgrid._trackScrollingIndex(scrollIndex);
                this._log();
                if(this._completeListener) {
                    this._completeListener();
                    this._completeListener = null;
                }
                this._clearTimer()// unlock
                ;
            };
            uiVirtualScroller.prototype._onSuperpanelPostScrolled = function () {
                if($.isFunction(this._postScrolled)) {
                    this._postScrolled.apply(this, arguments);
                }
            };
            uiVirtualScroller.prototype._log = function () {
                //if (window.console) {
                //	var bounds = this._wijgrid._view()._bounds;
                //	window.console.log("bounds: [" + bounds.start + ", " + bounds.end + "], scrollTo: " + bounds.start);
                //}
                            };
            return uiVirtualScroller;
        })();
        grid.uiVirtualScroller = uiVirtualScroller;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="interfaces.ts" />
    (function (grid) {
        /** @ignore */
        var renderBoundsCollection = (function () {
            function renderBoundsCollection(maxRowIndex) {
                this._items = [];
                this._capacity = null;
                this._maxRowIndex = maxRowIndex;
            }
            renderBoundsCollection.prototype.add = function (bounds) {
                this._capacity = null;
                var len = this._items.length, last;
                if(!len || (last = this._items[len - 1]).end < bounds.start) {
                    if(len && (bounds.start - last.end === 1)) {
                        last.end = bounds.end;
                    } else {
                        this._items.push(bounds);
                    }
                } else {
                    // todo: merge adjacent bounds
                                        var idxS = this._binSearchByStartVal(bounds.start), idxE = this._binSearchByEndVal(bounds.end), idxSn = idxS < 0 ? ~idxS : idxS, idxEn = idxE < 0 ? ~idxE : idxE, pinL = (idxS >= 0) || (idxSn > 0 && bounds.start <= this._items[idxSn - 1].end), pinR = (idxE >= 0) || (idxEn < len && bounds.end <= this._items[idxEn].end && bounds.end >= this._items[idxEn].start), cnt;
                    if(pinL) {
                        if(pinR) {
                            // 1 1
                            if(idxS >= 0) {
                                this._items[idxEn].start = this._items[idxSn].start;
                                if(cnt = (idxEn - idxSn)) {
                                    this._items.splice(idxSn, cnt);
                                }
                            } else {
                                this._items[idxEn].start = this._items[idxSn - 1].start;
                                if(cnt = idxEn - idxSn + 1) {
                                    this._items.splice(idxSn - 1, cnt);
                                }
                            }
                        } else {
                            // 1 0
                            if(idxS >= 0) {
                                this._items[idxSn].end = bounds.end;
                                if(cnt = (idxEn - idxSn - 1)) {
                                    this._items.splice(idxSn, cnt);
                                }
                            } else {
                                this._items[idxSn - 1].end = bounds.end;
                                if(cnt = (idxEn - idxSn)) {
                                    this._items.splice(idxSn, cnt);
                                }
                            }
                        }
                    } else {
                        // !pinL
                        if(pinR) {
                            // 0 1
                            this._items[idxEn].start = bounds.start;
                            if(cnt = (idxEn - idxSn)) {
                                this._items.splice(idxSn, cnt);
                            }
                        } else {
                            // 0 0
                            this._items.splice(idxSn, idxEn - idxSn, bounds);
                        }
                    }
                }
            };
            renderBoundsCollection.prototype.remove = function (bounds) {
                this._capacity = null;
                var len = this._items.length;
                if(len) {
                    var idxS = this._binSearchByStartVal(bounds.start), idxE = this._binSearchByEndVal(bounds.end), idxSn = idxS < 0 ? ~idxS : idxS, idxEn = idxE < 0 ? ~idxE : idxE, pinL = (idxS >= 0) || (idxSn > 0 && bounds.start <= this._items[idxSn - 1].end), pinR = (idxE >= 0) || (idxEn < len && bounds.end <= this._items[idxEn].end && bounds.end >= this._items[idxEn].start);
                    if(pinL) {
                        if(pinR) {
                            var boundIdxL = (idxS >= 0) ? idxS : idxSn - 1, boundIdxR = (idxE >= 0) ? idxE : idxEn;
                            if(idxS >= 0 && idxE >= 0) {
                                this._items.splice(idxSn, idxEn - idxSn + 1);
                            } else {
                                if(idxS >= 0) {
                                    this._items[idxEn].start = bounds.end + 1;
                                    this._items.splice(idxSn, idxEn - idxSn);
                                } else {
                                    if(idxE >= 0) {
                                        if(boundIdxL === boundIdxR) {
                                            // same bound
                                            this._items[idxSn - 1].end = bounds.start - 1;
                                        } else {
                                            this._items[idxSn].end = bounds.start - 1;
                                            this._items.splice(idxSn, idxEn - idxSn + 1);
                                        }
                                    } else {
                                        if(boundIdxL === boundIdxR) {
                                            // same bound, split single bound.
                                            var tEnd = this._items[idxSn - 1].end;
                                            this._items[idxSn - 1].end = bounds.start - 1;
                                            this._items.splice(idxSn, 0, {
                                                start: bounds.end + 1,
                                                end: tEnd
                                            });
                                        } else {
                                            this._items[idxSn - 1].end = bounds.start - 1;
                                            this._items[idxEn].start = bounds.end + 1;
                                            this._items.splice(idxSn, idxEn - idxSn);
                                        }
                                    }
                                }
                            }
                        } else {
                            if(idxS >= 0) {
                                this._items.splice(idxSn, idxEn - idxSn);
                            } else {
                                this._items[idxSn].end = bounds.start - 1;
                                this._items.splice(idxSn, idxEn - idxSn - 1);
                            }
                        }
                    } else {
                        if(pinR) {
                            if(idxE >= 0) {
                                this._items.splice(idxSn, idxEn - idxSn + 1);
                            } else {
                                // !!
                                this._items[idxEn].start = bounds.end + 1;
                                this._items.splice(idxSn, idxEn - idxSn);
                            }
                        } else {
                            this._items.splice(idxSn, idxEn - idxSn);
                        }
                    }
                }
            };
            renderBoundsCollection.prototype.clear = function () {
                this._capacity = 0;
                this._items = [];
            };
            renderBoundsCollection.prototype.item = function (index) {
                return this._items[index];
            };
            renderBoundsCollection.prototype.forEachIndex = //public forEachIndex(callback: (idx: number) => void ) {
            //	if (callback) {
            //		for (var i = 0, len = this._items.length; i < len; i++) {
            //			var bound = this._items[i];
            //			for (var start = bound.start, end = bound.end; start <= end; start++) {
            //				callback(start);
            //			}
            //		}
            //	}
            //}
            function (start, count, callback) {
                if(start < 0) {
                    return;
                }
                var len = this._items.length, state = this._getIteratorStateFor(start), cnt = 0, flag = true, abort = false;
                if(state) {
                    var j = state.j;
                    for(var i = state.i; i < len && !abort; i++) {
                        var item = this._items[i];
                        if(!flag) {
                            j = item.start;
                        }
                        for(j; j <= item.end && !abort; j++) {
                            if((++cnt > count) && (count !== -1)) {
                                return;
                            }
                            abort = (callback(j) === false);
                        }
                        flag = false;
                    }
                }
            };
            renderBoundsCollection.prototype.forEachIndexBackward = function (start, count, callback) {
                if(start < 0) {
                    return;
                }
                var len = this._items.length, state = this._getIteratorStateFor(start), cnt = 0, flag = true, abort = false;
                if(state) {
                    var j = state.j;
                    for(var i = state.i; i >= 0 && !abort; i--) {
                        var item = this._items[i];
                        if(!flag) {
                            j = item.end;
                        }
                        for(j; j >= item.start && !abort; j--) {
                            if((++cnt > count) && (count !== -1)) {
                                return;
                            }
                            abort = (callback(j) === false);
                        }
                        flag = false;
                    }
                }
            };
            renderBoundsCollection.prototype._getIteratorStateFor = function (visIndex) {
                var len = this._items.length, cap = 0;
                for(var i = 0; i < len; i++) {
                    var item = this._items[i];
                    cap += item.end - item.start + 1;
                    var delta = cap - visIndex;
                    if(delta >= 0) {
                        return {
                            i: i,
                            j: item.end - delta + 1
                        };
                    }
                }
                return null;
            };
            renderBoundsCollection.prototype.getAbsIndex = // [0-5],[10-15]
            // f(6) -> 10
            // Maps visible row index to absolute row (sketch)  index
            function (renderedIndex) {
                for(var i = 0, len = this._items.length; i < len; i++) {
                    var bound = this._items[i], relEndIdx = bound.end - bound.start;
                    if(renderedIndex <= relEndIdx) {
                        return bound.start + renderedIndex;
                    } else {
                        renderedIndex -= relEndIdx + 1// -= bound length
                        ;
                    }
                }
                return -1;
            };
            renderBoundsCollection.prototype.getRenderedIndex = // Maps absolute row (sketch) index to rendered row index
            function (absIndex) {
                var boundIndex = this.hasAbsIndex(absIndex);
                if(boundIndex >= 0) {
                    var capacity = 0;
                    for(var i = 0; i < boundIndex; i++) {
                        var bound = this._items[i];
                        capacity += bound.end - bound.start + 1;
                    }
                    return capacity + (absIndex - this._items[boundIndex].start);
                }
                return -1;
            };
            renderBoundsCollection.prototype.hasAbsIndex = // returns index of the IRenderBound item in the _items array or -1.
            function (absIndex) {
                if(this._items.length) {
                    var idx = this._binSearchByStartVal(absIndex);
                    if(idx >= 0) {
                        return idx;
                    } else {
                        idx = ~idx;
                        if(idx > 0 && absIndex <= this._items[idx - 1].end) {
                            return idx - 1;
                        }
                    }
                }
                return -1;
            };
            renderBoundsCollection.prototype.length = function () {
                return this._items.length;
            };
            renderBoundsCollection.prototype.capacity = function () {
                if(this._capacity === null) {
                    var result = 0;
                    for(var i = 0, len = this._items.length; i < len; i++) {
                        var bound = this._items[i];
                        result += (bound.end - bound.start) + 1;
                    }
                    this._capacity = result;
                }
                return this._capacity;
            };
            renderBoundsCollection.prototype.truncate = function (start, end) {
                this.truncateByStart(start);
                this.truncateByStart(end);
            };
            renderBoundsCollection.prototype.truncateByCount = function (value) {
                var count = 0;
                if(value === 0) {
                    this._items = [];
                } else {
                    for(var i = 0, len = this._items.length; i < len; i++) {
                        var bound = this._items[i];
                        count += (bound.end - bound.start) + 1;
                        if(count >= value) {
                            if(count > value) {
                                bound.end -= count - value;
                            }
                            this._items.splice(i + 1, this._items.length - (i + 1));
                            break;
                        }
                    }
                }
            };
            renderBoundsCollection.prototype.truncateByStart = function (value, pinFirstRemainingBoundToValue) {
                var idx = this._binSearchByStartVal(value), len = this._items.length;
                if(idx < 0) {
                    idx = ~idx;
                    if(idx < len) {
                        if(idx > 0 && this._items[idx - 1].end >= value) {
                            this._items[idx - 1].start = value;
                            this._items.splice(0, idx - 1);
                        } else {
                            if(pinFirstRemainingBoundToValue) {
                                this._items[idx].start = value;
                            }
                            this._items.splice(0, idx);
                        }
                    } else {
                        this._items = [];
                    }
                } else {
                    this._items.splice(0, idx);
                }
            };
            renderBoundsCollection.prototype.truncateByEnd = function (value, pinLastRemainingBoundToValue) {
                // todo
                                var idx = this._binSearchByEndVal(value), len = this._items.length;
                if(idx < 0) {
                    idx = ~idx;
                    if(idx < len) {
                        this._items[idx].end = value;
                        this._items.splice(idx + 1, this._items.length - idx + 1);
                    } else {
                        this._items = [];
                    }
                } else {
                    this._items.splice(idx + 1, this._items.length - idx + 1);
                }
            };
            renderBoundsCollection.prototype.deleteFromTop = function (count) {
                var i = 0, cap = 0;
                for(i = 0; i < this._items.length; i++) {
                    var item = this._items[i];
                    cap += item.end - item.start + 1;
                    if(cap >= count) {
                        break;
                    }
                }
                if(cap >= count) {
                    this._items[i].start = cap - count + 1;
                }
                this._items.splice(0, i);
            };
            renderBoundsCollection.prototype.deleteFromBottom = function (count) {
                // todo: check
                                var i = 0, cap = 0;
                for(i = this._items.length - 1; i >= 0; i--) {
                    var item = this._items[i];
                    cap += item.end - item.start + 1;
                    if(cap >= count) {
                        break;
                    }
                }
                if(cap >= count) {
                    this._items[i].start = cap - count + 1;
                }
                this._items.splice(i, this._items.length - i);
            };
            renderBoundsCollection.prototype._binSearchByStartVal = function (value) {
                var l = 0, u = this._items.length - 1;
                while(l <= u) {
                    var m = (u + l) >> 1, cmp = this._items[m].start - value;
                    if(cmp === 0) {
                        return m;
                    }
                    if(cmp < 0) {
                        l = m + 1;
                    } else {
                        u = m - 1;
                    }
                }
                return ~l;
            };
            renderBoundsCollection.prototype._binSearchByEndVal = function (value) {
                var l = 0, u = this._items.length - 1;
                while(l <= u) {
                    var m = (u + l) >> 1, cmp = this._items[m].end - value;
                    if(cmp < 0) {
                        l = m + 1;
                    } else {
                        if(cmp) {
                            u = m - 1;
                        } else {
                            return m;
                        }
                    }
                }
                return ~l;
            };
            return renderBoundsCollection;
        })();
        grid.renderBoundsCollection = renderBoundsCollection;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="../../../data/src/core.ts"/>
    /// <reference path="../../../data/src/util.ts"/>
    /// <reference path="../../../data/src/errors.ts"/>
    /// <reference path="../../../external/declarations/globalize.d.ts"/>
    (function (data) {
        var $ = jQuery, glob = Globalize;
        /** @ignore */
        function convert(val, fromType, toType, options) {
            var origValue = val;
            options = $.extend({
                nullString: "",
                format: ""
            }, options);
            function getParser(type) {
                options.parser = options.parser || data.defaultParsers[type];
                if(!options.parser && val != null) {
                    data.errors.noParser(type);
                }
                return options.parser;
            }
            fromType = fromType || val != null && typeof val;
            toType = toType || fromType;
            if(!toType) {
                return val;
            }
            if(toType == "string") {
                getParser(fromType);
                if(!options.parser) {
                    return val;
                }
                return options.parser.toStr(val, options.culture, options.format, options.nullString, true);
            }
            getParser(toType);
            if(!options.parser) {
                return val;
            }
            val = options.parser.parse(val, options.culture, options.format, options.nullString, true);
            if(isNaN(val) && val != null && data.util.isNumeric(val)) {
                if(options.ignoreError) {
                    return origValue;
                }
                data.errors.cantConvert(toType, origValue);
            }
            return val;
        }
        data.convert = convert;
        /** @ignore */
        data.defaultParsers = {
            string: {
                parse: // string -> string
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    switch(value) {
                        case null:
                            return null;
                        case nullString:
                            if(convertEmptyStringToNull) {
                                return null;
                            }
                        case undefined:
                        case "&nbsp":
                            return "";
                        default:
                            return "" + value;
                    }
                },
                toStr: // string -> string
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    if(value === null && convertEmptyStringToNull) {
                        return nullString;
                    }
                    return "" + value;
                }
            },
            number: {
                parse: // string/number -> number
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    var type = typeof (value);
                    if(type === "number") {
                        return isNaN(value) ? NaN : value;
                    }
                    if((!value && value !== 0) || (value === "&nbsp;") || (value === nullString && convertEmptyStringToNull)) {
                        return null;
                    }
                    return glob.parseFloat(value, 10, culture.name);
                },
                toStr: // number -> string
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    if(value === null && convertEmptyStringToNull) {
                        return nullString;
                    }
                    return glob.format(value, format || "n", culture.name);
                }
            },
            currency: {
                parse: // string/number -> number
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    var type = typeof (value);
                    if(type === "number") {
                        return isNaN(value) ? NaN : value;
                    }
                    if((!value && value !== 0) || (value === "&nbsp;") || (value === nullString && convertEmptyStringToNull)) {
                        return null;
                    }
                    if(type === "string") {
                        value = value.replace(culture.numberFormat.currency.symbol, "");
                    }
                    return glob.parseFloat(value, 10, culture.name);
                },
                toStr: // number -> string (currency)
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    if(value === null && convertEmptyStringToNull) {
                        return nullString;
                    }
                    return glob.format(value, format || "c", culture.name);
                }
            },
            datetime: {
                parse: // string/datetime -> datetime
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    var match;
                    if(value instanceof Date) {
                        return value;
                    }
                    if(!value || (value === "&nbsp;") || (value === nullString && convertEmptyStringToNull)) {
                        return null;
                    }
                    match = /^\/Date\((\d+)\)\/$/.exec(value);
                    if(match) {
                        return new Date(parseInt(match[1], 10));
                    }
                    var date = glob.parseDate(value, format, culture.name);
                    if(date == null || isNaN(date)) {
                        date = Date.parse(value);
                        date = isNaN(date) ? NaN : new Date(date);
                    }
                    return date;
                },
                toStr: // datetime -> string
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    if(value === null && convertEmptyStringToNull) {
                        return nullString;
                    }
                    return glob.format(value, format || "d", culture.name);
                }
            },
            boolean: {
                parse: // string/bool -> bool
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    var valType = typeof (value);
                    if(valType === "number") {
                        return value != 0;
                    }
                    if(valType === "boolean") {
                        return value;
                    }
                    if(valType === "string") {
                        value = $.trim(value);
                    }
                    if(!value || (value === "&nbsp;") || (value === nullString && convertEmptyStringToNull)) {
                        return null;
                    }
                    switch(value.toLowerCase()) {
                        case "true":
                            return true;
                        case "false":
                            return false;
                    }
                    return NaN;
                },
                toStr: // bool -> string
                function (value, culture, format, nullString, convertEmptyStringToNull) {
                    if(value === null && convertEmptyStringToNull) {
                        return nullString;
                    }
                    return (value) ? "true" : "false";
                }
            }
        };
        function checkGlob(func) {
            return function () {
                if(!glob) {
                    data.util.logError(data.errors.noGlobalize.create().message);
                }
                return func.apply(this, arguments);
            };
        }
        $.each(data.defaultParsers, function (_, parser) {
            parser.parse = parser.parse && checkGlob(parser.parse);
            parser.toStr = parser.toStr && checkGlob(parser.toStr);
        });
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    (function (data) {
        (function (filtering) {
            /// <reference path="../../../data/src/arrayDataView.ts"/>
            /** Provides compilation of the Extended Filtering Format
            *
            * @remarks
            * Some examples of extended filter format:
            *   [{ property: "name", value: "John" }, { property: "age", operator: "<", value: 10 }]
            *   ["or", { property: "name", value: "John" }, { property: "age", operator: "<", value: 10 }]
            *   ["and",
            *      ["or", { property: "name", value: "John" }, { property: "name", operator: "BeginsWith", value: "A" } ],
            *      { property: "age", operator: "<", value: 10 }]
            *   ]
            */
            /** @ignore */
            (function (extended) {
                /** @ignore */
                extended.Connective = {
                    AND: "and",
                    OR: "or"
                };
                function normalizeFilter(filter) {
                    function norm(filter) {
                        var result = [];
                        if(filter.length === 0) {
                            return result;
                        }
                        var connective = extended.Connective.AND;
                        data.util.each(filter, function (i, cond) {
                            if(i == 0 && data.util.isString(cond)) {
                                var lowerConnective = cond.toLowerCase();
                                if(lowerConnective == extended.Connective.AND || lowerConnective == extended.Connective.OR) {
                                    connective = lowerConnective;
                                    return;
                                }
                            }
                            if($.isArray(cond)) {
                                cond = norm(cond);
                                if(!cond) {
                                    return;
                                }
                                if(cond[0] === connective || cond.length == 2) {
                                    cond.shift();
                                    result = result.concat(cond);
                                    return;
                                }
                            } else {
                                var predicate = filtering.normalizeCondition(cond);
                                if(!predicate) {
                                    return;
                                }
                                predicate.property = cond.property;
                                cond = predicate;
                            }
                            result.push(cond);
                        });
                        if(result.length == 0) {
                            return null;
                        } else {
                            result.unshift(connective);
                            return result;
                        }
                    }
                    return norm(filter);
                }
                function compilAsExtended(extendedFilter) {
                    if(!$.isArray(extendedFilter)) {
                        return null;
                    }
                    var result = {
                        isEmpty: true,
                        original: extendedFilter,
                        normalized: normalizeFilter(extendedFilter),
                        func: null
                    };
                    if(result.normalized == null) {
                        result.func = function (x) {
                            return true;
                        };
                    } else {
                        result.isEmpty = false;
                        result.func = function (x) {
                            function check(filter) {
                                var isAnd = filter[0] === extended.Connective.AND, checker = isAnd ? data.util.every : data.util.some;
                                return checker(filter, function (cond, i) {
                                    if(i === 0) {
                                        return isAnd;
                                    }
                                    if($.isArray(cond)) {
                                        return check(cond);
                                    } else {
                                        var value = data.util.getProperty(x, cond.property);
                                        return cond.op.apply(value, cond.value);
                                    }
                                });
                            }
                            return check(result.normalized);
                        };
                    }
                    return result;
                }
                /** @ignore */
                function compile(filter) {
                    return compilAsExtended(filter) || data.filtering.compile(filter);
                }
                extended.compile = compile;
            })(filtering.extended || (filtering.extended = {}));
            var extended = filtering.extended;
        })(data.filtering || (data.filtering = {}));
        var filtering = data.filtering;
    })(wijmo.data || (wijmo.data = {}));
    var data = wijmo.data;
})(wijmo || (wijmo = {}));

var wijmo;
(function (wijmo) {
    /// <reference path="../../../data/src/arrayDataView.ts"/>
    /// <reference path="wijmo.data.filtering.extended.ts"/>
    (function (grid) {
        var $ = jQuery;
        var wijdata = wijmo.data;
        var filterExt = wijdata.filtering.extended;
        // in fact implements IDataView in run-time, but not at compile-time
        /** @ignore */
        var GridDataView = (function () {
            function GridDataView(real) {
                this.real = real;
                this._updatingFilter = false;
                this._overrideFilter();
                this._makeMemberProxies();
            }
            GridDataView.prototype._overrideFilter = function () {
                var _this = this;
                this.filter = wijdata.observable(this.real.filter());
                this.filter.subscribe(function (newValue) {
                    if(_this.real.filter() !== newValue && !_this._updatingFilter) {
                        _this.refresh({
                            filter: newValue
                        });
                    }
                });
                this.real.filter.subscribe(function (newValue) {
                    // Do not update this.filter if it is the same filter we've assigned to the underlying dataView.
                    // Otherwise we may end up replacing a property filter with a function
                    if(newValue !== _this._lastSetFilter) {
                        _this.filter(newValue);
                    }
                });
            };
            GridDataView.prototype.refresh = function (shape, local) {
                if (typeof local === "undefined") { local = false; }
                shape = $.extend({
                }, shape);
                var origFilter = shape.filter;
                shape.filter = this._coerceFilter(shape.filter);
                this._lastSetFilter = shape.filter;
                this._updatingFilter = true;
                try  {
                    if($.isFunction(shape.filter) && !$.isFunction(origFilter)) {
                        // it became a function. It means that the filter was complex
                        this.filter(origFilter);
                    } else {
                        this.filter(shape.filter);
                    }
                }finally {
                    this._updatingFilter = false;
                }
                return this.real.refresh(shape, local);
            };
            GridDataView.prototype._makeMemberProxies = function () {
                var _this = this;
                // make proxy methods for those that are not defined manually
                wijdata.util.each(this.real, function (key, value) {
                    if(!$.isFunction(value) || _this[key] || key.charAt(0) === "_") {
                        return;
                    }
                    _this[key] = $.isFunction(value.subscribe) ? value : function () {
                        return value.apply(_this.real, arguments);
                    };
                });
            };
            GridDataView.create = function create(dataView) {
                return new GridDataView(dataView);
            };
            GridDataView.prototype._convertComplexPropertyFilterToExtendedFilterFormat = function (filter) {
                var result = [];
                $.each(filter, function (prop, condList) {
                    if(!$.isArray(condList)) {
                        condList = [
                            condList
                        ];
                    } else {
                        var connective = wijdata.util.isString(condList[0]) && condList[0].toLowerCase();
                        if(connective === filterExt.Connective.AND || connective === filterExt.Connective.OR) {
                            result.push(condList);
                            return;
                        }
                    }
                    var normCondList = [];
                    $.each(condList, function (_, cond) {
                        var normCond = wijdata.filtering.normalizeCondition(cond);
                        if(normCond) {
                            normCond.property = prop;
                            normCondList.push(normCond);
                        }
                    });
                    if(normCondList.length > 0) {
                        result.push(normCondList);
                    }
                });
                return result.length > 0 ? result : null;
            };
            GridDataView.prototype._coerceFilter = function (filter) {
                if($.isArray(filter)) {
                    // assume extended
                    return filterExt.compile(filter).func;
                } else if(!$.isPlainObject(filter)) {
                    return filter;
                }
                filter = $.extend(true, {
                }, filter);
                var simpleFilter = {
                };
                $.each(filter, function (prop, cond) {
                    if(!$.isArray(cond)) {
                        cond = [
                            cond
                        ];
                    }
                    if(simpleFilter) {
                        var possibleConnective = wijdata.util.isString(cond[0]) && cond[0].toLowerCase();
                        if(cond.length == 1 || cond.length == 2 && (possibleConnective === "and" || possibleConnective === "or")) {
                            simpleFilter[prop] = cond[cond.length - 1];
                            return;
                        }
                    }
                    filter[prop] = cond;
                    simpleFilter = null;
                });
                if(simpleFilter) {
                    return simpleFilter;
                }
                var extendedFilter = this._convertComplexPropertyFilterToExtendedFilterFormat(filter);
                return filterExt.compile(extendedFilter).func;
            };
            GridDataView.prototype._unsafeReplace = function (index, newItem) {
                (this.real).sourceArray[index] = newItem;
                (this.real).local[index] = newItem;
            };
            GridDataView.prototype._unsafeSplice = function (index, count, item) {
                if(arguments.length === 2) {
                    (this.real).sourceArray.splice(index, count);
                    (this.real).local.splice(index, count);
                } else {
                    (this.real).sourceArray.splice(index, count, item);
                    (this.real).local.splice(index, count, item);
                }
            };
            GridDataView.prototype._unsafePush = function (item) {
                (this.real).sourceArray.push(item);
                (this.real).local.push(item);
            };
            return GridDataView;
        })();
        grid.GridDataView = GridDataView;        
    })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));

var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    (function (grid) {
        /** @ignore */
        var koDataView = (function (_super) {
            __extends(koDataView, _super);
            function koDataView(observableArray) {
                this.mObservableArray = observableArray;
                var sourceArray = ko.utils.unwrapObservable(this.mObservableArray);
                        _super.call(this, sourceArray, null);
            }
            koDataView.validSource = function validSource(source) {
                return !!(ko && ko.isObservable(source) && $.isFunction(source.slice));// is there is a better way to detect?
                
            };
            koDataView.prototype.refresh = function (shape, local) {
                if (typeof local === "undefined") { local = false; }
                this.sourceArray = ko.utils.unwrapObservable(this.mObservableArray);
                this.mPlainArray = ko.toJS(this.sourceArray);
                // ** #53562: ensure that pageIndex is within [0; pageCount) range
                var pageSize = shape && shape.pageSize !== undefined ? shape.pageSize : this.pageSize();
                var pageIndex = shape && shape.pageIndex !== undefined ? shape.pageIndex : this.pageIndex();
                if(pageSize > 0 && pageIndex > 0) {
                    var pageCount = wijmo.data.util.pageCount(this.sourceArray.length, pageSize);
                    if(pageIndex >= pageCount) {
                        pageIndex = Math.max(0, pageCount - 1);
                        if(!shape) {
                            shape = {
                            };
                        }
                        shape.pageIndex = pageIndex;
                    }
                }
                // ** #53562: ensure that pageIndex is within[0; pageCount) range
                return _super.prototype.refresh.apply(this, [
                    shape, 
                    local
                ]);
            };
            koDataView.prototype.getPlainSource = function () {
                return this.mPlainArray;
            };
            koDataView.prototype.dispose = function () {
                this.mObservableArray = null;
                this.mPlainArray = null;
                _super.prototype.dispose.apply(this, arguments);
            };
            return koDataView;
        })(wijmo.data.ArrayDataView);
        grid.koDataView = koDataView;        
        //wijmo.data.registerDataViewFactory(observableArray => {
        //	if (wijmo.grid.koDataView.validSource(observableArray)) {
        //		return new koDataView(observableArray);
        //	}
        //});
            })(wijmo.grid || (wijmo.grid = {}));
    var grid = wijmo.grid;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 * ----
 * Credits: Wijmo includes some MIT-licensed software, see copyright notices below.
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/*
* Depends:
*  jquery.ui.core.js
*  jquery.ui.widget.js
*  jquery.ui.position.js
*
*/
$.fn.extend({
    getBounds: function () {
        return $.extend({
        }, $(this).offset(), {
            width: $(this).outerWidth(true),
            height: $(this).outerHeight(true)
        });
    },
    setBounds: function (bounds) {
        $(this).css({
            'left': bounds.left,
            'top': bounds.top
        }).width(bounds.width).height(bounds.height);
        return this;
    },
    getMaxZIndex: function () {
        var max = (($(this).css('z-index') == 'auto') ? 0 : $(this).css('z-index')) * 1;
        $(this).siblings().each(function (i, e) {
            max = Math.max(max, (($(e).css('z-index') == 'auto') ? 0 : $(e).css('z-index')) * 1);
        });
        return Math.max(max, $(this).zIndex());
    }
});
var wijmo;
(function (wijmo) {
    (function (popup) {
        /** @widget */
        var wijpopup = (function (_super) {
            __extends(wijpopup, _super);
            function wijpopup() {
                _super.apply(this, arguments);

            }
            wijpopup.prototype._init = function () {
                this.elementZIndex = this.element.zIndex();
                if(!!this.options.ensureOutermost) {
                    var root = $('form');
                    if(root.length === 0) {
                        root = $(document.body);
                    }
                    this.element.appendTo(root);
                }
                this.element.data('visible.wijpopup', false);
                this.element.css('position', "absolute");
                this.element.position({
                    of: $(document.body)
                });
                this.element.hide();
            };
            wijpopup.prototype._setOption = function (key, value) {
                _super.prototype._setOption.call(this, key, value);
                if(key === 'autoHide') {
                    var visible = this.isVisible();
                    this.hide();
                    if(visible) {
                        this.show();
                    }
                }
            };
            wijpopup.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                _super.prototype.destroy.call(this);
                if(this.isVisible()) {
                    this.hide();
                }
                if($.browser.msie && (parseInt($.browser.version) < 7)) {
                    var jFrame = this.element.data('backframe.wijpopup');
                    if(!jFrame) {
                        jFrame.remove();
                    }
                }
                var self = this;
                this.element.unbind('.wijpopup');
                $.each([
                    "visible", 
                    "backframe", 
                    "animating", 
                    "width"
                ], function (i, prefix) {
                    self.element.removeData(prefix + ".wijpopup");
                });
            };
            wijpopup.prototype.isVisible = /** Determines whether the element is visible. */
            function () {
                return (!!this.element.data('visible.wijpopup') && this.element.is(':visible'));
            };
            wijpopup.prototype.isAnimating = /** @ignore */
            function () {
                return !!this.element.data("animating.wijpopup");
            };
            wijpopup.prototype.show = /** Popups the element.
            *  Position is an optional argument, it is the options object used in jquery.ui.position.
            * @param {?object} position An optional argument, it is the options object used in jquery.ui.position.
            */
            function (position) {
                var self = this;
                this._setPosition(position);
                if(this.isVisible()) {
                    return;
                }
                if(this._trigger('showing') === false) {
                    return;
                }
                if(this.options.autoHide) {
                    window.setTimeout(function () {
                        self._bindDocMouseUpEvent();
                    }, 0);
                }
                var effect = this.options.showEffect || "show";
                var duration = this.options.showDuration || 300;
                var ops = this.options.showOptions || {
                };
                this.element.data("animating.wijpopup", true);
                if($.effects && $.effects.effect[effect]) {
                    this.element.show(effect, ops, duration, $.proxy(this._showCompleted, this));
                } else {
                    this.element[effect]((effect === 'show' ? null : duration), $.proxy(this._showCompleted, this));
                }
                if(!effect || !duration || effect === 'show' || duration <= 0) {
                    this._showCompleted();
                }
            };
            wijpopup.prototype._showCompleted = function () {
                this.element.removeData("animating.wijpopup");
                this.element.data('visible.wijpopup', true);
                this._trigger('shown');
            };
            wijpopup.prototype.showAt = /** Popups the element at specified absolute position related to document.
            * @param {number} x The x coordinate at which to show the popup.
            * @param {number} y The y coordinate at which to show the popup.
            * @example
            *  // set the popup position is "100, 100" that related to document.
            *  $(".selector").wijpopup('showAt', 100, 100);
            */
            function (x, y) {
                this.show({
                    my: //jquery 1.10: offset has removed
                    //my: 'left top',
                    'left+' + x + ' top+' + y,
                    at: 'left top',
                    of: document.body
                });
                //,
                //jquery 1.10: offset has removed
                //offset: '' + x + ' ' + y
                            };
            wijpopup.prototype.hide = /** Hides the element. */
            function () {
                var _this = this;
                if(!this.isVisible()) {
                    return;
                }
                if(this._trigger('hiding') === false) {
                    window.setTimeout(function () {
                        _this._bindDocMouseUpEvent();
                    }, 0);
                    return;
                }
                //$(document).unbind('mouseup.wijpopup');
                var effect = this.options.hideEffect || "hide";
                var duration = this.options.hideDuration || 300;
                var ops = this.options.hideOptions || {
                };
                this.element.data("animating.wijpopup", true);
                if($.effects && $.effects.effect[effect]) {
                    this.element.hide(effect, ops, duration, $.proxy(this._hideCompleted, this));
                } else {
                    this.element[effect]((effect === 'hide' ? null : duration), $.proxy(this._hideCompleted, this));
                }
                if(!effect || !duration || effect === 'hide' || duration <= 0) {
                    this._hideCompleted();
                }
            };
            wijpopup.prototype._hideCompleted = function () {
                if(this.element.data('width.wijpopup') !== undefined) {
                    this.element.width(this.element.data('width.wijpopup'));
                    this.element.removeData('width.wijpopup');
                }
                this.element.unbind('move.wijpopup');
                this.element.removeData("animating.wijpopup");
                if($.browser.msie && (parseInt($.browser.version) < 7)) {
                    var jFrame = this.element.data('backframe.wijpopup');
                    if(jFrame) {
                        jFrame.hide();
                    }
                }
                this._trigger('hidden');
            };
            wijpopup.prototype._onDocMouseUp = // fix the issue 42892, the widget bind mouseup to document widget, and when call hide method, it will
            // unbind the mouseup event, it use namespace to bind/unbind the event. If there are more than one popup
            // widget in a page, when hide one, it will unbind the others's mouseup event will unbind.
            // here use one instead of bind, and if mouse click inside of the element, the event should bind one more time.
            // If use one popup inside another popup, this argument will wrong. so when bind the event, send this to event arguments.
            function (e, self) {
                var srcElement = e.target ? e.target : e.srcElement;
                if(self.isVisible() && !!self.options.autoHide) {
                    if(srcElement != self.element.get(0) && $(srcElement).parents().index(self.element) < 0) {
                        self.hide();
                    } else {
                        this._bindDocMouseUpEvent();
                    }
                }
            };
            wijpopup.prototype._bindDocMouseUpEvent = function () {
                var _this = this;
                var eventPre = '';
                if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                    eventPre = 'wij';
                }
                $(document).one(eventPre + 'mouseup.wijpopup', function (e) {
                    _this._onDocMouseUp(e, _this);
                });
            };
            wijpopup.prototype._onMove = function (e) {
                var jFrame = this.element.data('backframe.wijpopup');
                if(jFrame) {
                    this.element.before(jFrame);
                    jFrame.css({
                        'top': this.element.css('top'),
                        'left': this.element.css('left')
                    });
                }
            };
            wijpopup.prototype._addBackgroundIFrame = function () {
                if($.browser.msie && (parseInt($.browser.version) < 7)) {
                    var jFrame = this.element.data('backframe.wijpopup');
                    if(!jFrame) {
                        jFrame = jQuery('<iframe/>').css({
                            'position': 'absolute',
                            'display': 'none',
                            'filter': 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)'
                        }).attr({
                            'src': 'javascript:\'<html></html>\';',
                            'scrolling': 'no',
                            'frameborder': '0',
                            'tabIndex ': -1
                        });
                        this.element.before(jFrame);
                        this.element.data('backframe.wijpopup', jFrame);
                        this.element.bind('move.wijpopup', $.proxy(this._onMove, this));
                    }
                    jFrame.setBounds(this.element.getBounds());
                    jFrame.css({
                        'display': 'block',
                        'left': this.element.css('left'),
                        'top': this.element.css('top'),
                        'z-index': this.element.css('z-index') - 1
                    });
                }
            };
            wijpopup.prototype._setZIndex = function (index) {
                this.element.css('z-index', index);
                var jFrame = this.element.data('backframe.wijpopup');
                if(jFrame) {
                    jFrame.css('z-index', (this.element.css('z-index')) - 1);
                }
            };
            wijpopup.prototype._setPosition = function (position) {
                var visible = this.element.is(':visible'), of;
                this.element.show();
                this.element.position($.extend({
                }, this.options.position, position ? position : {
                }));
                if(!visible) {
                    this.element.hide();
                }
                if(position) {
                    of = position.of;
                }
                if(!of) {
                    of = this.options.position.of;
                }
                this._addBackgroundIFrame();
                var zIndex = Math.max(1000, this.elementZIndex);
                if(of) {
                    zIndex = Math.max(zIndex, $(of).getMaxZIndex());
                }
                this._setZIndex(zIndex + 10);
                this._trigger('posChanged');
            };
            return wijpopup;
        })(wijmo.JQueryUIWidget);
        popup.wijpopup = wijpopup;        
        var wijpopup_options = (function () {
            function wijpopup_options() {
                /** Determines if the element's parent element is the outermost element.
                * @remarks
                *  If true, the element's parent element will be changed to
                *  the body or outermost form element.
                */
                this.ensureOutermost = false;
                /** Specifies the effect to be used when the popup is shown.
                * @remarks
                *  This allows you to use a different effect when you show the popup
                *  than when you hide the popup.(See also hideEffect.) Possible values
                *  include 'blind', 'clip', 'drop', 'fade', 'fold', 'slide', and 'pulsate'.
                *  See the jQuery UI / Effects page for more information.
                */
                this.showEffect = 'show';
                /** Specifies the object/hash including specific options for the show effect.
                * @type {object}
                * @remarks
                *  See the option parameters used by the jQuery UI show effect for more information.
                * @example
                *       // set the show effect's direction.
                *       $(".selector").wijpopup({ showOptions: {direction: 'up' });
                */
                this.showOptions = {
                };
                /** A value that indicates the number of milliseconds it takes for the
                *  indicated animation effect to completely show the popup.
                * @remarks
                *  This allows you to use a different number of milliseconds when you
                *  show the popup than when you hide the popup.(See also hideDuration.)
                */
                this.showDuration = 300;
                /** Specifies the effect to be used when the popup is hidden.
                * @remarks
                *  This allows you to use a different effect when you show the popup than
                *  when you hide the popup.(See also showEffect.)
                *  Possible values include 'blind', 'clip', 'drop', 'fade', 'fold', 'slide',
                *  and 'pulsate'.See the jQuery UI / Effects page for more information.
                */
                this.hideEffect = 'hide';
                /** Specifies the object/hash including specific options for the hide effect.
                * @remarks
                *  See the option parameters used by the jQuery UI hide effect for more information.
                * @example
                *       // set the hide effect's direction.
                *       $(".selector").wijpopup({ hideOptions: {direction: 'up' });
                */
                this.hideOptions = {
                };
                /** A value that indicates the number of milliseconds it takes for the
                *  indicated animation effect to completely hide the popup.
                * @remarks
                *  This allows you to use a different number of milliseconds when
                *  you show the popup than when you hide the popup.(See also showDuration.)
                */
                this.hideDuration = 100;
                /** Determines whether to automatically hide the popup when clicking outside the element.
                * @remarks
                *  If true, the popup will be automatically hidden when another element is selected.
                *  If false (default), the popup will remain visible until hidden with the hide method.
                */
                this.autoHide = false;
                /** Options for positioning the element, please see jquery.ui.position for possible options.
                * @type {object}
                * @example
                *  // positioning the element, located on "#TextBox1" and up offset is 4
                *  $(".selector").wijpopup({ position:{ of: $('#TextBox1'), offset: '0 4' }});
                */
                this.position = {
                    at: 'left bottom',
                    my: 'left top'
                };
                /** The showing event handler.
                * A function called before the element is shown. Cancellable.
                * @remarks
                *     This is a cancelable event.You can set data.cancel = true to cancel the element to be shown.
                * @event
                */
                this.showing = null;
                /** The shown event handler. A function called after the element is shown.
                * @event
                */
                this.shown = null;
                /** The hiding event handler.
                * A function called before the element is hidden. Cancellable.
                * @remarks
                *     This is a cancelable event. You can set data.cancel = true to cancel the element to be hidden.
                * @event
                * @dataKey {boolean} cancel Cancel the element to be hidden if true.
                */
                this.hiding = null;
                /** The hidden event handler. A function called after the element is hidden.
                * @event
                */
                this.hidden = null;
                /** The posChanged event handler.
                *   A function called when the position of the element is changed.
                * @event
                */
                this.posChanged = null;
            }
            return wijpopup_options;
        })();        
        ;
        wijpopup.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijpopup_options());
        $.wijmo.registerWidget("wijpopup", wijpopup.prototype);
    })(wijmo.popup || (wijmo.popup = {}));
    var popup = wijmo.popup;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 * ----
 * Credits: Wijmo includes some MIT-licensed software, see copyright notices below.
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /// <reference path="../external/declarations/globalize.d.ts"/>
    /*globals window document clearTimeout setTimeout jQuery */
    /*
    * Depends:
    *	jQuery.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jQuery.ui.position.js
    *	jquery.bgiframe-2.1.3-pre.js
    */
    (function (tooltip) {
        "use strict";
        var $ = jQuery, widgetName = "wijtooltip", defaultTooltipKey = "@wijtp@", tipCss = "wijmo-wijtooltip", calloutCssPrefix = tipCss + "-arrow-", parseF = parseFloat, win = window, doc = document, math = Math, max = math.max, oldTipPos = {
        };
        /** @widget*/
        var wijtooltip = (function (_super) {
            __extends(wijtooltip, _super);
            function wijtooltip() {
                _super.apply(this, arguments);

            }
            wijtooltip._tooltips = new Array();
            wijtooltip.prototype._setOption = function (key, value) {
                var self = this, funName = "_set_" + key, oldValue = self.options[key];
                if(key === "controlwidth") {
                    self._setSize("width", value);
                    return;
                }
                if(key === "controlheight") {
                    self._setSize("height", value);
                    return;
                }
                _super.prototype._setOption.call(this, key, value);
                if($.isPlainObject(value)) {
                    self.options[key] = $.extend({
                    }, oldValue, value);
                }
                if(self[funName]) {
                    self[funName](oldValue);
                }
            };
            wijtooltip.prototype._set_cssClass = //fix the issue 21416: cssClass does not show.
            function () {
                var self = this, o = self.options, tooltip = self._tooltipCache._$tooltip;
                if(!tooltip) {
                    return;
                }
                if(!tooltip.hasClass(o.cssClass)) {
                    tooltip.addClass(o.cssClass);
                }
            };
            wijtooltip.prototype._set_content = function (value) {
                var self = this;
                if(self._isAjaxCallback) {
                    self._callbacked = true;
                    self.show();
                    self._callbacked = false;
                } else {
                    self._setText();
                }
            };
            wijtooltip.prototype._create = function () {
                var self = this, o = self.options, element = self.element, id = element && element.attr("id"), describedBy = "", cssClass = "", key = o.group || defaultTooltipKey, tooltip = wijtooltip._getTooltip(key);
                if(tooltip) {
                    tooltip.count++;
                } else {
                    tooltip = self._createTooltip();
                    tooltip.count = 0;
                    wijtooltip._tooltips[key] = tooltip;
                }
                //fix the issue 21416: cssClass does not show.
                cssClass = o.cssClass ? o.cssClass : "";
                if(!tooltip._$tooltip.hasClass(cssClass)) {
                    tooltip._$tooltip.addClass(cssClass);
                }
                o.position.of = self.element;
                self._bindLiveEvents();
                self._tooltipCache = tooltip;
                if(id) {
                    describedBy = tooltip._$tooltip.attr("aria-describedby");
                    describedBy = describedBy === undefined ? "" : describedBy + " ";
                    tooltip._$tooltip.attr("aria-describedby", describedBy + id);
                }
                if(o.controlwidth && o.controlwidth !== "") {
                    self._setSize("width", o.controlwidth);
                }
                if(o.controlheight && o.controlheight !== "") {
                    self._setSize("height", o.controlheight);
                }
            };
            wijtooltip.prototype.destroy = /** Removes the wijtooltip functionality completely.
            * This returns the element back to its pre-init state.
            */
            function () {
                var self = this, element = self.element, key = self.options.group || defaultTooltipKey;
                element.unbind(".tooltip");
                element.attr("title", self._content);
                wijtooltip._removeTooltip(key);
                _super.prototype.destroy.call(this);
            };
            wijtooltip.prototype.widget = /** Returns the wijtooltip element. */
            function () {
                return this._tooltipCache._$tooltip;
            };
            wijtooltip.prototype.show = /** Shows the tooltip */
            function () {
                this.showAt(null);
            };
            wijtooltip.prototype.showAt = /** Shows the tooltip at the specified position
            * @param {object} point A point value that indicates the position that tooltip will be shown.
            * @example
            * //Shows the tooltip at point {x: 100, y: 120}.
            * $("#tooltip").wijtooltip("showAt", {x:100, y:120});
            */
            function (point) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, o = self.options;
                if(!tooltipCache || o.disabled) {
                    return;
                }
                _$tooltip.stop(true, true);
                if(tooltipCache._showAnimationTimer) {
                    clearTimeout(tooltipCache._showAnimationTimer);
                    tooltipCache._showAnimationTimer = null;
                }
                if(tooltipCache._showAtAnimationTimer) {
                    clearTimeout(tooltipCache._showAtAnimationTimer);
                    tooltipCache._showAtAnimationTimer = null;
                }
                if(tooltipCache._hideAnimationTimer) {
                    clearTimeout(tooltipCache._hideAnimationTimer);
                    tooltipCache._hideAnimationTimer = null;
                }
                if(!point) {
                    if(o.ajaxCallback && $.isFunction(o.ajaxCallback) && !self._callbacked) {
                        self._isAjaxCallback = true;
                        o.ajaxCallback.call(self.element);
                        return;
                    }
                    self._setText();
                }
                if(!!o.showDelay) {
                    tooltipCache._showAtAnimationTimer = setTimeout(function () {
                        self._showToolTipHelper(point, _$tooltip);
                    }, o.showDelay);
                } else {
                    self._showToolTipHelper(point, _$tooltip);
                }
            };
            wijtooltip.prototype.hide = /** Hides the tooltip.*/
            function () {
                var self = this, tooltipCache = self._tooltipCache;
                if(!tooltipCache) {
                    return;
                }
                if(tooltipCache._showAnimationTimer) {
                    clearTimeout(tooltipCache._showAnimationTimer);
                    tooltipCache._showAnimationTimer = null;
                }
                if(tooltipCache._showAtAnimationTimer) {
                    clearTimeout(tooltipCache._showAtAnimationTimer);
                    tooltipCache._showAtAnimationTimer = null;
                }
                if(tooltipCache._hideAnimationTimer) {
                    clearTimeout(tooltipCache._hideAnimationTimer);
                    tooltipCache._hideAnimationTimer = null;
                }
                //clearTimeout(tooltip._showAnimationTimer);
                if(!!self.options.hideDelay) {
                    tooltipCache._hideAnimationTimer = setTimeout($.proxy(self._hideTooltip, self), self.options.hideDelay);
                } else {
                    self._hideTooltip();
                }
            };
            wijtooltip.prototype._createTooltip = //begin private methods
            function () {
                var self = this, o = self.options, tooltipCache = new TooltipCache(), _$tooltip = $("<div></div>").addClass(o.wijCSS.tooltip).addClass(o.wijCSS.widget).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerAll), container = $("<div></div>").addClass(o.wijCSS.tooltipContainer), callout = $("<div></div>").addClass(o.wijCSS.content).addClass(o.wijCSS.tooltipPointer).append($("<div></div>").addClass(o.wijCSS.tooltipPointerInner)), title = $("<div></div>").addClass(o.wijCSS.tooltipTitle).addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll), closeBtn = $("<a href='#'></a>").addClass(o.wijCSS.tooltipClose).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
                closeBtn.append($("<span></span>").addClass(o.wijCSS.icon).addClass(o.wijCSS.iconClose)).bind("click", $.proxy(self._onClickCloseBtn, self));
                if(o.closeBehavior !== "sticky") {
                    closeBtn.hide();
                }
                if(!o.showCallout) {
                    callout.hide();
                }
                _$tooltip.append(title).append(closeBtn).append(container).append(callout).css("position", "absolute").attr("role", "tooltip").appendTo("body").hide();
                tooltipCache._$tooltip = _$tooltip;
                tooltipCache._container = container;
                tooltipCache._callout = callout;
                tooltipCache._closeBtn = closeBtn;
                tooltipCache._title = title;
                return tooltipCache;
            };
            wijtooltip.prototype._showToolTipHelper = function (point, _$tooltip) {
                if(point) {
                    var self = this, tooltipCache = self._tooltipCache, calloutPos, offsetX = 0, offsetY = 0, hBorder, vBorder, border, width, height, offset = {
                    }, calloutShape, callout, visible = _$tooltip.is(":visible"), callout = tooltipCache ? tooltipCache._callout : null;
                    if(!callout) {
                        return;
                    }
                    self._setText();
                    oldTipPos = _$tooltip.offset();
                    _$tooltip.offset({
                        left: 0,
                        top: 0
                    }).show();
                    calloutPos = callout.position();
                    offsetX = calloutPos.left;
                    offsetY = calloutPos.top;
                    border = self._getBorder(callout);
                    hBorder = border.left || border.right;
                    vBorder = border.top || border.bottom;
                    width = _$tooltip.width();
                    height = _$tooltip.height();
                    calloutShape = self._getCalloutShape();
                    offset = {
                        "rt": {
                            left: point.x - width - hBorder,
                            top: point.y - offsetY
                        },
                        "rc": {
                            left: point.x - width - hBorder,
                            top: point.y - height / 2
                        },
                        "rb": {
                            left: point.x - width - hBorder,
                            top: point.y - offsetY - vBorder
                        },
                        "lt": {
                            left: point.x + hBorder,
                            top: point.y - offsetY
                        },
                        "lc": {
                            left: point.x + hBorder,
                            top: point.y - height / 2
                        },
                        "lb": {
                            left: point.x + hBorder,
                            top: point.y - offsetY - vBorder
                        },
                        "tl": {
                            left: point.x - offsetX,
                            top: point.y + vBorder
                        },
                        "tc": {
                            left: point.x - width / 2,
                            top: point.y + vBorder
                        },
                        "tr": {
                            left: point.x - offsetX - hBorder,
                            top: point.y + vBorder
                        },
                        "bl": {
                            left: point.x - offsetX,
                            top: point.y - height - vBorder
                        },
                        "bc": {
                            left: point.x - width / 2,
                            top: point.y - height - vBorder
                        },
                        "br": {
                            left: point.x - offsetX - hBorder,
                            top: point.y - height - vBorder
                        },
                        "cc": {
                            left: point.x - width / 2,
                            top: point.y - height / 2
                        }
                    }[calloutShape];
                    calloutShape = self._flipTooltip(offset, calloutShape, border);
                    self._setUnfilledCallout(calloutShape);
                    _$tooltip.offset(offset)//.hide();
                    ;
                    if(!visible) {
                        _$tooltip.hide();
                    }
                    self._calloutShape = calloutShape;
                } else {
                    oldTipPos = _$tooltip.offset();
                    if(this.options.mouseTrailing) {
                        this._setCalloutCss();
                        return;
                    }
                    this._setPosition();
                }
                this._showTooltip();
            };
            wijtooltip.prototype._bindLiveEvents = function () {
                var self = this, o = self.options, element = self.element;
                if(self._content === undefined) {
                    self._content = element.attr("title");
                    element.attr("title", "");
                }
                element.unbind('.tooltip');
                if(o.mouseTrailing) {
                    element.bind("mousemove.tooltip", function (e) {
                        if(o.disabled) {
                            return;
                        }
                        var offset = o.position.offset || "", offsets = offset.split(" ");
                        if(offsets.length === 2) {
                            self.showAt({
                                x: e.pageX + parseInt(offsets[0], 10),
                                y: e.pageY + parseInt(offsets[1], 10)
                            });
                        } else {
                            self.showAt({
                                x: e.pageX,
                                y: e.pageY
                            });
                        }
                    });
                }
                element.bind("mouseout.tooltip", $.proxy(self._hideIfNeeded, self));
                switch(o.triggers) {
                    case "hover":
                        element.bind("mouseover.tooltip", $.proxy(self.show, self));
                        break;
                    case "click":
                        element.bind("click.tooltip", $.proxy(self.show, self));
                        break;
                    case "focus":
                        element.bind("focus.tooltip", $.proxy(self.show, self)).bind("blur.tooltip", $.proxy(self._hideIfNeeded, self));
                        break;
                    case "rightClick":
                        element.bind("contextmenu.tooltip", function (e) {
                            self.show();
                            e.preventDefault();
                        });
                        break;
                }
            };
            wijtooltip.prototype._hideIfNeeded = function () {
                var self = this, o = self.options, closeBehavior = o.closeBehavior;
                if(closeBehavior === "sticky" || o.modal || closeBehavior === "none" || o.disabled) {
                    return;
                }
                self.hide();
            };
            wijtooltip.prototype._flipTooltip = function (pos, calloutShape, calloutBorder) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, bound = {
                    width: _$tooltip.width(),
                    height: _$tooltip.height()
                }, flipCallout = self._flipCallout(pos, bound, calloutShape), flip = flipCallout && flipCallout.flip, width, height;
                if(!tooltipCache || !flipCallout || (!flip.h && !flip.v)) {
                    return flipCallout.calloutShape;
                }
                width = _$tooltip.width();
                height = _$tooltip.height();
                if(flip.h === "l") {
                    pos.left -= (width + calloutBorder.right * 2) + 1;
                } else if(flip.h === "r") {
                    pos.left += (width + calloutBorder.left * 2) + 1;
                } else if(flip.v === "t") {
                    pos.top -= (height + calloutBorder.bottom * 2) + 1;
                } else if(flip.v === "b") {
                    pos.top += (height + calloutBorder.top * 2) + 1;
                }
                return flipCallout.calloutShape;
            };
            wijtooltip.prototype._flipCallout = function (pos, bound, calloutShape) {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache._$tooltip, flip = {
                    h: false,
                    v: false
                }, jqWin = $(win), collision = (o.position.collision || "flip").split(" ");
                if(collision.length === 1) {
                    collision[1] = collision[0];
                }
                if(!tooltipCache || (collision[0] !== "flip" && collision[1] !== "flip")) {
                    return {
                        flip: flip,
                        calloutShape: null
                    };
                }
                if(collision[0] === "flip") {
                    if(pos.left < 0 || pos.left + bound.width > jqWin.width() + jqWin.scrollLeft()) {
                        flip.h = true;
                    }
                }
                if(collision[0] === "flip") {
                    if(pos.top < 0 || pos.top + bound.height > jqWin.height() + jqWin.scrollTop()) {
                        flip.v = true;
                    }
                }
                //fix the issue 21386, calloutShape undefind
                if(o.showCallout) {
                    if(flip.h) {
                        if(calloutShape.indexOf('l') > -1) {
                            calloutShape = calloutShape.replace(/l/, 'r');
                            flip.h = "l";
                        } else if(calloutShape.indexOf('r') > -1) {
                            calloutShape = calloutShape.replace(/r/, 'l');
                            flip.h = "r";
                        }
                    }
                    if(flip.v) {
                        if(calloutShape.indexOf('t') > -1) {
                            calloutShape = calloutShape.replace(/t/, 'b');
                            flip.v = "t";
                        } else if(calloutShape.indexOf('b') > -1) {
                            calloutShape = calloutShape.replace(/b/, 't');
                            flip.v = "b";
                        }
                    }
                    if(flip.h || flip.v) {
                        self._removeCalloutCss();
                        _$tooltip.addClass(calloutCssPrefix + calloutShape);
                    }
                }
                return {
                    flip: flip,
                    calloutShape: calloutShape
                };
            };
            wijtooltip.prototype._set_position = //methods for options setters
            function (oldValue) {
                var self = this, o = self.options, val = o.position;
                if(o.showCallout) {
                    if(oldValue.my !== val.my || oldValue.at !== val.at) {
                        self._setPosition();
                    }
                    self._setCalloutOffset(true);
                }
                //fix the issue 21467.
                self._setText();
            };
            wijtooltip.prototype._set_showCallout = function () {
                var self = this, tooltipCache = self._tooltipCache, callout = tooltipCache ? tooltipCache._callout : null;
                if(!tooltipCache || !callout) {
                    return;
                }
                if(self.options.showCallout) {
                    self._setCalloutCss();
                    callout.show();
                } else {
                    callout.hide();
                }
            };
            wijtooltip.prototype._set_closeBehavior = function () {
                var self = this, tooltipCache = self._tooltipCache, closeBtn = tooltipCache ? tooltipCache._closeBtn : null;
                if(closeBtn) {
                    closeBtn[self.options.closeBehavior === "sticky" ? "show" : "hide"]();
                }
            };
            wijtooltip.prototype._set_triggers = function () {
                this._bindLiveEvents();
            };
            wijtooltip.prototype._set_mouseTrailing = function () {
                this._bindLiveEvents();
            };
            wijtooltip.prototype._getCalloutShape = //end of methods for options setters.
            function () {
                var self = this, position = self.options.position, makeArr = //makeArr = function (items) {
                //	return $.map(items, function (item) {
                //		return item.substr(0, 1);
                //	});
                //},
                function (items) {
                    return $.makeArray($.map(items, function (item) {
                        return item.substr(0, 1);
                    }));
                }, myItems = makeArr(position.my.split(" ")), atItems = makeArr(position.at.split(" ")), shape = [];
                if(myItems.length === 2) {
                    shape = myItems;
                }
                if(myItems[0] === atItems[0]) {
                    if((myItems[1] === 't' && atItems[1] === 'b') || (myItems[1] === 'b' && atItems[1] === 't')) {
                        shape.reverse();
                    }
                } else if(atItems[0] === 'c') {
                    shape.reverse();
                }
                if(shape[0] === 'c') {
                    shape.reverse();
                }
                return shape.join("");
            };
            wijtooltip.prototype._setCalloutCss = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, cssName = "", calloutShape = "", isTouchEnabled = $.support.isTouchEnabled;
                if(!o.showCallout && !isTouchEnabled) {
                    return;
                }
                self._removeCalloutCss();
                calloutShape = self._getCalloutShape();
                cssName = calloutCssPrefix + calloutShape;
                if(_$tooltip) {
                    _$tooltip.addClass(cssName);
                }
                return calloutShape;
            };
            wijtooltip.prototype._removeCalloutCss = function () {
                var tooltipCache = this._tooltipCache, _$tooltip;
                if(tooltipCache) {
                    _$tooltip = tooltipCache._$tooltip;
                    $.each([
                        "tl", 
                        "tc", 
                        "tr", 
                        "bl", 
                        "bc", 
                        "br", 
                        "rt", 
                        "rc", 
                        "rb", 
                        "lt", 
                        "lc", 
                        "lb", 
                        "cc"
                    ], function (idx, compass) {
                        var cssName = calloutCssPrefix + compass;
                        if(_$tooltip.hasClass(cssName)) {
                            _$tooltip.removeClass(cssName);
                            return false;
                        }
                    });
                }
            };
            wijtooltip.prototype._getBorder = function (element) {
                var obj = {
                };
                $.each([
                    "top", 
                    "right", 
                    "left", 
                    "bottom"
                ], function (idx, compass) {
                    obj[compass] = parseF(element.css("border-" + compass + "-width"));
                });
                return obj;
            };
            wijtooltip.prototype._setPosition = function () {
                var self = this, o = self.options, position = o.position, my = position.my, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, isHidden = _$tooltip.is(":hidden"), calloutShape = self._setCalloutCss(), arrCalloutShape = calloutShape ? calloutShape.split('') : null, offset = [
                    0, 
                    0
                ], callout = //sOffset = "",
                tooltipCache._callout, border, top, left, right, bottom, bound = {
                    width: _$tooltip.width(),
                    height: _$tooltip.height()
                }, flipCallout, flip, isTouchEnabled = $.support.isTouchEnabled;
                if(isHidden) {
                    _$tooltip.show();
                }
                _$tooltip.css({
                    left: 0,
                    top: 0
                });
                if(o.showCallout) {
                    border = self._getBorder(callout);
                    left = parseF(callout.css("left"));
                    top = parseF(callout.css("top"));
                    right = parseF(callout.css("right"));
                    bottom = parseF(callout.css("bottom"));
                    switch(arrCalloutShape[0]) {
                        case "l":
                            offset[0] = border.right;
                            break;
                        case "r":
                            offset[0] = -border.left;
                            break;
                        case "b":
                            offset[1] = bottom;
                            break;
                        case "t":
                            offset[1] = -top;
                            break;
                    }
                    switch(arrCalloutShape[1]) {
                        case "t":
                            offset[1] = -top;
                            break;
                        case "b":
                            offset[1] = bottom;
                            break;
                        case "r":
                            offset[0] = right;
                            break;
                        case "l":
                            offset[0] = -left;
                            break;
                    }
                    //sOffset = offset.join(" ");
                                    }
                if(isTouchEnabled && isTouchEnabled()) {
                    switch(arrCalloutShape[0]) {
                        case "l":
                            offset[0] = offset[0] + 30;
                            break;
                        case "r":
                            offset[0] = offset[0] - 30;
                            break;
                        case "b":
                            offset[1] = offset[1] - 30;
                            break;
                        case "t":
                            offset[1] = offset[1] + 30;
                            break;
                    }
                    switch(arrCalloutShape[1]) {
                        case "t":
                            offset[1] = offset[1] + 30;
                            break;
                        case "b":
                            offset[1] = offset[1] - 30;
                            break;
                        case "r":
                            offset[0] = offset[0] - 30;
                            break;
                        case "l":
                            offset[0] = offset[0] + 30;
                            break;
                    }
                    //sOffset = offset.join(" ");
                                    }
                //"left+10 top+-10"
                if(position.my.indexOf(" ") > -1) {
                    my = position.my.split(" ")[0] + "+" + offset[0] + " " + position.my.split(" ")[1] + "+" + offset[1];
                } else {
                    my = position.my + "+" + offset[0] + " " + position.my + "+" + offset[1];
                }
                _$tooltip.position({
                    my: my,
                    at: position.at,
                    of: position.of,
                    collision: //offset: sOffset, collision: "none none"
                    "none none"
                });
                flipCallout = self._flipCallout(_$tooltip.offset(), bound, calloutShape);
                flip = flipCallout.flip;
                if(flip.h || flip.v) {
                    _$tooltip.css({
                        left: 0,
                        top: 0
                    });
                    _$tooltip.position({
                        my: my,
                        at: position.at,
                        of: position.of,
                        collision: //offset: sOffset, collision: position.collision
                        position.collision
                    });
                }
                if(o.showCallout) {
                    self._setUnfilledCallout(calloutShape);
                }
                self._calloutShape = calloutShape;
                if(isHidden) {
                    _$tooltip.hide();
                }
            };
            wijtooltip.prototype._setCalloutOffset = function (showCalloutAnimation) {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, callout = tooltipCache && tooltipCache._callout, calloutShape = self._calloutShape, horizontal = false, offset = o.position.offset, value = "", offsetItems = [], calloutAnimation = o.calloutAnimation;
                if(!callout) {
                    return;
                }
                if(!offset || offset.length === 0) {
                    return;
                }
                callout.stop(true, true);
                $.each([
                    "tr", 
                    "tc", 
                    "tl", 
                    "bl", 
                    "bc", 
                    "br"
                ], function (idx, compass) {
                    if(calloutShape === compass) {
                        horizontal = true;
                        return false;
                    }
                });
                if(offset) {
                    offsetItems = offset.split(" ");
                    if(offsetItems.length === 2) {
                        value = horizontal ? offsetItems[0] : offsetItems[1];
                    } else if(offsetItems.length === 1) {
                        value = offsetItems[0];
                    }
                }
                //when 'position.offset' is set "none none",
                //the properties left and top of the 'callout' element in the tooltip
                //need to be removed.
                if(offsetItems && offsetItems.length === 2 && offsetItems[0] === "none" && offsetItems[1] === "none") {
                    callout.css("left", "").css("top", "");
                } else if(value === "none") {
                    callout.css(horizontal ? "left" : "top", "");
                } else if(value !== "") {
                    if(showCalloutAnimation && !showCalloutAnimation.disabled) {
                        if(horizontal) {
                            callout.animate({
                                left: value
                            }, calloutAnimation.duration, calloutAnimation.easing);
                        } else {
                            callout.animate({
                                top: value
                            }, calloutAnimation.duration, calloutAnimation.easing);
                        }
                    } else {
                        callout.css(horizontal ? "left" : "top", value);
                    }
                }
            };
            wijtooltip.prototype._setUnfilledCallout = function (calloutShape) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, callout = tooltipCache && tooltipCache._callout, innerCallout = callout && callout.children(), arrCalloutSharp = calloutShape.split(''), borderColor = _$tooltip ? _$tooltip.css("background-color") : "";
                if(!innerCallout) {
                    return;
                }
                innerCallout.css({
                    "border-left-color": "",
                    "border-top-color": "",
                    "border-bottom-color": "",
                    "border-right-color": ""
                });
                if(!self.options.calloutFilled) {
                    switch(arrCalloutSharp[0]) {
                        case "l":
                            innerCallout.css("border-right-color", borderColor);
                            break;
                        case "t":
                            innerCallout.css("border-bottom-color", borderColor);
                            break;
                        case "r":
                            innerCallout.css("border-left-color", borderColor);
                            break;
                        case "b":
                            innerCallout.css("border-top-color", borderColor);
                            break;
                    }
                }
            };
            wijtooltip.prototype._showTooltip = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, showAnimation, animations, curPos;
                if(!tooltipCache) {
                    return;
                }
                if(self._trigger("showing", null, self) === false) {
                    //fixed the issue 41097, when the tooltip is visible, hide the tooltip.
                    if(_$tooltip.is(":visible")) {
                        _$tooltip.hide();
                    }
                    return;
                }
                self._showModalLayer();
                _$tooltip.css("z-index", 99999);
                if($.fn.wijshow) {
                    animations = {
                        show: true,
                        context: _$tooltip
                    };
                    showAnimation = $.extend({
                    }, o.animation, o.showAnimation);
                    if(_$tooltip.is(":visible")) {
                        curPos = _$tooltip.offset();
                        _$tooltip.offset(oldTipPos);
                        $.extend(animations, {
                            pos: curPos
                        });
                        showAnimation.animated = "tooltipSlide";
                    }
                    _$tooltip.wijshow(showAnimation, wijtooltip.animations, animations, null, function () {
                        self._trigger("shown");
                    });
                } else {
                    _$tooltip.show();
                    self._trigger("shown");
                }
                self._setCalloutOffset(false);
            };
            wijtooltip.prototype._hideTooltip = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, hideAnimation = $.extend({
                }, o.animation, o.hideAnimation), animations;
                if(!tooltipCache) {
                    return;
                }
                if(self._trigger("hiding", null, self) === false) {
                    return;
                }
                self._hideModalLayer();
                if($.fn.wijhide) {
                    animations = {
                        show: false,
                        context: _$tooltip
                    };
                    _$tooltip.wijhide(hideAnimation, wijtooltip.animations, animations, null, function () {
                        self._trigger("hidden");
                        _$tooltip.css("z-index", "");
                    });
                } else {
                    _$tooltip.hide();
                    self._trigger("hidden");
                    _$tooltip.css("z-index", "");
                }
            };
            wijtooltip.prototype._getContent = function (content) {
                var obj = {
                    data: ""
                }, retValue;
                if($.isFunction(content)) {
                    retValue = content.call(this.element, obj);
                    if(obj.data !== "") {
                        return obj.data;
                    } else {
                        return retValue;
                    }
                } else if(window[content] && $.isFunction(window[content])) {
                    // if window[content/title] is a function, then get the
                    // function value.
                    retValue = window[content].call(this.element, obj);
                    if(obj.data !== "") {
                        return obj.data;
                    } else {
                        return retValue;
                    }
                }
                return content;
            };
            wijtooltip.prototype._setText = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, content = "", title = "", jqTitle = tooltipCache ? tooltipCache._title : null;
                if(!tooltipCache) {
                    return;
                }
                content = self._getContent(o.content);
                content = content === "" ? self._content : content;
                tooltipCache._container.html(content);
                title = self._getContent(o.title);
                if(title !== "") {
                    jqTitle.html(title).show();
                } else {
                    jqTitle.hide();
                }
            };
            wijtooltip.prototype._showModalLayer = function () {
                var self = this, o = self.options, modalLayer = null;
                if(self.options.modal) {
                    modalLayer = $("<div>").addClass(o.wijCSS.overlay).css("z-index", 99000).width(self._getDocSize("Width")).height(self._getDocSize("Height")).appendTo("body");
                    $(window).bind("resize.wijtooltip", function () {
                        modalLayer.width(self._getDocSize("Width")).height(self._getDocSize("Height"));
                    });
                    self._tooltipCache._modalLayer = modalLayer;
                }
            };
            wijtooltip.prototype._hideModalLayer = function () {
                var self = this, modalLayer = self._tooltipCache._modalLayer;
                if(modalLayer) {
                    modalLayer.css("z-index", "").remove();
                    $(window).unbind("resize.wijtooltip");
                }
            };
            wijtooltip.prototype._getDocSize = function (name) {
                var scrollValue, offsetValue, de = "documentElement", body = "body";
                // handle IE 6
                if($.browser.msie && parseFloat($.browser.version) < 9) {
                    scrollValue = max(doc[de]["scroll" + name], doc[body]["scroll" + name]);
                    offsetValue = max(doc[de]["offset" + name], doc[body]["offset" + name]);
                    return (scrollValue < offsetValue ? ($(win)[name.toLowerCase()]() + 'px') : scrollValue + 'px');
                } else {
                    return $(doc)[name.toLowerCase()]() + 'px';
                }
            };
            wijtooltip.prototype._setSize = function (key, val) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null;
                if(_$tooltip) {
                    _$tooltip.css(key, val);
                }
            };
            wijtooltip.prototype._onClickCloseBtn = //begin event handler methods
            function (e) {
                this.hide();
                e.preventDefault();
            };
            wijtooltip.animations = {
                fade: function (options, additions) {
                    options = $.extend({
                        duration: 300,
                        easing: "swing"
                    }, options, additions);
                    options.context.stop(true, true).animate(options.show ? {
                        opacity: 'show'
                    } : {
                        opacity: 'hide'
                    }, options);
                },
                tooltipSlide: function (options, additions) {
                    options = $.extend({
                        duration: 300,
                        easing: "swing"
                    }, options, additions);
                    options.context.stop(true, true).animate({
                        left: options.pos.left,
                        top: options.pos.top
                    }, options);
                }
            };
            wijtooltip._getTooltip = function _getTooltip(key) {
                return wijtooltip._tooltips[key];
            };
            wijtooltip._removeTooltip = function _removeTooltip(key) {
                var tooltipCache = wijtooltip._tooltips[key], _$tooltip = tooltipCache ? tooltipCache._$tooltip : null;
                if(tooltipCache) {
                    tooltipCache.count--;
                    if(tooltipCache.count <= 0) {
                        _$tooltip.remove();
                        wijtooltip._tooltips[key] = null;
                    }
                    //tooltip = null;
                                    }
            };
            return wijtooltip;
        })(wijmo.wijmoWidget);
        tooltip.wijtooltip = wijtooltip;        
        //#endregion
        var wijtooltip_options = (function () {
            function wijtooltip_options() {
                /** Selector option for auto self initialization.
                * This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijtooltip')";
                /** tooltip css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijCSS = {
                    tooltip: "wijmo-wijtooltip",
                    tooltipContainer: "wijmo-wijtooltip-container",
                    tooltipPointer: "wijmo-wijtooltip-pointer",
                    tooltipPointerInner: "wijmo-wijtooltip-pointer-inner",
                    tooltipTitle: "wijmo-wijtooltip-title",
                    tooltipClose: "wijmo-wijtooltip-close"
                };
                /** @ignore */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-a",
                    stateDefault: "ui-btn ui-btn-a",
                    stateHover: "ui-btn-down-a",
                    stateActive: "ui-btn-down-a"
                };
                /** Sets the tooltip's content.
                * @type {string|function}
                * @remarks  The value can be a string, html code, or a function.
                * If it is a function, then the content will be
                * the function's return value.
                * @example
                * //Set tooltip's content to "my content".
                * $(".selector").wijtooltip("option", "content", "my content").
                */
                this.content = '';
                /** Specifies a value that sets the tooltip's title.
                * @type {string|function}
                * @remarks The value can be a string, html code, or a function.
                * If it is a function, then the title will be the function's return value.
                * @example
                * //Set tooltip's title to "my title".
                * $(".selector").wijtooltip("option", "title", "my title");
                */
                this.title = '';
                /** Determines how to close the tooltip. Behaviors include auto or sticky.
                * @remarks Options: "auto", "none" and "sticky".
                */
                this.closeBehavior = 'auto';
                /** If true, then the tooltip moves with the mouse. */
                this.mouseTrailing = false;
                /** Sets the event that will cause the tooltip to appear.
                * @remarks Options: "hover", "click", "focus", "rightClick", "custom".
                */
                this.triggers = 'hover';
                /** Sets the tooltip's position mode in relation to the 'relativeTo',
                * 'offsetX', and 'offsetY' properties.
                * @remarks See jQuery ui position for more details
                * http://api.jqueryui.com/position/ .
                */
                this.position = {
                    my: 'left bottom',
                    at: 'right top',
                    offset: null
                };
                /** Determines whether to show the callout element. */
                this.showCallout = true;
                /** Sets the showAnimation and hideAnimation options if they are  not specified individually.
                * @remarks This should be an object value. Possible values include:
                * 'animated', 'duration', and 'easing'. You can create custom easing
                * animations using jQuery UI Easings.
                * This property works with jQuery animation.
                */
                this.animation = {
                    animated: 'fade',
                    duration: 500,
                    easing: null
                };
                /** Determines the animation effect that will be shown.
                * @remarks This should be an object value. Possible values include:
                * 'animated', 'duration', and 'easing'. You can create custom easing
                * animations using jQuery UI Easings.
                * This property works with jQuery animation.
                */
                this.showAnimation = {
                };
                /** Determines whether the animation effect can be seen.
                * @remarks This should be an object value. Possible values include:
                * 'animated', 'duration', and 'easing'. You can create custom easing
                * animations using jQuery UI Easings.
                * This property works with jQuery animation.
                */
                this.hideAnimation = {
                };
                /** Determines the length of the delay before the tooltip appears. */
                this.showDelay = 150;
                /** Determines the length of the delay before the tooltip disappears. */
                this.hideDelay = 150;
                /** Sets the callout's offset changing animation.
                * @remarks This should be an object value. Possible values include:
                * 'disabled', 'duration', and 'easing'.
                */
                this.calloutAnimation = {
                    duration: 1000,
                    disabled: false,
                    easing: null
                };
                /** Determines the callout's class style.
                * If true, then the callout triangle is filled.
                */
                this.calloutFilled = false;
                /** A value that indicates whether to show the modal tooltip. */
                this.modal = false;
                /** Determines which group the tooltip belongs to.
                * @type {string}
                */
                this.group = null;
                /** A function that defines a callback when AJAX is uesd to set the
                * content property.
                * @type {function}
                * @remarks In AJAX's complete callback method, the user set the callback
                * data to the content option.
                */
                this.ajaxCallback = null;
                /** Trigegred before showing the tooltip.
                * Use return false; to cancel the event and stop showing the tooltip.
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.showing = null;
                /** Triggered once the tooltip has shown.
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.shown = null;
                /** Triggered before hiding the tooltip.If data.cancel is
                * set to true, then the tooltip is no longer hidden
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.hiding = null;
                /** Triggered once the tooltip is hidden.
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.hidden = null;
                /** A value that indicates whether to set user-defined class. */
                this.cssClass = '';
                /** Determines the width of the tooltip. */
                this.controlwidth = null;
                /** Determines the height of the tooltip. */
                this.controlheight = null;
            }
            return wijtooltip_options;
        })();        
        ;
        //#region options
        wijtooltip.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijtooltip_options());
        //#endregion
        $.wijmo.registerWidget(widgetName, wijtooltip.prototype);
    })(wijmo.tooltip || (wijmo.tooltip = {}));
    var tooltip = wijmo.tooltip;
})(wijmo || (wijmo = {}));
/** @ignore */
var TooltipCache = (function () {
    function TooltipCache() { }
    return TooltipCache;
})();
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 * ----
 * Credits: Wijmo includes some MIT-licensed software, see copyright notices below.
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijpopup/jquery.wijmo.wijpopup.ts"/>
    /// <reference path="../external/declarations/globalize.d.ts"/>
    /*globals jQuery,window,document*/
    /*
    * Depends:
    *     jquery.ui.core.js
    *     jquery.ui.widget.js
    *     jquery.wijmo.wijtooltip.js
    */
    (function (calendar) {
        "use strict";
        var $ = jQuery, widgetName = "wijcalendar";
        var wijDayType = {
            general: /** A general day cell, denotes nothing.*/
            0,
            weekEnd: /** A weekend day cell.*/
            1,
            otherMonth: /** A day cell with a date blongs to other month.*/
            2,
            outOfRange: /** A day cell with a date out of the minDate/maxDate range.*/
            4,
            today: /** A day cell represents today.*/
            8,
            custom: /** A custom day cell, which has CSS class 'wijmo-wijcalendar-customday' associated.*/
            16,
            disabled: /** A day cell in disabled state.*/
            32,
            selected: /** A day cell in selected state.*/
            64,
            gap: /** A blank day cell.*/
            128
        };
        /** @widget */
        var wijcalendar = (function (_super) {
            __extends(wijcalendar, _super);
            function wijcalendar() {
                _super.apply(this, arguments);

                this._touchRangeSelect = false;
            }
            wijcalendar.prototype._create = function () {
                var self = this, wijCSS = self.options.wijCSS;
                self._originalStyle = self.element.attr("style");
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                // Add for parse date options for jUICE. D.H
                if($.isFunction(window["wijmoASPNetParseOptions"])) {
                    wijmoASPNetParseOptions(this.options);
                }
                this.element.addClass("wijmo-wijcalendar  " + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll).attr('role', 'grid');
                this._previewWrapper(this.options.allowPreview);
                this.element.data('preview.wijcalendar', false);
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        self.refresh();
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijcalendar");
                }
            };
            wijcalendar.prototype._init = function () {
                if(this.options.popupMode) {
                    var po = {
                        autoHide: !!this.options.autoHide,
                        showing: undefined,
                        shown: undefined,
                        hiding: undefined,
                        hidden: undefined
                    }, self = this;
                    if(this.options.beforePopup) {
                        po.showing = this.options.beforePopup;
                    }
                    if(this.options.afterPopup) {
                        po.shown = this.options.afterPopup;
                    }
                    if(this.options.beforeClose) {
                        po.hiding = this.options.beforeClose;
                    }
                    po.hidden = function (data) {
                        self.element.removeData("lastdate.wijcalendar");
                        if(self.options.afterClose) {
                            self.options.afterClose.call(data);
                        }
                    };
                    this.element.wijpopup(po);
                } else {
                    this.element.removeAttr("style");
                    if(this._originalStyle) {
                        this.element.attr("style", this._originalStyle);
                    }
                }
                this._getSelectedDates();
                this._getDisabledDates();
                this._resetWidth();
                this.refresh();
                //this.element.width(this.element.width() + 2);
                            };
            wijcalendar.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var wijCSS = this.options.wijCSS;
                //$.wijmo.widget.prototype.destroy.apply(this, arguments);
                _super.prototype.destroy.call(this);
                this.close();
                this._unbindEvents();
                this.element.html("");
                this.element.removeClass("wijmo-wijcalendar " + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll + " " + wijCSS.datepickerMulti).removeAttr('role');
                var self = this;
                $.each([
                    "preview", 
                    "disableddates", 
                    "selecteddates", 
                    "dragging", 
                    "lastdate", 
                    "animating"
                ], function (i, prefix) {
                    self.element.removeData(prefix + ".wijcalendar");
                });
                this._previewWrapper(false);
            };
            wijcalendar.prototype._setOption = function (key, value) {
                //$.wijmo.widget.prototype._setOption.apply(this, arguments);
                if(key === "disabled" && value === this.options.disabled) {
                    return;
                }
                _super.prototype._setOption.call(this, key, value);
                switch(key) {
                    case "showWeekDays":
                    case "showWeekNumbers":
                    case "showTitle":
                    case "showOtherMonthDays":
                    case "selectionMode":
                        this.unSelectAll();
                        this._resetWidth();
                        this.refresh();
                        break;
                    case "culture":
                        this.refresh();
                        break;
                    case "allowPreview":
                        this._previewWrapper(value);
                        this.refresh();
                        break;
                    case "monthCols":
                        this._resetWidth();
                        this.refresh();
                        break;
                    case "monthRows":
                        if(this._myGrid) {
                            this._myGrid = undefined;
                        }
                        break;
                    case "autoHide":
                        this.element.wijpopup({
                            autoHide: this.options.autoHide
                        });
                        break;
                    case "selectedDates":
                        this._getSelectedDates().setDates(value);
                        this.refresh();
                        break;
                    case "disabledDates":
                        this._getDisabledDates().setDates(value);
                        this.refresh();
                        break;
                    case "displayDate":
                        this.refresh();
                        break;
                    case "allowQuickPick":
                        this.refresh();
                        break;
                    case "disabled":
                        if(value) {
                            this._unbindEvents();
                        } else {
                            //some classes are not added to some elements when disabled is true,
                            //so invoke this._bindEvents method is not enough.
                            this.refresh();
                        }
                }
            };
            wijcalendar.prototype._previewWrapper = function (add) {
                if(add) {
                    if(!this.element.parent().hasClass('wijmo-wijcalendar-preview-wrapper')) {
                        this.element.wrap("<div class='wijmo-wijcalendar-preview-wrapper" + " " + this.options.wijCSS.helperClearFix + "'></div>");
                    }
                } else {
                    if(this.element.parent().hasClass('wijmo-wijcalendar-preview-wrapper')) {
                        this.element.unwrap();
                    }
                }
            };
            wijcalendar.prototype._isRTL = function () {
                return !!this._getCulture(null).isRTL;
            };
            wijcalendar.prototype.refresh = /** Refreshes the calendar.*/
            function () {
                if(this._myGrid) {
                    this._myGrid = undefined;
                }
                this.element.empty().append(this._createCalendar());
                this.element[(this._isRTL() ? 'add' : 'remove') + 'Class'](this.options.wijCSS.datepickerRtl);
                if(!this.options.showTitle) {
                    this.element.addClass("wijmo-wijcalendar-notitle");
                } else {
                    this.element.removeClass("wijmo-wijcalendar-notitle");
                }
                this._bindEvents();
            };
            wijcalendar.prototype.refreshDate = /** Refereshes a single date on the calendar.
            * @param {Date} date The date to be refreshed.
            */
            function (date) {
                if(!this._monthViews) {
                    return;
                }
                if(date < this._groupStartDate || date > this._groupEndDate) {
                    return;
                }
                $.each(this._monthViews, function () {
                    this._refreshDate(date);
                });
            };
            wijcalendar.prototype.getDisplayDate = /** Gets the valid display date.*/
            function () {
                var d = this.options.displayDate ? this.options.displayDate : new Date();
                if(wijDateOps.isSameDate(d, new Date(1900, 0, 1))) {
                    d = new Date();
                }
                return d;
            };
            wijcalendar.prototype.getSelectedDate = /** Gets the currently selected date.*/
            function () {
                var dates = this.options.selectedDates;
                return (!dates || dates.length === 0) ? null : dates[0];
            };
            wijcalendar.prototype.selectDate = /** Selects the specified date.
            * @param {Date} date The date to be selected.
            */
            function (date) {
                date = new Date(date);
                if(this._getDisabledDates().contains(date)) {
                    return false;
                }
                if(date < this.options.minDate || date > this.options.maxDate) {
                    return false;
                }
                this._getSelectedDates().add(date);
                this.refreshDate(date);
                return true;
            };
            wijcalendar.prototype.unSelectDate = /** Clears any selection from the specified date.
            * @param {Date} date The date to be removed from the selectedDates collection.
            */
            function (date) {
                date = new Date(date);
                if(this._getDisabledDates().contains(date)) {
                    return false;
                }
                if(date < this.options.minDate || date > this.options.maxDate) {
                    return false;
                }
                this._getSelectedDates().remove(date);
                this.refreshDate(date);
                return true;
            };
            wijcalendar.prototype.unSelectAll = /** Clears any selections from dates on the calendar, removing them from the selectedDates collection.*/
            function () {
                var dates = this.options.selectedDates, i;
                if(dates && dates.length > 0) {
                    this._getSelectedDates().clear();
                    for(i = 0; i < dates.length; i++) {
                        this.refreshDate(dates[i]);
                    }
                }
            };
            wijcalendar.prototype._slideToDate = function (date) {
                if(wijDateOps.isSameMonth(this.getDisplayDate(), date)) {
                    return;
                }
                var visible = this.element.is(":visible");
                if(!visible) {
                    this.options.displayDate = date;
                } else {
                    if(this._trigger('beforeSlide') === false) {
                        return;
                    }
                    if(this._isSingleMonth()) {
                        this._playSlideAnimation(date);
                    } else {
                        this._playMmSlideAnimation(date);
                    }
                }
            };
            wijcalendar.prototype.isPopupShowing = /** Determines whether the calendar is in the pop-up state.*/
            function () {
                return !!this.options.popupMode ? this.element.wijpopup('isVisible') : false;
            };
            wijcalendar.prototype.popup = /** Pops up the calendar at specifies position.
            * @param {Object} position  A jQuery Position plugin that indicates the position in which to pop up the calendar.
            *                    Please see "http://jqueryui.com/demos/position/" for details of the parameter.
            */
            function (position) {
                this._myGrid = undefined;
                this.refresh();
                this.element.data('dragging.wijcalendar', false);
                if(this.element.data("wijmo-wijpopup")) {
                    this.element.wijpopup('show', position);
                }
            };
            wijcalendar.prototype.popupAt = /** Pops up the calendar at the specified X and Y coordinates in the document.
            * @param {number} x X offset.
            * @param {number} y Y offset.
            */
            function (x, y) {
                this._myGrid = undefined;
                this.refresh();
                this.element.data('dragging.wijcalendar', false);
                if(this.element.data("wijmo-wijpopup")) {
                    this.element.wijpopup('showAt', x, y);
                }
            };
            wijcalendar.prototype.close = /** Closes the calendar if it is in the pop-up state.*/
            function () {
                if(this.isPopupShowing()) {
                    this.element.wijpopup('hide');
                }
            };
            wijcalendar.prototype._getCulture = function (name) {
                return Globalize.findClosestCulture(name || this.options.culture);
            };
            wijcalendar.prototype._getDates = function (token) {
                var name = token.toLowerCase() + ".wijcalendar", dates = this.element.data(name);
                if(dates === undefined) {
                    dates = new wijDateCollection(this, token);
                    this.element.data(name, dates);
                }
                return dates;
            };
            wijcalendar.prototype._getDisabledDates = function () {
                return this._getDates('disabledDates');
            };
            wijcalendar.prototype._getSelectedDates = function () {
                return this._getDates('selectedDates');
            };
            wijcalendar.prototype._onDayDragStart = function (e) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            };
            wijcalendar.prototype._onDayMouseDown = function (e) {
                e.preventDefault();
                e.stopPropagation();
                var o = this.options, self = this, date, args, selected = false, selDates = o.selectedDates, exist = false, dates = [];
                if(e.which !== 1) {
                    if(e.which === 0) {
                        this._onTouchstart(e);
                    }
                    return false;
                }
                if($.browser.msie) {
                    if(parseFloat($.browser.version) >= 10) {
                        if(e.originalEvent.pointerType) {
                            if(e.originalEvent.pointerType === 2 || e.originalEvent.pointerType === "touch") {
                                this._onTouchstart(e);
                                return false;
                            }
                        } else if(e.originalEvent.originalEvent && e.originalEvent.originalEvent.pointerType) {
                            if(e.originalEvent.originalEvent.pointerType === 2 || e.originalEvent.originalEvent.pointerType === "touch") {
                                this._onTouchstart(e);
                                return false;
                            }
                        }
                    }
                }
                date = this._getCellDate(e.currentTarget);
                if(date === undefined) {
                    return false;
                }
                if(!o.selectionMode.day) {
                    return false;
                }
                args = {
                    date: date
                };
                if(this._trigger("beforeSelect", null, args) === false) {
                    return false;
                }
                if(!o.selectionMode.days || (!e.metaKey && !e.shiftKey && !e.ctrlKey)) {
                    this.unSelectAll();
                }
                if(!!o.selectionMode.days) {
                    if(e.shiftKey && this.element.data("lastdate.wijcalendar")) {
                        this._selectRange(this.element.data("lastdate.wijcalendar"), date, null);
                        selected = true;
                    } else {
                        if(e.ctrlKey) {
                            this.element.data("lastdate.wijcalendar", date);
                            $.each(selDates, function (i, d) {
                                if(date.getFullYear() === d.getFullYear() && date.getMonth() === d.getMonth() && date.getDate() === d.getDate()) {
                                    exist = true;
                                    return false;
                                }
                            });
                            if(exist) {
                                this.unSelectDate(date);
                            } else {
                                this.selectDate(date);
                            }
                            selDates = o.selectedDates;
                            $.each(selDates, function (i, d) {
                                dates.push(new Date(d));
                            });
                            this._trigger('selectedDatesChanged', null, {
                                dates: dates
                            });
                            selected = true;
                        }
                    }
                }
                if(!selected) {
                    this.element.data("lastdate.wijcalendar", date);
                    selected = this.selectDate(date);
                    this._trigger('selectedDatesChanged', null, {
                        dates: [
                            date
                        ]
                    });
                }
                if(selected) {
                    this._trigger('afterSelect', null, args);
                    if(!!o.selectionMode.days) {
                        this.element.data('dragging.wijcalendar', true);
                        $(document.body).one("mouseup." + this.widgetName, function () {
                            self.element.data('dragging.wijcalendar', false);
                        });
                    }
                }
                return false;
            };
            wijcalendar.prototype._onMouseUp = function (e) {
                e.preventDefault();
                e.stopPropagation();
                //var self = this;
                this.element.data('dragging.wijcalendar', false);
                return false;
            };
            wijcalendar.prototype._onDayClicked = function (e) {
                var date = this._getCellDate(e.currentTarget);
                if(date === undefined) {
                    return false;
                }
                if(!this.options.selectionMode.day) {
                    return false;
                }
                if(this.isPopupShowing()) {
                    this.close();
                } else {
                    if($(e.currentTarget).hasAllClasses(this.options.wijCSS.datepickerOtherMonth)) {
                        this._slideToDate(date);
                    }
                }
                return false;
            };
            wijcalendar.prototype._onDayMouseEnter = function (e) {
                $(e.currentTarget).attr('state', 'hover');
                this._refreshDayCell(e.currentTarget);
                if(!!this.element.data('dragging.wijcalendar')) {
                    var date = this._getCellDate(e.currentTarget);
                    if(date === undefined) {
                        return;
                    }
                    this.unSelectAll();
                    this._selectRange(this.element.data("lastdate.wijcalendar"), date, true);
                }
            };
            wijcalendar.prototype._onDayMouseLeave = function (e) {
                $(e.currentTarget).attr('state', 'normal');
                this._refreshDayCell(e.currentTarget);
            };
            wijcalendar.prototype._onTouchstart = function (e) {
                this._touchStartTime = new Date();
            };
            wijcalendar.prototype._onTouchend = function (e) {
                e.preventDefault();
                e.stopPropagation();
                var touchEndTime = new Date(), timeDiff = touchEndTime - this._touchStartTime, o = this.options, self = this, date, args, selDates = o.selectedDates, exist = false, dates = [];
                this.element.data('dragging.wijcalendar', false);
                if($.browser.msie) {
                    if(parseFloat($.browser.version) >= 10) {
                        if(e.originalEvent.pointerType) {
                            if(e.originalEvent.pointerType !== 2 && e.originalEvent.pointerType !== "touch") {
                                return false;
                            }
                        } else if(e.originalEvent.originalEvent.pointerType) {
                            if(e.originalEvent.originalEvent.pointerType !== 2 && e.originalEvent.originalEvent.pointerType !== "touch") {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    }
                } else if(e.which !== 0) {
                    return false;
                }
                date = this._getCellDate(e.currentTarget);
                if(date === undefined) {
                    return false;
                }
                if(!o.selectionMode.day) {
                    return false;
                }
                args = {
                    date: date
                };
                if(this._trigger("beforeSelect", null, args) === false) {
                    return false;
                }
                $.each(selDates, function (i, d) {
                    if(date.getFullYear() === d.getFullYear() && date.getMonth() === d.getMonth() && date.getDate() === d.getDate()) {
                        exist = true;
                        return false;
                    }
                });
                if(!this._touchRangeSelect && timeDiff >= 750) {
                    this.element.data("lastdate.wijcalendar", date);
                    if(exist) {
                        if(!!o.selectionMode.days) {
                            this.unSelectDate(date);
                        }
                    } else {
                        if(!o.selectionMode.days) {
                            this.unSelectAll();
                        } else {
                            this._touchRangeSelect = true;
                        }
                        this.selectDate(date);
                    }
                    selDates = o.selectedDates;
                    $.each(selDates, function (i, d) {
                        dates.push(new Date(d));
                    });
                    if(selDates.length > 0) {
                        this._trigger('selectedDatesChanged', null, {
                            dates: dates
                        });
                    }
                } else {
                    if(!o.selectionMode.days) {
                        this.unSelectAll();
                        this._touchRangeSelect = false;
                    }
                    if(!this._touchRangeSelect) {
                        this.unSelectAll();
                        this.element.data("lastdate.wijcalendar", date);
                        this.selectDate(date);
                        this._trigger('selectedDatesChanged', null, {
                            dates: [
                                date
                            ]
                        });
                    } else {
                        if(timeDiff >= 750) {
                            if(!!o.selectionMode.days) {
                                this.element.data("lastdate.wijcalendar", date);
                                if(exist) {
                                    this.unSelectDate(date);
                                    this._touchRangeSelect = false;
                                } else {
                                    this.selectDate(date);
                                }
                                selDates = o.selectedDates;
                                $.each(selDates, function (i, d) {
                                    dates.push(new Date(d));
                                });
                                this._trigger('selectedDatesChanged', null, {
                                    dates: dates
                                });
                            }
                        }
                        if(timeDiff < 750 && this.element.data("lastdate.wijcalendar")) {
                            this._selectRange(this.element.data("lastdate.wijcalendar"), date, null);
                            if(this._touchRangeSelect) {
                                this._touchRangeSelect = false;
                            }
                        }
                    }
                }
                this._trigger('afterSelect', null, args);
                this._touchStartTime = null;
                return false;
            };
            wijcalendar.prototype._selectRange = function (start, end, bymouse) {
                if(start !== undefined && start !== new Date(1900, 1, 1)) {
                    var minDate = start, maxDate = end, selDates = [];
                    if(start > end) {
                        maxDate = start;
                        minDate = end;
                    }
                    while(true) {
                        if(minDate > maxDate) {
                            break;
                        }
                        this.selectDate(minDate);
                        selDates[selDates.length] = minDate;
                        minDate = wijDateOps.addDays(minDate, 1);
                    }
                    if(!bymouse) {
                        this.element.removeData("lastdate.wijcalendar");
                    }
                    this._trigger('selectedDatesChanged', null, {
                        dates: selDates
                    });
                } else {
                    this.selectDate(start);
                    this._trigger('selectedDatesChanged', null, {
                        dates: [
                            start
                        ]
                    });
                }
                return true;
            };
            wijcalendar.prototype._getCellDate = function (c) {
                var d = $(c).attr('date');
                return (d === undefined) ? d : new Date(d);
            };
            wijcalendar.prototype._getParentTable = function (c) {
                var parents = $(c).parents('table');
                return (parents.length === 0) ? undefined : parents.get(0);
            };
            wijcalendar.prototype._initMonthSelector = function (ms) {
                if($(ms).data('cells') !== undefined) {
                    return;
                }
                var tokens = ms.id.split('_'), monthID, monthTable, cells = [], i, j, td, dt, row;
                if(tokens[tokens.length - 1] !== 'ms') {
                    throw Error["create"]('not a monthview');
                }
                monthID = (tokens.slice(0, tokens.length - 1)).join('_');
                monthTable = this._getParentTable(ms);
                if(monthTable) {
                    if(monthTable.id !== monthID) {
                        throw Error["create"]('not a monthview');
                    }
                    for(i = 0; i < monthTable.rows.length; i++) {
                        row = monthTable.rows[i];
                        for(j = 0; j < row.cells.length; j++) {
                            td = row.cells[j];
                            if(td) {
                                dt = $(td).attr('daytype');
                                if(dt !== undefined) {
                                    if($(td).find('a').hasAllClasses(this.options.wijCSS.prioritySecondary) === false) {
                                        if(this._isSelectable(parseInt(dt, 10))) {
                                            cells[cells.length] = td;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                $(ms).data('cells', cells);
            };
            wijcalendar.prototype._onMonthSelectorClicked = function (e) {
                this._initMonthSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
                this.element.removeData("lastdate.wijcalendar");
                this.unSelectAll();
                for(i = 0; i < cells.length; i++) {
                    c = cells[i];
                    d = $(c).attr('date');
                    if(d !== undefined) {
                        date = new Date(d);
                        this.selectDate(date);
                        selDates[selDates.length] = date;
                    }
                }
                this._trigger('selectedDatesChanged', null, {
                    dates: selDates
                });
                if(this.isPopupShowing()) {
                    this.close();
                }
                return false;
            };
            wijcalendar.prototype._onMonthSelectorMouseEnter = function (e) {
                this._initMonthSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseEnter(e);
                }
            };
            wijcalendar.prototype._onMonthSelectorMouseLeave = function (e) {
                this._initMonthSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseLeave(e);
                }
            };
            wijcalendar.prototype._initWeekDaySelector = function (wd) {
                if($(wd).data('cells') !== undefined) {
                    return;
                }
                var tokens = wd.id.split('_'), colIndex, monthID, monthTable, cells = [], i = 0, tr, td, dt;
                if(tokens[tokens.length - 2] !== 'cs') {
                    throw Error["create"]('not a column');
                }
                colIndex = parseInt(tokens[tokens.length - 1], 10);
                monthID = (tokens.slice(0, tokens.length - 2)).join('_');
                monthTable = this._getParentTable(wd);
                if(monthTable) {
                    if(monthTable.id !== monthID) {
                        throw Error["create"]('not a column');
                    }
                    /** update for issue 29995
                    if (!this._isSingleMonth()) {
                    i++;
                    }*/
                    if(this.options.showWeekDays) {
                        i++;
                    }
                    for(; i < monthTable.rows.length; i++) {
                        tr = monthTable.rows[i];
                        if(colIndex < tr.cells.length) {
                            td = tr.cells[colIndex];
                            if(td) {
                                dt = $(td).attr('daytype');
                                if(dt !== undefined) {
                                    if($(td).find('a').hasAllClasses(this.options.wijCSS.prioritySecondary) === false) {
                                        if(this._isSelectable(parseInt(dt, 10))) {
                                            cells[cells.length] = td;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                $(wd).data('cells', cells);
            };
            wijcalendar.prototype._onWeekDayClicked = function (e) {
                this._initWeekDaySelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
                this.unSelectAll();
                for(i = 0; i < cells.length; i++) {
                    c = $(cells[i]);
                    d = c.attr('date');
                    if(d !== undefined) {
                        date = new Date(d);
                        this.selectDate(date);
                        selDates[selDates.length] = date;
                    }
                }
                this._trigger('selectedDatesChanged', null, {
                    dates: selDates
                });
                if(this.isPopupShowing()) {
                    this.close();
                }
                return false;
            };
            wijcalendar.prototype._onWeekDayMouseEnter = function (e) {
                this._initWeekDaySelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseEnter(e);
                }
            };
            wijcalendar.prototype._onWeekDayMouseLeave = function (e) {
                this._initWeekDaySelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseLeave(e);
                }
            };
            wijcalendar.prototype._initWeekNumberSelector = function (wn) {
                if($(wn).data('cells') !== undefined) {
                    return;
                }
                var tokens = wn.id.split('_'), rowIndex, monthID, monthTable, cells = [], tr, i, td, dt;
                if(tokens[tokens.length - 2] !== 'rs') {
                    throw Error["create"]('not a row');
                }
                rowIndex = parseInt(tokens[tokens.length - 1], 10);
                monthID = (tokens.slice(0, tokens.length - 2)).join('_');
                monthTable = this._getParentTable(wn);
                if(monthTable) {
                    if(monthTable.id !== monthID) {
                        throw Error["create"]('not a row');
                    }
                    tr = monthTable.rows[rowIndex];
                    if(tr) {
                        i = 0;
                        if(this.options.showWeekNumbers) {
                            i++;
                        }
                        for(; i < tr.cells.length; i++) {
                            td = tr.cells[i];
                            if(td) {
                                dt = $(td).attr('daytype');
                                if(dt !== undefined) {
                                    if($(td).find('a').hasAllClasses(this.options.wijCSS.prioritySecondary) === false) {
                                        if(this._isSelectable(parseInt(dt, 10))) {
                                            cells[cells.length] = td;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                $(wn).data('cells', cells);
            };
            wijcalendar.prototype._onWeekNumberClicked = function (e) {
                this._initWeekNumberSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
                this.unSelectAll();
                for(i = 0; i < cells.length; i++) {
                    c = $(cells[i]);
                    d = c.attr('date');
                    if(d !== undefined) {
                        date = new Date(d);
                        this.selectDate(date);
                        selDates[selDates.length] = date;
                    }
                }
                this._trigger('selectedDatesChanged', null, {
                    dates: selDates
                });
                if(this.isPopupShowing()) {
                    this.close();
                }
                return false;
            };
            wijcalendar.prototype._onWeekNumberMouseEnter = function (e) {
                this._initWeekNumberSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseEnter(e);
                }
            };
            wijcalendar.prototype._onWeekNumberMouseLeave = function (e) {
                this._initWeekNumberSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseLeave(e);
                }
            };
            wijcalendar.prototype._isAnimating = function () {
                return !!this.element.data('animating.wijcalendar');
            };
            wijcalendar.prototype._onPreviewMouseEnter = function (e) {
                if(!!this.element.data('previewContainer')) {
                    return;
                }
                if(this._isAnimating()) {
                    return;
                }
                var btn = $(e.currentTarget), btnId = btn.attr('id'), mainDate = this.getDisplayDate(), wijCSS = this.options.wijCSS, months = this.options.monthCols * this.options.monthRows, previewContainer = $('<div/>');
                if(btnId === undefined) {
                    return;
                }
                if(btnId === "prevPreview") {
                    months = -months;
                }
                this.options.displayDate = wijDateOps.addMonths(mainDate, months);
                this.element.data('preview.wijcalendar', true);
                previewContainer.appendTo(document.body);
                previewContainer.hide();
                previewContainer.addClass('wijmo-wijcalendar ' + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll);
                previewContainer.append(this._createCalendar());
                this.options.displayDate = mainDate;
                this.element.data('preview.wijcalendar', false);
                this._createMonthViews();
                previewContainer.wijpopup({
                    showEffect: 'slide',
                    showOptions: {
                        direction: (btnId === 'prevPreview' ? 'right' : 'left')
                    },
                    hideEffect: 'slide',
                    hideOptions: {
                        direction: (btnId === 'prevPreview' ? 'right' : 'left')
                    }
                });
                previewContainer.wijpopup('show', {
                    my: (btnId === 'prevPreview' ? 'right top' : 'left top'),
                    at: (btnId === 'prevPreview' ? 'left top' : 'right top'),
                    of: btn
                });
                this.element.data('previewContainer', previewContainer);
            };
            wijcalendar.prototype._onPreviewMouseLeave = function (e) {
                var btn = $(e.currentTarget), btnId = btn.attr('id'), previewContainer = this.element.data('previewContainer'), self = this;
                if(btnId === undefined) {
                    return;
                }
                if(previewContainer) {
                    if(previewContainer.wijpopup('isAnimating')) {
                        window.setTimeout(function () {
                            self._onPreviewMouseLeave(e);
                        }, 200);
                    } else {
                        previewContainer.wijpopup('hide');
                        this.element.removeData('previewContainer');
                    }
                }
            };
            wijcalendar.prototype._resetWidth = function () {
                if(!this._myGrid) {
                    this.element.css('height', '');
                    if(this.options.monthCols > 1) {
                        this.element.css('width', 17 * this.options.monthCols + 'em');
                        this.element.addClass(this.options.wijCSS.datepickerMulti);
                    } else {
                        this.element.css('width', '');
                        this.element.removeClass(this.options.wijCSS.datepickerMulti);
                    }
                }
            };
            wijcalendar.prototype._playMmSlideAnimation = function (toDate) {
                var w = this.element.width(), h = this.element.height(), date = this.getDisplayDate(), curContent, newContent, goNext, direction = this.options.direction || 'horizontal', calendar = this, curContentAniOpts, newContentAniOpts;
                this.element.height(h);
                this.element.wrapInner("<div class='wijmo-wijcalendar-multi-aniwrapper'></div>");
                curContent = this.element.find('>:first-child').width(w).height(h);
                newContent = curContent.clone(false);
                newContent.hide();
                this.options.displayDate = toDate;
                this._createMonthViews();
                newContent.empty().append(this._createMonthGroup());
                newContent.appendTo(this.element);
                goNext = toDate > date;
                this.element.data('animating.wijcalendar', true);
                if($.effects) {
                    curContent.effect('slide', {
                        mode: 'hide',
                        direction: direction === 'horizontal' ? (goNext ? 'left' : 'right') : (goNext ? 'up' : 'down'),
                        easing: this.options.easing || 'easeOutBack',
                        duration: this.options.duration
                    }, function () {
                        curContent.remove();
                    });
                    newContent.effect('slide', {
                        direction: direction === 'horizontal' ? (goNext ? 'right' : 'left') : (goNext ? 'down' : 'up'),
                        easing: this.options.easing || 'easeOutBack',
                        duration: this.options.duration
                    }, function () {
                        while(newContent.parent().is('.wijmo-wijcalendar-multi-aniwrapper')) {
                            newContent.parent().replaceWith(newContent);
                        }
                        newContent.replaceWith(newContent.contents());
                        calendar.element.height('');
                        calendar._bindEvents();
                        calendar.element.data('animating.wijcalendar', false);
                        calendar._trigger('afterSlide');
                    });
                } else {
                    if(direction === 'horizontal') {
                        curContentAniOpts = {
                            width: 0
                        };
                        newContentAniOpts = {
                            width: '100%'
                        };
                    } else {
                        curContentAniOpts = {
                            height: 0
                        };
                        newContentAniOpts = {
                            height: '100%'
                        };
                    }
                    curContent.animate(curContentAniOpts, this.options.duration, //this.options.easing || 'easeOutBack',
                    null, function () {
                        curContent.remove();
                    });
                    newContent.animate(newContentAniOpts, this.options.duration, null, //this.options.easing || 'easeOutBack',
                    function () {
                        while(newContent.parent().is('.wijmo-wijcalendar-multi-aniwrapper')) {
                            newContent.parent().replaceWith(newContent);
                        }
                        newContent.replaceWith(newContent.contents());
                        calendar.element.height('');
                        calendar._bindEvents();
                        calendar.element.data('animating.wijcalendar', false);
                        calendar._trigger('afterSlide');
                    });
                }
            };
            wijcalendar.prototype._playSlideAnimation = function (toDate) {
                if(!this._isSingleMonth()) {
                    return;
                }
                var self = this, date = this.getDisplayDate(), wijCSS = self.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, slideContainer, yearStep = 1, direction = this.options.direction || 'horizontal', goNext = toDate > date, months = [], w, h, wrapperAniOpts;
                if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    wrapper = curTable.parent();
                } else {
                    //wrapper = $.effects.createWrapper(curTable).css({ overflow: 'hidden' });
                    wrapper = $.createWrapper(curTable).css({
                        overflow: 'hidden'
                    });
                    wrapper.removeClass(wijCSS.effectsWrapper);
                    wrapper.addClass('wijmo-wijcalendar-aniwrapper');
                }
                if(wrapper.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    slideContainer = wrapper.parent();
                } else {
                    //slideContainer = $.effects.createWrapper(wrapper)
                    //	.css({ overflow: 'hidden' });
                    slideContainer = $.createWrapper(wrapper).css({
                        overflow: 'hidden'
                    });
                    slideContainer.removeClass(wijCSS.effectsWrapper);
                    slideContainer.addClass('wijmo-wijcalendar-aniwrapper');
                }
                if(this._myGrid) {
                    switch(this._myGrid.gridType) {
                        case "month":
                            yearStep = 1;
                            break;
                        case "year":
                            yearStep = 10;
                            break;
                        case "decade":
                            yearStep = 100;
                            break;
                    }
                }
                months[months.length] = toDate;
                w = curTable.outerWidth();
                h = curTable.outerHeight();
                if(direction === 'horizontal') {
                    curTable.width(w).css('float', goNext ? 'left' : 'right');
                    wrapper.width((months.length + 1) * w);
                    wrapper.css('left', goNext ? 0 : -months.length * w).css('position', 'absolute');
                } else {
                    wrapper.width(w);
                    wrapper.css('top', goNext ? 0 : -months.length * h).css('position', 'absolute');
                    wrapper.height((months.length + 1) * h);
                }
                $.each(months, function (index, date) {
                    if(self._myGrid === undefined) {
                        var mv = new wijMonthView(self, date), $view = self._customize(mv.getHtml(true));
                        if(direction === 'horizontal') {
                            $view.width(w).css('float', goNext ? 'left' : 'right').appendTo(wrapper);
                        } else {
                            $view.appendTo(wrapper);
                        }
                    } else {
                        if(direction === 'horizontal') {
                            $(self._myGrid.getHtml(date, true)).width(w).height(h).css('float', goNext ? 'left' : 'right').appendTo(wrapper);
                        } else {
                            $(self._myGrid.getHtml(date, true)).height(h).appendTo(wrapper);
                        }
                    }
                });
                this.options.displayDate = toDate;
                if(this._myGrid === undefined) {
                    this._createMonthViews();
                }
                this._refreshTitle();
                this.element.data('animating.wijcalendar', true);
                if($.effects) {
                    wrapper.effect('slide', {
                        mode: 'hide',
                        direction: direction === 'horizontal' ? (goNext ? 'left' : 'right') : (goNext ? 'up' : 'down'),
                        easing: this.options.easing || 'easeOutBack',
                        distance: (direction === 'horizontal' ? w : h) * months.length,
                        duration: this.options.duration
                    }, function () {
                        curTable = wrapper.children(':last');
                        while(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                            curTable.parent().replaceWith(curTable);
                        }
                        curTable.css({
                            'float': '',
                            'width': ''
                        });
                        self._bindEvents();
                        self.element.data('animating.wijcalendar', false);
                        self._trigger('afterSlide');
                    });
                } else {
                    if(direction === 'horizontal') {
                        wrapperAniOpts = {
                            width: 0
                        };
                    } else {
                        wrapperAniOpts = {
                            height: 0
                        };
                    }
                    wrapper.animate(wrapperAniOpts, this.options.duration, null, //this.options.easing || 'easeOutBack',
                    function () {
                        curTable = wrapper.children(':last');
                        while(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                            curTable.parent().replaceWith(curTable);
                        }
                        curTable.css({
                            'float': '',
                            'width': ''
                        });
                        self._bindEvents();
                        self.element.data('animating.wijcalendar', false);
                        self._trigger('afterSlide');
                    });
                }
            };
            wijcalendar.prototype._onTitleClicked = function () {
                if(!this.options.allowQuickPick || !this._isSingleMonth()) {
                    return;
                }
                if(this._isAnimating()) {
                    return;
                }
                if(this._myGrid === undefined) {
                    this._myGrid = new wijMyGrid(this);
                } else {
                    switch(this._myGrid.gridType) {
                        case "month":
                            this._myGrid.gridType = "year";
                            break;
                        case "year":
                            this._myGrid.gridType = "decade";
                            break;
                        case "decade":
                            return;
                    }
                }
                this._refreshTitle();
                this.element.width(this.element.width()).height(this.element.height());
                var wijCSS = this.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, container, nextTable, w = curTable.outerWidth(), h = curTable.outerHeight(), selIndex, row, col, toWidth, toHeight, toBounds, calendar = this;
                if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    wrapper = curTable.parent();
                } else {
                    //wrapper = $.effects.createWrapper(curTable).css({ overflow: 'hidden' })
                    wrapper = $.createWrapper(curTable).css({
                        overflow: 'hidden'
                    }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper');
                }
                if(wrapper.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    container = wrapper.parent();
                } else {
                    //container = $.effects.createWrapper(wrapper).css({ overflow: 'hidden' })
                    container = $.createWrapper(wrapper).css({
                        overflow: 'hidden'
                    }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').width(w).height(h);
                }
                nextTable = $(this._myGrid.getHtml(true)).css({
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    opacity: 0
                }).appendTo(container).height(h);
                selIndex = this._myGrid.getSelectedIndex();
                row = Math.floor(selIndex / 4);
                col = selIndex - (row * 4);
                toWidth = w / 4;
                toHeight = h / 3;
                toBounds = {
                    left: toWidth * col,
                    top: toHeight * row,
                    width: toWidth,
                    height: toHeight
                };
                curTable.width("100%").height("100%");
                wrapper.css({
                    border: 'solid 1px #cccccc'
                });
                this.element.data('animating.wijcalendar', true);
                if($.effects) {
                    wrapper.effect('size', {
                        to: toBounds,
                        duration: this.options.duration || 500
                    }, function () {
                        wrapper.remove();
                    });
                } else {
                    wrapper.animate(toBounds, this.options.duration || 500, null, function () {
                        wrapper.remove();
                    });
                }
                nextTable.animate({
                    opacity: 1
                }, this.options.duration || 500, null, function () {
                    nextTable.css({
                        position: '',
                        top: '',
                        left: '',
                        filter: ''
                    });
                    while(nextTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                        nextTable.parent().replaceWith(nextTable);
                    }
                    calendar._bindEvents();
                    calendar.element.data('animating.wijcalendar', false);
                });
            };
            wijcalendar.prototype._onMyGridClicked = function (e) {
                if(this._myGrid === undefined) {
                    return false;
                }
                if(this._isAnimating()) {
                    return false;
                }
                var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10), value = parseInt(cell.attr('value'), 10), wijCSS = this.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, container, w, h, bounds, $content, date, mv, nextTable, calendar = this;
                if(this._myGrid.gridType !== "month") {
                    if(!index || index === 11) {
                        return false;
                    }
                }
                if(!cell.hasAllClasses(wijCSS.stateActive)) {
                    this._myGrid.select(index, value);
                }
                if(this._myGrid.gridType === "decade") {
                    this._myGrid.gridType = "year";
                } else {
                    if(this._myGrid.gridType === "year") {
                        this._myGrid.gridType = "month";
                    } else {
                        this._myGrid = undefined;
                    }
                }
                this._refreshTitle();
                w = curTable.outerWidth();
                h = curTable.outerHeight();
                if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    container = curTable.parent();
                } else {
                    //container = $.effects.createWrapper(curTable).css({ overflow: 'hidden' })
                    container = $.createWrapper(curTable).css({
                        overflow: 'hidden'
                    }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').width(w).height(h);
                }
                bounds = $.extend({
                }, cell.position(), {
                    width: cell.width(),
                    height: cell.height()
                });
                if(this._myGrid === undefined) {
                    this._createMonthViews();
                    date = this.getDisplayDate();
                    mv = this._getMonthView(date);
                    $content = this._customize(mv.getHtml(true));
                } else {
                    $content = $(this._myGrid.getHtml(true));
                }
                nextTable = $content.height(h).appendTo(container);
                //wrapper = $.effects.createWrapper(nextTable).css({ overflow: 'hidden' })
                wrapper = $.createWrapper(nextTable).css({
                    overflow: 'hidden'
                }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').css($.extend(bounds, {
                    border: 'solid 1px #cccccc',
                    position: 'absolute'
                }));
                this.element.data('animating.wijcalendar', true);
                wrapper.animate({
                    left: 0,
                    top: 0,
                    width: w,
                    height: h
                }, this.options.duration || 500, null, function () {
                    nextTable.css("width", "");
                });
                curTable.animate({
                    opacity: 0
                }, this.options.duration || 500, null, function () {
                    curTable.remove();
                    while(nextTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                        nextTable.parent().replaceWith(nextTable);
                    }
                    if(calendar._myGrid === undefined) {
                        calendar.element.width('').height('');
                    }
                    calendar._bindEvents();
                    calendar.element.data('animating.wijcalendar', false);
                });
                return false;
            };
            wijcalendar.prototype._onMyGridMouseEnter = function (e) {
                if(this._myGrid === undefined) {
                    return;
                }
                var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10);
                if(this._myGrid.gridType !== "month" && (index < 0 || index > 11)) {
                    return;
                }
                cell.addClass(this.options.wijCSS.stateHover);
            };
            wijcalendar.prototype._onMyGridMouseLeave = function (e) {
                if(this._myGrid === undefined) {
                    return;
                }
                var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10);
                if(this._myGrid.gridType !== "month" && (index < 0 || index > 11)) {
                    return;
                }
                cell.removeClass(this.options.wijCSS.stateHover);
            };
            wijcalendar.prototype._unbindEvents = function () {
                var self = this, ele = self.element, wijCSS = self.options.wijCSS, selectionMode = self.options.selectionMode;
                ele.unbind(".wijcalendar");
                ele.find('div .wijmo-wijcalendar-navbutton').unbind();
                ele.find("." + wijCSS.datepickerTitle).unbind();
                ele.find(".wijmo-wijcalendar-prevpreview-button, .wijmo-wijcalendar-nextpreview-button").unbind('mouseenter.wijcalendar').unbind('mouseleave.wijcalendar');
                if(self._myGrid === undefined) {
                    ele.find(".wijmo-wijcalendar-day-selectable").unbind();
                    if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                        if($.browser.msie) {
                            ele.unbind("contextmenu.wijcalendar");
                        }
                        ele.find(".wijmo-wijcalendar-day-selectable").unbind("wijmouseup.wijcalendar");
                    }
                    if(!!selectionMode.month) {
                        ele.find(".wijmo-wijcalendar-monthselector").unbind();
                    }
                    if(!!selectionMode.weekDay) {
                        ele.find("." + wijCSS.datepickerWeekDay).unbind();
                    }
                    if(!!selectionMode.weekNumber) {
                        ele.find(".wijmo-wijcalendar-week-num").unbind();
                    }
                } else {
                    ele.find(".wijmo-wijcalendar-day-selectable").unbind();
                }
            };
            wijcalendar.prototype._bindEvents = function () {
                var wijCSS = this.options.wijCSS, eventPre = "";
                // fix the issue 42890, if touch is enabled, all the touch events should use wij prefix.
                // otherwise, do not use wij prefix.
                if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                    eventPre = "wij";
                }
                if(!this.element.data('preview.wijcalendar') && !this.options.disabledState && !this.options.disabled) {
                    this.element.find('div .wijmo-wijcalendar-navbutton').unbind().bind('mouseout.wijcalendar', function () {
                        var el = $(this);
                        el.removeClass(wijCSS.stateHover);
                        if(el.hasAllClasses(wijCSS.datepickerNextHover)) {
                            el.removeClass(wijCSS.datepickerNextHover);
                        } else if(el.hasAllClasses(wijCSS.datepickerPrevHover)) {
                            el.removeClass(wijCSS.datepickerPrevHover);
                        }
                    }).bind('mouseover.wijcalendar', function () {
                        var el = $(this);
                        el.addClass(wijCSS.stateHover);
                        if(el.hasAllClasses(wijCSS.datepickerNext)) {
                            el.addClass(wijCSS.datepickerNextHover);
                        } else if(el.hasAllClasses(wijCSS.datepickerPrev)) {
                            el.addClass(wijCSS.datepickerPrevHover);
                        }
                    }).bind('click.wijcalendar', $.proxy(this._onNavButtonClicked, this));
                    this.element.unbind(".wijcalendar").bind(eventPre + "mouseup.wijcalendar", $.proxy(this._onMouseUp, this));
                    this.element.find("." + wijCSS.datepickerTitle).unbind().bind('mouseout.wijcalendar', function () {
                        $(this).removeClass(wijCSS.stateHover);
                    }).bind('mouseover.wijcalendar', function () {
                        $(this).addClass(wijCSS.stateHover);
                    }).bind('click.wijcalendar', $.proxy(this._onTitleClicked, this));
                    this.element.find(".wijmo-wijcalendar-prevpreview-button, " + ".wijmo-wijcalendar-nextpreview-button").unbind('mouseenter.wijcalendar').unbind('mouseleave.wijcalendar').bind({
                        "mouseenter.wijcalendar": $.proxy(this._onPreviewMouseEnter, this),
                        "mouseleave.wijcalendar": $.proxy(this._onPreviewMouseLeave, this)
                    });
                    if(this._myGrid === undefined) {
                        this.element.find(".wijmo-wijcalendar-day-selectable").unbind().bind(eventPre + "click.wijcalendar", $.proxy(this._onDayClicked, this)).bind("mouseenter.wijcalendar", $.proxy(this._onDayMouseEnter, this)).bind("mouseleave.wijcalendar", $.proxy(this._onDayMouseLeave, this)).bind(eventPre + "mousedown.wijcalendar", $.proxy(this._onDayMouseDown, this)).bind("dragstart.wijcalendar", $.proxy(this._onDayDragStart, this));
                        if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                            if($.browser.msie) {
                                this.element.unbind("contextmenu.wijcalendar").bind({
                                    "contextmenu.wijcalendar": function () {
                                        return false;
                                    }
                                });
                            }
                            this.element.find(".wijmo-wijcalendar-day-selectable").unbind(eventPre + "mouseup.wijcalendar").bind(eventPre + "mouseup.wijcalendar", $.proxy(this._onTouchend, this));
                        }
                        if(!!this.options.selectionMode.month) {
                            this.element.find(".wijmo-wijcalendar-monthselector").unbind().bind({
                                "click.wijcalendar": $.proxy(this._onMonthSelectorClicked, this),
                                "mouseenter.wijcalendar": $.proxy(this._onMonthSelectorMouseEnter, this),
                                "mouseleave.wijcalendar": $.proxy(this._onMonthSelectorMouseLeave, this)
                            });
                        }
                        if(!!this.options.selectionMode.weekDay) {
                            this.element.find("." + wijCSS.datepickerWeekDay).unbind().bind({
                                "click.wijcalendar": $.proxy(this._onWeekDayClicked, this),
                                "mouseenter.wijcalendar": $.proxy(this._onWeekDayMouseEnter, this),
                                "mouseleave.wijcalendar": $.proxy(this._onWeekDayMouseLeave, this)
                            });
                        }
                        if(!!this.options.selectionMode.weekNumber) {
                            this.element.find(".wijmo-wijcalendar-week-num").unbind().bind({
                                "click.wijcalendar": $.proxy(this._onWeekNumberClicked, this),
                                "mouseenter.wijcalendar": $.proxy(this._onWeekNumberMouseEnter, this),
                                "mouseleave.wijcalendar": $.proxy(this._onWeekNumberMouseLeave, this)
                            });
                        }
                    } else {
                        this.element.find(".wijmo-wijcalendar-day-selectable").unbind().bind({
                            "click.wijcalendar": $.proxy(this._onMyGridClicked, this),
                            "mouseenter.wijcalendar": $.proxy(this._onMyGridMouseEnter, this),
                            "mouseleave.wijcalendar": $.proxy(this._onMyGridMouseLeave, this)
                        });
                    }
                }
            };
            wijcalendar.prototype._isSelectable = function (dayType) {
                var o = this.options;
                return (o.showOtherMonthDays && (dayType & wijDayType.otherMonth)) || !(dayType & (wijDayType.outOfRange | wijDayType.disabled | wijDayType.otherMonth));
            };
            wijcalendar.prototype._getCellClassName = function (dayType, date, previewMode) {
                var o = this.options, cssCell = '', cssText = o.wijCSS.stateDefault, allowSelDay = (!!o.selectionMode.day || !!o.selectionMode.days);
                previewMode = previewMode || false;
                if(!previewMode && !o.disabledState && !o.disabled && allowSelDay && this._isSelectable(dayType)) {
                    cssCell += " wijmo-wijcalendar-day-selectable";
                }
                if((dayType & wijDayType.weekEnd)) {
                    cssCell += ' ' + o.wijCSS.datepickerWeekEnd;
                }
                if((dayType & wijDayType.otherMonth)) {
                    cssCell += ' ' + o.wijCSS.datepickerOtherMonth;
                    cssText += ' ' + o.wijCSS.prioritySecondary;
                }
                if((dayType & wijDayType.outOfRange)) {
                    cssCell += ' wijmo-wijcalendar-outofrangeday';
                    cssText += ' ' + o.wijCSS.prioritySecondary;
                }
                if((dayType & wijDayType.gap)) {
                    cssCell += ' wijmo-wijcalendar-gap';
                } else {
                    if((dayType & wijDayType.disabled)) {
                        cssCell += ' ' + o.wijCSS.datepickerUnselectable;
                        cssText += ' ' + o.wijCSS.stateDisabled;
                    }
                    if((dayType & wijDayType.today)) {
                        cssCell += ' ' + o.wijCSS.datepickerDaysCellOver + ' ' + o.wijCSS.datepickerToday;
                        cssText += ' ' + o.wijCSS.stateHighlight;
                    }
                    if((dayType & wijDayType.selected) && ((dayType & (wijDayType.outOfRange | wijDayType.disabled)) === 0)) {
                        cssCell += ' ' + o.wijCSS.datepickerCurrentDay;
                        cssText += ' ' + o.wijCSS.stateActive;
                    }
                    if((dayType & wijDayType.gap)) {
                        cssCell += ' wijmo-wijcalendar-gap';
                    }
                    if((dayType & wijDayType.custom)) {
                        cssCell += ' wijmo-wijcalendar-customday';
                    }
                }
                return {
                    cssCell: cssCell,
                    cssText: cssText
                };
            };
            wijcalendar.prototype._onNavButtonClicked = function (e) {
                if(this._isAnimating()) {
                    return false;
                }
                var step = 1, btnId = $(e.currentTarget).attr('id'), date = this.getDisplayDate(), nextDate = date;
                if(this._myGrid === undefined) {
                    step = btnId.indexOf('quick') >= 0 ? this.options.quickNavStep : 1;
                    step = btnId.indexOf('next') >= 0 ? step : -step;
                    step = step * this.options.monthRows * this.options.monthCols;
                    nextDate = wijDateOps.addMonths(date, step);
                } else {
                    step = btnId.indexOf('next') >= 0 ? 1 : -1;
                    switch(this._myGrid.gridType) {
                        case "month":
                            nextDate = wijDateOps.addYears(date, step);
                            break;
                        case "year":
                            nextDate = wijDateOps.addYears(date, step * 10);
                            break;
                        case "decade":
                            nextDate = wijDateOps.addYears(date, step * 100);
                            break;
                    }
                }
                this._slideToDate(nextDate);
                return false;
            };
            wijcalendar.prototype._getMonthGroupHtml = function () {
                var date = this.getDisplayDate(), mv, width, hw, wijCSS = this.options.wijCSS, r, c;
                if(this._isSingleMonth()) {
                    mv = this._getMonthView(date);
                    mv.showPreview = this.options.allowPreview && !this.element.data('preview.wijcalendar');
                    return mv.getHtml();
                }
                width = 100 / this.options.monthCols + '%';
                hw = new htmlTextWriter();
                for(r = 0; r < this.options.monthRows; r++) {
                    for(c = 0; c < this.options.monthCols; c++) {
                        hw.writeBeginTag('div');
                        hw.writeAttribute('class', wijCSS.datepickerGroup + (c === 0 ? ' ' + wijCSS.datepickerGroupFirst : '') + (c === this.options.monthCols - 1 ? ' ' + wijCSS.datepickerGroupLast : ''));
                        hw.writeAttribute('style', 'width:' + width);
                        hw.writeTagRightChar();
                        mv = this._getMonthView(date);
                        mv.showPreview = false;
                        hw.write(mv.getHtml());
                        hw.writeEndTag('div');
                        date = wijDateOps.addMonths(date, 1);
                    }
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.datepickerRowBreak);
                    hw.writeTagRightChar();
                    hw.writeEndTag('div');
                }
                return hw.toString();
            };
            wijcalendar.prototype._getCalendarHtml = function () {
                this._createMonthViews();
                var hw = new htmlTextWriter();
                hw.write(this._getMonthGroupHtml());
                return hw.toString();
            };
            wijcalendar.prototype._customizeDayCell = function ($dayCell) {
                if($dayCell.attr("state") === undefined) {
                    $dayCell.attr("state", 'normal');
                }
                if($dayCell.attr("daytype") === undefined) {
                    return;
                }
                if($dayCell.attr("date") === undefined) {
                    return;
                }
                var dayType = parseInt($dayCell.attr("daytype"), 10), date = new Date($dayCell.attr("date")), hover = $dayCell.attr("state") === 'hover';
                this.options.customizeDate($dayCell, date, dayType, hover);
            };
            wijcalendar.prototype._customize = function (html) {
                var o = this.options, self = this, $h = $(html);
                if(!$.isFunction(o.customizeDate)) {
                    return $h;
                }
                $.each($h.find('.wijmo-wijcalendar-day-selectable'), function (index, dayCell) {
                    self._customizeDayCell($(dayCell));
                });
                return $h;
            };
            wijcalendar.prototype._createCalendar = function () {
                //for jquery change to 1.9 $.parseHTML
                return this._customize($($.parseHTML(this._getCalendarHtml())));
            };
            wijcalendar.prototype._createMonthGroup = function () {
                return this._customize($(this._getMonthGroupHtml()));
            };
            wijcalendar.prototype._getMonthID = function (date) {
                return date.getFullYear() + '_' + (date.getMonth() + 1);
            };
            wijcalendar.prototype._createMonthViews = function () {
                this._monthViews = {
                };
                var monthID = '', date = this.getDisplayDate(), row, col, mv, count;
                for(row = 0; row < this.options.monthRows; row++) {
                    for(col = 0; col < this.options.monthCols; col++) {
                        monthID = this._getMonthID(date);
                        this._monthViews[monthID] = new wijMonthView(this, date);
                        if(row === 0) {
                            if(col === 0) {
                                this._monthViews[monthID].isFirst = true;
                            }
                            if(col === this.options.monthCols - 1) {
                                this._monthViews[monthID].isLast = true;
                            }
                        }
                        date = wijDateOps.addMonths(date, 1);
                    }
                }
                date = this.getDisplayDate();
                monthID = this._getMonthID(date);
                mv = this._monthViews[monthID];
                if(mv) {
                    this._groupStartDate = mv.getStartDate();
                }
                count = this.options.monthRows * this.options.monthCols;
                if(count > 1) {
                    date = wijDateOps.addMonths(date, count - 1);
                    monthID = this._getMonthID(date);
                    mv = this._monthViews[monthID];
                }
                if(mv) {
                    this._groupEndDate = mv.getEndDate();
                }
            };
            wijcalendar.prototype._getMonthView = function (date) {
                var monthID = this._getMonthID(date);
                return this._monthViews[monthID];
            };
            wijcalendar.prototype._getId = function () {
                return this.element.attr("id");
            };
            wijcalendar.prototype._getChildElement = function (id) {
                var child = this.element.find('[id*=\'' + id + '\']');
                return child.length === 0 ? undefined : child;
            };
            wijcalendar.prototype._refreshDayCell = function (dayCell) {
                var $dc = $(dayCell), o = this.options, dayType, date, hover, txt;
                if($dc.attr("state") === undefined) {
                    $dc.attr("state", 'normal');
                }
                if($dc.attr("daytype") === undefined) {
                    return;
                }
                if($dc.attr("date") === undefined) {
                    return;
                }
                dayType = parseInt($dc.attr("daytype"), 10);
                date = new Date($dc.attr("date"));
                hover = $dc.attr("state") === 'hover';
                $dc.attr('class', this._getCellClassName(dayType, date, undefined).cssCell);
                $dc.removeAttr('aria-selected');
                if(dayType & wijDayType.selected) {
                    $dc.attr('aria-selected', true);
                }
                if($.isFunction(o.customizeDate)) {
                    if(this._customizeDayCell($dc)) {
                        return;
                    }
                }
                txt = $dc.find('a');
                if(txt.length > 0) {
                    txt.toggleClass(this.options.wijCSS.stateHover, hover);
                    txt.toggleClass(this.options.wijCSS.stateActive, ((dayType & wijDayType.selected) !== 0));
                }
            };
            wijcalendar.prototype._isSingleMonth = function () {
                return this.options.monthCols * this.options.monthRows === 1;
            };
            wijcalendar.prototype._splitString = function (s, sep, count) {
                if(count === undefined) {
                    return s.split(sep);
                }
                var ret = [], arr = s.split(sep), i;
                for(i = 0; i < arr.length; i++) {
                    if(i >= count) {
                        ret[count - 1] = ret[count - 1] + sep + arr[i];
                    } else {
                        ret.push(arr[i]);
                    }
                }
                return ret;
            };
            wijcalendar.prototype._getNavButtonHtml = function (id, cls, imgClass, tooltip) {
                var hw = new htmlTextWriter();
                hw.writeBeginTag('a');
                hw.writeAttribute('id', id);
                hw.writeAttribute('class', cls);
                hw.writeAttribute('role', 'button');
                hw.writeAttribute('href', '#');
                if(tooltip) {
                    hw.writeAttribute('title', tooltip);
                    hw.writeAttribute('aria-label', tooltip);
                }
                hw.writeTagRightChar();
                hw.writeBeginTag('span');
                hw.writeAttribute('class', imgClass);
                hw.writeTagRightChar();
                if(tooltip) {
                    hw.write(tooltip);
                }
                hw.writeEndTag('span');
                hw.writeEndTag('a');
                return hw.toString();
            };
            wijcalendar.prototype._getTitleText = // 2013-1-6
            function (monthDate) {
                if(this._myGrid !== undefined) {
                    return this._myGrid.getTitle();
                } else {
                    var d = monthDate || this.getDisplayDate(), f = this.options.titleFormat || 'MMMM yyyy';
                    if($.isFunction(this.options.title)) {
                        return this.options.title(d, f) || this._formatDate(f, d);
                    }
                    return this._formatDate(f, d);
                }
            };
            wijcalendar.prototype._refreshTitle = function () {
                this.element.find('.' + this.options.wijCSS.datepickerTitle).html(this._getTitleText(undefined));
            };
            wijcalendar.prototype._fillTitle = function (hw, date) {
                var wijCSS = this.options.wijCSS;
                hw.writeBeginTag('div');
                hw.writeAttribute('class', wijCSS.datepickerTitle + ' wijmo-wijcalendar-title' + ' ' + wijCSS.stateDefault + ' ' + wijCSS.cornerAll);
                hw.writeTagRightChar();
                hw.write(this._getTitleText(date));
                hw.writeEndTag('div');
            };
            wijcalendar.prototype._getHeaderHtml = function (monthDate, prevButtons, nextButtons) {
                var previewMode = !!this.element.data('preview.wijcalendar'), wijCSS = this.options.wijCSS, buttons = previewMode ? 'none' : (this._isSingleMonth() ? this.options.navButtons : 'default'), isRTL = this.element.is('.' + wijCSS.datepickerRtl), hw = new htmlTextWriter();
                if(buttons === 'quick') {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.header + ' wijmo-wijcalendar-header ' + wijCSS.helperClearFix + ' ' + wijCSS.cornerAll);
                    hw.writeAttribute('role', 'heading');
                    hw.writeTagRightChar();
                    if(!!prevButtons) {
                        hw.write(this._getNavButtonHtml('quickprev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-seek-' + (isRTL ? 'next' : 'prev') + ' ' + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.quickPrevTooltip.replace('#', this.options.quickNavStep)));
                    }
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.datepickerHeader + ' wijmo-wijcalendar-header-inner');
                    hw.writeTagRightChar();
                    if(!!prevButtons) {
                        hw.write(this._getNavButtonHtml('prev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + " " + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.prevTooltip));
                    }
                    this._fillTitle(hw, monthDate);
                    if(!!nextButtons) {
                        hw.write(this._getNavButtonHtml('next', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + " " + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.nextTooltip));
                    }
                    hw.writeEndTag('div');
                    if(!!nextButtons) {
                        hw.write(this._getNavButtonHtml('quicknext', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-seek-' + (isRTL ? 'prev' : 'next') + " " + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.quickNextTooltip.replace('#', this.options.quickNavStep)));
                    }
                    hw.writeEndTag('div');
                } else {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.datepickerHeader + ' ' + wijCSS.header + ' ' + wijCSS.datepickerHeader + ' ' + wijCSS.helperClearFix + ' ' + wijCSS.cornerAll);
                    hw.writeAttribute('role', 'heading');
                    hw.writeTagRightChar();
                    if(buttons !== 'none' && !!prevButtons) {
                        hw.write(this._getNavButtonHtml('prev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + ' ' + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.prevTooltip));
                    }
                    this._fillTitle(hw, monthDate);
                    if(buttons !== 'none' && !!nextButtons) {
                        hw.write(this._getNavButtonHtml('next', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + ' ' + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.nextTooltip));
                    }
                    hw.writeEndTag('div');
                }
                return hw.toString();
            };
            wijcalendar.prototype._formatDate = function (format, date) {
                if(!wijDateOps.getTicks(date)) {
                    return '&nbsp;';
                }
                return Globalize.format(date, format, this._getCulture(null));
            };
            return wijcalendar;
        })(wijmo.wijmoWidget);
        calendar.wijcalendar = wijcalendar;        
        var wijcalendar_options = (function () {
            function wijcalendar_options() {
                /** Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijcalendar')";
                //All CSS classes used in widgets that use jQuery UI CSS Framework
                /** @ignore*/
                this.wijCSS = {
                    datepickerInline: "ui-datepicker-inline",
                    datepicker: "ui-datepicker",
                    datepickerCalendar: "ui-datepicker-calendar",
                    datepickerMulti: "ui-datepicker-multi",
                    datepickerRtl: "datepicker-rtl",
                    datepickerOtherMonth: "ui-datepicker-other-month",
                    prioritySecondary: "ui-priority-secondary",
                    effectsWrapper: "ui-effects-wrapper",
                    datepickerNextHover: "ui-datepicker-next-hover",
                    datepickerPrevHover: "ui-datepicker-prev-hover",
                    datepickerNext: "ui-datepicker-next",
                    datepickerPrev: "ui-datepicker-prev",
                    datepickerTitle: "ui-datepicker-title",
                    datepickerWeekDay: "ui-datepicker-week-day",
                    datepickerWeekEnd: "ui-datepicker-week-end",
                    datepickerUnselectable: "ui-datepicker-unselectable",
                    datepickerDaysCellOver: "ui-datepicker-days-cell-over",
                    datepickerToday: "ui-datepicker-today",
                    stateHighlight: "ui-state-highlight",
                    datepickerCurrentDay: "ui-datepicker-current-day",
                    datepickerGroup: "ui-datepicker-group",
                    datepickerGroupFirst: "ui-datepicker-group-first",
                    datepickerGroupLast: "ui-datepicker-group-last",
                    datepickerRowBreak: "ui-datepicker-row-break",
                    datepickerHeader: "ui-datepicker-header",
                    uiIconGripDottedVertical: "ui-icon-grip-dotted-vertical",
                    uiDatepickerWeekCol: "ui-datepicker-week-col"
                };
                /** @ignore*/
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body ui-body-b",
                    stateDefault: "ui-btn ui-btn-b",
                    stateHighlight: "ui-btn-down-e"
                };
                /** Assigns the string value of the culture ID that appears on the calendar
                *   for the weekday and title names.
                */
                this.culture = '';
                /** Gets or sets the number of calendar months in horizontal direction.
                * @remarks
                *        By setting the monthCols property, calendar months will be added horizontally to the widget.
                *        The default value of this option is "1", which displays one calendar month at a time.
                */
                this.monthCols = 1;
                /** Gets or sets the number of calendar months in vertical direction.
                * @remarks
                *        By setting the monthRows property, calendar months will be added vertically to the widget.
                *        The default value of this option is "1", which displays one calendar month at a time.
                */
                this.monthRows = 1;
                /** Gets or sets the format for the title text.*/
                this.titleFormat = "MMMM yyyy";
                /** A Boolean property that determines whether to display the calendar's title.*/
                this.showTitle = true;
                /** Gets or sets the display date for the first month view.
                *   You can specify the date via a Date object.
                * @type {Date}
                */
                this.displayDate = undefined;
                /** Gets or sets the number of day rows that appear in the calendar.
                *  This is useful if you want to view more or less calendar days on the calendar month.
                */
                this.dayRows = 6;
                /** Gets or sets the number of day columns that appear in the calendar.
                *  This is useful if you want to view more or less calendar days on the calendar month.
                */
                this.dayCols = 7;
                /** Gets or sets the format for the week day.
                * @remarks
                *          Possible values are: "short", "full", "firstLetter" or "abbreviated".
                */
                this.weekDayFormat = "short";
                /** A Boolean property that determines whether to display week days.*/
                this.showWeekDays = true;
                /** Determines whether to display week numbers.
                * @remarks
                *      When enabled, the week numbers appear vertically on the left side of the calendar.
                *      The week numbers represent a week number for each week in the calendar month.
                *      In the calendar year there are a total of 52 weeks so the weeknumbers will range from 1 to 52.
                */
                this.showWeekNumbers = false;
                /** Defines different rules for determining the first week of the year.
                * @example
                *  $("#calendar1").wijcalendar(
                *            { calendarWeekRule: 'firstFourDayWeek'}
                *   );
                * @remarks
                *          Possible values are: "firstDay", "firstFullWeek" or "firstFourDayWeek"
                */
                this.calendarWeekRule = "firstDay";
                /** Determines the minimum date to display. You can specify the minDate via a Date object.
                * @type {Date}
                * @remarks The default value is new Date(1900, 0, 1).
                */
                this.minDate = new Date(1900, 0, 1);
                /** Determines the maximum date to display. You can specify the maxDate via a Date object.
                * @type {Date}
                * @remarks The default value is new Date(1900, 0, 1).
                */
                this.maxDate = new Date(2099, 11, 31);
                /** Determines whether to display the days of the next and/or previous month.
                */
                this.showOtherMonthDays = true;
                /** Determines whether to add zeroes to days with only one digit
                * @remarks
                *      for example, "1" would become "01" if this property were set to "true"
                */
                this.showDayPadding = false;
                /** Gets or sets the date selection mode on the calendar control that
                *  specifies whether the user can select a single day, a week, or an entire month.
                * @remarks
                *      Possible fields in hash are: day, days, weekDay, weekNumber, month.
                * @example
                *  $("#calendar1").wijcalendar(
                *             { selectionMode: {day:true, weekDay:true}}
                *   );
                */
                this.selectionMode = {
                    day: true,
                    days: true
                };
                /** Allows users to preview the next and previous months by
                *  hovering over the previousPreview and nextPreview buttons.
                */
                this.allowPreview = false;
                /** Determines whether users can change the view to month/year/decade
                *  while clicking on the calendar title.
                */
                this.allowQuickPick = true;
                /** Gets or sets the format for the ToolTip. */
                this.toolTipFormat = "dddd, MMMM dd, yyyy";
                /** Gets or sets the text for the 'previous' button's ToolTip. */
                this.prevTooltip = "Previous";
                /** Gets or sets the text for the 'next' button's ToolTip. */
                this.nextTooltip = "Next";
                /** Gets or sets the "quick previous" button's ToolTip.*/
                this.quickPrevTooltip = "Quick Previous";
                /** Gets or sets the "quick next" button's ToolTip.*/
                this.quickNextTooltip = "Quick Next";
                /** Gets or sets the "previous preview" button's ToolTip.*/
                this.prevPreviewTooltip = "";
                /** Gets or sets the "next preview" button's ToolTip. */
                this.nextPreviewTooltip = "";
                /** Determines the display type of navigation buttons.
                * @remarks
                *      Possible values are: "default", "quick" or "none"
                */
                this.navButtons = 'default';
                /** Determines the increase/decrease steps when clicking the quick navigation button. */
                this.quickNavStep = 12;
                /** Determines the month slide direction.
                * @remarks
                *     Possible values are: horizontal or vertical
                */
                this.direction = 'horizontal';
                /** Gets or sets the animation duration in milliseconds.  */
                this.duration = 250;
                /** Sets the type of animation easing effect that users experience
                *   when they click the previous or next buttons on the wijcalendar.
                * @remarks
                *     For example, if the easing is set to "easeInBounce" the calendar
                *      bounces back and forth several times and then slides to the previous
                *      or next calendar month.
                *      You can create custom easing animations using jQuery UI Easings.
                */
                this.easing = 'easeInQuad';
                /** A Boolean property that determines whether the wijcalendar widget
                *  is a pop-up calendar.
                * @remarks
                *     this is useful, for example,
                *           if you're integrating the calendar with an input control to create a date picker.
                */
                this.popupMode = false;
                /** A Boolean property that determines whether to autohide
                *   the calendar in pop-up mode when clicking outside of the calendar.
                */
                this.autoHide = true;
                /** Function used for customizing the content, style and attributes of a day cell.
                * @type {function}
                * @remarks the function include following parameter:
                *  $daycell:jQuery jQuery object that represents table cell of the date to be customized.
                *  date: Date Date of the cell.
                *  hover: boolean Whether mouse is over the day cell.
                *  preview: object Whether rendering in preview container.
                *  returns true if day cell content has been changed
                *  and default cell content will not be applied.
                */
                this.customizeDate = null;
                /** A callback function used to customizing the title text on month view.
                * @type {function}
                * @remarks the function include following parameter:
                * date: Date The display date of the month.
                * format: string The title format. Determined by the options.titleFormat.
                */
                this.title = null;
                /** The beforeSlide event handler.
                * A function called before the calendar view slides to another month.
                * Cancellable.
                * @event
                */
                this.beforeSlide = null;
                /** The afterSlide event handler.
                * A function called after the calendar view slided to another month.
                * Cancellable.
                * @event
                */
                this.afterSlide = null;
                /** The beforeSelect event handler.
                * A function called before user selects a day by mouse. Cancellable.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {ISelectedDate} args The data with this event.
                * @example
                * $("#calendar1").wijcalendar({
                *       beforeSelect: function (e, data)
                *       {
                *              var selDates = $("#calendar1").wijcalendar('option', 'selectedDates'),
                *              selected = false,
                *              list;
                *              $.each(selDates, function (i, d)
                *                  {
                *                    if (data.date.getFullYear() === d.getFullYear() &&
                *                        data.date.getMonth() === d.getMonth() &&                        data.date.getDate() === d.getDate())
                *                                   {
                *                            selected = true;
                *                            return false;
                *                         }
                *              );
                *
                *           if (selected)
                *           {
                *                    $("#calendar1").wijcalendar('unSelectDate', data.date);
                *                       } else
                *                                  {
                *                            $("#calendar1").wijcalendar('selectDate', data.date);
                *                       }
                *
                *            list = $("#msg").empty();
                *                        selDates = $("#calendar1").wijcalendar('option', 'selectedDates');
                *                       $.each(selDates, function (i, d)
                *                       {
                *                 var li = $("<li/>");
                *                 li.text(d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate());
                *                list.append(li);
                *             });
                *
                *                return false;
                *             }
                *                    });
                */
                this.beforeSelect = null;
                /** The afterSelect event handler.
                * A function called after user selects a day by mouse.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {ISelectedDate} args The data with this event.
                */
                this.afterSelect = null;
                /** The selectedDatesChanged event handler.
                * A function called after the selectedDates collection changed.
                * @event
                * @dataKey {Date} dates The array with all selected date object.
                * @example
                *  $("#calendar").wijcalendar(
                *   {
                *   popupMode: true,
                *   selectedDatesChanged: function () {
                *   var selDate = $(this).wijcalendar("getSelectedDate");
                *   var selectDate = new Date(selDate);
                *   if (!!selDate) $("#popdate").val(selectDate.getMonth() + 1 + "/" + selectDate.getDate() + "/" + selectDate.getFullYear());
                *   }
                */
                this.selectedDatesChanged = null;
            }
            return wijcalendar_options;
        })();        
        ;
        wijcalendar.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijcalendar_options());
        $.wijmo.registerWidget("wijcalendar", wijcalendar.prototype);
        /** @ignore */
        var htmlTextWriter = (function () {
            function htmlTextWriter() {
                this._html = [];
            }
            htmlTextWriter.prototype.writeTagLeftChar = function () {
                this._html[this._html.length] = '<';
            };
            htmlTextWriter.prototype.writeTagRightChar = function () {
                this._html[this._html.length] = '>';
            };
            htmlTextWriter.prototype.write = function (text) {
                this._html[this._html.length] = ' ' + text + ' ';
            };
            htmlTextWriter.prototype.writeBeginTag = function (tagName) {
                this._html[this._html.length] = '<' + tagName;
            };
            htmlTextWriter.prototype.writeEndTag = function (tagName) {
                this._html[this._html.length] = '</' + tagName + '>';
            };
            htmlTextWriter.prototype.writeFullBeginTag = function (tagName) {
                this._html[this._html.length] = '<' + tagName + '>';
            };
            htmlTextWriter.prototype.writeSelfClosingTagEnd = function () {
                this._html[this._html.length] = '/>';
            };
            htmlTextWriter.prototype.writeAttribute = function (name, value) {
                if(value === undefined || value === null) {
                    return;
                }
                this._html[this._html.length] = ' ' + name + '=\"';
                this._html[this._html.length] = value;
                this._html[this._html.length] = '\"';
            };
            htmlTextWriter.prototype.clean = function () {
                this._html = [];
            };
            htmlTextWriter.prototype.toString = function () {
                return this._html.join('');
            };
            return htmlTextWriter;
        })();
        calendar.htmlTextWriter = htmlTextWriter;        
        var wijDateOps = {
            addDays: function (date, days) {
                var dt = new Date(date.getFullYear(), date.getMonth(), date.getDate() + days);
                if(days) {
                    if(dt.getDate() === date.getDate()) {
                        dt = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                        dt.setTime(dt.getTime() + (days * 24 * 3600 * 1000));
                    }
                }
                return dt;
            },
            addMonths: function (date, months) {
                return new Date(date.getFullYear(), date.getMonth() + months, 1);
            },
            addYears: function (date, years) {
                return this.addMonths(date, years * 12);
            },
            getDate: function (date) {
                return new Date(date.getFullYear(), date.getMonth(), date.getDate());
            },
            getTicks: function (date) {
                return date.valueOf();
            },
            isSameDate: function (date1, date2) {
                return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
            },
            isSameMonth: function (date1, date2) {
                return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
            },
            getDaysInMonth: function (date) {
                return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            },
            getWeekStartDate: function (date, firstDayOfWeek) {
                return new Date(date.getFullYear(), date.getMonth(), date.getDate() - ((date.getDay() - firstDayOfWeek + 7) % 7));
            },
            getDayOfYear: function (date) {
                var start = new Date(date.getFullYear(), 0, 1), distance = this.getTicks(date) - this.getTicks(start), days = distance / (24 * 60 * 60 * 1000);
                return Math.floor(days) + 1;
            },
            getFirstDayWeekOfYear: function (date, firstDayOfWeek) {
                var days = this.getDayOfYear(date) - 1, offset = date.getDay() - (days % 7), weeks;
                offset = ((offset - firstDayOfWeek) + 14) % 7;
                weeks = ((days + offset) / 7);
                return Math.floor(weeks) + 1;
            },
            getDayOfWeek: function (date, firstDayOfWeek) {
                return ((date.getDay() - firstDayOfWeek + 7) % 7);
            },
            getWeekOfYearFullDays: function (time, rule, firstDayOfWeek, fullDays) {
                var days = this.getDayOfYear(time) - 1, offset = (this.getDayOfWeek(time, firstDayOfWeek)) - (days % 7);
                offset = ((firstDayOfWeek - offset) + 14) % 7;
                if((offset) && (offset >= fullDays)) {
                    offset -= 7;
                }
                offset = days - offset;
                if(offset >= 0) {
                    return (Math.floor(offset / 7) + 1);
                }
                return this.getWeekOfYearFullDays(this.addDays(time, -(days + 1)), rule, firstDayOfWeek, fullDays);
            },
            getWeekOfYear: function (date, rule, firstDayOfWeek) {
                switch(rule) {
                    case "firstDay":
                        return this.getFirstDayWeekOfYear(date, firstDayOfWeek);
                    case "firstFullWeek":
                        return this.getWeekOfYearFullDays(date, rule, firstDayOfWeek, 7);
                    case "firstFourDayWeek":
                        return this.getWeekOfYearFullDays(date, rule, firstDayOfWeek, 4);
                }
                return this.getFirstDayWeekOfYear(date, firstDayOfWeek);
            },
            getDateToken: function (date) {
                return date.getFullYear() + '_' + date.getMonth() + '_' + date.getDate();
            }
        };
        /** @ignore */
        var wijMonthView = (function () {
            function wijMonthView(calendar, displayDate) {
                this.calendar = calendar;
                if(displayDate === undefined || wijDateOps.isSameDate(displayDate, new Date(1900, 0, 1))) {
                    displayDate = new Date();
                }
                this.displayDate = displayDate;
                this.id = this.calendar._getId() + '_' + this.calendar._getMonthID(displayDate);
                this.isFirst = false;
                this.isLast = false;
                this.showPreview = false;
                this.culture = this.calendar._getCulture();
                this._calcDates(this.displayDate);
            }
            wijMonthView.prototype._calcDates = function (date) {
                var daysInMonth = wijDateOps.getDaysInMonth(date);
                this._startDateInMonth = new Date(date.getFullYear(), date.getMonth(), 1);
                this._endDateInMonth = wijDateOps.addDays(this._startDateInMonth, daysInMonth - 1);
                this._startDate = wijDateOps.getWeekStartDate(this._startDateInMonth, this.culture.calendar.firstDay);
                this._endDate = wijDateOps.addDays(this._startDate, this.calendar.options.dayRows * this.calendar.options.dayCols - 1);
            };
            wijMonthView.prototype._isFirstMonth = function () {
                var date = this.calendar.getDisplayDate();
                return wijDateOps.isSameMonth(this._startDateInMonth, date);
            };
            wijMonthView.prototype._isLastMonth = function () {
                var date = this.calendar.getDisplayDate();
                date = new Date(date.getFullYear(), date.getMonth(), 1);
                date = wijDateOps.addMonths(date, this.calendar.options.monthCols * this.calendar.options.monthRows - 1);
                return wijDateOps.isSameMonth(this._startDateInMonth, date);
            };
            wijMonthView.prototype.getStartDate = function () {
                return this._startDate;
            };
            wijMonthView.prototype.getEndDate = function () {
                return this._endDate;
            };
            wijMonthView.prototype._getMonthDate = function () {
                if(this._startDateInMonth === undefined) {
                    //this._calcDates(this.getDisplayDate());
                                    }
                return this._startDateInMonth;
            };
            wijMonthView.prototype._setMonthDate = function (date) {
                this._calcDates(date);
            };
            wijMonthView.prototype._getWeekDayText = function (day, format) {
                format = format || "short";
                var days = this.culture.calendar.days, text = '';
                switch(format) {
                    case "full":
                        text = days.names[day];
                        break;
                    case "firstLetter":
                        text = days.names[day].substring(0, 1);
                        break;
                    case "abbreviated":
                        text = days.namesAbbr[day];
                        break;
                    default:
                        text = days.namesShort[day];
                        break;
                }
                return text;
            };
            wijMonthView.prototype._getRowCount = function () {
                var o = this.calendar.options;
                return o.showWeekDays ? o.dayRows + 1 : o.dayRows;
            };
            wijMonthView.prototype._getColCount = function () {
                var o = this.calendar.options;
                return o.showWeekNumbers ? o.dayCols + 1 : o.dayCols;
            };
            wijMonthView.prototype._getDayType = function (date) {
                var o = this.calendar.options, dayType = wijDayType.general, dow = date.getDay(), weekEnd = dow === 6 || dow === 0, outOfRange = // Saturday or Sunday
                date < o.minDate || date > o.maxDate, otherMonth = date < this._startDateInMonth || date > this._endDateInMonth, isDisabled = outOfRange || this.calendar._getDisabledDates().contains(date), isSelected = this.calendar._getSelectedDates().contains(date), today = new Date(), isToday = wijDateOps.isSameDate(date, today), isCustom = false;
                if(weekEnd) {
                    dayType |= wijDayType.weekEnd;
                }
                if(isToday) {
                    dayType |= wijDayType.today;
                }
                if(isDisabled) {
                    dayType |= wijDayType.disabled;
                }
                if(otherMonth) {
                    dayType |= wijDayType.otherMonth;
                }
                if(outOfRange) {
                    dayType |= wijDayType.outOfRange;
                }
                if(isSelected) {
                    dayType |= wijDayType.selected;
                }
                if(isCustom) {
                    dayType |= wijDayType.custom;
                }
                if(otherMonth && !o.showOtherMonthDays) {
                    dayType |= wijDayType.gap;
                }
                return dayType;
            };
            wijMonthView.prototype._refreshDate = function (date) {
                if(date < this._startDate || date > this._endDate) {
                    return;
                }
                var o = this.calendar.options, dUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()), startUTC = Date.UTC(this._startDate.getFullYear(), this._startDate.getMonth(), this._startDate.getDate()), offset = (Math.floor(Math.abs(dUTC - startUTC) / (24 * 60 * 60 * 1000))), row = Math.floor(offset / this.calendar.options.dayCols), col = Math.floor(offset % this.calendar.options.dayCols), tbl, r, dayCell, dayType;
                if(o.showWeekNumbers) {
                    col++;
                }
                if(o.showWeekDays) {
                    row++;
                }
                tbl = $("#" + this.id, this.calendar.element).get(0);
                if(tbl) {
                    if(row < tbl.rows.length) {
                        r = tbl.rows[row];
                        if(col < r.cells.length) {
                            dayCell = r.cells[col];
                            dayType = this._getDayType(date);
                            $(dayCell).attr('daytype', dayType.toString());
                            this.calendar._refreshDayCell(dayCell);
                        }
                    }
                }
            };
            wijMonthView.prototype._fillDayCell = function (hw, date, previewMode) {
                var o = this.calendar.options, custom = null, text = date.getDate().toString(), tooltip = this.calendar._formatDate(o.toolTipFormat || "dddd, MMMM dd, yyyy", date), dayType = this._getDayType(date), selectable = this.calendar._isSelectable(dayType), css = this.calendar._getCellClassName(dayType, date, previewMode);
                text = (o.showDayPadding && text.length === 1) ? '0' + text : text;
                hw.writeBeginTag('td');
                hw.writeAttribute('daytype', (dayType).toString());
                if(selectable) {
                    hw.writeAttribute('title', tooltip);
                    hw.writeAttribute('aria-label', tooltip);
                }
                hw.writeAttribute('date', date.toDateString());
                hw.writeAttribute('class', css.cssCell);
                hw.writeAttribute('role', 'gridcell');
                if(!selectable) {
                    hw.writeAttribute('aria-disabled', 'true');
                }
                hw.writeTagRightChar();
                if((dayType & wijDayType.gap)) {
                    hw.write('&#160;');
                } else {
                    if(custom && custom.content) {
                        hw.write(custom.content);
                    } else {
                        hw.writeBeginTag('a');
                        hw.writeAttribute('class', css.cssText);
                        hw.writeAttribute('href', '#');
                        hw.writeAttribute('onclick', 'return false;');
                        hw.writeTagRightChar();
                        hw.write(text);
                        hw.writeEndTag('a');
                    }
                }
                hw.writeEndTag('td');
            };
            wijMonthView.prototype.getHtml = function (tableOnly) {
                tableOnly = !!tableOnly;
                var o = this.calendar.options, wijCSS = o.wijCSS, previewMode = !!this.calendar.element.data('preview.wijcalendar'), hw = new htmlTextWriter(), i, j, dayOfWeek, weekStartDate, weekEnd, colIndex, txt, fullTxt, date, wnDate, rowIndex, weekNumber;
                if(!tableOnly && o.showTitle) {
                    hw.write(this.calendar._getHeaderHtml(this._startDateInMonth, this.isFirst, this.isLast));
                }
                if(!tableOnly && !previewMode && this.showPreview) {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', 'wijmo-wijcalendar-prevpreview-button');
                    hw.writeAttribute('role', 'button');
                    hw.writeAttribute('aria-haspopup', 'true');
                    hw.writeAttribute('id', 'prevPreview');
                    hw.writeTagRightChar();
                    hw.writeBeginTag('a');
                    hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.uiIconGripDottedVertical);
                    hw.writeAttribute('href', '#');
                    hw.writeAttribute('title', o.prevPreviewTooltip);
                    hw.writeAttribute('aria-label', o.prevPreviewTooltip);
                    hw.writeAttribute('onclick', 'return false;');
                    hw.writeTagRightChar();
                    hw.write('&#160;');
                    hw.writeEndTag('a');
                    hw.writeEndTag('div');
                }
                hw.writeBeginTag('table');
                hw.writeAttribute('id', this.id);
                hw.writeAttribute('class', wijCSS.datepickerCalendar + ' wijmo-wijcalendar-table');
                hw.writeAttribute('role', 'grid');
                hw.writeAttribute('summary', this.calendar._getTitleText(this._startDateInMonth));
                hw.writeAttribute('onselectstart', 'return false;');
                hw.writeTagRightChar();
                if(o.showWeekDays) {
                    hw.writeFullBeginTag('thead');
                    hw.writeBeginTag('tr');
                    hw.writeTagRightChar();
                    if(o.showWeekNumbers) {
                        hw.writeBeginTag('th');
                        hw.writeAttribute('id', this.id + '_ms');
                        hw.writeAttribute('class', wijCSS.uiDatepickerWeekCol + ' wijmo-wijcalendar-monthselector' + (!!o.selectionMode.month ? ' wijmo-wijcalendar-selectable' : ''));
                        hw.writeAttribute('role', 'columnheader');
                        hw.writeTagRightChar();
                        if(!!o.selectionMode.month && !previewMode) {
                            // && !o.disabledState && !o.disabled) { for 30863 issue
                            hw.writeBeginTag('a');
                            hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.iconArrowRightDown);
                            hw.writeAttribute('style', 'display: block;');
                            hw.writeSelfClosingTagEnd();
                        } else {
                            hw.write(o.weekString ? o.weekString : "Wk");
                        }
                        hw.writeEndTag('th');
                    }
                    dayOfWeek = this._startDate.getDay();
                    weekStartDate = this._startDate;
                    for(i = 0; i < o.dayCols; i++) {
                        weekEnd = dayOfWeek === 6 || dayOfWeek === 0;
                        colIndex = i + ((o.showWeekNumbers) ? 1 : 0);
                        txt = this._getWeekDayText(dayOfWeek, o.weekDayFormat);
                        fullTxt = this._getWeekDayText(dayOfWeek, "full");
                        hw.writeBeginTag('th');
                        hw.writeAttribute('id', this.id + '_cs_' + colIndex);
                        hw.writeAttribute('class', wijCSS.datepickerWeekDay + (weekEnd ? ' ' + wijCSS.datepickerWeekEnd : '') + (!!o.selectionMode.weekDay ? ' wijmo-wijcalendar-selectable' : ''));
                        hw.writeAttribute('role', 'columnheader');
                        hw.writeTagRightChar();
                        hw.writeBeginTag('span');
                        hw.writeAttribute('title', fullTxt);
                        hw.writeAttribute('aria-label', fullTxt);
                        hw.writeTagRightChar();
                        hw.write(txt);
                        hw.writeEndTag('span');
                        hw.writeEndTag('th');
                        dayOfWeek = ((dayOfWeek + 1) % 7);
                        weekStartDate = wijDateOps.addDays(weekStartDate, 1);
                    }
                    hw.writeEndTag('tr');
                    hw.writeEndTag('thead');
                }
                hw.writeFullBeginTag('tbody');
                date = this._startDate;
                wnDate = this._startDateInMonth;
                for(i = 0; i < o.dayRows; i++) {
                    hw.writeBeginTag('tr');
                    hw.writeTagRightChar();
                    if(o.showWeekNumbers) {
                        rowIndex = i + ((o.showWeekDays) ? 1 : 0);
                        hw.writeBeginTag('td');
                        hw.writeAttribute('id', this.id + '_rs_' + rowIndex);
                        hw.writeAttribute('class', wijCSS.uiDatepickerWeekCol + ' wijmo-wijcalendar-week-num' + (!!o.selectionMode.weekNumber ? ' wijmo-wijcalendar-selectable' : ''));
                        hw.writeAttribute('role', 'rowheader');
                        hw.writeTagRightChar();
                        weekNumber = wijDateOps.getWeekOfYear(wnDate, o.calendarWeekRule, this.culture.calendar.firstDay);
                        hw.write(weekNumber);
                        hw.writeEndTag('td');
                        wnDate = wijDateOps.addDays(wnDate, o.dayCols);
                    }
                    for(j = 0; j < o.dayCols; j++) {
                        this._fillDayCell(hw, date, previewMode);
                        date = wijDateOps.addDays(date, 1);
                    }
                    hw.writeEndTag('tr');
                }
                hw.writeEndTag('tbody');
                hw.writeEndTag('table');
                if(!tableOnly && !previewMode && this.showPreview) {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', 'wijmo-wijcalendar-nextpreview-button');
                    hw.writeAttribute('role', 'button');
                    hw.writeAttribute('aria-haspopup', 'true');
                    hw.writeAttribute('id', 'nextPreview');
                    hw.writeTagRightChar();
                    hw.writeBeginTag('a');
                    hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.uiIconGripDottedVertical);
                    hw.writeAttribute('href', '#');
                    hw.writeAttribute('title', o.nextPreviewTooltip);
                    hw.writeAttribute('aria-label', o.nextPreviewTooltip);
                    hw.writeAttribute('onclick', 'return false;');
                    hw.writeTagRightChar();
                    hw.write('&#160;');
                    hw.writeEndTag('a');
                    hw.writeEndTag('div');
                }
                return hw.toString();
            };
            return wijMonthView;
        })();
        calendar.wijMonthView = wijMonthView;        
        /** @ignore */
        var wijDateCollection = (function () {
            function wijDateCollection(calendar, optionName) {
                this._calendar = calendar;
                this._optionName = optionName ? optionName : 'selectedDates';
                this._normalize();
            }
            wijDateCollection.prototype.getDates = function () {
                if(this._calendar.options[this._optionName] === undefined) {
                    this._calendar.options[this._optionName] = [];
                }
                return this._calendar.options[this._optionName];
            };
            wijDateCollection.prototype.setDates = function (dates) {
                this._calendar.options[this._optionName] = dates;
                this._normalize();
            };
            wijDateCollection.prototype.getCount = function () {
                return this.getDates().length;
            };
            wijDateCollection.prototype.clear = function () {
                this.setDates([]);
            };
            wijDateCollection.prototype.add = function (date) {
                this.addRange(date, date);
            };
            wijDateCollection.prototype.remove = function (date) {
                this.removeRange(date, date);
            };
            wijDateCollection.prototype.indexOf = function (date) {
                if(!this.getCount()) {
                    return -1;
                }
                return this._findRangeBound(date, true, false);
            };
            wijDateCollection.prototype.contains = function (date) {
                return this.indexOf(date) !== -1;
            };
            wijDateCollection.prototype.removeRange = function (start, end) {
                if(!this.getCount()) {
                    return;
                }
                var startIndex = this._findRangeBound(start, false, true), endIndex = this._findRangeBound(end, false, false), dates, startSlice, endSlice;
                if(startIndex < 0 || endIndex < 0) {
                    return;
                }
                if(startIndex > endIndex) {
                    return;
                }
                dates = this.getDates();
                if(dates[endIndex] > end) {
                    return;
                }
                startSlice = (!startIndex) ? [] : dates.slice(0, startIndex);
                endSlice = endIndex >= (dates.length - 1) ? [] : dates.slice(endIndex + 1);
                this.setDates(startSlice.concat(endSlice));
            };
            wijDateCollection.prototype.addRange = function (start, end) {
                this.removeRange(start, end);
                var dates = this.getDates(), insertIndex = this._findRangeBound(start, false, true), startSlice = (!insertIndex) ? [] : dates.slice(0, insertIndex), endSlice = dates.slice(insertIndex), midSlice = [], curDate;
                start = wijDateOps.getDate(start);
                end = wijDateOps.getDate(end);
                for(curDate = start; curDate <= end; curDate = wijDateOps.addDays(curDate, 1)) {
                    midSlice[midSlice.length] = curDate;
                }
                this.setDates(startSlice.concat(midSlice.concat(endSlice)));
            };
            wijDateCollection.prototype._findRangeBound = function (date, exact, isStart) {
                var dates = this.getDates(), low = 0, hi = dates.length, index;
                while(low < hi) {
                    index = (low + hi) >> 1;
                    if(wijDateOps.isSameDate(date, dates[index])) {
                        return index;
                    }
                    if(date < dates[index]) {
                        hi = index;
                    } else {
                        low = index + 1;
                    }
                }
                if(exact) {
                    return -1;
                }
                return (isStart) ? low : hi;
            };
            wijDateCollection.prototype._parseDate = function (date) {
                var strDate;
                if(!date) {
                    date = new Date();
                } else {
                    if(typeof date === 'string') {
                        strDate = date;
                    }
                }
                if(strDate) {
                    strDate = strDate.replace(/-/g, '/');
                    try  {
                        date = new Date(strDate);
                        if(isNaN(date)) {
                            date = new Date();
                        }
                    } catch (e) {
                        date = new Date();
                    }
                }
                return date;
            };
            wijDateCollection.prototype._normalize = function () {
                //Normalize the array
                                var dates = this._calendar.options[this._optionName], self = this, newDates;
                if($.isArray(dates)) {
                    newDates = $.map(dates, function (d, i) {
                        return self._parseDate(d);
                    });
                    this._calendar.options[this._optionName] = newDates.sort(function (a, b) {
                        return a.getTime() - b.getTime();
                    });
                }
            };
            return wijDateCollection;
        })();
        calendar.wijDateCollection = wijDateCollection;        
        /** @ignore */
        var wijMyGrid = (function () {
            function wijMyGrid(calendar) {
                this.gridType = "month";
                this.calendar = calendar;
                if(calendar) {
                    this.culture = calendar._getCulture();
                }
            }
            wijMyGrid.prototype.select = function (index, value) {
                var date = this.calendar.getDisplayDate();
                switch(this.gridType) {
                    case "month":
                        date.setMonth(value);
                        break;
                    case "year":
                        date.setFullYear(value);
                        break;
                    case "decade":
                        date.setFullYear(value);
                        break;
                }
                this.calendar.options.displayDate = date;
            };
            wijMyGrid.prototype.getSelectedIndex = function () {
                var date = this.calendar.getDisplayDate(), year = date.getFullYear(), startYear = Math.floor(year / 10) * 10 - 1, startDecade = Math.floor(year / 100) * 100 - 10;
                switch(this.gridType) {
                    case "month":
                        return date.getMonth();
                    case "year":
                        return year - startYear;
                    case "decade":
                        return Math.floor((year - startDecade) / 10);
                }
                return 0;
            };
            wijMyGrid.prototype.getTitle = function () {
                var date = this.calendar.getDisplayDate(), year = date.getFullYear(), startYear = Math.floor(year / 10) * 10 - 1, startDecade = Math.floor(year / 100) * 100 - 10;
                switch(this.gridType) {
                    case "month":
                        return year.toString();
                    case "year":
                        return (startYear + 1) + " - " + (startYear + 10);
                    case "decade":
                        return (startDecade + 10) + " - " + (startDecade + 109);
                }
                return '';
            };
            wijMyGrid.prototype.getHtml = function (date, tableOnly) {
                if(date === undefined) {
                    date = this.calendar.getDisplayDate();
                } else {
                    if(typeof (date) === 'boolean') {
                        tableOnly = date;
                        date = this.calendar.getDisplayDate();
                    }
                }
                tableOnly = !!tableOnly;
                var o = this.calendar.options, rows = 3, cols = 4, hw = new htmlTextWriter(), wijCSS = o.wijCSS, height, year, startMonth, startYear, startDecade, ms, i, j, index, selected, outofRange, cellText, v, cls;
                if(o.showTitle && !tableOnly) {
                    hw.write(this.calendar._getHeaderHtml(null, true, true));
                }
                height = 100 / rows + '%';
                height = '30%';
                hw.writeBeginTag('table');
                hw.writeAttribute('class', wijCSS.datepickerCalendar + ' wijmo-wijcalendar-mygrid');
                hw.writeAttribute('role', 'grid');
                hw.writeAttribute('onselectstart', 'return false;');
                hw.writeTagRightChar();
                year = date.getFullYear();
                startMonth = date.getFullYear() * 12;
                startYear = Math.floor(year / 10) * 10 - 1;
                startDecade = Math.floor(year / 100) * 100 - 10;
                ms = this.culture.calendar.months;
                for(i = 0; i < rows; i++) {
                    hw.writeBeginTag('tr');
                    hw.writeAttribute('height', height);
                    hw.writeTagRightChar();
                    for(j = 0; j < cols; j++) {
                        index = i * 4 + j;
                        selected = false;
                        outofRange = false;
                        cellText = '';
                        v = null;
                        switch(this.gridType) {
                            case "month":
                                if(date.getMonth() === index) {
                                    selected = true;
                                }
                                v = index;
                                cellText = ms.namesAbbr[index];
                                outofRange = ((startMonth + index) < (o.minDate.getFullYear() * 12 + o.minDate.getMonth())) || ((startMonth + index) > (o.maxDate.getFullYear() * 12 + o.maxDate.getMonth()));
                                break;
                            case "year":
                                if(index === 0 || index === 11) {
                                    outofRange = true;
                                }
                                v = startYear + index;
                                if(v < o.minDate.getFullYear() || v > o.maxDate.getFullYear()) {
                                    outofRange = true;
                                } else {
                                    selected = (year === v);
                                }
                                cellText = v.toString();
                                break;
                            case "decade":
                                if(index === 0 || index === 11) {
                                    outofRange = true;
                                }
                                v = startDecade + index * 10;
                                if(v + 10 < o.minDate.getFullYear() || v > o.maxDate.getFullYear()) {
                                    outofRange = true;
                                } else {
                                    selected = (year >= v && year < (v + 10));
                                }
                                cellText = v.toString() + '-<br/>' + (v + 9).toString();
                                break;
                        }
                        cls = wijCSS.datepickerWeekDay;
                        if(outofRange) {
                            cls = cls + ' ' + wijCSS.datepickerOtherMonth + ' ' + wijCSS.prioritySecondary + ' ' + wijCSS.datepickerUnselectable;
                        } else {
                            if(!o.disabledState && !o.disabled) {
                                cls += " wijmo-wijcalendar-day-selectable";
                            }
                        }
                        cls += " " + wijCSS.stateDefault + (outofRange ? ' ' + wijCSS.stateDisabled : '') + (selected ? ' ' + wijCSS.stateActive + ' ' + wijCSS.stateHighlight : '');
                        hw.writeBeginTag('td');
                        hw.writeAttribute('class', cls);
                        hw.writeAttribute('role', 'gridcell');
                        //hw.writeAttribute('width', width);
                        hw.writeAttribute('index', index.toString());
                        hw.writeAttribute('value', v.toString());
                        hw.writeAttribute('other', outofRange.toString());
                        hw.writeTagRightChar();
                        hw.writeBeginTag('a');
                        hw.writeAttribute('href', '#');
                        hw.writeTagRightChar();
                        hw.write(cellText);
                        hw.writeEndTag('a');
                        hw.writeEndTag('td');
                    }
                    hw.writeEndTag('tr');
                }
                hw.writeEndTag('table');
                return hw.toString();
            };
            return wijMyGrid;
        })();
        calendar.wijMyGrid = wijMyGrid;        
    })(wijmo.calendar || (wijmo.calendar = {}));
    var calendar = wijmo.calendar;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
var wijmo;
(function (wijmo) {
    (function (input) {
        /** @ignore */
        var CharType = (function () {
            function CharType() {
                /// <summary>
                ///   Indicates that the character is not of a particular category.
                /// </summary>
                this.OtherChar = 0x0000;
                /// <summary>
                ///   Indicates that the character is a control code.
                /// </summary>
                this.Control = 0x0001;
                /// <summary>
                ///   Indicates that the character is a numeric digit.
                /// </summary>
                this.Numeric = 0x0002;
                /// <summary>
                ///   Indicates that the character is a mathematical symbol.
                /// </summary>
                this.MathSymbol = 0x0003;
                /// <summary>
                ///   Indicates that the character is a symbol.
                /// </summary>
                this.Symbol = 0x0004;
                /// <summary>
                ///   Indicates that the character is a punctuation. ( Open &amp; Close )
                /// </summary>
                this.Punctuation = 0x0005;
                /// <summary>
                ///   Indicates that the character is a space character.
                /// </summary>
                this.Space = 0x0006;
                /// <summary>
                ///   Indicates that the character is an upper case letter.
                /// </summary>
                this.UpperCase = 0x0007;
                /// <summary>
                ///   Indicates that the character is a lower case letter.
                /// </summary>
                this.LowerCase = 0x0008;
                /// <summary>
                ///   Indicates that the character is a Japanese Katakana character.
                /// </summary>
                this.Katakana = 0x0009;
                /// <summary>
                ///   Indicates that the character is a Japanese Hiragana character.
                /// </summary>
                this.Hiragana = 0x000a;
                /// <summary>
                ///   Indicates that the character is a CJK punctuation.
                /// </summary>
                this.FarEastPunctation = 0x000b;
                /// <summary>
                ///   Indicates that the character is a Hangal character.
                /// </summary>
                this.Hangul = 0x000c;
                /// <summary>
                ///   Indicates that the character is of full width.
                /// </summary>
                this.FullWidth = 0x8000;
            }
            return CharType;
        })();
        input.CharType = CharType;        
        /** @ignore */
        var CharCategory = (function () {
            function CharCategory() {
                // Min & Max values ----------------------------------
                ///   Represents the smallest possible value of a Char.
                ///   This field is constant.
                this.MinValue = '\u0000';
                ///   Represents the largest possible value of a Char.
                ///   This field is constant.
                this.MaxValue = '\uffff';
                //Full/HalfWidth characters (different cultures)------
                this.ANSISTART = 0x0000;
                this.ANSIEND = 0x00ff;
                this.BOTHWIDTHSTART = 0xff00;
                this.BOTHWIDTHEND = 0xffef;
                this.FULLALPHASTART = 0xff01;
                this.FULLUPPERSTART = 0xff21;
                this.FULLUPPEREND = 0xff3a;
                this.FULLALPHAEND = 0xff5e;
                this.CJKHALFSYMBOLSTART = 0xff61;
                this.CJKHALFSYMBOLEND = 0xff64;
                this.KANAHALFSTART = 0xff65;
                this.KANAHALFEND = 0xff9f;
                this.HANGULHALFSTART = 0xffa0;
                this.HANGULHALFEND = 0xffdc;
                this.FULLSYMBOLSTART = 0xffe0;
                this.FULLSYMBOLEND = 0xffe6;
                this.HALFPUNCTSTART = 0xffe8;
                this.HALFPUNCTEND = 0xffee;
                // Voiced characters (Japanese)------------------------
                this.KATAKANA_VOICED = '\uff9e';
                this.KATAKANA_SEMIVOICED = '\uff9f';
                //Others-----------------------------------------------
                this.Tab = '\u0009';
                this.Space = '\u0020';
                //>>> Static Data (tables) ----------------------------
                // Character Groups...
                ///   Character groups (character codes) based on Unicode 3.1.
                this._charstarts = [
                    '\u0000', 
                    // Basic Latin
                    '\u0080', 
                    // Latin 1 Supplement
                    '\u0100', 
                    // Latin Extended - A
                    '\u0180', 
                    // Latin Extended - B
                    '\u0250', 
                    // IPA extensions
                    '\u02b0', 
                    // Spacing Modifier Letters
                    '\u0300', 
                    // Combining Diacritical Marks
                    '\u0370', 
                    // Greek
                    '\u0400', 
                    // Cyrillic
                    '\u0530', 
                    // Armenian
                    '\u0590', 
                    // Hebrew
                    '\u0600', 
                    // Arabic
                    '\u0700', 
                    // Syriac
                    '\u0780', 
                    // Thaana
                    '\u0900', 
                    // Devanagari
                    '\u0980', 
                    // Bengali
                    '\u0a00', 
                    // Gurmukhi
                    '\u0a80', 
                    // Gujarati
                    '\u0b00', 
                    // Oriya
                    '\u0b80', 
                    // Tamil
                    '\u0c00', 
                    // Telugu
                    '\u0c80', 
                    // Kannada
                    '\u0d00', 
                    // Malayalam
                    '\u0d80', 
                    // Sinhala
                    '\u0e00', 
                    // Thai
                    '\u0e80', 
                    // Lao
                    '\u0f00', 
                    // Tibetan
                    '\u1000', 
                    // Myanmar
                    '\u10a0', 
                    // Georgian
                    '\u1100', 
                    // Hangal Jamo
                    '\u1200', 
                    // Ethiopic
                    '\u13a0', 
                    // Cherokee
                    '\u1400', 
                    // Unified Canadian Aboriginal Syllabic
                    '\u1680', 
                    // Ogham
                    '\u16a0', 
                    // Runic
                    '\u1780', 
                    // Khmer
                    '\u1800', 
                    // Mongolian
                    '\u1e00', 
                    // Latin Extended Additional
                    '\u1f00', 
                    // Greek Extended
                    '\u2000', 
                    // General Punctuation
                    '\u2070', 
                    // Superscripts and Subscripts
                    '\u20a0', 
                    // Currency Symbols
                    '\u20d0', 
                    // Combining Marks for Symbols
                    '\u2100', 
                    // Letter like Symbols
                    '\u2150', 
                    // Number Forms
                    '\u2190', 
                    // Arrows
                    '\u2200', 
                    // Mathematical operators
                    '\u2300', 
                    // Miscellaneous Technical
                    '\u2400', 
                    // Control Pictures
                    '\u2440', 
                    // Optical Character Recognition
                    '\u2460', 
                    // Enclosed AlphaNumerics
                    '\u2500', 
                    // Box drawing
                    '\u2580', 
                    // Block Elements
                    '\u25a0', 
                    // Geometric Shapes
                    '\u2600', 
                    // Miscellaneous Symbols
                    '\u2700', 
                    // Dingbats
                    '\u2800', 
                    // Braille Patterns
                    '\u2e80', 
                    // CJK Radicals Supplement
                    '\u2f00', 
                    // Kangxi Radicals
                    '\u2ff0', 
                    // Ideographic Description Characters
                    '\u3000', 
                    // CJK Symbols and Punctuations
                    '\u3040', 
                    // Hiragana
                    '\u30a0', 
                    // Katakana
                    '\u3100', 
                    // Bopomofo
                    '\u3130', 
                    // Hangal Compatibility Jamo
                    '\u3190', 
                    // Kanbun
                    '\u31a0', 
                    // Bopomofo Extended
                    '\u3200', 
                    // Enclosed CJK Letters and Months
                    '\u3300', 
                    // CJK Compatiblity
                    '\u3400', 
                    // CJK Unified Ideographs Extension
                    '\u4e00', 
                    // CJK Undified Ideographs
                    '\ua000', 
                    // Yi Syllables
                    '\ua490', 
                    // Yi Radicals
                    '\uac00', 
                    // Hangul Syllables
                    '\uf900', 
                    // CJK Compatible Ideographs
                    '\ufb00', 
                    // Alphabetic Presentation Forms
                    '\ufb50', 
                    // Arabic Presentation Forms A
                    '\ufe20', 
                    // Combining Half Marks
                    '\ufe30', 
                    // CJK Compatiblity Form
                    '\ufe50', 
                    // Small Form Variants
                    '\ufe70', 
                    // Arabi Presentation Forms B
                    '\uff00', 
                    // Halfwidth and Fullwidth Forms
                    '\ufff0'
                ];// Specials
                
                //Character Block Categories...
                ///   Character blocks categorized base on the Unicode standard.
                this.Blocks = [
                    'BASIC_LATIN', 
                    'LATIN_1_SUPPLEMENT', 
                    'LATIN_EXTENDED_A', 
                    'LATIN_EXTENDED_B', 
                    'IPA_EXTENSIONS', 
                    'SPACING_MODIFIER_LETTERS', 
                    'COMBINING_DIACRITICAL_MARKS', 
                    'GREEK', 
                    'CYRILLIC', 
                    'ARMENIAN', 
                    'HEBREW', 
                    'ARABIC', 
                    'SYRIAC', 
                    'THAANA', 
                    'DEVANAGARI', 
                    'BENGALI', 
                    'GURMUKHI', 
                    'GUJARATI', 
                    'ORIYA', 
                    'TAMIL', 
                    'TELUGU', 
                    'KANNADA', 
                    'MALAYALAM', 
                    'SINHALA', 
                    'THAI', 
                    'LAO', 
                    'TIBETAN', 
                    'MYANMAR', 
                    'GEORGIAN', 
                    'HANGUL_JAMO', 
                    'ETHIOPIC', 
                    'CHEROKEE', 
                    'UNIFIED_CANADIAN_ABORIGINAL_SYLLABIC', 
                    'OGHAM', 
                    'RUNIC', 
                    'KUMER', 
                    'MONGOLIAN', 
                    'LATIN_EXTENDED_ADDITIONAL', 
                    'GREEK_EXTENDED', 
                    'GENERAL_PUNCTUATION', 
                    'SUPERSCRIPTS_AND_SUBSCRIPTS', 
                    'CURRENCY_SYMBOLS', 
                    'COMBINING_MARKS_FOR_SYMBOLS', 
                    'LETTERLIKE_SYMBOLS', 
                    'NUMBER_FORMS', 
                    'ARROWS', 
                    'MATHEMATICAL_OPERATORS', 
                    'MISCELLANEOUS_TECHNICAL', 
                    'CONTROL_PICTURES', 
                    'OPTICAL_CHARACTER_RECOGNITION', 
                    'ENCLOSED_ALPHANUMERICS', 
                    'BOX_DRAWING', 
                    'BLOCK_ELEMENTS', 
                    'GEOMETRIC_SHAPES', 
                    'MISCELLANEOUS_SYMBOLS', 
                    'DINGBATS', 
                    'BRAILLE_PATTERNS', 
                    'CJK_RADICALS_SUPPLEMENT', 
                    'KANGXI_RADICALS', 
                    'IDEOGRAPHIC_DESCRIPTION_CHARACTERS', 
                    'CJK_SYMBOLS_AND_PUNCTUATION', 
                    'HIRAGANA', 
                    'KATAKANA', 
                    'BOPOMOFO', 
                    'HANGUL_COMPATIBILITY_JAMO', 
                    'KANBUN', 
                    'BOPOMOFO_EXTENDED', 
                    'ENCLOSED_CJK_LETTERS_AND_MONTHS', 
                    'CJK_COMPATIBILITY', 
                    'CJK_UNIFIED_IDEOGRAPHS_EXTENSION', 
                    'CJK_UNIFIED_IDEOGRAPHS', 
                    'YI_SYLLABLES', 
                    'YI_RADICALS', 
                    'HANGUL_SYLLABLES', 
                    'CJK_COMPATIBILITY_IDEOGRAPHS', 
                    'ALPHABETIC_PRESENTATION_FORMS', 
                    'ARABIC_PRESENTATION_FORMS_A', 
                    'COMBINING_HALF_MARKS', 
                    'CJK_COMPATIBILITY_FORMS', 
                    'SMALL_FORM_VARIANTS', 
                    'ARABIC_PRESENTATION_FORMS_B', 
                    'HALFWIDTH_AND_FULLWIDTH_FORMS', 
                    'SPECIALS'
                ];
                // Multi width character block mapping table...
                ///   Table of multi-width character blocks.
                this._fullhalfblocks = [
                    '\uff01', 
                    // Symbols
                    '\uff10', 
                    // Numbers
                    '\uff1a', 
                    // Symbols
                    '\uff21', 
                    // Uppercase
                    '\uff3b', 
                    // Symbols
                    '\uff41', 
                    // Lowercase
                    '\uff5b', 
                    // Symbols
                    '\uff61', 
                    // CJK Halfwidth Punctuation
                    '\uff65', 
                    // Halfwidth Katakana
                    '\uffa0', 
                    // Halfwidth Hangal
                    '\uffe0', 
                    // Fullwidth symbol variants
                    '\uffe8'
                ];// Halfwidth symbol variants
                
                // Half width Katakana map table...
                ///   Mapping table of full width Katakana.
                this._halfkana = [
                    '\u30fb', 
                    '\u30f2', 
                    // ., small o
                    '\u30a1', 
                    '\u30a3', 
                    '\u30a5', 
                    '\u30a7', 
                    '\u30a9', 
                    // small a
                    '\u30e3', 
                    '\u30e5', 
                    '\u30e7', 
                    // small ya
                    '\u30c3', 
                    '\u30fc', 
                    // small tu, -
                    '\u30a2', 
                    '\u30a4', 
                    '\u30a6', 
                    '\u30a8', 
                    '\u30aa', 
                    // a
                    '\u30ab', 
                    '\u30ad', 
                    '\u30af', 
                    '\u30b1', 
                    '\u30b3', 
                    // ka
                    '\u30b5', 
                    '\u30b7', 
                    '\u30b9', 
                    '\u30bb', 
                    '\u30bd', 
                    // sa
                    '\u30bf', 
                    '\u30c1', 
                    '\u30c4', 
                    '\u30c6', 
                    '\u30c8', 
                    // ta
                    '\u30ca', 
                    '\u30cb', 
                    '\u30cc', 
                    '\u30cd', 
                    '\u30ce', 
                    // na
                    '\u30cf', 
                    '\u30d2', 
                    '\u30d5', 
                    '\u30d8', 
                    '\u30db', 
                    // ha
                    '\u30de', 
                    '\u30df', 
                    '\u30e0', 
                    '\u30e1', 
                    '\u30e2', 
                    // ma
                    '\u30e4', 
                    '\u30e6', 
                    '\u30e8', 
                    // ya
                    '\u30e9', 
                    '\u30ea', 
                    '\u30eb', 
                    '\u30ec', 
                    '\u30ed', 
                    // ra
                    '\u30ef', 
                    '\u30f3', 
                    // wa
                    '\u3099', 
                    '\u309a'
                ];// daku-on
                
                // Full width Katakana map table...
                ///   Mapping table of half-width Katakana.
                this._fullkana = [
                    '\uff67', 
                    '\uff71', 
                    '\uff68', 
                    '\uff72', 
                    '\uff69', 
                    '\uff73', 
                    //a
                    '\uff6a', 
                    '\uff74', 
                    '\uff6b', 
                    '\uff75', 
                    '\uff76', 
                    '\uff76', 
                    '\uff77', 
                    '\uff77', 
                    '\uff78', 
                    '\uff78', 
                    // ka
                    '\uff79', 
                    '\uff79', 
                    '\uff7a', 
                    '\uff7a', 
                    '\uff7b', 
                    '\uff7b', 
                    '\uff7c', 
                    '\uff7c', 
                    '\uff7d', 
                    '\uff7d', 
                    // sa
                    '\uff7e', 
                    '\uff7e', 
                    '\uff7f', 
                    '\uff7f', 
                    '\uff80', 
                    '\uff80', 
                    '\uff81', 
                    '\uff81', 
                    '\uff6f', 
                    '\uff82', 
                    // ta
                    '\uff82', 
                    '\uff83', 
                    '\uff83', 
                    '\uff84', 
                    '\uff84', 
                    '\uff85', 
                    '\uff86', 
                    '\uff87', 
                    '\uff88', 
                    '\uff89', 
                    // na
                    '\uff8a', 
                    '\uff8a', 
                    '\uff8a', 
                    '\uff8b', 
                    '\uff8b', 
                    '\uff8b', 
                    // ha
                    '\uff8c', 
                    '\uff8c', 
                    '\uff8c', 
                    '\uff8d', 
                    '\uff8d', 
                    '\uff8d', 
                    '\uff8e', 
                    '\uff8e', 
                    '\uff8e', 
                    '\uff8f', 
                    '\uff90', 
                    '\uff91', 
                    '\uff92', 
                    '\uff93', 
                    // ma
                    '\uff6c', 
                    '\uff94', 
                    '\uff6d', 
                    '\uff95', 
                    '\uff6e', 
                    '\uff96', 
                    // ya
                    '\uff97', 
                    '\uff98', 
                    '\uff99', 
                    '\uff9a', 
                    '\uff9b', 
                    // ra
                    '\uff9c', 
                    '\uff9c', 
                    '\uff68', 
                    '\uff6a', 
                    '\uff66', 
                    '\uff9d', 
                    // wa,... un
                    //modified by sj for NKOI-8C7E84AA2
                    //'\uff73', '\uff68', '\uff6c', '\uff9c', '\uff68', '\uff6a',
                    '\uff73', 
                    '\uff76', 
                    '\uff79', 
                    '\uff9c', 
                    '\uff68', 
                    '\uff6a', 
                    //end by sj
                    '\uff66', 
                    '\uff65', 
                    '\uff70'
                ];
                this._fullkanaSmall = [
                    '\uff67', 
                    '\uff68', 
                    '\uff69', 
                    '\uff6a', 
                    '\uff6b', 
                    '\uff6c', 
                    '\uff6d', 
                    '\uff6e', 
                    '\uff6f'
                ];
                // Voiced (accent) map table (Japanese)...
                ///   Mapping table for accents for the Japanese language.
                this._accentkana = [
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    // a
                    -1, 
                    1, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    // ka
                    -1, 
                    1, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    // sa
                    -1, 
                    1, 
                    -1, 
                    1, 
                    0, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    -1, 
                    1, 
                    // ta
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    // na
                    -3, 
                    1, 
                    2, 
                    -3, 
                    1, 
                    2, 
                    -3, 
                    1, 
                    2, 
                    -3, 
                    1, 
                    2, 
                    -3, 
                    1, 
                    2, 
                    // ha
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    // ma
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    // ya
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    // ra
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    // wa,...un
                    1, 
                    0, 
                    0, 
                    1, 
                    1, 
                    1, 
                    1, 
                    0, 
                    0
                ];
                // Special quotations for FarEast...
                this._feQuotes = [
                    '\u2018', 
                    '\u2019', 
                    '\u201c', 
                    '\u201d'
                ];
                // Katakana & Hiragana mixed characters (Japanese)...
                this._jpnMixed = [
                    '\u30fc'
                ];
                // Full / Half width special character map table...
                this._jpnSpecialFull = [
                    '\u3000', 
                    // Space
                    '\u3001', 
                    // Comma
                    '\u3002', 
                    // Stop (Period)
                    '\u300c', 
                    // Left bracket
                    '\u300d', 
                    // Right bracket
                    '\u201c', 
                    // Double Quotes
                    '\u201d', 
                    //     "
                    '\u2018', 
                    // Single Quotes
                    '\u2019', 
                    //	   "
                    '\u309b', 
                    // JPN Voiced (heavy)
                    '\u309c', 
                    // JPN Voiced (light)
                    '\uffe5'
                ];// yen mark !
                
                this._jpnSpecialHalf = [
                    '\u0020', 
                    // Space
                    '\uff64', 
                    // Comma
                    '\uff61', 
                    // Stop (Period)
                    '\uff62', 
                    // Left bracket
                    '\uff63', 
                    // Right bracket
                    '\u0022', 
                    // Double Quotes
                    '\u0022', 
                    //     "
                    '\u0027', 
                    // Single Quotes
                    '\u0027', 
                    //	   "
                    '\uff9e', 
                    // JPN Voiced (heavy)
                    '\uff9f', 
                    // JPN Voiced (light)
                    '\u00a5'
                ];// yen mark !
                
                var _charType = new CharType();
                this._mwtable = [
                    _charType.Symbol | _charType.FullWidth, 
                    _charType.Numeric | _charType.FullWidth, 
                    _charType.Symbol | _charType.FullWidth, 
                    _charType.UpperCase | _charType.FullWidth, 
                    _charType.Symbol | _charType.FullWidth, 
                    _charType.LowerCase | _charType.FullWidth, 
                    _charType.Symbol | _charType.FullWidth, 
                    _charType.FarEastPunctation, 
                    _charType.Katakana, 
                    _charType.Hangul, 
                    _charType.Symbol | _charType.FullWidth, 
                    _charType.Symbol
                ];
            }
            return CharCategory;
        })();
        input.CharCategory = CharCategory;        
        /** @ignore */
        var CharProcess = (function () {
            function CharProcess() {
                this.CharCategory = new CharCategory();
                this.Ctype = new CharType();
            }
            CharProcess.LowerKana = "\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\uff67\uff68\uff69\uff6a\uff6b\uff6c\uff6d\uff6e\uff6f\u30F5\u30F6\u3095\u3096";
            CharProcess.UpperKana = "\u3042\u3044\u3046\u3048\u304a\u3064\u3084\u3086\u3088\u308f\u30a2\u30a4\u30a6\u30a8\u30aa\u30c4\u30e4\u30e6\u30e8\u30ef\uff71\uff72\uff73\uff74\uff75\uff94\uff95\uff96\uff82\u30AB\u30B1\u304B\u3051";
            CharProcess.FullWidthSymbolArray = [
                //'\u3000',	//IDEOGRAPHIC SPACE
                '\u3001', 
                //IDEOGRAPHIC COMMA
                '\u3002', 
                //IDEOGRAPHIC FULL STOP
                '\uFF0C', 
                //FULLWIDTH COMMA
                '\uFF0E', 
                //FULLWIDTH FULL STOP
                '\u30FB', 
                //KATAKANA MIDDLE DOT
                '\uFF1A', 
                //FULLWIDTH COLON
                '\uFF1B', 
                //FULLWIDTH SEMICOLON
                '\uFF1F', 
                //FULLWIDTH QUESTION MARK
                '\uFF01', 
                //FULLWIDTH EXCLAMATION MARK
                '\u309B', 
                //KATAKANA-HIRAGANA VOICED SOUND MARK
                '\u309C', 
                //KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
                '\u00B4', 
                //ACUTE ACCENT
                '\uFF40', 
                //FULLWIDTH GRAVE ACCENT
                '\u00A8', 
                //DIAERESIS
                '\uFF3E', 
                //FULLWIDTH CIRCUMFLEX ACCENT
                '\uFFE3', 
                //FULLWIDTH MACRON
                '\uFF3F', 
                //FULLWIDTH LOW LINE
                '\u30FD', 
                //KATAKANA ITERATION MARK
                '\u30FE', 
                //KATAKANA VOICED ITERATION MARK
                '\u309D', 
                //HIRAGANA ITERATION MARK
                '\u309E', 
                //HIRAGANA VOICED ITERATION MARK
                '\u3003', 
                //DITTO MARK
                '\u4EDD', 
                //<cjk>
                '\u3005', 
                //IDEOGRAPHIC ITERATION MARK
                '\u3006', 
                //IDEOGRAPHIC CLOSING MARK
                '\u3007', 
                //IDEOGRAPHIC NUMBER ZERO
                '\u30FC', 
                //KATAKANA-HIRAGANA PROLONGED SOUND MARK
                '\u2014', 
                //EM DASH	Windows: U+2015
                '\u2010', 
                //HYPHEN
                '\uFF0F', 
                //FULLWIDTH SOLIDUS
                //'\u005C',	//REVERSE SOLIDUS	Fullwidth: U+FF3C
                '\u301C', 
                //WAVE DASH	Windows: U+FF5E
                '\u2016', 
                //DOUBLE VERTICAL LINE	Windows: U+2225
                '\uFF5C', 
                //FULLWIDTH VERTICAL LINE
                '\u2026', 
                //HORIZONTAL ELLIPSIS
                '\u2025', 
                //TWO DOT LEADER
                '\u2018', 
                //LEFT SINGLE QUOTATION MARK
                '\u2019', 
                //RIGHT SINGLE QUOTATION MARK
                '\u201C', 
                //LEFT DOUBLE QUOTATION MARK
                '\u201D', 
                //RIGHT DOUBLE QUOTATION MARK
                '\uFF08', 
                //FULLWIDTH LEFT PARENTHESIS
                '\uFF09', 
                //FULLWIDTH RIGHT PARENTHESIS
                '\u3014', 
                //LEFT TORTOISE SHELL BRACKET
                '\u3015', 
                //RIGHT TORTOISE SHELL BRACKET
                '\uFF3B', 
                //FULLWIDTH LEFT SQUARE BRACKET
                '\uFF3D', 
                //FULLWIDTH RIGHT SQUARE BRACKET
                '\uFF5B', 
                //FULLWIDTH LEFT CURLY BRACKET
                '\uFF5D', 
                //FULLWIDTH RIGHT CURLY BRACKET
                '\u3008', 
                //LEFT ANGLE BRACKET
                '\u3009', 
                //RIGHT ANGLE BRACKET
                '\u300A', 
                //LEFT DOUBLE ANGLE BRACKET
                '\u300B', 
                //RIGHT DOUBLE ANGLE BRACKET
                '\u300C', 
                //LEFT CORNER BRACKET
                '\u300D', 
                //RIGHT CORNER BRACKET
                '\u300E', 
                //LEFT WHITE CORNER BRACKET
                '\u300F', 
                //RIGHT WHITE CORNER BRACKET
                '\u3010', 
                //LEFT BLACK LENTICULAR BRACKET
                '\u3011', 
                //RIGHT BLACK LENTICULAR BRACKET
                '\uFF0B', 
                //FULLWIDTH PLUS SIGN
                '\u2212', 
                //MINUS SIGN	Windows: U+FF0D
                '\u00B1', 
                //PLUS-MINUS SIGN
                '\u00D7', 
                //MULTIPLICATION SIGN
                '\u00F7', 
                //DIVISION SIGN
                '\uFF1D', 
                //FULLWIDTH EQUALS SIGN
                '\u2260', 
                //NOT EQUAL TO
                '\uFF1C', 
                //FULLWIDTH LESS-THAN SIGN
                '\uFF1E', 
                //FULLWIDTH GREATER-THAN SIGN
                '\u2266', 
                //LESS-THAN OVER EQUAL TO
                '\u2267', 
                //GREATER-THAN OVER EQUAL TO
                '\u221E', 
                //INFINITY
                '\u2234', 
                //THEREFORE
                '\u2642', 
                //MALE SIGN
                '\u2640', 
                //FEMALE SIGN
                '\u00B0', 
                //DEGREE SIGN
                '\u2032', 
                //PRIME
                '\u2033', 
                //DOUBLE PRIME
                '\u2103', 
                //DEGREE CELSIUS
                '\uFFE5', 
                //FULLWIDTH YEN SIGN
                '\uFF04', 
                //FULLWIDTH DOLLAR SIGN
                '\u00A2', 
                //CENT SIGN	Windows: U+FFE0
                '\u00A3', 
                //POUND SIGN	Windows: U+FFE1
                '\uFF05', 
                //FULLWIDTH PERCENT SIGN
                '\uFF03', 
                //FULLWIDTH NUMBER SIGN
                '\uFF06', 
                //FULLWIDTH AMPERSAND
                '\uFF0A', 
                //FULLWIDTH ASTERISK
                '\uFF20', 
                //FULLWIDTH COMMERCIAL AT
                '\u00A7', 
                //SECTION SIGN
                '\u2606', 
                //WHITE STAR
                '\u2605', 
                //BLACK STAR
                '\u25CB', 
                //WHITE CIRCLE
                '\u25CF', 
                //BLACK CIRCLE
                '\u25CE', 
                //BULLSEYE
                '\u25C7', 
                //WHITE DIAMOND
                '\u25C6', 
                //BLACK DIAMOND
                '\u25A1', 
                //WHITE SQUARE
                '\u25A0', 
                //BLACK SQUARE
                '\u25B3', 
                //WHITE UP-POINTING TRIANGLE
                '\u25B2', 
                //BLACK UP-POINTING TRIANGLE
                '\u25BD', 
                //WHITE DOWN-POINTING TRIANGLE
                '\u25BC', 
                //BLACK DOWN-POINTING TRIANGLE
                '\u203B', 
                //REFERENCE MARK
                '\u3012', 
                //POSTAL MARK
                '\u2192', 
                //RIGHTWARDS ARROW
                '\u2190', 
                //LEFTWARDS ARROW
                '\u2191', 
                //UPWARDS ARROW
                '\u2193', 
                //DOWNWARDS ARROW
                '\u3013', 
                //GETA MARK
                '\uFF07', 
                //FULLWIDTH APOSTROPHE
                '\uFF02', 
                //FULLWIDTH QUOTATION MARK	[2000]
                '\uFF0D', 
                //FULLWIDTH HYPHEN-MINUS	[2000]
                //'\u007E',	//TILDE	[2000]	Fullwidth: U+FF5E
                '\u3033', 
                //VERTICAL KANA REPEAT MARK UPPER HALF	[2000]
                '\u3034', 
                //VERTICAL KANA REPEAT WITH VOICED SOUND MARK UPPER HALF	[2000]
                '\u3035', 
                //VERTICAL KANA REPEAT MARK LOWER HALF	[2000]
                '\u303B', 
                //VERTICAL IDEOGRAPHIC ITERATION MARK	[2000]	[Unicode3.2]
                '\u303C', 
                //MASU MARK	[2000]	[Unicode3.2]
                '\u30FF', 
                //KATAKANA DIGRAPH KOTO	[2000]	[Unicode3.2]
                '\u309F', 
                //HIRAGANA DIGRAPH YORI	[2000]	[Unicode3.2]
                '\u2208', 
                //ELEMENT OF	[1983]
                '\u220B', 
                //CONTAINS AS MEMBER	[1983]
                '\u2286', 
                //SUBSET OF OR EQUAL TO	[1983]
                '\u2287', 
                //SUPERSET OF OR EQUAL TO	[1983]
                '\u2282', 
                //SUBSET OF	[1983]
                '\u2283', 
                //SUPERSET OF	[1983]
                '\u222A', 
                //UNION	[1983]
                '\u2229', 
                //INTERSECTION	[1983]
                '\u2284', 
                //NOT A SUBSET OF	[2000]
                '\u2285', 
                //NOT A SUPERSET OF	[2000]
                '\u228A', 
                //SUBSET OF WITH NOT EQUAL TO	[2000]
                '\u228B', 
                //SUPERSET OF WITH NOT EQUAL TO	[2000]
                '\u2209', 
                //NOT AN ELEMENT OF	[2000]
                '\u2205', 
                //EMPTY SET	[2000]
                '\u2305', 
                //PROJECTIVE	[2000]
                '\u2306', 
                //PERSPECTIVE	[2000]
                '\u2227', 
                //LOGICAL AND	[1983]
                '\u2228', 
                //LOGICAL OR	[1983]
                '\u00AC', 
                //NOT SIGN	[1983]	Windows: U+FFE2
                '\u21D2', 
                //RIGHTWARDS DOUBLE ARROW	[1983]
                '\u21D4', 
                //LEFT RIGHT DOUBLE ARROW	[1983]
                '\u2200', 
                //FOR ALL	[1983]
                '\u2203', 
                //THERE EXISTS	[1983]
                '\u2295', 
                //CIRCLED PLUS	[2000]
                '\u2296', 
                //CIRCLED MINUS	[2000]
                '\u2297', 
                //CIRCLED TIMES	[2000]
                '\u2225', 
                //PARALLEL TO	[2000]
                '\u2226', 
                //NOT PARALLEL TO	[2000]
                '\u2985', 
                //LEFT WHITE PARENTHESIS	[2000]	[Unicode3.2]
                '\u2986', 
                //RIGHT WHITE PARENTHESIS	[2000]	[Unicode3.2]
                '\u3018', 
                //LEFT WHITE TORTOISE SHELL BRACKET	[2000]
                '\u3019', 
                //RIGHT WHITE TORTOISE SHELL BRACKET	[2000]
                '\u3016', 
                //LEFT WHITE LENTICULAR BRACKET	[2000]
                '\u3017', 
                //RIGHT WHITE LENTICULAR BRACKET	[2000]
                '\u2220', 
                //ANGLE	[1983]
                '\u22A5', 
                //UP TACK	[1983]
                '\u2312', 
                //ARC	[1983]
                '\u2202', 
                //PARTIAL DIFFERENTIAL	[1983]
                '\u2207', 
                //NABLA	[1983]
                '\u2261', 
                //IDENTICAL TO	[1983]
                '\u2252', 
                //APPROXIMATELY EQUAL TO OR THE IMAGE OF	[1983]
                '\u226A', 
                //MUCH LESS-THAN	[1983]
                '\u226B', 
                //MUCH GREATER-THAN	[1983]
                '\u221A', 
                //SQUARE ROOT	[1983]
                '\u223D', 
                //REVERSED TILDE 	[1983]
                '\u221D', 
                //PROPORTIONAL TO	[1983]
                '\u2235', 
                //BECAUSE	[1983]
                '\u222B', 
                //INTEGRAL	[1983]
                '\u222C', 
                //DOUBLE INTEGRAL	[1983]
                '\u2262', 
                //NOT IDENTICAL TO	[2000]
                '\u2243', 
                //ASYMPTOTICALLY EQUAL TO	[2000]
                '\u2245', 
                //APPROXIMATELY EQUAL TO	[2000]
                '\u2248', 
                //ALMOST EQUAL TO	[2000]
                '\u2276', 
                //LESS-THAN OR GREATER-THAN	[2000]
                '\u2277', 
                //GREATER-THAN OR LESS-THAN	[2000]
                '\u2194', 
                //LEFT RIGHT ARROW	[2000]
                '\u212B', 
                //ANGSTROM SIGN	[1983]
                '\u2030', 
                //PER MILLE SIGN	[1983]
                '\u266F', 
                //MUSIC SHARP SIGN	[1983]
                '\u266D', 
                //MUSIC FLAT SIGN	[1983]
                '\u266A', 
                //EIGHTH NOTE	[1983]
                '\u2020', 
                //DAGGER	[1983]
                '\u2021', 
                //DOUBLE DAGGER	[1983]
                '\u00B6', 
                //PILCROW SIGN	[1983]
                '\u266E', 
                //MUSIC NATURAL SIGN	[2000]
                '\u266B', 
                //BEAMED EIGHTH NOTES	[2000]
                '\u266C', 
                //BEAMED SIXTEENTH NOTES	[2000]
                '\u2669', 
                //QUARTER NOTE	[2000]
                '\u25EF', 
                //LARGE CIRCLE	[1983]
                // Added by shen yuan at 2005-10-26
                '\uFF3C', 
                // ''
                '\uFF5E', 
                // ''
                '\uFFE0', 
                // 'E
                '\uFFE1', 
                // 'E
                '\uFFE2', 
                // 'V'
                '\u2015'
            ];
            CharProcess.HalfWidthSymbolArray = [
                '\u005C', 
                //REVERSE SOLIDUS	Fullwidth: U+FF3C
                '\u007E', 
                //TILDE	[2000]	Fullwidth: U+FF5E
                //'\u00AC',	//NOT SIGN	[1983]	Windows: U+FFE2
                //'\u00B6'	//PILCROW SIGN	[1983]
                // Added by shen yuan at 2005-10-26
                '\u0021', 
                // '! '
                '\u0022', 
                // '" '
                '\u0023', 
                // '# '
                '\u0024', 
                // '$ '
                '\u0025', 
                // '% '
                '\u0026', 
                // '& '
                '\u0027', 
                // '' '
                '\u0028', 
                // '( '
                '\u0029', 
                // ') '
                '\u002A', 
                // '* '
                '\u002B', 
                // '+ '
                '\u002C', 
                // ', '
                '\u002D', 
                // '- '
                '\u002E', 
                // '. '
                '\u002F', 
                // '/ '
                '\u003A', 
                // ': '
                '\u003B', 
                // '; '
                '\u003C', 
                // '<'
                '\u003D', 
                // '= '
                '\u003E', 
                // '>'
                '\u003F', 
                // '? '
                '\u0040', 
                // '@ '
                '\u005B', 
                // '[ '
                '\u005D', 
                // '] '
                '\u005E', 
                // '^ '
                '\u005F', 
                // '_ '
                '\u0060', 
                // '` '
                '\u007B', 
                // '{ '
                '\u007C', 
                // '| '
                '\u007D', 
                // '} '
                '\uFF61', 
                // '? '
                '\uFF62', 
                // Halfwidth Left Corner Bracket
                '\uFF63', 
                // Halfwidth Right Corner Bracket
                '\uFF64', 
                // 'E
                '\uFF65', 
                // ' '
                '\u00A1', 
                '\u00A4', 
                '\u00A5'
            ];
            CharProcess.CharEx = new CharProcess();
            CharProcess.prototype.ToHalfKatakana = function (c) {
                var result = "";
                if(this.IsFullWidth(c)) {
                    if(this.IsKatakana(c)) {
                        var katakana = c;
                        var n = katakana.charCodeAt(0) - (this.CharCategory._charstarts[62].charCodeAt(0) + 1);
                        if(n < 0 || n > 91) {
                            return katakana;
                        }
                        katakana = this.CharCategory._fullkana[n];
                        var accent = this.CharCategory._accentkana[n];
                        if(accent > 0) {
                            //accent == 1 ? this.CharCategory.KATAKANA_VOICED.charCodeAt(0) : this.CharCategory.KATAKANA_SEMIVOICED.charCodeAt(0) ;
                            katakana = katakana + String.fromCharCode(accent == 1 ? this.CharCategory.KATAKANA_VOICED.charCodeAt(0) : this.CharCategory.KATAKANA_SEMIVOICED.charCodeAt(0));
                        }
                        result = katakana;
                    } else if(this.IsHiragana(c)) {
                        var katakana = String.fromCharCode(c.charCodeAt(0) - this.CharCategory._charstarts[61].charCodeAt(0) + this.CharCategory._charstarts[62].charCodeAt(0));
                        var n = katakana.charCodeAt(0) - (this.CharCategory._charstarts[62].charCodeAt(0) + 1);
                        if(n < 0 || n > 91) {
                            return katakana;
                        }
                        katakana = this.CharCategory._fullkana[n];
                        var accent = this.CharCategory._accentkana[n];
                        if(accent > 0) {
                            //accent == 1 ? this.CharCategory.KATAKANA_VOICED.charCodeAt(0) : this.CharCategory.KATAKANA_SEMIVOICED.charCodeAt(0) ;
                            katakana = katakana + String.fromCharCode(accent == 1 ? this.CharCategory.KATAKANA_VOICED.charCodeAt(0) : this.CharCategory.KATAKANA_SEMIVOICED.charCodeAt(0));
                        }
                        result = katakana;
                    }
                } else {
                    if(this.IsKatakana(c)) {
                        result = c;
                    }
                }
                return result;
            };
            CharProcess.prototype.GetCharType = function (c) {
                var ctype = this.Ctype.OtherChar;
                var block = this.BelongTo(c);
                if(c == '\u007f' || ('\u0000' <= c && c <= '\u001f') || ('\u0080' <= c && c <= '\u009f')) {
                    return this.Ctype.Control;
                }
                if('A' <= c && c <= 'Z') {
                    return this.Ctype.UpperCase;
                }
                if('a' <= c && c <= 'z') {
                    return this.Ctype.LowerCase;
                }
                if('0' <= c && c <= '9') {
                    return this.Ctype.Numeric;
                }
                //modified by sj
                //the logic that charex call textfilter is wrong
                //	var tFilter = new TextFilter(true,true,"");
                //	if (tFilter.IsSymbol(c))
                //	{
                //		ctype = this.Ctype.Symbol;
                //	}
                if(this.IsFullWidthSymbol(c) || this.IsHalfWidthSymbol(c)) {
                    ctype = this.Ctype.Symbol;
                }
                //end by sj
                if(c.charCodeAt(0) == 8216 || c.charCodeAt(0) == 8217 || c.charCodeAt(0) == 8220 || c.charCodeAt(0) == 8221) {
                    ctype = this.Ctype.Punctuation;
                }
                if(c.charCodeAt(0) == 12288) {
                    ctype = this.Ctype.Space;
                }
                switch(this.CharCategory.Blocks[block]) {
                    case 'HALFWIDTH_AND_FULLWIDTH_FORMS':
                        return this.MultiWidthDetails(c);
                    case 'KATAKANA':
                        return this.Ctype.Katakana | this.Ctype.FullWidth;
                    case 'HIRAGANA':
                        return this.Ctype.Hiragana | this.Ctype.FullWidth;
                }
                if(this.IsFarEastBlock(block, c)) {
                    ctype |= this.Ctype.FullWidth;
                }
                return ctype;
            };
            CharProcess.prototype.IsCharOfType = function (c, type) {
                return this.GetCharType(c) == type;
            };
            CharProcess.prototype.IsMultiWidth = function (c) {
                var block = this.BelongTo(c);
                var category = this.CharCategory.Blocks[block];
                return (category == 'KATAKANA' || category == 'CJK_SYMBOLS_AND_PUNCTUATION' || category == 'HALFWIDTH_AND_FULLWIDTH_FORMS' || (category == 'BASIC_LATIN' && c >= '\u0020'));
            };
            CharProcess.prototype.IsFullWidthSymbol = function (c) {
                for(var i = 0; i < CharProcess.FullWidthSymbolArray.length; i++) {
                    if(c === CharProcess.FullWidthSymbolArray[i]) {
                        return true;
                    }
                }
                return false;
            };
            CharProcess.prototype.IsHalfWidthSymbol = function (c) {
                for(var i = 0; i < CharProcess.HalfWidthSymbolArray.length; i++) {
                    if(c === CharProcess.HalfWidthSymbolArray[i]) {
                        return true;
                    }
                }
                return false;
            };
            CharProcess.prototype.IsFullWidth = function (c) {
                if(this.IsFullWidthSymbol(c)) {
                    return true;
                }
                if(this.IsHalfWidthSymbol(c)) {
                    return false;
                }
                var block = this.BelongTo(c);
                var bFullWidth = this.IsFarEastBlock(block, c);
                if(this.CharCategory.Blocks[block] == 'HALFWIDTH_AND_FULLWIDTH_FORMS') {
                    bFullWidth = ((this.MultiWidthDetails(c) & this.Ctype.FullWidth) == this.Ctype.FullWidth);
                }
                return bFullWidth;
            };
            CharProcess.prototype.IsSurrogatePair = function (c) {
                if(c.charCodeAt(0) >= '\uD800'.charCodeAt(0) && c.charCodeAt(0) <= '\uDBFF'.charCodeAt(0) && c.charCodeAt(1) >= '\uDC00'.charCodeAt(0) && c.charCodeAt(1) <= '\uDFFF'.charCodeAt(0)) {
                    return true;
                }
                return false;
            };
            CharProcess.prototype.IsSurrogate = function (c) {
                return c != null && ((c.charCodeAt(0) >= '\uD800'.charCodeAt(0)) && c.charCodeAt(0) <= '\uDFFF'.charCodeAt(0));
            };
            CharProcess.prototype.IsOther = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.OtherChar);
            };
            CharProcess.prototype.IsControl = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.Control);
            };
            CharProcess.prototype.IsKatakana = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.Katakana);
            };
            CharProcess.prototype.IsSmallHalfKatakana = function (c) {
                var _halfkanaSmall = new Array('\u30a1', '\u30a3', '\u30a5', '\u30a7', '\u30a9', // small a
                '\u30e3', '\u30e5', '\u30e7', // small ya
                '\u30c3', '\u30ee');
                // small tu, 
                var c1 = c;
                if(c.charCodeAt(0) > this.CharCategory.KANAHALFSTART) {
                    c1 = this.CharCategory._halfkana[c.charCodeAt(0) - this.CharCategory.KANAHALFSTART];
                }
                for(var i = 0; i < _halfkanaSmall.length; i++) {
                    if(c1 == _halfkanaSmall[i]) {
                        return true;
                    }
                }
                return false;
            };
            CharProcess.prototype.IsHiragana = function (c) {
                return (((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.Hiragana) || //- Masa (2002/12/24) Japan wanted this special support --------------------------------------------
                (this.CharCategory._jpnMixed[0] == c));
                //--------------------------------------------------------------------------------------------------
                            };
            CharProcess.prototype.IsShiftJIS = function (c) {
                //var unicode = c.charCodeAt(0);
                //var offset = Math.floor(unicode / 8);
                //var mod = unicode % 8;
                //var flagString = CharProcess.ShiftJISCode.substr(offset * 2, 2);
                //var binaryString = parseInt(flagString, 16).toString(2);
                //while (binaryString.length < 8)
                //{
                //    binaryString = "0" + binaryString;
                //}
                //if (binaryString.substr(mod, 1) == "1")
                //{
                //    return true;
                //}
                return false;
            };
            CharProcess.prototype.IsJISX0208 = function (c) {
                //var unicode = c.charCodeAt(0);
                //var offset = Math.floor(unicode / 8);
                //var mod = unicode % 8;
                //var flagString = CharProcess.JISX0208Code.substr(offset * 2, 2);
                //var binaryString = parseInt(flagString, 16).toString(2);
                //while (binaryString.length < 8)
                //{
                //    binaryString = "0" + binaryString;
                //}
                //if (binaryString.substr(mod, 1) == "1")
                //{
                //    return true;
                //}
                return false;
            };
            CharProcess.prototype.IsDigit = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.Numeric);
            };
            CharProcess.prototype.IsPunctuation = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.Punctuation);
            };
            CharProcess.prototype.IsMathSymbol = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.MathSymbol);
            };
            CharProcess.prototype.IsSymbol = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.Symbol);
            };
            CharProcess.prototype.IsLower = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.LowerCase);
            };
            CharProcess.prototype.IsUpper = function (c) {
                return ((this.GetCharType(c) & ~this.Ctype.FullWidth) == this.Ctype.UpperCase);
            };
            CharProcess.prototype.IsDigitOrSymbol = function (c) {
                return (this.IsDigit(c) || this.IsMathSymbol(c));
            };
            CharProcess.prototype.IsAlphabet = function (c) {
                return (this.IsUpper(c) || this.IsLower(c));
            };
            CharProcess.prototype.IsAlphaOrDigit = function (c) {
                return (this.IsUpper(c) || this.IsLower(c) || this.IsDigit(c));
            };
            CharProcess.prototype.IsUpperKana = function (c) {
                return !this.IsLowerKana(c);
            };
            CharProcess.prototype.IsLowerKana = function (c) {
                return (CharProcess.LowerKana.search(c) != -1);
            };
            CharProcess.prototype.HasLowerKana = function (c) {
                return (CharProcess.UpperKana.search(c) != -1 || this.IsLowerKana(c));
            };
            CharProcess.prototype.ToUpperKana = function (c) {
                var index = CharProcess.LowerKana.search(c);
                return (index == -1) ? c : CharProcess.UpperKana.substr(index, 1);
            };
            CharProcess.prototype.ToLowerKana = function (c) {
                var index = CharProcess.UpperKana.search(c);
                if(index >= CharProcess.UpperKana.length - 4 && index < CharProcess.UpperKana.length) {
                    return c;
                }
                return (index == -1) ? c : CharProcess.LowerKana.substr(index, 1);
            };
            CharProcess.prototype.ToLower = function (c) {
                if(this.IsUpper(c)) {
                    return String.fromCharCode(c.charCodeAt(0) + 32);
                }
                return c;
            };
            CharProcess.prototype.ToUpper = function (c) {
                if(this.IsLower(c)) {
                    return String.fromCharCode(c.charCodeAt(0) - 32);
                }
                return c;
            };
            CharProcess.prototype.IsSpace = function (c) {
                return c == '\u0020' || c === '\u3000';
            };
            CharProcess.prototype.ToFullWidth = function (c) {
                var retObj = {
                    text: "",
                    processedAll: false
                };
                retObj.text = c;
                retObj.processedAll = false;
                if(c.length == 0) {
                    return retObj;
                }
                var c1 = c.substring(0, 1);
                if(this.IsMultiWidth(c1)) {
                    //
                    // Latin basic characters can be directly converted
                    // by making a few shifts...
                    //
                    if(c1 < this.CharCategory._charstarts[1])//LATIN_1_SUPPLEMENT
                     {
                        //
                        // Funny why 'space' was left out of this category.
                        //
                        if(c1 == '\u0020') {
                            retObj.text = '\u3000';
                            return retObj;
                        }
                        var temp = '\u0021';//!
                        
                        retObj.text = String.fromCharCode(c1.charCodeAt(0) - temp.charCodeAt(0) + (this.CharCategory._charstarts[81].charCodeAt(0) + 1))//Blocks.HALFWIDTH_AND_FULLWIDTH_FORMS
                        ;
                        return retObj;
                    }
                    //
                    //- pickup a direct map from the table...
                    //
                    if((this.MultiWidthDetails(c1) & this.Ctype.Katakana) == this.Ctype.Katakana) {
                        if(c1.charCodeAt(0) < this.CharCategory.KANAHALFSTART) {
                            var c2 = this.GetFullHalfWidthSpecialChar(c1, true);
                            retObj.text = (c2 !== "") ? c2 : c1;
                            return retObj;
                        }
                        c1 = this.CharCategory._halfkana[c1.charCodeAt(0) - this.CharCategory.KANAHALFSTART];
                        //
                        // Handle the soundex here....
                        //
                        if(c.length < 2) {
                            retObj.text = c1;
                            return retObj;
                        }
                        var daku = c.charCodeAt(1) - (this.CharCategory.KATAKANA_VOICED.charCodeAt(0) - 1);// should be KATAKANA_VOICED or KATAKANA_SEMIVOICED.
                        
                        if(daku == 1 || daku == 2) {
                            retObj.processedAll = true;
                            var accent = this.CharCategory._accentkana[(c1.charCodeAt(0) - (this.CharCategory._charstarts[62].charCodeAt(0) + 1))];//Blocks.KATAKANA
                            
                            if(accent != 0) {
                                if((Math.abs(accent) & 2) == daku) {
                                    c1 = String.fromCharCode(c1.charCodeAt(0) + 1);
                                }
                                c1 = String.fromCharCode(c1.charCodeAt(0) + 1);
                            }
                        }
                        //add by sj for bug 2955
                        if(daku == 1 && c1 == '\u30A6') {
                            c1 = '\u30F4';
                        }
                        //end by sj
                                            }
                }
                retObj.text = c1;
                return retObj;
                //return c1;
                            };
            CharProcess.prototype.ToHalfWidth = function (c) {
                //
                // Need to return only the first character.
                //
                return this.ToHalfWidthEx(c);
            };
            CharProcess.prototype.ToHalfWidthEx = function (c) {
                var ctype = this.GetCharType(c);
                var multiWidth = this.IsMultiWidth(c);
                //
                // First filter out half width characters and characters that
                // are not of CJK groups.
                if((ctype & this.Ctype.FullWidth) == this.Ctype.FullWidth) {
                    switch(ctype & ~this.Ctype.FullWidth) {
                        case this.Ctype.Punctuation:
                        case this.Ctype.UpperCase:
                        case this.Ctype.LowerCase:
                        case this.Ctype.Symbol:
                        case this.Ctype.Numeric:
                        case this.Ctype.MathSymbol:
 {
                                var c1 = this.GetFullHalfWidthSpecialChar(c, false);
                                if(c1 !== "") {
                                    c = c1;
                                } else {
                                    if(multiWidth) {
                                        var temp = '\u0021';//!
                                        
                                        //c = (char)(( c - (_charstarts[(int)Blocks.HALFWIDTH_AND_FULLWIDTH_FORMS] + 1) ) + '\u0021');
                                        c = String.fromCharCode(c.charCodeAt(0) - (this.CharCategory._charstarts[81].charCodeAt(0) + 1) + temp.charCodeAt(0))//Blocks.HALFWIDTH_AND_FULLWIDTH_FORMS
                                        ;
                                    }
                                }
                            }
                            break;
                        case this.Ctype.Katakana:
 {
                                var n = c.charCodeAt(0) - (this.CharCategory._charstarts[62].charCodeAt(0) + 1);
                                if(n < 0 || n > 91) {
                                    return c;
                                }
                                c = this.CharCategory._fullkana[n];
                                var accent = this.CharCategory._accentkana[n];
                                if(accent > 0) {
                                    //accent == 1 ? this.CharCategory.KATAKANA_VOICED.charCodeAt(0) : this.CharCategory.KATAKANA_SEMIVOICED.charCodeAt(0) ;
                                    c = c + String.fromCharCode(accent == 1 ? this.CharCategory.KATAKANA_VOICED.charCodeAt(0) : this.CharCategory.KATAKANA_SEMIVOICED.charCodeAt(0));
                                    return c;
                                }
                                //return new char[] { c, accent == 1 ? KATAKANA_VOICED : KATAKANA_SEMIVOICED };
                                                            }
                            break;
                        case this.Ctype.Space:
                            c = '\u0020';
                            break;
                            // (Masa, add Hangul support later... )
                                                    case this.Ctype.Hangul:
                            break;
                    }
                }
                return c;
            };
            CharProcess.prototype.ToKatakana = function (c) {
                //
                // Simply return the character if it isn't a hiragana.
                //
                if(!this.IsCharOfType(c, this.Ctype.Hiragana | this.Ctype.FullWidth)) {
                    return c;
                }
                //
                // Need to handle special characters here...
                //
                var c1 = this.GetFullHalfWidthSpecialChar(c, false);
                //			if( c == '\u309b' || c == '\u309c' )
                //				return (char)('\uff9e' + (c - '\u309b'));
                if(c1 !== "") {
                    return c1;
                }
                //return (char)( c - _charstarts[(int)Blocks.HIRAGANA] + _charstarts[(int)Blocks.KATAKANA] );
                return String.fromCharCode(c.charCodeAt(0) - this.CharCategory._charstarts[61].charCodeAt(0) + this.CharCategory._charstarts[62].charCodeAt(0));//Blocks.KATAKANA
                
            };
            CharProcess.prototype.ToHiragana = function (c) {
                //
                // Simply return the character if it isn't a hiragana.
                if(!this.IsKatakana(c)) {
                    return c;
                }
                // Convert to fullwidth Katakana.
                if(!this.IsFullWidth(c)) {
                    c = this.ToFullWidth(c).text;
                }
                //validate
                if(!this.IsCharOfType(c, this.Ctype.Katakana | this.Ctype.FullWidth)) {
                    return c;
                }
                //
                // Some fullwidth Katakana characters can't be expressed in Hiragaga
                // so mask it out.
                //
                //modified by sj for NKOI-8C7E84AA2
                //if (c >= '\u30f6' && c <= '\u30ff')
                //	return c;
                if(c >= '\u30f7' && c <= '\u30ff') {
                    return c;
                }
                if(c == '\u30f5') {
                    return '\u304b';
                }
                if(c == '\u30f6') {
                    return '\u3051';
                }
                //end by sj
                //return (char)( c - _charstarts[(int)Blocks.KATAKANA] + _charstarts[(int)Blocks.HIRAGANA] );
                return String.fromCharCode(c.charCodeAt(0) + this.CharCategory._charstarts[61].charCodeAt(0) - this.CharCategory._charstarts[62].charCodeAt(0));//Blocks.KATAKANA
                
            };
            CharProcess.prototype.ToBigHalfKatakana = function (c) {
                if(!this.IsSmallHalfKatakana(c)) {
                    return c;
                }
                var c1 = this.CharCategory._halfkana[c.charCodeAt(0) - this.CharCategory.KANAHALFSTART];
                c1 = String.fromCharCode(c1.charCodeAt(0) + 1);
                return c1;
            };
            CharProcess.prototype.BelongTo = function (c) {
                var bottom = 0;
                var top = 83;//this.CharCategory._charstarts.length;
                
                var current = top >> 1;
                //
                // Binary search used to find proper type.
                //
                while(top - bottom > 1) {
                    if(c >= this.CharCategory._charstarts[current]) {
                        bottom = current;
                    } else {
                        top = current;
                    }
                    current = (top + bottom) >> 1;
                }
                return current;
            };
            CharProcess.prototype.MultiWidthDetails = function (c) {
                var bottom = 0;
                var top = this.CharCategory._fullhalfblocks.length;
                var current = top >> 1;
                //
                // Binary search used to find proper type.
                //
                while(top - bottom > 1) {
                    if(c >= this.CharCategory._fullhalfblocks[current]) {
                        bottom = current;
                    } else {
                        top = current;
                    }
                    current = (top + bottom) >> 1;
                }
                return this.CharCategory._mwtable[current];
            };
            CharProcess.prototype.IsFarEastBlock = function (block, c) {
                switch(this.CharCategory.Blocks[block]) {
                    case 'CJK_COMPATIBILITY':
                    case 'CJK_COMPATIBILITY_FORMS':
                    case 'CJK_COMPATIBILITY_IDEOGRAPHS':
                    case 'CJK_RADICALS_SUPPLEMENT':
                    case 'CJK_SYMBOLS_AND_PUNCTUATION':
                    case 'CJK_UNIFIED_IDEOGRAPHS':
                    case 'CJK_UNIFIED_IDEOGRAPHS_EXTENSION':
                    case 'HALFWIDTH_AND_FULLWIDTH_FORMS':
                    case 'BOPOMOFO':
                    case 'BOPOMOFO_EXTENDED':
                    case 'HIRAGANA':
                    case 'KATAKANA':
                    case 'KANBUN':
                    case 'HANGUL_COMPATIBILITY_JAMO':
                    case 'HANGUL_JAMO':
                    case 'HANGUL_SYLLABLES':
                        return true;
                    default:
                        // Add comments by Yang at 14:28 March 6th 2008
                        // For fix the bug 9709
                        // There are some different requirements from InputMan Winform.
                        // No matter the current cultureinfo.
                        for(var i = 0; i < this.CharCategory._feQuotes.length; i++) {
                            if(c == this.CharCategory._feQuotes[i]) {
                                return true;
                            }
                        }
                        if(c.charCodeAt(0) > 255) {
                            return true;
                        }
                        if(c.charCodeAt(0) == 8216 || c.charCodeAt(0) == 8217 || c.charCodeAt(0) == 8220 || c.charCodeAt(0) == 8221) {
                            return true;
                        }
                        //			if (c.charCodeAt(0) == 8216 || c.charCodeAt(0) == 8217 ||
                        //			    c.charCodeAt(0) == 8220 || c.charCodeAt(0) == 8221)
                        //				return true;
                        //			if( c.charCodeAt(0) > 255 )
                        // End by Yang
                        break;
                }
                return false;
            };
            CharProcess.prototype.GetFullHalfWidthSpecialChar = function (c, toFull) {
                if(toFull == true) {
                    var srctable = this.CharCategory._jpnSpecialHalf;
                    var desttable = this.CharCategory._jpnSpecialFull;
                } else {
                    var srctable = this.CharCategory._jpnSpecialFull;
                    var desttable = this.CharCategory._jpnSpecialHalf;
                }
                var found = -1;
                var tempIndex = 0;
                while(tempIndex < srctable.length) {
                    if(srctable[tempIndex] == c) {
                        found = tempIndex;
                        break;
                    }
                    tempIndex++;
                }
                if(found != -1) {
                    if(tempIndex < desttable.length) {
                        return desttable[tempIndex];
                    }
                }
                return "";
            };
            return CharProcess;
        })();
        input.CharProcess = CharProcess;        
    })(wijmo.input || (wijmo.input = {}));
    var input = wijmo.input;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
var wijmo;
(function (wijmo) {
    (function (input) {
        var CharInfo = (function () {
            function CharInfo() { }
            CharInfo.PADCHAR = "=";
            CharInfo.ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            CharInfo.Getbyte64 = function Getbyte64(s, i) {
                var idx = CharInfo.ALPHA.indexOf(s.charAt(i));
                if(idx == -1) {
                    throw "Cannot decode base64";
                }
                return idx;
            };
            CharInfo.Decode = function Decode(s) {
                if(window.atob !== undefined) {
                    return window.atob(s);
                }
                // convert to string
                s = "" + s;
                var getbyte64 = CharInfo.Getbyte64;
                var pads, i, b10;
                var imax = s.length;
                if(imax == 0) {
                    return s;
                }
                if(imax % 4 != 0) {
                    throw "Cannot decode base64";
                }
                pads = 0;
                if(s.charAt(imax - 1) == CharInfo.PADCHAR) {
                    pads = 1;
                    if(s.charAt(imax - 2) == CharInfo.PADCHAR) {
                        pads = 2;
                    }
                    // either way, we want to ignore this last block
                    imax -= 4;
                }
                var x = [];
                for(i = 0; i < imax; i += 4) {
                    b10 = (getbyte64(s, i) << 18) | (getbyte64(s, i + 1) << 12) | (getbyte64(s, i + 2) << 6) | getbyte64(s, i + 3);
                    x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff, b10 & 0xff));
                }
                switch(pads) {
                    case 1:
                        b10 = (getbyte64(s, i) << 18) | (getbyte64(s, i + 1) << 12) | (getbyte64(s, i + 2) << 6);
                        x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff));
                        break;
                    case 2:
                        b10 = (getbyte64(s, i) << 18) | (getbyte64(s, i + 1) << 12);
                        x.push(String.fromCharCode(b10 >> 16));
                        break;
                }
                return x.join('');
            };
            CharInfo.prototype.getbyte = function (s, i) {
                var x = s.charCodeAt(i);
                if(x > 255) {
                    throw "INVALID_CHARACTER_ERR: DOM Exception 5";
                }
                return x;
            };
            CharInfo._charInfo = [];
            CharInfo._base64CharInfo = "YwBoAGEAcgBpAG4AZgBvAC4AbgBsAHAAAAD+/wgAPAAAAGBLAAD0SwAAgHcAAIB4AAAAERARIBEwEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEQASEBIgEjASQBJQEmAScBKAEpASoBKwEsAS0BLgEvASABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BMAFBAUIBQwFFAS/v8ZAEAUUBL+/1EAUBRgFFAS/v8DAHAUUBKAFJAUoBSwFMAUgBFQEv7/KwDQFOAU/v8IAPAU/v8ZAFASABUQFSAVMBVAFVAVYBVwFYAVkBWgFYAR/v8DALAVwBXQFYAR/v8VAFAS/v8DAOAV8BWAEf7/qwAAFhAWIBYwFkAWUBZgFnAWgBH+/xgAgBaAEf7/DwBQEv7/pgCQFoAR/v9RAFAS/v8CAKAWgBH+/wULsBbAFoAR/v/+APAU/v//ANAW8BT+//8A0BbgFugW8Bb4FgAXCBcQFxgXIBcoFzAXOBdAF0gXUBdYF2AX/v8DAGgXcBdgF/7/AgB4F4AXiBeQF5gXoBeoF2AXsBdgF/7/AwC4F8AXUBf+/wQAyBdQF9AX2BfgF+gX8Bf4F/7/BwAAGAgYEBgYGFAXIBgoGGAXMBhAF/7/AwBQF/7/AwBgF/7/AgA4GGAX/v8DAEAYYBf+/wUASBhQGEAXWBhgGFAXaBhwGPgXeBiAGIgYkBiYGKAYqBiwGLgYwBjIGNAY2Bi4GP7/BQDgGOgY8Bj4GAAZuBj4FwgZuBj+/wUAEBkYGSAZiBgoGTAZOBn+/xAAQBlIGf7/AgBQGVgZYBloGXAZeBmAGYgZkBmYGaAZqBmwGbgZgBmIGcAZyBnQGdgZ4BnoGfAZiBn4GQAaCBqoGRAaeBmAGYgZGBogGigaqBkwGjgaQBpIGlAaWBpgGtgZaBpwGngaiBmAGogakBqoGZgaoBp4GogZqBqwGrgaqBnAGqAaeBqIGcga0BrYGqgZ4BroGvAaSBn4GgAbCBs4GRAbGBtIGf7/AgAgGygbMBs4Gf7/AgA4G0AbSBtQG1gbYBs4Gf7/AgBoG3AbeBuAG4gbSBmQG5gboBuoG/gXsBu4G8AbOBn+/wIASBn+/wIAyBvQG9gb4BvoG/Ab+BsAHEAX/v8CAAgcSBn+/wIAEBxIGf7/BQAYHEgZ/v8EACAcSBn+/wQAKBxIGf7/BAAwHDgcSBn+/wIAMBxIGf7/AgBAHEgcUBxIGf7/AwBIHEgZ/v8DAFgcYBxoHEgZcBxIGf7/BQB4HBgbSBn+/yUAgByIHJAcmBxIGf7/BACgHKgcsBy4HEgZwBxIGcgcsBzQHEgZ/v8DANgc4BzoHPAc+BwAHfAcSBn+/wIACB1IGf7/AgAQHUgZ/v8CABgdOBn+/wUASBmQGyAdKB0wHUgZOB14HEgZ/v8CACgcQB1IHVAdWB3+/wIASBlgHTgZ/v8OAGgdSBn+/wIAcB14HdgbgB2IHZAdSBmYHfAcOBn+/wQASBn+/wIAoB2oHbAduB1IGcAdOBn+/wgAUBf+/wIAyB3QHf7/AwDYHeAdUBfoHdAd/v8CAPgX/v8CAPAd+B1gF/7/CQAAHmAX/v8GAAgeEB4IHv7/AgAQHhgeCB4gHige/v8DADAeOB5AHkgeUB5YHmAeaB5wHngegB6IHpAemB6gHqgesB44GbgewB7IHtAe2B7gHuge8B74HgAf/v8CAAgfEB8YH1gdIB8oH1gdMB84H0AfOB/+/w4ASB9YHVAfWB9gH/7/AwBoH1gdcB84H3gfWB2AH4gfOBlYHf7/AgCQHzgZmB84GaAf/v8CAKgfsB9gH/7/BAC4H6AfWB3+/wsAwB/IH1gd/v8CANAfWB3+/wYA2B9YHf7/AgDgH+gf8B/4HzgZ/v8DAAAgWB0IIFgdECAYICAgKCCgHzAgWB04IEAgOB9IIDgfYB/+/xAAOB/+/wgAUCBYIDgf/v8DAGAgOB9oIDgf/v8QAFgd/v8DADgfcCB4IDgZ/v8KAEAX/v8CAIAgUBf+/wIAiCCQIJggYBf+/wYAoCCoIFAX/v8CALAgSBn+/wMAuCA4GUgZiBzAIP7/BAD4F/7/AgDIINAg2CDgIDgZ/v8EAFgd6CBYHf7/BQD4H1gd/v8NAPAgOBn4IAAhCCEQIRghGBtIGf7/BAAgISghSBn+/wQAMCE4IUgZOB0YG0gZ/v8EAEAhSCFIGRAdWB3+/wIA+B9IGWAfUCFYIWAfYCFoIWAfcCFYIWAf/v8CAHghgCFgH/7/AgCIIWAf/v8HAJAhYB/+/wUAmCFgH6AhSBn+/wsAqCFYHf7/BABIGf7/DACwITgZ/v8DAEgZuCFIGf7/FgCQG1gd/v8DAJAfOBn+/wMAwCFIGcghOBlgF/7/AgDQIdghYBfgITgZ/v8GAPAX6CHwIfghYBf+/wMAACIIIjgZ/v8GABAiGCJIGSAiOBlIGf7/AwAoIjAiSBn+/wIAOCJAIvAcOBn+/wIAuB1IGUgiSBlQIlgiOBn+/woASBn+/wIAYCJoInAieCI4Gf7/CgBIGf7/CgCwITgZ/v8FAIAi/v8QAIgi/v8QAEgZ/v8CADgdSBn+/wMAkCJIGf7/BgAoHDgZ/v8CAJgioCKoIrAiuCK4GP7/BgDAIjgZyCK4GP7/FQDQIjgZuBj+/wQA2CK4GP7/AgDgIjgZ/v8CAOgi+BfwIvAd+CIAIwgjECMYI7gY/v8HACAjKCP4FgAXCBcQFzAjOCNAI0gZSCNIGUAhUCNYI2AjaCNwI0gZUBx4Izgd/v8CADgZ/v8CAEgZ/v8HAJAigCOII/7/AgCQI5gj/v8DAKAjqCP4IDgZ/v8DAGAf/v8CALAjOBn+/wgASBmQG0gZ/v8DAAgaOBn+/wIASBlAIbgjSBnAIzgZ/v8DAEgZyCNIGf7/AgDQI9gjOBn+/wIAQBf+/wIA4CNQF/7/AgBIGf7/BAA4HfAcOBn+/wUA6COIGP7/AgDwIzgZ/v8MAIgY+COIGAAkOBn+/wwACCQQJIgYGCQgJCgkOBn+/woASBn+/wYAQCE4Gf7/CQAAH/7/BgAwJDgkOBn+/wgAYB/+/w8AQCRgH/7/AgBIJGAf/v8DAFAkWCRgJGAfaCRgH/7/AgBwJDgZ/v8CAFgd/v8EAHgkOBn+/wsAWB3+/wUAkB+II4AkOBn+/wgAQBeIJFAXkCSYJKAkCB5AF6gksCS4JMAkyCRAF4gkUBfQJNgkUBfgJOgk8CT4JEAXACVQF0AXiCRQF5AkmCRQFwgeQBeoJPgkQBcAJVAXQBeIJFAXCCVAFxAlGCUgJSglUBcwJUAXOCVAJUglUCVQF1glQBdgJVAXaCVwJf7/AwBYHf7/AgD4IFgd/v8GAPgfOBn+/wYASBn+/w0AiBw4Gf7/AgBIGTgdOBn+/w4AeCU4GYAl/v8GADgZ/v8IAPgX/v8PADgZiCL+/w8AiCUBAf7/BAABAgMCBAMBAf7/BwADAwMCBQYGBwgHBgYJCgYLDA0MDA4O/v8FAAwGDw8PBgYQEBD+/wwAEAkGChESERMTE/7/DAATCQ8KDwEBAf7/AgABAwEB/v8NABQGCAj+/wIAFRURFRMWDxcVERgZGhoRExUGERoTGxwcHAYQEP7/CwAQDxAQ/v8DABATExP+/wsAEw8TE/7/BAAQE/7/DAATEP7/CAATExAT/v8HABAQExD+/wIAExMTEBAT/v8CABAQExAQEBMTEBD+/wIAExAQExAQEBMTExAQExAQE/7/AwAQEBMQExMQExAQExAQEBMQ/v8CABATEx0QExMTHR3+/wIAEB4TEB4TEB4TEP7/CAATExATExAeExATEBAQE/7/BgATE/7/AwAQEBMQEBMTEP7/AgAQEBAT/v8FABMT/v8CAB0TExP+/wUAHx/+/wQAHyAgHx8f/v8DABER/v8CACAg/v8FAB8fERH+/wcAHx/+/wIAHxEREf7/AwAgER8RERH+/wgAISH+/wgAEBP+/wIAIBEQEwAAHxMTEwYAAAD+/wIAEREQBhAQEAD+/wIAEBATEBAQ/v8IAAAQEBD+/wQAExP+/wkAExATExAQEBMTExAT/v8EABMT/v8CABATDxATEBATExAQEBATIiEhIf7/AgAjIxAT/v8DABAQExD+/wYAExMQE/7/AgAAAP7/BgAAEBAQ/v8KABAAAB8kJP7/AwAAExMT/v8LAAAkJQAAAP7/AgAAISEh/v8OACYhJyEhJyEhJyEAAP7/BAAoKP7/DQAoAAAA/v8CACgoKCcnAAAA/v8FACkp/v8CAAAADw8qBwcrDCwVFSEh/v8FACEsAAAsLAAtLS3+/w8ALi0tLf7/BAAtISEh/v8JACEALy/+/wUABzAwLC0tIS0tLf7/CQAsLSEh/v8DACEpIyEhIf7/AgAhLi4hIRUhIf7/AgAtLQ4O/v8FAC0tLTExLSws/v8HAAAXLSEtLf7/BwAhIf7/BQAhAAAtLS3+/wQAISH+/wUAIS0AAP7/BwAyMv7/BQAoKP7/CAAoISEh/v8EADMzFQYGBjMAAAD+/woAACEhNB0d/v8TAAAAIR00NDQhISH+/wMAITQ0NDQhAAAdISEhIQAAAB0d/v8FACEhJCQ1Nf7/BQAkHx0AAAD+/wMAAB0dHf7/AgAAITQ0AB0dHf7/AwAdAAAdHQAAHR0d/v8KAB0AHR3+/wMAHQD+/wIAAAAdHf7/AgAAACEdNDQ0ISEhIQAANDQAADQ0IR0AAAD+/wMAADQAAP7/AgAdHQAdHR0hIQAANTX+/wUAHR0ICDY2/v8DACIAAAD+/wIAACEhNAAdHR3+/wIAHQAAAAAdHQAdHQAdHQAdHQAAIQA0NDQhIQAAAAAhIQAAISEhAAAAIQAA/v8DAAAdHR0dAP7/AgAAAP7/AwA1Nf7/BQAhIR0dHSEAAP7/BQAAISE0AB0dHf7/BAAAHR0dAB0dHf7/BgAdAB0dAB0dHf7/AgAAACEdNDQ0ISEh/v8CAAAhITQANDQhAAAdAAAA/v8HAAAIAAD+/wcAHQAdHQAdHR3+/wIAAAAhHTQh/v8CACEhIQAANDQAADQ0IQAA/v8EACE0AAD+/wIAHR0AHSIdAAD+/wgAIR0AHR0d/v8CAB0AAAAdHR0AHR3+/wIAAAAAHR0A/v8CAB0dAAAAHR0AAAAdHR0AAAAdHf7/BgAAAP7/AgA0NCE0NAAAADQ0NAA0NDQhAAAdAAAA/v8CAAA0AAD+/wQANjY2FRUV/v8CABUIFQAAAP7/AgAANDQ0AB0dHf7/AwAdAB0dHQAdHf7/CQAAHR0d/v8CAAAAAB0hISE0NDQ0ACEhIQAhIf7/AgAAAP7/AwAAISEAHR0AAP7/BwAcHP7/AwAcIgAANDQAHR0d/v8DAB0AHR3+/wMAAB0dHf7/AgAAACEdNDc0NP7/AgA0ADc0NAA0NCEhAAD+/wMAADQ0AAAA/v8DAB0AABUVAAAA/v8GAB0d/v8FAAAAAB00NDQhISEhADQ0NAA0NDQhAAD+/wQAADQAAP7/BAA2Nv7/AwAAAAAiHR3+/wMAAAA0NAAdHR3+/wgAHQAAAB0d/v8EAAAdHR3+/wQAAB0AAB0d/v8DAB0AAAAhAAAAADQ0NCEhIQD+/wIANDT+/wQAAAA0NCQAAAD+/wUAAB0dHf7/BwAdIR0dISH+/wMAIQAAAAAIHR3+/wMAHyEhIf7/AwAhJDU1/v8FACQkAAD+/wIAAB0dAP7/AgAAHR0A/v8CAAAdAAD+/wMAHR3+/wIAAB0dHf7/AwAAHR0dAB3+/wIAAAAdHQAdHR0dIR0dISH+/wMAACEhHQAAHR3+/wIAHQAfACEh/v8DAAAANTX+/wUAAAAdHQAAHSIiIiQk/v8HACQiIiL+/wIAISEiIv7/AwA1Nf7/BQA2Nv7/BQAiIf7/AwAJCv7/AgA0NB0d/v8EAAAdHR3+/wkAHQAAAAAhISH+/wYAITQhIf7/AgAhJCEhHR3+/wIAAAD+/wIAISH+/wQAACEhIf7/CQAhACIi/v8EACEiIiL+/wIAIgAiIiQk/v8CACQAAAD+/wUAHR3+/wUAHTQ0ISEhITQhIf7/AwA0ISE0NCEhHTU1/v8FACQk/v8DAB0d/v8DADQ0ISEdHf7/AgAhISEdNDQ0HR00NDT+/wMAHR0dISEhIR0dHf7/BgAhNDQhITQ0NP7/AgA0IR00NTX+/wUAAAD+/wIAIiIQEP7/AwAAAP7/BQAdHf7/BQAdJB8AAAAdHf7/BQAAAP7/AgAAHR0dHQAAAP7/AgAdHf7/CQAAAP7/AwAdHf7/BAAdAB0d/v8CAAAAHR3+/wMAHQD+/wIAHR3+/wIAAAAdAB0d/v8CAAAAHR3+/wMAHQD+/wIAHR3+/wIAAAAdHf7/BwAdAB0d/v8JAB0AAAAAISIkJCT+/wMAJDY2Nv7/CQA2AAAAFRX+/wUAAAD+/wMAHR3+/wIAHQAAAP7/BQAdHf7/BgAdJCQdHR3+/wMAHQAAAP7/BAAFHR0d/v8MAB0JCgAAAB0d/v8FAB0kJCQ4ODgAAAD+/wcAHR3+/wYAHQAdHf7/AgAhISEAAAD+/wUAHR0hISEkJAAAAP7/BAAdHSEhAAD+/wYAHQAhIQAA/v8GAB0d/v8CADk5NCEhIf7/AwA0NP7/BAAhNDQhISH+/wUAJCQkHyQkJAgdIQAANTX+/wUAAAD+/wMAHBz+/wUAAAD+/wMABgb+/wMAJQYGBgYhISEFAB0dHR8dHf7/CgAAAP7/BAAdHf7/BAAdIR0AAAD+/wIAISEhNDQ0NCEhNDQ0AAD+/wIANDQhNDQ0/v8CADQhISEAAP7/AgAVAAAABgY1Nf7/BQAdHf7/BwAAADQ0/v8IADQdHR3+/wMANDQAAP7/AwA1Nf7/BQAAAP7/AgAGBhUV/v8IAB0d/v8DAB0hITQ0NAAAJCQhIf7/AgA0HR0d/v8HACE0ISH+/wIAITT+/wIANDT+/wIAITQ0HR0d/v8DAAAA/v8CACQiIiL+/wQAIiEhIf7/BAAiIv7/BAAiAAAAISE0HR0d/v8GAB00ISH+/wIANDQhITQAAAAdHf7/AwA0NP7/BAAhIf7/BAA0NCEhAAAAJCQk/v8CADU1/v8FAAAAAB0dHTU1/v8FAB0d/v8HAB8f/v8DACQkExP+/wYAHx/+/wsAExP+/wsAHxMTE/7/CAATHx8f/v8CACEh/v8DACEAAAD+/wsAISEQE/7/AwATE/7/BAAQExMT/v8EABAQ/v8EABMT/v8DAAAAEBD+/wMAAAATE/7/BAAAEP7/BAATE/7/BwAAABMT/v8EAB4e/v8EABMT/v8CABMAExMQEP7/AgAeERMRERETExMAExMQEP7/AgAeERERExP+/wIAAAATExAQ/v8CAAARERETE/7/BAAQEP7/AgAQERERAAATExMAExMQEP7/AgAeEREABQX+/wUABRcXFzk6JSX+/wMABgYWGwkWFhsJFgYG/v8EADs8PT4/QEEUBwf+/wIABwYGBgYWGwYGBgYSEgYGBkIJCgYGBv7/BQAPBhIGBgb+/wQABgUXF/7/AgAXAAAA/v8CABcX/v8DABoTAAAaGv7/AwALCw8JChMaGv7/BQALCw8JCgAfH/7/AgAfAAAA/v8FAAgI/v8LAAAA/v8FACEh/v8GACEjIyMjISMjIyEhIf7/BQAhAAAA/v8HABUVEBUVFRUQFRUTEBAQExMQEBATFRAVFRUQEBD+/wIAFRX+/wMAEBX+/wMAEBD+/wIAGBMQEP7/AgATHR0dHRMVFRMTEBAPD/7/AgAPEBMT/v8CABUPFRUTIgAAABwcHP7/BgA4OP7/CQA4EBM4ODg4AAAA/v8DAA8P/v8CAA8VFRX+/wIADw8VFf7/AgAPFRUPFRUPFRUV/v8DAA8VFRX+/wcADw8VFQ8V/v8CABUV/v8HAA8P/v8PAAsZDw/+/wYAFRX+/wQADw/+/wIAFRX+/wIADw8VFf7/AwAVCQoVFRX+/wUAIiL+/xIAIhUPFRUV/v8DABUiFRX+/wIAFQ8PD/7/BAAVFf7/DAAPD/7/AwAVFf7/AwAAAP7/BAAVFf7/AwAVAAAA/v8EABUV/v8FABUAAAD+/wIAHBz+/wwAGhr+/woAIiL+/wcAHBz+/wMAFRX+/wMAFQ8VFf7/BAAVDxUV/v8LAA8P/v8EABUV/v8HABUPFRX+/wcAAAAVFf7/BgAiFRUV/v8HABUAAAAVFf7/AgAAAP7/BgAAFRUVFQAVFf7/AgAAABUV/v8GAAAVFRX+/wkAABX+/wIAFRUVAAAAFQAVFf7/AwAVAAAVFRX+/wMACQr+/wcAHBz+/wcAFQAAABUV/v8EAAAVFRX+/wYAFQAPD/7/AgAPCQoPDw8PAP7/AgAAAA8P/v8DAAkK/v8FAA8PDwkKCf7/CgAKDw8P/v8HAAkK/v8CAA8P/v8IAAkKDw/+/wMADxUVDw8P/v8CAA8AAAAVFf7/AgAVAAAA/v8FABAQ/v8HABAAExP+/wcAEwAQExAQEBMTEP7/BAAQEAATEBMTEBMT/v8DABMfAAAQE/7/AgATFRUV/v8CABUAAAD+/wYAAAYGBgYcBgYTE/7/AwAAAP7/BQAdHf7/AwAAAP7/BAAAHx0d/v8DAB0AHR3+/wMAHQAGBhYb/v8CAAYGBhYbBhYbBgb+/wQABiUGBiUGFhsGBhYbCQr+/wQABgb+/wIABiAGAAAA/v8HABUV/v8FAAAVFRX+/wUAAAD+/wUAFRX+/wYAAAD+/wIABQYGBhUfHTgJCv7/BQAVFQkK/v8EACUJCgoVODg4/v8EACEh/v8DACUfHx/+/wIAFRU4ODgfHQYVFR0d/v8DAB0AACEhEREfHx0lHR0d/v8MAB0GHx8fHQAA/v8CAAAdHR3+/wwAHQAiIjY2/v8CACIi/v8LACIVFQA2Nv7/BQAiIv7/BQAAAP7/BgAVHBwc/v8HACIi/v8GABUVFSIiHBwc/v8HACIi/v8GABUV/v8CACIi/v8HACIAIiL+/wMAIhUVFRUiIiL+/wkAFRUiIv7/BwAiFR0d/v8DAAAA/v8FAB0d/v8CAAAA/v8GAB0d/v8CAB0fHR3+/wsAHwYGBjU1/v8FAB0dAAD+/wMAEBP+/wYAHSEjIyMGAAD+/wQAISEGIBAT/v8EAAAA/v8EABER/v8DABEgICD+/wQAEREQE/7/BwATExAT/v8HAB8TExP+/wMAExD+/wMAEBP+/wUAIENDEBMAAAD+/wYAAB0dHf7/AwAhHR0dIR0dHR0hHR3+/wMAHTQ0ISE0FRX+/wIAAAD+/wIAHR3+/wIABgb+/wIAAAD+/wQANDQdHf7/CQA0NP7/CAAhAAAA/v8EACQkHR3+/wMAISH+/wQAJCQdHf7/AwAdISEh/v8FADQ0AAD+/wUAACQdHf7/BAAdISEh/v8CACE0NCEhNDQhIQAAAP7/BAAdHR0hHR3+/wQAITQAADU1/v8FAAAAJCT+/wIARET+/wgARUX+/wgAHR3+/wUAHQAAAP7/AgATE/7/AwATAAAA/v8FAAATExP+/wIAAAD+/wIAACghKCgo/v8EACgLKCj+/wYAKAAoKP7/AgAoAP7/AgAoKAAoKAAoKP7/BQAtLQAA/v8IAAAtLS3+/w0ACQoAAC0t/v8LAAAA/v8EAC0t/v8GACsVAAAGBv7/AwAGCQoGAAD+/wMABiUlEhIJCgn+/wcACgYGCQoGBgYGEhISDAYMAAYMBgYlCQoJ/v8CAAoHBgYLDQ8PDwAGCAcGAAD+/wIALS3+/wIALQAtLf7/CwAtAAAXAAYGBwgHBgYJCgYLDA0MDBMT/v8FABMJDwoPCQoGCQoGBh0d/v8FAB8dHR3+/w4AHx8AAB0d/v8DAAAAHR3+/wMAAAAdHf7/AwAAAB0dHQAAAAgIDxEVCAgAFQ8PDw8VFQAAAP7/BAAARkZGFRUAAB0d/v8GAAAdHR3+/wYAHQAdHQAdJAYiAAAAADY2Nv7/DgAAAAAiIiL+/wQAR0f+/woARxwcHBwVFRX+/wgAHAAAAP7/AgAiIv7/BgAiIQAANjb+/wIAAAD+/wYAHTgdHf7/BAA4AAAA/v8CAB0d/v8HAAAkHR3+/wIAAAD+/wIAHR3+/wQAJDg4OP7/AgAAAP7/BQAQEP7/BAATE/7/BAAoKP7/AwAAACgAKCj+/wYAACgoAAAAKAAAKCgo/v8DAEhI/v8CAAAA/v8CAAAGKCj+/wUAAAD+/wIAACcoISEhACEhAAAA/v8CACEh/v8CACgo/v8CAAAoKCgAKCgo/v8FAAAA/v8CACEhIQAAAAAhSEj+/wQAAAD+/wQAJyf+/wQAJwAAAP7/AwA4ODgAAAD+/wYAJCT+/wIAAAD+/wYAIiL+/wMAAAD+/wUAIiL+/wMAIgAAIiIi/v8FACI0NCEhISIiIjQ0NP7/AgA0FxcX/v8DABchISH+/wMAISIiISEh/v8DACIi/v8HACEh/v8CACIi/v8IAAAAFRUhISEVAAD+/wUANjYAAP7/BwAQEP7/BQATE/7/BQAQEP7/DQATE/7/AwATABMT/v8FABAQExP+/w0AEAAQEAAAEAAAEBAAABAQEBAAEBD+/wQAExP+/wIAABP+/wIAExP+/wMAABMTE/7/BwAQEAAQEBAQAAAQEBD+/wMAEAAQEP7/AwAQABMT/v8FABAQABAQEBAAEBD+/wIAEAD+/wIAAAAQEP7/AwAQABMT/v8NABAQ/v8FABMT/v8IAAAAEBD+/wQAEEkTE/7/DAATSRMT/v8DABAQ/v8MABBJExP+/wQAE0kTE/7/AwAQEP7/BAAQSRMT/v8MABNJExP+/wMAEBD+/wwAEEkTE/7/BAATSRMT/v8DABAQ/v8EABBJExP+/wQAE0kTE/7/AwAQEwAADg7+/wkAABcAAP7/BwAXF/7/CABFRf7/BwAAAO7u/v8CAB0ADg4OEA4PDhELERgSGAoaChQSFRIZCRgMEwkICBkSAAAbEhISAQALDBwSFhIPDhwKGQoKCBcSChIEAAIAAwADEgUNHAAHDRgAExITAxgDBAMPCxkEGgQYBAQEAwQICxgLHAQIAwMDBgAIAAoABQAJAA8ADwMMEQ0PDwEPBQ8HDwIPBhkMGwAQABEADxIJEgoDGQAAERAR/v8FACARMBEQEUARUBFgEXARgBGQEaARsBEQEf7/AgDAERAR/v8CANAR4BHwEQASEBEQEiASEBH+/wMAMBJAEhAR/v8CAFASEBH+/wIAYBIQEf7/BABwEhAR/v8DAIASkBKgEhAR/v9zALASEBHAEtAS4BIQEf7/TgDwEhAR/v8FAPAREBEAExAREBMgExAR/v8EADATQBMQEf7/GQBQExAR/v+uAGATEBH+/wMAcBMQEf7/IAGAExAR/v8HDpAT/v8DAJgTkBP+/wcAoBOQE/7/GgCYE5AT/v8IAJgTkBP+/wwAmBOQE/7/CQCoE5AT/v8HAKgTsBOQE/7/BgCoE5AT/v8HAKgTkBP+/wcAqBOQE/7/BwCoE7gTkBP+/wYAqBPAE5AT/v8GAKgTkBP+/wcAqBPIE5AT/v8NAJgTkBP+/wcAmBOQE/7/BADQE9gTkBP+/xAAmBOQE/7/BACYE5AT/v8MAOAT6BOQE/7/FgDwE/gTkBP+/w4AmBMAFJATmBOQE/7/EgCoE5AT/v8IAJgTkBP+/wcAmBOQE/7/BQCYE5AT/v8IAJgT/v8CAJAT/v8RAAgUEBSQE/7/DAAYFCAU/v8CACgUkBP+/w0AMBQ4FEAUSBSQE/7/BABQFFgUkBP+/wcAYBRoFHAUkBP+/xUAeBSAFJATiBSQFJAT/v8VAJgUkBP+/wgAoBSQE/7/AgCoFJAT/v8CAKAUkBP+/wIAsBSQE/7/BgCYE5AT/v8aAJgTkBP+/wIAmBOQE/7/FACYE5AT/v8QALgUwBSQE/7/AwDIFJAT0BSQE9gU4BToFPAU+BQAFQgVEBUYFSAVkBP+/wkAKBWQEzAVkBP+/wgAOBWQE/7/DACYE5AT/v8GAEAVkBP+/xIASBWQE/7/CwBQFVgVYBVoFXAVeBWAFZAT/v8PAIgVkBWQE/7/FACYFaAVqBWwFZAT/v8JALgVkBP+/wYAAAD+/wgAAQIDBAUGBwgJCgAA/v8EAAsMAAD+/wIAAA0AAA4PEAAAAP7/AwABAgMEBQYHCAkKAAD+/wIAERITFAAVAAD+/wMAFhcYAAAA/v8KABkREhMREhMAFhcYDg8QAAD+/wUAAQIDBAUGBwgJCg8aGxwdHh8gISIAAP7/CgAADQsMIyQlJicoFikqKywtLi8wFzEAAAD+/wgAMjM0AAAA/v8HABkREhMUNTY3ODkAAP7/AwA6AAAAIyQlJicoAAD+/wMAOg0LDCMkJSYnKAAA/v8EAAA7PD0+P0BBQkNERUYRERITFDU2Nzg5FkdILBdJGBhKMQAANixLTAAAAP7/AwANCwwjJCUmJygWR0hNTk8VMjM0KQ0LDCMkJSYnKBZHSE1OTxUyMzQpDQsMIyQlJicoFkdITU5PFTIzNCkAAP7/BwA6R0hNTk8VMjM0KQ0LDCMkJSYnKBY6AAD+/wMADQsMIyQlJicoFg0LDCMkJSYnKBYNCwwjJCUmJygWAAD+/wwAAA8AAP7/BAAAGQAA/v8EAAAREhMUNTY3ODkAAP7/BwAWKSoAAAD+/wMAERITFAAA/v8FABESExQ1Njc4ORYAAP7/AwAAUFFSU1RVVldYKllaW1xdAF5fYGErYmNkZWZnaGlqLAAA/v8FAAATAAD+/wMAABYAAP7/AgASAAAA/v8EABkAAAD+/wYAADb+/wIAAAD+/wwAABYAAP7/BAAAERITFDU2Nzg5FikqKywtLi8wF2tsbUlub3BxGHJzdEp1dnd4MXl6e0t8fX5/AAD+/wYADg8RNSxJSks1FiwXSRhKNRYsF0kYMUsWEREREhISEjUWFv7/AgAWKiws/v8CABdsSUn+/wIASRhKNSwPDzwQAAAA/v8IABkAAAD+/wIAETUWLAAA/v8GAAAwAAD+/wQAcQAAAP7/AgAAERIWKRcAAP7/CAARFikXAAD+/wMADQsMIxYpFxgAAP7/BAASExQ1Njc4ORMUNTY3ODkUNTY3ODkREhMUNTY3ODkREhMUNRITExQ1Njc4ORESExMUNQAAERITExQ1ExMUFP7/AgA2Nzc3ODg5Of7/AgASExQ1NhESExQUNTUAABESOzxCOzxDDkEOAAAA/v8GABESExQ1Njc4ORYpKissLS4vMAAA/v8OAAECAwQFBgcICQoBAgMEBQYHCAkKAQIDBAUGBwgJCgECAwQFBgcICQoBAgMEBQYHCAkKOQAAAP7/BwDu7v7/BgD//wAAAQECAgMDBAQFBQYGBwcICAkJ/wL/A/8B///+/xUA/wT/Bf8G/wf/CP8J///+/xEA/wD///7/RQAAAP7/AwDwvwAA/v8HAPA/AAD+/wMAAEAAAP7/AwAIQAAA/v8DABBAAAD+/wMAFEAAAP7/AwAYQAAA/v8DABxAAAD+/wMAIEAAAP7/AwAiQAAA/v8DAABAAAD+/wMACEAAAP7/AwDwPwAA/v8DANA/AAD+/wMA4D8AAP7/AwDoPwAA/v8DAPA/AAD+/wMAAEAAAP7/AwAIQAAA/v8DABBAAAD+/wMAMEAAAP7/AwAkQAAA/v8DAFlAAAD+/wIAAECPQAAA/v8HAPg/AAD+/wMABEAAAP7/AwAMQAAA/v8DABJAAAD+/wMAFkAAAP7/AwAaQAAA/v8DAB5AAAD+/wMAIUAAAP7/AwDgvwAA/v8DABBAAAD+/wMAFEAAAP7/AwAYQAAA/v8DABxAAAD+/wMAIEAAAP7/AwAiQAAA/v8DADRAAAD+/wMAPkAAAP7/AwBEQAAA/v8DAElAAAD+/wMATkAAAP7/AgAAgFFAAAD+/wMAVEAAAP7/AgAAgFZAAAD+/wIAAIjDQAAA/v8DADFAAAD+/wMAMkAAAP7/AwAzQAAA/v8DABRAAAD+/wMAGEAAAP7/AwAcQAAA/v8DACBAAAD+/wMAIkAAAP7/BABVVf7/AwDVP1VV/v8DAOU/mpmZmf7/AgDJP5qZmZn+/wIA2T8zM/7/AwDjP5qZmZn+/wIA6T9VVf7/AwDFP6uqqqr+/wIA6j8AAP7/AwDAPwAA/v8DANg/AAD+/wMA5D8AAP7/AwDsPwAA/v8DACZAAAD+/wMAKEAAAP7/AgAAQH9AAAD+/wIAAIizQAAA/v8CAABq6EAAAP7/AgAAavhAAAD+/wMAKkAAAP7/AwAsQAAA/v8DAC5AAAD+/wMANUAAAP7/AwA2QAAA/v8DADdAAAD+/wMAOEAAAP7/AwA5QAAA/v8DADpAAAD+/wMAO0AAAP7/AwA8QAAA/v8DAD1AAAD+/wMAP0AAAP7/AwBAQAAA/v8CAACAQEAAAP7/AwBBQAAA/v8CAACAQUAAAP7/AwBCQAAA/v8CAACAQkAAAP7/AwBDQAAA/v8CAACAQ0AAAP7/AgAAgERAAAD+/wMARUAAAP7/AgAAgEVAAAD+/wMARkAAAP7/AgAAgEZAAAD+/wMAR0AAAP7/AgAAgEdAAAD+/wMASEAAAP7/AgAAgEhAAAD+/wMAaUAAAP7/AgAAwHJAAAD+/wMAeUAAAP7/AgAAwIJAAAD+/wIAAOCFQAAA/v8DAIlAAAD+/wIAACCMQAAA/v8CAABAn0AAAP7/AgAAcKdAAAD+/wIAAECvQAAA/v8CAABwt0AAAP7/AgAAWLtAAAD+/wIAAEC/QAAA/v8CAACUwUAAAP7/AgAAiNNAAAD+/wIAAEzdQAAA/v8CAACI40AAAP7/AgAATO1AAAD+/wIAABfxQAAA/v8CAACI80AAAP7/AgAA+fVA";
            CharInfo.DecodeCharInfo = function DecodeCharInfo() {
                var str = CharInfo.Decode(CharInfo._base64CharInfo);
                var numArr = [];
                var i = 0;
                for(i = 0; i < str.length; i += 2) {
                    var num = (str.charCodeAt(i + 1) * 256) + str.charCodeAt(i);
                    numArr.push(num);
                }
                var tempResult = [];
                for(i = 0; i < numArr.length; i++) {
                    if(numArr[i] != 0xfffe) {
                        tempResult.push(numArr[i]);
                    } else {
                        var number = numArr[i + 1];
                        for(var j = 1; j < number; j++) {
                            tempResult.push(numArr[i - 1]);
                        }
                        i++;
                    }
                }
                for(i = 0; i < tempResult.length; i += 2) {
                    var val = (tempResult[i + 1] * 65536) + tempResult[i];
                    CharInfo._charInfo.push(val);
                }
            };
            CharInfo.GetByte = function GetByte(index) {
                if(CharInfo._charInfo.length === 0) {
                    CharInfo.DecodeCharInfo();
                }
                var i = Math.floor(index / 4);
                var j = index % 4;
                var value = CharInfo._charInfo[i];
                switch(j) {
                    case 0:
                        return value & 0xff;
                    case 1:
                        return (value >> 8) & 0xff;
                    case 2:
                        return (value >> 16) & 0xff;
                    case 3:
                        return (value >> 24) & 0xff;
                }
            };
            CharInfo.GetShortValue = function GetShortValue(index) {
                var i = CharInfo.GetByte(index);
                var j = CharInfo.GetByte(index + 1);
                return j * 256 + i;
            };
            CharInfo.GetIntValue = function GetIntValue(index) {
                var a = CharInfo.GetByte(index);
                var b = CharInfo.GetByte(index + 1);
                var c = CharInfo.GetByte(index + 2);
                var d = CharInfo.GetByte(index + 3);
                return d * 65535 * 256 + c * 65535 + b * 256 + a;
            };
            return CharInfo;
        })();
        input.CharInfo = CharInfo;        
        var CharUnicodeInfo = (function () {
            function CharUnicodeInfo() { }
            CharUnicodeInfo.InitTable = function InitTable() {
                CharUnicodeInfo.globalizationResourceBytePtr = 0;
                CharUnicodeInfo.headerPtr = CharUnicodeInfo.globalizationResourceBytePtr;
                CharUnicodeInfo.s_pCategoryLevel1Index = CharInfo.GetIntValue(CharUnicodeInfo.globalizationResourceBytePtr + 40);
                CharUnicodeInfo.s_pCategoriesValue = CharInfo.GetIntValue(CharUnicodeInfo.globalizationResourceBytePtr + 0x2c);
                CharUnicodeInfo.s_pNumericLevel1Index = CharInfo.GetIntValue(CharUnicodeInfo.globalizationResourceBytePtr + 0x30);
                CharUnicodeInfo.s_pNumericValues = CharInfo.GetIntValue(CharUnicodeInfo.globalizationResourceBytePtr + 0x38);
                CharUnicodeInfo.s_pDigitValues = CharInfo.GetIntValue(CharUnicodeInfo.globalizationResourceBytePtr + 0x34);
            };
            CharUnicodeInfo.InternalConvertToUtf32 = function InternalConvertToUtf32(s, index, charLength) {
                charLength.length = 1;
                if(index < (s.length - 1)) {
                    var num = s.charCodeAt(index) - 0xd800;
                    if((num >= 0) && (num <= 0x3ff)) {
                        var num2 = s.charCodeAt(index + 1) - 0xdc00;
                        if((num2 >= 0) && (num2 <= 0x3ff)) {
                            charLength.length++;
                            return (((num * 0x400) + num2) + 0x10000);
                        }
                    }
                }
                return s.charCodeAt(index);
            };
            CharUnicodeInfo.InternalGeteCategoryValue = function InternalGeteCategoryValue(ch, offset) {
                if(offset === undefined || offset === null) {
                    offset = 0;
                }
                var num = CharInfo.GetShortValue(CharUnicodeInfo.s_pCategoryLevel1Index + 2 * (ch >> 8));
                num = CharInfo.GetShortValue(CharUnicodeInfo.s_pCategoryLevel1Index + 2 * (num + ((ch >> 4) & 15)));
                var numPtr = CharUnicodeInfo.s_pCategoryLevel1Index + 2 * num;
                var num2 = CharInfo.GetByte(numPtr + (ch & 15));
                return CharInfo.GetByte(CharUnicodeInfo.s_pCategoriesValue + (num2 * 2) + offset);
            };
            CharUnicodeInfo.InternalGetUnicodeCategory = function InternalGetUnicodeCategory(str, index, charLength) {
                var utf32 = CharUnicodeInfo.InternalConvertToUtf32(str, index, charLength);
                return CharUnicodeInfo.InternalGeteCategoryValue(utf32, 0);
            };
            CharUnicodeInfo.IsCombiningCategory = function IsCombiningCategory(uc) {
                if((uc !== UnicodeCategory.NonSpacingMark) && (uc !== UnicodeCategory.SpacingCombiningMark)) {
                    return (uc === UnicodeCategory.EnclosingMark);
                }
                return true;
            };
            return CharUnicodeInfo;
        })();
        input.CharUnicodeInfo = CharUnicodeInfo;        
        CharUnicodeInfo.InitTable();
        (function (UnicodeCategory) {
            UnicodeCategory._map = [];
            UnicodeCategory.ClosePunctuation = 0x15;
            UnicodeCategory.ConnectorPunctuation = 0x12;
            UnicodeCategory.Control = 14;
            UnicodeCategory.CurrencySymbol = 0x1a;
            UnicodeCategory.DashPunctuation = 0x13;
            UnicodeCategory.DecimalDigitNumber = 8;
            UnicodeCategory.EnclosingMark = 7;
            UnicodeCategory.FinalQuotePunctuation = 0x17;
            UnicodeCategory.Format = 15;
            UnicodeCategory.InitialQuotePunctuation = 0x16;
            UnicodeCategory.LetterNumber = 9;
            UnicodeCategory.LineSeparator = 12;
            UnicodeCategory.LowercaseLetter = 1;
            UnicodeCategory.MathSymbol = 0x19;
            UnicodeCategory.ModifierLetter = 3;
            UnicodeCategory.ModifierSymbol = 0x1b;
            UnicodeCategory.NonSpacingMark = 5;
            UnicodeCategory.OpenPunctuation = 20;
            UnicodeCategory.OtherLetter = 4;
            UnicodeCategory.OtherNotAssigned = 0x1d;
            UnicodeCategory.OtherNumber = 10;
            UnicodeCategory.OtherPunctuation = 0x18;
            UnicodeCategory.OtherSymbol = 0x1c;
            UnicodeCategory.ParagraphSeparator = 13;
            UnicodeCategory.PrivateUse = 0x11;
            UnicodeCategory.SpaceSeparator = 11;
            UnicodeCategory.SpacingCombiningMark = 6;
            UnicodeCategory.Surrogate = 0x10;
            UnicodeCategory.TitlecaseLetter = 2;
            UnicodeCategory.UppercaseLetter = 0;
        })(input.UnicodeCategory || (input.UnicodeCategory = {}));
        var UnicodeCategory = input.UnicodeCategory;
        var StringInfo = (function () {
            function StringInfo() { }
            StringInfo.GetNextTextElement = function GetNextTextElement(str, index, ref) {
                var num2;
                if(str == null) {
                    throw "ArgumentNullException";
                }
                var length = str.length;
                if((index < 0) || (index >= length)) {
                    if(index != length) {
                        throw "ArgumentOutOfRangeException";
                    }
                    return "";
                }
                var charLengh = {
                };
                var ucCurrent = CharUnicodeInfo.InternalGetUnicodeCategory(str, index, charLengh);
                num2 = charLengh.length;
                var elementLen = StringInfo.GetCurrentTextElementLen(str, index, length, ucCurrent, num2, ref);
                ref.length = elementLen;
                return str.substr(index, elementLen);
            };
            StringInfo.GetCurrentTextElementLen = function GetCurrentTextElementLen(str, index, len, ucCurrent, currentCharCount, ref) {
                var num;
                if((index + currentCharCount) === len) {
                    return currentCharCount;
                }
                var charLength = {
                };
                var uc = CharUnicodeInfo.InternalGetUnicodeCategory(str, index + currentCharCount, charLength);
                num = charLength.length;
                if(((!CharUnicodeInfo.IsCombiningCategory(uc) || CharUnicodeInfo.IsCombiningCategory(ucCurrent)) || ((ucCurrent === UnicodeCategory.Format) || (ucCurrent === UnicodeCategory.Control))) || ((ucCurrent === UnicodeCategory.OtherNotAssigned) || (ucCurrent === UnicodeCategory.Surrogate))) {
                    var num3 = currentCharCount;
                    ref.ucCurrent = uc;
                    ref.currentCharCount = num;
                    return num3;
                }
                var num2 = index;
                index += currentCharCount + num;
                while(index < len) {
                    var charLength = {
                    };
                    uc = CharUnicodeInfo.InternalGetUnicodeCategory(str, index, charLength);
                    num = charLength.length;
                    if(!CharUnicodeInfo.IsCombiningCategory(uc)) {
                        ref.ucCurrent = uc;
                        ref.currentCharCount = num;
                        break;
                    }
                    index += num;
                }
                return (index - num2);
            };
            StringInfo.GetTextElement = function GetTextElement(str) {
                var result = [];
                var index = 0;
                while(index < str.length) {
                    var ref = {
                    };
                    var element = StringInfo.GetNextTextElement(str, index, ref);
                    result.push(element);
                    index += ref.length;
                }
                return result;
            };
            return StringInfo;
        })();
        input.StringInfo = StringInfo;        
        var StringCache = (function () {
            function StringCache() { }
            StringCache.TextElementCache = {
            };
            StringCache.TextElementCacheCount = 0;
            StringCache.AddElementCache = function AddElementCache(str, element) {
                if(StringCache.TextElementCacheCount > 500) {
                    StringCache.TextElementCache = {
                    };
                    StringCache.TextElementCacheCount = 0;
                }
                StringCache.TextElementCache[str] = element;
                StringCache.TextElementCacheCount++;
            };
            return StringCache;
        })();
        input.StringCache = StringCache;        
        String.prototype.GetStandardPosition = function (position, start) {
            this.CreateSurrogateArray();
            var newValue = position;
            if(StringCache.TextElementArray !== null && position > 0) {
                var maxIndex = Math.min(position, StringCache.TextElementArray.length);
                var totalElementSize = 0;
                for(var i = 0; i < maxIndex; i++) {
                    totalElementSize += StringCache.TextElementArray[i].length;
                }
                newValue = totalElementSize;
            }
            return newValue;
        };
        String.prototype.CreateSurrogateArray = function () {
            if(StringCache.TextElementArray === undefined || StringCache._InnerValue.toString() != this.toString()) {
                StringCache._InnerValue = this;
                //save position of surrogate pair
                var elementCol = StringCache.TextElementCache[this];
                if(elementCol === undefined) {
                    elementCol = StringInfo.GetTextElement(this);
                    // Improve performance.
                    StringCache.AddElementCache(this, elementCol);
                }
                if(elementCol.length === this.length) {
                    StringCache.TextElementArray = null;
                } else {
                    StringCache.TextElementArray = elementCol;
                    StringCache.MultiCharExit = false;
                    for(var i = 0; i < elementCol.length; i++) {
                        if(elementCol[i].length > 2) {
                            StringCache.MultiCharExit = true;
                            break;
                        }
                    }
                }
            }
        };
        String.prototype.GetLength = function () {
            this.CreateSurrogateArray();
            var newLength = this.length;
            if(StringCache.TextElementArray !== null) {
                newLength = StringCache.TextElementArray.length;
            }
            return newLength;
        };
        String.prototype.Substring = function (start, end) {
            this.CreateSurrogateArray();
            if(start >= end) {
                return "";
            }
            var newValue = this.substring(start, end);
            if(StringCache.TextElementArray !== null) {
                start = Math.max(0, start);
                end = Math.min(StringCache.TextElementArray.length, end);
                var result = [];
                for(var i = start; i < end; i++) {
                    result.push(StringCache.TextElementArray[i]);
                }
                newValue = result.join("");
            }
            return newValue;
        };
        String.prototype.IndexOf = function (findtext, startindex) {
            this.CreateSurrogateArray();
            var newValue = this.indexOf(findtext, startindex);
            if(StringCache.TextElementArray !== null && newValue > 0) {
                var totalLength = 0;
                for(var i = 0; i < StringCache.TextElementArray.length; i++) {
                    totalLength += StringCache.TextElementArray[i].length;
                    if(totalLength == newValue) {
                        newValue = i + 1;
                        break;
                    }
                }
            }
            if(StringCache.TextElementArray !== null && newValue >= 0) {
                if(this.Substring(newValue, newValue + findtext.GetLength()).length != findtext.length) {
                    newValue = -1;
                }
            }
            return newValue;
        };
        String.prototype.LastIndexOf = function (text) {
            this.CreateSurrogateArray();
            var newValue = this.lastIndexOf(text);
            if(StringCache.TextElementArray !== null && newValue > 0) {
                var totalLength = 0;
                for(var i = 0; i < StringCache.TextElementArray.length; i++) {
                    totalLength += StringCache.TextElementArray[i];
                    if(totalLength == newValue) {
                        newValue = i + 1;
                        break;
                    }
                }
            }
            if(StringCache.TextElementArray !== null && newValue >= 0) {
                if(this.Substring(newValue, newValue + text.GetLength()).length != text.length) {
                    newValue = -1;
                }
            }
            return newValue;
        };
        String.prototype.CharAt = function (position) {
            this.CreateSurrogateArray();
            var newValue = this.charAt(position);
            if(StringCache.TextElementArray !== null) {
                if(position >= 0 && position < StringCache.TextElementArray.length) {
                    newValue = StringCache.TextElementArray[position];
                } else {
                    newValue = "";
                }
            }
            return newValue;
        };
        String.prototype.startWith = function (str) {
            if(str == null || str == "" || this.length == 0 || str.length > this.length) {
                return false;
            }
            if(this.substr(0, str.length) == str) {
                return true;
            } else {
                return false;
            }
        };
        String.prototype.IsNulOrEmpty = function (str) {
            return str == null || str == "";
        };
    })(wijmo.input || (wijmo.input = {}));
    var input = wijmo.input;
})(wijmo || (wijmo = {}));
;
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../external/declarations/globalize.d.ts"/>
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijpopup/jquery.wijmo.wijpopup.ts"/>
    /// <reference path="../wijlist/jquery.wijmo.wijlist.ts"/>
    /// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts"/>
    /// <reference path="jquery.wijmo.wijcharex.ts" />
    /*globals Globalize window jQuery wijInputResult document*/
    (function (input) {
        "use strict";
        var $ = jQuery, jqKeyCode = wijmo.getKeyCodeEnum();
        /** @widget */
        var wijinputcore = (function (_super) {
            __extends(wijinputcore, _super);
            function wijinputcore() {
                _super.apply(this, arguments);

                this._boundMouseWheel = false;
                this._wasPopupShowing = false;
                this._blockNextTriggerClickedEvent = false;
            }
            wijinputcore.prototype._elemWithClasses = function (elem, classes) {
                if (typeof classes === "undefined") { classes = []; }
                return $(elem).addClass(classes.join(" "));
            };
            wijinputcore.prototype._divWithClasses = function () {
                var classes = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    classes[_i] = arguments[_i + 0];
                }
                return this._elemWithClasses("<div/>", classes);
            };
            wijinputcore.prototype._spanWithClasses = function () {
                var classes = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    classes[_i] = arguments[_i + 0];
                }
                return this._elemWithClasses("<span/>", classes);
            };
            wijinputcore.prototype._horizontalBorderWidth = function (elem) {
                return elem.leftBorderWidth() + elem.rightBorderWidth();
            };
            wijinputcore.prototype._verticalBorderWidth = function (elem) {
                return elem.topBorderWidth() + elem.bottomBorderWidth();
            };
            wijinputcore.prototype._create = function () {
                var _this = this;
                try  {
                    var focused = document.activeElement == this.element[0];
                } catch (e) {
                }
                var hBorder = this._horizontalBorderWidth(this.element);
                var vBorder = this._verticalBorderWidth(this.element);
                if(this.element[0].tagName.toLowerCase() !== 'input' && this.element[0].tagName.toLowerCase() !== 'textarea') {
                    throw "Target element is not a INPUT";
                }
                this._creationDate = new Date();
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                if(this.element.is(":hidden") && this.element.wijAddVisibilityObserver) {
                    this.element.wijAddVisibilityObserver(function () {
                        _this._destroy();
                        _this._create();
                        if(_this.element.wijRemoveVisibilityObserver) {
                            _this.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijinput");
                }
                this.element.data("widgetName", this.widgetName);
                //$.effects.save(this.element, ['width', 'height']);
                if($.effects && $.effects.save) {
                    $.effects.save(this.element, [
                        'width', 
                        'height'
                    ]);
                } else if($.save) {
                    $.save(this.element, [
                        'width', 
                        'height'
                    ]);
                }
                var wijCSS = this.options.wijCSS;
                this.element.wrap("<div><span/></div");
                this.wrapper = this.element.parent();
                this.outerDiv = this.wrapper.parent();
                this.outerDiv.addClass([
                    wijCSS.wijinput, 
                    wijCSS.widget, 
                    wijCSS.helperClearFix, 
                    wijCSS.stateDefault, 
                    wijCSS.cornerAll
                ].join(" "));
                this.wrapper.addClass(wijCSS.wijinputWrapper);
                this.element.addClass(wijCSS.wijinputInput).addClass(wijCSS.cornerAll).attr('role', 'textbox');
                if(!(Utility.IsIE() && parseFloat($.browser.version) <= 7)) {
                    //Can't set 'aria-multiline' attribute by jQuery's attr() api in IE10 Compatibility View
                    try  {
                        this.element.attr('aria-multiline', false);
                    } catch (e) {
                        this.element[0].setAttribute('aria-multiline', "false");
                    }//self.element.attr('aria-multiline', false);
                    
                }
                if(this.options.showTrigger != undefined) {
                    this.options.showDropDownButton = this.options.showTrigger;
                }
                this._createDropDownAndSpin();
                this._initialize();
                if(focused) {
                    $(function () {
                        return _this.element.focus().wijtextselection(0, _this.element.val().length);
                    });
                }
                // We need to move width and height from the <input/> to the outer <div/> because the input must span the parent wrapper.
                // It must be done if A dimension is set in the style attribute, hence the "if" statements
                // The a dimension is in pixels, it must be adjusted according to the input's and div's border/margin/padding.
                // The input's total border size must be calcualted before changing the classes, hence variables hBorder and vBorder.
                var style = this.element[0].style;
                if(style.width) {
                    if(this._isInPercents(style.width)) {
                        this.outerDiv.width(style.width);
                    } else {
                        this.outerDiv.width(this.element.width() + hBorder - this._horizontalBorderWidth(this.outerDiv));
                    }
                    this.element.width("");
                }
                if(style.height) {
                    if(this._isInPercents(style.height)) {
                        this.outerDiv.height(style.height);
                    } else {
                        this.outerDiv.height(this.element.height() + vBorder - this._verticalBorderWidth(this.outerDiv));
                    }
                    this.element.height(this.outerDiv.height() - (parseInt(this.wrapper.css('padding-top')) + parseInt(this.wrapper.css('padding-bottom'))));
                    this.wrapper.height(style.height);
                }
            };
            wijinputcore.prototype._createDropDownAndSpin = function () {
                this._createDropDownAndSpinElement();
                this._createDropDownAndSpinStyle();
                this._createDropDownAndSpinLayout();
            };
            wijinputcore.prototype._createDropDownAndSpinElement = function () {
                var wijCSS = this.options.wijCSS;
                var spinnerAlign = this.options.spinnerAlign;
                var leftSpinnerBtn = spinnerAlign === 'verticalLeft';
                var leftDropDownBtn = this.options.dropDownButtonAlign === 'left';
                var showSpinner = this.options.showSpinner;
                var showDropDownButton = this._isDropDownButtonShown();
                if(this.options.buttonAlign != null) {
                    leftSpinnerBtn = this.options.buttonAlign == 'left';
                    leftDropDownBtn = this.options.buttonAlign == 'left';
                    spinnerAlign = this.options.buttonAlign == 'left' ? "verticalLeft" : "verticalRight";
                }
                this.triggerBtn = null;
                this.spinUpElement = null;
                this.spinDownElement = null;
                this.outerDiv.css("overflow", "hidden");
                if(showDropDownButton) {
                    var cornerCSS = leftDropDownBtn ? wijCSS.cornerLeft : wijCSS.cornerRight;
                    this.triggerBtn = this._divWithClasses(wijCSS.wijinputTrigger, wijCSS.stateDefault, cornerCSS).append(this._spanWithClasses(wijCSS.icon, wijCSS.iconArrowDown)).attr('role', 'button');
                    this.element.attr({
                        'role': 'combobox',
                        'aria-expanded': false
                    });
                }
                if(showSpinner) {
                    this.spinnerLeft = this._divWithClasses(wijCSS.wijinputSpinnerLeft, wijCSS.wijinputButton);
                    this.spinnerRight = this._divWithClasses(wijCSS.wijinputSpinnerRight, wijCSS.wijinputButton);
                    if(spinnerAlign === "verticalLeft" || spinnerAlign === "verticalRight") {
                        this.spinUpElement = this._divWithClasses(wijCSS.stateDefault, wijCSS.wijinputSpinUp).append(this._spanWithClasses(wijCSS.icon, wijCSS.iconArrowUp)).css({
                            "padding": "0px"
                        }).attr('role', 'upbutton');
                        this.spinDownElement = this._divWithClasses(wijCSS.stateDefault, wijCSS.wijinputSpinDown).append(this._spanWithClasses(wijCSS.icon, wijCSS.iconArrowDown)).css({
                            "padding": "0px"
                        }).attr('role', 'downbutton');
                    } else {
                        this.spinUpElement = this._divWithClasses(wijCSS.stateDefault, wijCSS.wijinputSpin).append(this._spanWithClasses(wijCSS.icon, wijCSS.iconPlus, wijCSS.glyphIcon, wijCSS.glyphIconPlus)).css({
                            "padding": "0px"
                        }).attr('role', 'upbutton');
                        this.spinDownElement = this._divWithClasses(wijCSS.stateDefault, wijCSS.wijinputSpin).append(this._spanWithClasses(wijCSS.icon, wijCSS.iconMinus, wijCSS.glyphIcon, wijCSS.glyphIconMinus)).css({
                            "padding": "0px"
                        }).attr('role', 'downbutton');
                    }
                    this.element.attr('role', 'spinner');
                }
            };
            wijinputcore.prototype._createDropDownAndSpinStyle = function () {
                var wijCSS = this.options.wijCSS;
                var spinnerAlign = this.options.spinnerAlign;
                var leftSpinnerBtn = this.options.spinnerAlign === 'verticalLeft';
                var leftDropDownBtn = this.options.dropDownButtonAlign === 'left';
                var showSpinner = this.options.showSpinner;
                var showDropDownButton = this._isDropDownButtonShown();
                if(this.options.buttonAlign != null) {
                    leftSpinnerBtn = this.options.buttonAlign == 'left';
                    leftDropDownBtn = this.options.buttonAlign == 'left';
                    spinnerAlign = this.options.buttonAlign == 'left' ? "verticalLeft" : "verticalRight";
                }
                //Flag CSS
                if(showDropDownButton && showSpinner) {
                    if(leftDropDownBtn) {
                        switch(spinnerAlign) {
                            case "verticalLeft":
                                this.outerDiv.addClass(wijCSS.inputSpinnerTriggerLeft);
                                break;
                            case "verticalRight":
                                this.outerDiv.addClass(wijCSS.inputTriggerLeft);
                                this.outerDiv.addClass(wijCSS.inputSpinnerRight);
                                break;
                            case "horizontalDownLeft":
                            case "horizontalUpLeft":
                                this.outerDiv.addClass(wijCSS.inputSpinnerTriggerLeft);
                                this.outerDiv.addClass(wijCSS.inputSpinnerRight);
                                break;
                        }
                    } else {
                        switch(spinnerAlign) {
                            case "verticalLeft":
                                this.outerDiv.addClass(wijCSS.inputTriggerRight);
                                this.outerDiv.addClass(wijCSS.inputSpinnerLeft);
                                break;
                            case "verticalRight":
                                this.outerDiv.addClass(wijCSS.inputSpinnerTriggerRight);
                                break;
                            case "horizontalDownLeft":
                            case "horizontalUpLeft":
                                this.outerDiv.addClass(wijCSS.inputSpinnerTriggerRight);
                                this.outerDiv.addClass(wijCSS.inputSpinnerLeft);
                                break;
                        }
                    }
                } else if(showDropDownButton) {
                    if(leftDropDownBtn) {
                        this.outerDiv.addClass(wijCSS.inputTriggerLeft);
                    } else {
                        this.outerDiv.addClass(wijCSS.inputTriggerRight);
                    }
                } else if(showSpinner) {
                    switch(spinnerAlign) {
                        case "verticalLeft":
                            this.outerDiv.addClass(wijCSS.inputSpinnerLeft);
                            break;
                        case "verticalRight":
                            this.outerDiv.addClass(wijCSS.inputSpinnerRight);
                            break;
                        case "horizontalDownLeft":
                        case "horizontalUpLeft":
                            this.outerDiv.addClass(wijCSS.inputSpinnerLeft);
                            this.outerDiv.addClass(wijCSS.inputSpinnerRight);
                            break;
                    }
                }
                //Corner CSS
                if(showDropDownButton && showSpinner) {
                    if(leftDropDownBtn) {
                        switch(spinnerAlign) {
                            case "verticalRight":
                                this.spinUpElement.addClass(wijCSS.cornerTR);
                                this.spinDownElement.addClass(wijCSS.cornerBR);
                                break;
                            case "horizontalDownLeft":
                                this.spinUpElement.addClass(wijCSS.cornerRight);
                                break;
                            case "horizontalUpLeft":
                                this.spinDownElement.addClass(wijCSS.cornerRight);
                                break;
                        }
                    } else {
                        switch(spinnerAlign) {
                            case "verticalLeft":
                                this.spinUpElement.addClass(wijCSS.cornerTL);
                                this.spinDownElement.addClass(wijCSS.cornerBL);
                                break;
                            case "horizontalDownLeft":
                                this.spinDownElement.addClass(wijCSS.cornerLeft);
                                break;
                            case "horizontalUpLeft":
                                this.spinUpElement.addClass(wijCSS.cornerLeft);
                                break;
                        }
                    }
                } else if(showSpinner) {
                    switch(spinnerAlign) {
                        case "verticalLeft":
                            this.spinUpElement.addClass(wijCSS.cornerTL);
                            this.spinDownElement.addClass(wijCSS.cornerBL);
                            break;
                        case "verticalRight":
                            this.spinUpElement.addClass(wijCSS.cornerTR);
                            this.spinDownElement.addClass(wijCSS.cornerBR);
                            break;
                        case "horizontalDownLeft":
                            this.spinDownElement.addClass(wijCSS.cornerLeft);
                            this.spinUpElement.addClass(wijCSS.cornerRight);
                            break;
                        case "horizontalUpLeft":
                            this.spinUpElement.addClass(wijCSS.cornerLeft);
                            this.spinDownElement.addClass(wijCSS.cornerRight);
                            break;
                    }
                }
            };
            wijinputcore.prototype._createDropDownAndSpinLayout = function () {
                var spinnerAlign = this.options.spinnerAlign;
                var showSpinner = this.options.showSpinner;
                var showDropDownButton = this._isDropDownButtonShown();
                if(this.options.buttonAlign != null) {
                    spinnerAlign = this.options.buttonAlign == 'left' ? "verticalLeft" : "verticalRight";
                }
                if(showDropDownButton) {
                    this.triggerBtn.appendTo(this.outerDiv);
                }
                if(showSpinner) {
                    switch(spinnerAlign) {
                        case "verticalLeft":
                            this.spinnerLeft.append(this.spinUpElement).append(this.spinDownElement).appendTo(this.outerDiv);
                            break;
                        case "verticalRight":
                            this.spinnerRight.append(this.spinUpElement).append(this.spinDownElement).appendTo(this.outerDiv);
                            break;
                        case "horizontalDownLeft":
                            this.spinnerLeft.append(this.spinDownElement).appendTo(this.outerDiv);
                            this.spinnerRight.append(this.spinUpElement).appendTo(this.outerDiv);
                            break;
                        case "horizontalUpLeft":
                            this.spinnerLeft.append(this.spinUpElement).appendTo(this.outerDiv);
                            this.spinnerRight.append(this.spinDownElement).appendTo(this.outerDiv);
                            break;
                    }
                }
            };
            wijinputcore.prototype._isDropDownButtonShown = function () {
                var showTrigger = this.options.showTrigger;
                if(showTrigger === undefined) {
                    showTrigger = false;
                }
                return showTrigger || this.options.showDropDownButton;
            };
            wijinputcore.prototype._isInPercents = function (size) {
                return size.match(/%$/);
            };
            wijinputcore.prototype._createTextProvider = function () {
                return undefined;
            };
            wijinputcore.prototype._beginUpdate = function () {
            };
            wijinputcore.prototype._endUpdate = function () {
                var _this = this;
                if(this.element.mousewheel && !this._boundMouseWheel) {
                    this.element.mousewheel(function (e, delta) {
                        if(_this.isFocused() && _this._doSpin(delta > 0, false)) {
                            e.preventDefault();
                        }
                    });
                    this._boundMouseWheel = true;
                }
            };
            wijinputcore.prototype._isPopupShowing = function () {
                return !!this._comboDiv && this._comboDiv.wijpopup("isVisible");
            };
            wijinputcore.prototype._onTriggerMouseDown = function (evt) {
                if(this._wasPopupShowing) {
                    this._blockNextTriggerClickedEvent = true;
                }
            };
            wijinputcore.prototype._onTriggerMouseUp = function (evt) {
            };
            wijinputcore.prototype._onTriggerClicked = function () {
                if(this._blockNextTriggerClickedEvent) {
                    this._blockNextTriggerClickedEvent = false;
                    return;
                }
                if(this._popupVisible()) {
                    this._hidePopup();
                } else {
                    this._showPopup();
                }
            };
            wijinputcore.prototype._showPopup = function () {
                return this._popupComboList();
            };
            wijinputcore.prototype._hidePopup = function () {
                this._comboDiv.wijpopup('hide');
            };
            wijinputcore.prototype._initialize = function () {
                var _this = this;
                this.element.data('initializing', true);
                this._trigger('initializing');
                this.element.data('preText', this.element.val());
                this.element.data('elementValue', this.element.val());
                this.element.data('errorstate', false);
                this.element.data('breakSpinner', true);
                this.element.data('prevSelection', null);
                this.element.data('simulating', false);
                this._createTextProvider();
                this._beginUpdate();
                var options = this.options, isLeftButton = function (e) {
                    return (!e.which ? e.button : e.which) === 1;
                }, spinButtonDown = function (e) {
                    if(_this.options.disabled) {
                        return;
                    }
                    if(!isLeftButton(e)) {
                        return;
                    }
                    if(_this.options.disableUserInput) {
                        return;
                    }
                    _this._trySetFocus();
                    if(Utility.IsFireFox4OrLater()) {
                        _this._stopEvent(e);
                    }
                    _this.element.data('breakSpinner', false);
                    _this._addState('active', $(_this));
                    _this._doSpin($(e.currentTarget).attr("role") == "upbutton", true);
                }, spinButtonUp = function (e) {
                    if(_this.options.disabled) {
                        return;
                    }
                    if(!isLeftButton(e)) {
                        return;
                    }
                    if(_this.options.disableUserInput) {
                        return;
                    }
                    _this._stopSpin();
                    _this._removeState('active', $(_this));
                };
                if(this.triggerBtn && !options.disabledState) {
                    this.triggerBtn.bind({
                        'mouseover': function () {
                            if(_this.options.disabled) {
                                return;
                            }
                            _this._addState('hover', $(_this));
                        },
                        'mouseout': function () {
                            if(_this.options.disabled) {
                                return;
                            }
                            _this._removeState('hover', $(_this));
                        },
                        'mousedown': function (e) {
                            if(_this.options.disabled) {
                                return;
                            }
                            if(!isLeftButton(e)) {
                                return;
                            }
                            _this._stopEvent(e);
                            _this._addState('active', $(_this));
                            _this._trigger('triggerMouseDown');
                            _this._trigger('dropDownButtonMouseDown');
                            _this._onTriggerMouseDown(e);
                        },
                        'mouseup': function (e) {
                            _this._onTriggerMouseUp(e);
                        },
                        'click': function (e) {
                            if(_this.options.disabled) {
                                return;
                            }
                            _this._stopEvent(e);
                            _this._stopSpin();
                            _this._removeState('active', $(_this));
                            _this._trigger('triggerMouseUp');
                            _this._trigger('dropDownButtonMouseUp');
                            _this._onTriggerClicked();
                            _this._trySetFocus();
                        }
                    });
                }
                if(this.spinUpElement && !options.disabledState) {
                    this.spinUpElement.bind({
                        'mouseover': function () {
                            if(_this.options.disabled) {
                                return;
                            }
                            _this._addState('hover', $(_this));
                        },
                        'mouseout': function () {
                            if(_this.options.disabled) {
                                return;
                            }
                            _this._removeState('hover', $(_this));
                            _this._removeState('active', $(_this));
                            _this._stopSpin();
                        },
                        'mousedown': spinButtonDown,
                        'mouseup': spinButtonUp
                    });
                }
                if(this.spinDownElement && !options.disabledState) {
                    this.spinDownElement.bind({
                        'mouseover': function () {
                            if(_this.options.disabled) {
                                return;
                            }
                            _this._addState('hover', $(_this));
                        },
                        'mouseout': function () {
                            if(_this.options.disabled) {
                                return;
                            }
                            _this._removeState('hover', $(_this));
                            _this._removeState('active', $(_this));
                            _this._stopSpin();
                        },
                        'mousedown': spinButtonDown,
                        'mouseup': spinButtonUp
                    });
                }
                this._attachInputEvent();
                this.element.data('initializing', false);
                this._resetData();
                this._endUpdate();
                this._updateText();
                if(this.options.disabledState) {
                    var dis = options.disabled;
                    this.disable();
                    options.disabled = dis;
                }
                if(this.options.disabled) {
                    this.disable();
                }
                if(this.options.imeMode) {
                    this.element.css("ime-mode", this.options.imeMode);
                }
                this.element.data('initialized', true);
                this._trigger('initialized');
            };
            wijinputcore.prototype._attachInputEvent = function () {
                this.element.bind({
                    'focus.wijinput': $.proxy(this._onFocus, this),
                    'beforedeactivate.wijinput': $.proxy(this._onBeforeDeactivate, this),
                    'blur.wijinput': $.proxy(this._onBlur, this),
                    'mousedown.wijinput': $.proxy(this._onMouseDown, this),
                    'mouseup.wijinput': $.proxy(this._onMouseUp, this),
                    'keypress.wijinput': $.proxy(this._onKeyPress, this),
                    'keydown.wijinput': $.proxy(this._onKeyDown, this),
                    'keyup.wijinput': $.proxy(this._onKeyUp, this),
                    'compositionstart.wijinput': $.proxy(this._onCompositionStart, this),
                    'compositionend.wijinput': $.proxy(this._onCompositionEnd, this),
                    'change.wijinput': $.proxy(this._onChange, this),
                    'paste.wijinput': $.proxy(this._onPaste, this),
                    'drop.wijinput': $.proxy(this._onDrop, this)
                });
                this.element.bind('propertychange.wijinput input.wijinput', $.proxy(this._onInput, this));
            };
            wijinputcore.prototype._detachInputEvent = function () {
                this.element.unbind('.wijinput');
            };
            wijinputcore.prototype._init = function () {
                if(this.element.attr("readOnly")) {
                    this.options.readonly = true;
                }
                if(this.options.readonly === true) {
                    this.options.disableUserInput = true;
                }
                if(this.options.readonly === true || this.options.disableUserInput === true) {
                    this.element.attr('readOnly', true);
                }
                if(this.options.placeholder != null) {
                    this.options.nullText = this.options.placeholder;
                }
            };
            wijinputcore.prototype._showNullText = function () {
                return !!this.options.nullText || this.options.nullText === "";
            };
            wijinputcore.prototype._setOption = function (key, value) {
                switch(key) {
                    case 'readonly':
                        this._super(key, value);
                        key = "disableUserInput";
                        break;
                    case 'placeholder':
                        this._super(key, value);
                        key = 'nullText';
                        break;
                    case 'showTrigger':
                        this.options.showTrigger = value;
                        this.options.showDropDownButton = value;
                        break;
                }
                this._super(key, value);
                switch(key) {
                    case 'spinnerAlign':
                    case 'dropDownButtonAlign':
                    case 'showDropDownButton':
                    case 'buttonAlign':
                    case 'showTrigger':
                    case 'showSpinner':
                        this._destroy();
                        this._create();
                        break;
                    case 'showNullText':
                    case 'nullText':
                        this._updateText();
                        break;
                    case 'imeMode':
                        this.element.css("ime-mode", this.options.imeMode);
                        break;
                    case 'disabled':
                        this.element.attr('disabled', value);
                        var addRemove = value ? 'addClass' : 'removeClass';
                        var stateDisabled = this.options.wijCSS.stateDisabled;
                        this.element[addRemove](stateDisabled);
                        if(this.triggerBtn) {
                            this.triggerBtn[addRemove](stateDisabled);
                        }
                        if(this.spinUpElement) {
                            this.spinUpElement[addRemove](stateDisabled);
                        }
                        if(this.spinDownElement) {
                            this.spinDownElement[addRemove](stateDisabled);
                        }
                        break;
                    case 'disableUserInput':
                        this.element.attr('readOnly', value);
                        break;
                    case 'pickers':
                        this._deleteComboDiv();
                        break;
                }
            };
            wijinputcore.prototype.destroy = /** Destroy the widget.
            */
            function () {
                this._super();
                if(this._comboDiv) {
                    this._comboDiv.remove();
                }
                this._destroy();
            };
            wijinputcore.prototype.drop = /** Open the dropdown list.
            */
            function () {
                this._onTriggerClicked();
            };
            wijinputcore.prototype.isDestroyed = /** Get a bool value indicates that whether the widget has been destroyed.
            */
            function () {
                return !this.outerDiv;
            };
            wijinputcore.prototype._destroy = function () {
                if(this.isDestroyed()) {
                    return;
                }
                this.wrapper = undefined;
                this.outerDiv = undefined;
                this._detachInputEvent();
                this.element.removeData('errorstate').removeData('breakSpinner').removeData('prevSelection').removeData('simulating').removeData('isPassword').removeClass(this.options.wijCSS.wijinputInput).removeAttr('role').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuenow').removeAttr('aria-expanded');
                this.element.parent().replaceWith(this.element);
                this.element.parent().replaceWith(this.element);
                //$.effects.restore(this.element, ['width', 'height']);
                if($.effects && $.effects.restore) {
                    $.effects.restore(this.element, [
                        'width', 
                        'height'
                    ]);
                } else if($.restore) {
                    $.restore(this.element, [
                        'width', 
                        'height'
                    ]);
                }
                // DaryLuo 2014/03/05 fix bug 50664.
                this.triggerBtn = undefined;
            };
            wijinputcore.prototype.widget = /** Gets element this widget is associated.
            */
            function () {
                return this.outerDiv || this._super();
            };
            wijinputcore.prototype._getCulture = function (name) {
                if (typeof name === "undefined") { name = this.options.culture; }
                return Globalize.findClosestCulture(name || this.options.culture);
            };
            wijinputcore.prototype._addState = function (state, el) {
                if(el.is(':not(.ui-state-disabled)')) {
                    el.addClass(this.options.wijCSS.getState(state));
                }
            };
            wijinputcore.prototype._removeState = function (state, el) {
                el.removeClass(this.options.wijCSS.getState(state));
            };
            wijinputcore.prototype._isInitialized = function () {
                return !this.element.data('initializing');
            };
            wijinputcore.prototype._setData = function (val) {
                this.setText(val);
            };
            wijinputcore.prototype._resetData = function () {
            };
            wijinputcore.prototype._validateData = function () {
            };
            wijinputcore.prototype.getText = /** Gets the text displayed in the input box.
            */
            function () {
                if(!this._isInitialized()) {
                    return this.element.val();
                }
                return this._textProvider.toString(true, false, false);
            };
            wijinputcore.prototype.setText = /** Sets the text displayed in the input box.
            * @example
            * // This example sets text of a wijinputcore to "Hello"
            * $(".selector").wijinputcore("setText", "Hello");
            */
            function (value) {
                if(!this._isInitialized()) {
                    this.element.val(value);
                } else {
                    this._textProvider.setText(value);
                    if(value !== "" && this.element.val() !== this.options.nullText) {
                        this.element.data('isShowNullText', false);
                    }
                    this._updateText();
                }
            };
            wijinputcore.prototype.getPostValue = /** Gets the text value when the container form is posted back to server.
            */
            function () {
                if(!this._isInitialized()) {
                    return this.element.val();
                }
                return this._textProvider.toString(true, false, true);
            };
            wijinputcore.prototype.selectText = /** Selects a range of text in the widget.
            * @param {Number} start Start of the range.
            * @param {Number} end End of the range.
            * @example
            * // Select first two symbols in a wijinputcore
            * $(".selector").wijinputdate("selectText", 0, 2);
            */
            function (start, end) {
                if (typeof start === "undefined") { start = 0; }
                if (typeof end === "undefined") { end = this.getText().length; }
                var _this = this;
                if(isNaN(start)) {
                    start = 0;
                }
                if(isNaN(end)) {
                    end = 0;
                }
                if(Utility.IsFireFox4OrLater()) {
                    this.focus();
                }
                if(this.element.is(':disabled')) {
                    return;
                }
                this.isSelectingFromAPI = true;
                this.element.wijtextselection(start, end);
                setTimeout(function () {
                    return _this.isSelectingFromAPI = false;
                }, 100);
            };
            wijinputcore.prototype.focus = /** Set the focus to the widget.
            */
            function () {
                if(this.element.is(':disabled')) {
                    return;
                }
                this.element.get(0).focus();
            };
            wijinputcore.prototype.isFocused = /** Determines whether the widget has the focus.
            */
            function () {
                if(!this.outerDiv) {
                    return false;
                }
                return this.outerDiv.hasClass(this.options.wijCSS.stateFocus);
            };
            wijinputcore.prototype.getSelectedText = /** Gets the selected text.
            */
            function () {
                if(this.isFocused()) {
                    return this.element.wijtextselection().text;
                } else {
                    if(this.element.data('prevSelection')) {
                        var start = this.element.data('prevSelection').start, end = this.element.data('prevSelection').end;
                        return this.element.val().substring(start, end);
                    } else {
                        return "";
                    }
                }
            };
            wijinputcore.prototype._raiseTextChanged = function () {
                var txt = this.element.val(), preText = this.element.data('preText');
                if(!!this.element.data('initialized') && preText !== txt) {
                    this._trigger('textChanged', null, {
                        text: txt
                    });
                    this.element.data('changed', true);
                }
                this.element.data('preText', txt);
            };
            wijinputcore.prototype._raiseDataChanged = function () {
            };
            wijinputcore.prototype._allowEdit = function () {
                return !this.element.is(':disabled');
            };
            wijinputcore.prototype._updateText = function (keepSelection) {
                if (typeof keepSelection === "undefined") { keepSelection = false; }
                if(!this._isInitialized()) {
                    return;
                }
                // default is false
                keepSelection = !!keepSelection;
                var range;
                if(this.element.data('selectionbeforeblur') !== undefined) {
                    range = this.element.data('selectionbeforeblur');
                    this.element.removeData('selectionbeforeblur');
                } else {
                    range = this.element.wijtextselection();
                }
                var opt = this.options;
                if(this.isDeleteAll && this._showNullText()) {
                    this.isDeleteAll = false;
                    opt.date = null;
                    this.element.val(opt.nullText);
                } else {
                    this.element.val(this._textProvider.toString());
                    this.options.text = this._textProvider.toString(true, false, false);
                }
                if(this.element.is(':disabled')) {
                    return;
                }
                if(keepSelection) {
                    this.selectText(range.start, range.end);
                }
                this.element.data('prevSelection', range);
                this._raiseTextChanged();
                this._raiseDataChanged();
            };
            wijinputcore.prototype._trySetFocus = function () {
                if(document.activeElement !== this.element[0]) {
                    try  {
                        if(!this.options.disableUserInput) {
                            this.element.focus();
                        }
                    } catch (e) {
                    }
                }
            };
            wijinputcore.prototype._deleteSelText = function (backSpace) {
                if (typeof backSpace === "undefined") { backSpace = false; }
                if(!this._allowEdit()) {
                    return;
                }
                var selRange = this.element.wijtextselection();
                if(backSpace) {
                    if(selRange.end < 1) {
                        return;
                    }
                    if(selRange.end === selRange.start) {
                        selRange.start--;
                    }
                }
                selRange.end--;
                if(selRange.end < selRange.start) {
                    selRange.end = selRange.start;
                }
                var rh = new input.wijInputResult();
                this._textProvider.removeAt(selRange.start, selRange.end, rh);
                this._updateText();
                this.selectText(rh.testPosition, rh.testPosition);
            };
            wijinputcore.prototype._fireIvalidInputEvent = function (chr) {
                var _this = this;
                var invalidInputResult = this._trigger('invalidInput', null, {
                    widget: this,
                    char: chr
                });
                if($.isFunction(this.options.invalidInput) && invalidInputResult === true) {
                    return;
                }
                if(!this.element.data('errorstate')) {
                    var cls = this.options.invalidClass || this.options.wijCSS.stateError;
                    this.element.data('errorstate', true);
                    window.setTimeout(function () {
                        if(_this.outerDiv) {
                            _this.outerDiv.removeClass(cls);
                        }
                        _this.element.data('errorstate', false);
                    }, 200);
                    this.outerDiv.addClass(cls);
                }
            };
            wijinputcore.prototype._onInput = function (e) {
                if(!this._isSimulating() || !this.element.data('ime') || this.element.data("isComposingIME")) {
                    if(this.element.data("isComposingIME")) {
                        this.element.data("simulationPending", true);
                    }
                    return;
                }
                this._simulate();
            };
            wijinputcore.prototype._keyDownPreview = function (e) {
                var key = e.keyCode || e.which;
                if(e.ctrlKey === true && key === 88) {
                    // Ctrl + X
                    return true;
                }
                if(e.ctrlKey === true && key === 90) {
                    // Ctrl + Z
                    return true;
                }
                return false;// true means handled.
                
            };
            wijinputcore.prototype._onDoubleByteCharacter = function () {
                var prev = this.element.data("lastDbsState");
                var curSel = this.element.wijtextselection();
                var curText = this.element.val();
                if(this.element.data("isComposingIME") && prev && prev.selection.start === curSel.start && prev.Text === curText) {
                    // nothing changed. The input must be accepted
                    this.element.removeData("lastDbsState");
                    this._onCompositionEnd();
                } else {
                    this.element.data("lastDbsState", {
                        selection: curSel,
                        text: curText
                    });
                    this._onCompositionStart();
                }
            };
            wijinputcore.prototype._onCompositionStart = function () {
                if(this.element.data("isComposingIME")) {
                    return;
                }
                this.element.data("isComposingIME", true);
                this._beforeSimulate(true);
            };
            wijinputcore.prototype._onCompositionEnd = function () {
                if(!this.element.data("isComposingIME")) {
                    return;
                }
                this.element.data("isComposingIME", false);
                if(this._isInitialized() && (!this._textProvider || !this._textProvider.noMask)) {
                    this._simulateIfPending();
                }
            };
            wijinputcore.prototype._simulateIfPending = function () {
                if(this.element.data("simulationPending") && this.element.data("lastSelection")) {
                    this._simulate();
                }
            };
            wijinputcore.prototype._beforeSimulate = function (ime) {
                if (typeof ime === "undefined") { ime = false; }
                if(!this.element.data('lastSelection')) {
                    this.element.data('lastSelection', this.element.wijtextselection());
                    this.element.data('lastValue', this.element.val());
                }
                this.element.data('ime', ime);
                this.element.data('simulating', true);
            };
            wijinputcore.prototype._isSimulating = function () {
                return this.element.data('simulating');
            };
            wijinputcore.prototype._simulate = function (text) {
                var self = this;
                var str = null;
                this.element.data("simulationPending", false);
                if(typeof text === "string") {
                    str = text;
                } else {
                    var range = this.element.wijtextselection();
                    var start = this.element.data('lastSelection').start;
                    var end = range.end;
                    if(end >= start) {
                        str = this.element.val().substring(start, end);
                    }
                }
                if(str) {
                    window.setTimeout(function () {
                        if(self._isLastValueNull()) {
                            return;
                        }
                        self.element.val(self.element.data('lastValue'));
                        var lastSel = self.element.data('lastSelection');
                        self.element.wijtextselection(lastSel);
                        self._batchKeyPress = true;
                        self.element.data('simulating', false);
                        var e = jQuery.Event('keypress');
                        e.ctrlKey = e.altKey = false;
                        for(var i = 0; i < str.length; i++) {
                            e.which = e.charCode = e.keyCode = str.charCodeAt(i);
                            self._nextChar = i === str.length - 1 ? "" : str.charAt(i + 1);
                            self._onKeyPress(e);
                            self._nextChar = "";
                            var appendChar = self._appendChar;
                            if(appendChar && appendChar.length > 0) {
                                self._appendChar = "";
                                e.which = e.charCode = e.keyCode = appendChar.charCodeAt(i);
                                self._onKeyPress(e);
                            }
                            if(self._skipNextChar) {
                                i++;
                                self._skipNextChar = false;
                            }
                        }
                        self._batchKeyPress = false;
                        self._endSimulate();
                    }, 1);
                }
            };
            wijinputcore.prototype._isLastValueNull = function () {
                return !this.element.data('lastValue');
            };
            wijinputcore.prototype._endSimulate = function () {
                this._simulateIfPending();
                this.element.removeData('ime');
                this.element.removeData('lastSelection');
                this.element.removeData('lastValue');
            };
            wijinputcore.prototype._processKeyForDropDownList = function (e) {
                var k = this._getKeyCode(e);
                if(e.altKey && (k === jqKeyCode.UP || k === jqKeyCode.DOWN)) {
                    this._onTriggerClicked();
                    this._stopEvent(e);
                    return true;
                }
                if(k === jqKeyCode.ESCAPE) {
                    if(this._wasPopupShowing) {
                        this._hidePopup();
                        this._stopEvent(e);
                        return true;
                    }
                }
                if(this._wasPopupShowing && this._comboDiv !== undefined) {
                    if(k === jqKeyCode.DOWN) {
                        try  {
                            this._comboDiv.wijlist('next');
                        } catch (ee) {
                        }
                        this._stopEvent(e);
                        return true;
                    } else if(k === jqKeyCode.UP) {
                        try  {
                            this._comboDiv.wijlist('previous');
                        } catch (ee) {
                        }
                        this._stopEvent(e);
                        return true;
                    } else if(k === jqKeyCode.ENTER) {
                        this._comboDiv.wijlist('select');
                        this._stopEvent(e);
                        return true;
                    } else //else if (k === jqKeyCode.HOME) {
                    //     var listItems = this._comboDiv.wijlist("getList");
                    //     if (listItems.length > 0) {
                    //         this._comboDiv.wijlist('activate', null, listItems[0], true);
                    //     }
                    //     this._stopEvent(e);
                    //     return;
                    // }
                    // else if (k === jqKeyCode.END) {
                    //     var listItems = this._comboDiv.wijlist("getList");
                    //     if (listItems.length > 0) {
                    //         this._comboDiv.wijlist('activate', null, listItems[listItems.length - 1], true);
                    //     }
                    //     this._stopEvent(e);
                    //     return;
                    // }
                    if(k === jqKeyCode.PAGE_DOWN) {
                        try  {
                            this._comboDiv.wijlist('nextPage');
                        } catch (ee) {
                        }
                        this._stopEvent(e);
                        return true;
                    } else if(k === jqKeyCode.PAGE_UP) {
                        try  {
                            this._comboDiv.wijlist('previousPage');
                        } catch (ee) {
                        }
                        this._stopEvent(e);
                        return true;
                    }
                }
            };
            wijinputcore.prototype._processKeyOnNoMask = function (e) {
                var k = this._getKeyCode(e);
                if(k === jqKeyCode.Enter) {
                    this._onEnterDown(e);
                }
                if(k === jqKeyCode.LEFT || k === jqKeyCode.RIGHT) {
                    if(this._processLeftRightKey(k === jqKeyCode.LEFT)) {
                        this._stopEvent(e);
                        return;
                    }
                }
                this._processKeyForDropDownList(e);
            };
            wijinputcore.prototype._onKeyDown = function (e) {
                this.element.data('prevSelection', null);
                this._deleteKeyDown = false;
                if(!this._isInitialized()) {
                    return;
                }
                if(this._textProvider && !!this._textProvider.noMask) {
                    this._processKeyOnNoMask(e);
                    return;
                }
                var k = this._getKeyCode(e);
                if(k === 229) {
                    // Double Bytes
                    this._onDoubleByteCharacter();
                    return;
                }
                this._onCompositionEnd();
                if(this.options.disableUserInput) {
                    if(k === jqKeyCode.TAB) {
                        if(this._processTabKey(e)) {
                            this._stopEvent(e);
                        }
                    } else {
                        this._stopEvent(e);
                    }
                    return;
                }
                if(this._keyDownPreview(e)) {
                    this._stopEvent(e);
                    return;
                }
                if(this._processKeyForDropDownList(e)) {
                    return;
                }
                switch(k) {
                    case jqKeyCode.UP:
                        this._doSpin(true, false);
                        this._stopEvent(e);
                        return;
                    case jqKeyCode.DOWN:
                        this._doSpin(false, false);
                        this._stopEvent(e);
                        return;
                    case jqKeyCode.LEFT:
                    case jqKeyCode.RIGHT:
                        if(this._processLeftRightKey(k === jqKeyCode.LEFT)) {
                            this._stopEvent(e);
                        }
                        return;
                    case jqKeyCode.TAB:
                        if(this._processTabKey(e)) {
                            this._stopEvent(e);
                        }
                        return;
                }
                if(e.ctrlKey) {
                    switch(k) {
                        case jqKeyCode.INSERT:
                        case 67:
                            // 'c'
                            return;
                        default:
                            break;
                    }
                }
                if(e.ctrlKey || e.altKey) {
                    return;
                }
                switch(k) {
                    case 112:
                        // F1-F6
                                            case 113:
                    case 114:
                    case 115:
                    case 116:
                    case 117:
                    case jqKeyCode.TAB:
                    case jqKeyCode.CAPSLOCK:
                    case jqKeyCode.END:
                    case jqKeyCode.HOME:
                    case jqKeyCode.CTRL:
                    case jqKeyCode.SHIFT:
                        return;
                    case jqKeyCode.BACKSPACE:
                        this._deleteSelText(true);
                        this._stopEvent(e);
                        return;
                    case jqKeyCode.DELETE:
                        this._deleteSelText(false);
                        this._stopEvent(e);
                        this._deleteKeyDown = true;
                        return;
                    case jqKeyCode.ENTER:
                        this._onEnterDown(e);
                        break;
                    case jqKeyCode.ESCAPE:
                        this._stopEvent(e);
                        window.setTimeout($.proxy(this._resetData, this), 1);
                        return;
                    case jqKeyCode.PAGE_UP:
                    case jqKeyCode.PAGE_DOWN:
                    case jqKeyCode.ALT:
                        this._stopEvent(e);
                        return;
                }
            };
            wijinputcore.prototype._onEnterDown = function (e) {
                if(this.options.hideEnter) {
                    this._stopEvent(e);
                }
            };
            wijinputcore.prototype._onKeyUp = function (e) {
                if(this._textProvider && !!this._textProvider.noMask) {
                    return;
                }
                var key = this._getKeyCode(e);
                if(this._isSimulating()) {
                    if(key === jqKeyCode.ENTER) {
                        this._onCompositionEnd();
                    }
                    return;
                }
                if(!this._isInitialized()) {
                    return;
                }
                if(key === jqKeyCode.ENTER || key === jqKeyCode.ESCAPE) {
                    return;
                }
                if(this.options.disableUserInput) {
                    this._raiseTextChanged();
                    this._raiseDataChanged();
                    return;
                }
                this._stopEvent(e);
            };
            wijinputcore.prototype._getKeyCode = function (e) {
                var userAgent = window.navigator.userAgent;
                if((userAgent.indexOf('iPod') !== -1 || userAgent.indexOf('iPhone') !== -1) && e.which === 127) {
                    return 8;
                }
                return e.keyCode || e.which;
            };
            wijinputcore.prototype._keyPressPreview = function (e) {
                return false;
            };
            wijinputcore.prototype._onKeyPress = function (e) {
                if(this._isSimulating() || (this._textProvider && !!this._textProvider.noMask)) {
                    return;
                }
                this.element.data('prevSelection', null);
                if(this.options.disableUserInput) {
                    return;
                }
                if(!this._allowEdit()) {
                    return;
                }
                if(e.ctrlKey && e.keyCode === 119) {
                    //Ctrl + F8
                    this._onPaste(e);
                    return;
                }
                var key = e.keyCode || e.which;
                if(Utility.IsFireFox4OrLater()) {
                    switch(e.keyCode) {
                        case jqKeyCode.UP:
                        case jqKeyCode.DOWN:
                        case jqKeyCode.LEFT:
                        case jqKeyCode.RIGHT:
                        case jqKeyCode.HOME:
                        case jqKeyCode.END:
                            return;
                    }
                }
                switch(key) {
                    case 0:
                    case jqKeyCode.TAB:
                        //case jqKeyCode.UP:
                        //case jqKeyCode.DOWN:
                        //case jqKeyCode.LEFT:
                        //case jqKeyCode.RIGHT:
                        return;
                    case jqKeyCode.BACKSPACE:
                        this._stopEvent(e);
                        return;
                    case jqKeyCode.DELETE:
                        if(this._deleteKeyDown) {
                            this._stopEvent(e);
                            return;
                        }
                        break;
                    case jqKeyCode.ENTER:
                        if(this.options.hideEnter) {
                            this._stopEvent(e);
                        }
                        return;
                }
                if(e.ctrlKey || e.altKey) {
                    if(key !== jqKeyCode.SPACE) {
                        return;
                    }
                }
                if(this._keyPressPreview(e)) {
                    return;
                }
                var ch = String.fromCharCode(key);
                var rh = this._textProvider.replaceWith(this.element.wijtextselection(), ch);
                if(rh) {
                    this._updateText();
                    this.selectText(rh.testPosition + 1, rh.testPosition + 1);
                    this.element.data('prevSelection', {
                        start: rh.testPosition + 1,
                        end: rh.testPosition + 1
                    });
                } else {
                    this._fireIvalidInputEvent(ch);
                }
                if(!this._batchKeyPress) {
                    this._stopEvent(e);
                }
            };
            wijinputcore.prototype._isNullText = function (val) {
                val = val || this.element.val();
                return this._showNullText() && val === this.options.nullText;
            };
            wijinputcore.prototype._doFocus = function () {
                var selRange = this.element.wijtextselection();
                var sta = selRange.start;
                this._updateText();
                var s = this.element.val();
                if(s.length === sta) {
                    sta = 0;
                }
                if(!$.browser.safari) {
                    this.selectText(sta, sta);
                }
            };
            wijinputcore.prototype._afterFocused = function () {
                if(this._isNullText()) {
                    this._doFocus();
                }
            };
            wijinputcore.prototype._onFocus = function (e) {
                if(this.options.disableUserInput) {
                    return;
                }
                this._addState('focus', this.outerDiv);
                if(!this.element.data('breakSpinner')) {
                    return;
                }
                if(!this._isInitialized()) {
                    return;
                }
                if(!this._allowEdit()) {
                    return;
                }
                if(this.isSelectingFromAPI) {
                    return;
                }
                if(!this.element.data('focusNotCalledFirstTime')) {
                    this.element.data('focusNotCalledFirstTime', new Date().getTime());
                }
                this._afterFocused();
            };
            wijinputcore.prototype._onBeforeDeactivate = function (e) {
                if(this.options.disableUserInput) {
                    return;
                }
                if(!this.element.data('breakSpinner')) {
                    return;
                }
                if(!this._isInitialized()) {
                    return;
                }
                if(!this._allowEdit()) {
                    return;
                }
                this.element.data('selectionbeforeblur', this.element.wijtextselection());
            };
            wijinputcore.prototype._onBlur = function (e) {
                if(this.options.disableUserInput) {
                    return;
                }
                this._onCompositionEnd();
                if(this._isComboListVisible()) {
                    return;
                }
                var isFocused = this.isFocused();
                this._removeState('focus', this.outerDiv);
                if(!this.element.data('breakSpinner')) {
                    this.element.get(0).focus();
                    if(this.element.data('prevSelection')) {
                        var curPos = this.element.data('prevSelection').start;
                        if(curPos !== undefined && curPos !== null) {
                            this.selectText(curPos, curPos);
                        }
                    }
                    return;
                }
                if(!this._isInitialized() || !isFocused) {
                    return;
                }
                this.element.data('value', this.element.val());
                this._updateTextOnLostFocus();
            };
            wijinputcore.prototype._updateTextOnLostFocus = function () {
                var _this = this;
                window.setTimeout(function () {
                    _this._onChange();
                    _this._updateText();
                    _this._validateData();
                    if(_this.element.data('changed')) {
                        _this.element.data('changed', false);
                        if(!_this._popupVisible()) {
                            _this._trigger('change');
                            _this.element.change();
                        }
                    }
                }, 100);
            };
            wijinputcore.prototype._popupVisible = function () {
                return this._wasPopupShowing;
            };
            wijinputcore.prototype._onMouseDown = function (e) {
                if(!this._isInitialized()) {
                    return;
                }
                if(this.element.is(':disabled')) {
                    return;
                }
                if(Utility.IsMouseDownOnClearButton(e)) {
                    var isFocused = false;
                    try  {
                        isFocused = document.activeElement === e.target;
                    } catch (ee) {
                    }
                    this.element.data("focusedWhenMouseDown", isFocused);
                    this.element.data('mouseDownOnClearButton', true);
                    return;
                }
            };
            wijinputcore.prototype._onMouseUp = function (e) {
                if(!this._isInitialized()) {
                    return;
                }
                if(this.element.is(':disabled')) {
                    return;
                }
                if(Utility.IsMouseDownOnClearButton(e) && this.element.data('mouseDownOnClearButton') && this.element.data('focusedWhenMouseDown') === true) {
                    if(!this.options.disableUserInput) {
                        var self = this;
                        setTimeout(function () {
                            self._processClearButton();
                        }, 0);
                    }
                    this.element.data('mouseDownOnClearButton', false);
                    return;
                }
                this.element.data('mouseDownOnClearButton', false);
                this.element.data('focusedWhenMouseDown', false);
                var selRange = this.element.wijtextselection();
                this.element.data('prevSelection', selRange);
                // fixed an issue of IE10(browser mode IE9), when runs in this mode,
                // the input element will show clear button at the right side of the input element.
                // click the button, the widget's text value will not cleared.
                if(this.element.val() == '') {
                    return;
                }
                var self = this;
                // Wait for it....
                setTimeout(function () {
                    if(self.element.val() == '') {
                        self.setText("");
                    }
                }, 5);
                if(this.element.data('isFocusSelecting')) {
                    this.element.data('isFocusSelecting', false);
                    e.preventDefault();
                }
            };
            wijinputcore.prototype._onChange = function () {
                if(!this.element) {
                    return;
                }
                var val = this.element.val();
                var txt = this.getText();
                if(txt !== val) {
                    this.setText(val);
                }
            };
            wijinputcore.prototype._onPaste = function (e) {
                if(this._textProvider && !!this._textProvider.noMask) {
                    return;
                }
                this._beforeSimulate();
                var self = this;
                window.setTimeout(function () {
                    self._simulate();
                }, 1);
            };
            wijinputcore.prototype._onDrop = function (e) {
                this._beforeSimulate();
                if(e.originalEvent && e.originalEvent.dataTransfer) {
                    var text = e.originalEvent.dataTransfer.getData('Text');
                    if(text) {
                        this._simulate(text);
                    }
                }
            };
            wijinputcore.prototype._stopEvent = function (e) {
                e.stopPropagation();
                e.preventDefault();
            };
            wijinputcore.prototype._calcSpinInterval = function () {
                this._repeatingCount++;
                if(this._repeatingCount > 10) {
                    return 50;
                } else if(this._repeatingCount > 4) {
                    return 100;
                } else if(this._repeatingCount > 2) {
                    return 200;
                }
                return 400;
            };
            wijinputcore.prototype._doSpin = function (up, repeating) {
                return false;
            };
            wijinputcore.prototype._stopSpin = function () {
                this.element.data('breakSpinner', true);
                this._repeatingCount = 0;
                var spintimer = this.element.data("spintimer");
                if(spintimer) {
                    clearTimeout(spintimer);
                    this.element.data("spintimer", undefined);
                }
            };
            wijinputcore.prototype._hasComboItems = function () {
                return !!this._getcomboItems() && this._getcomboItems().length;
            };
            wijinputcore.prototype._getcomboItems = function () {
                if(!!this.options.comboItems && this.options.comboItems.length > 0) {
                    return this.options.comboItems;
                }
                return this.options.pickers.list;
            };
            wijinputcore.prototype._getcomboWidth = function () {
                return this.options.comboWidth || this.options.pickers.width;
            };
            wijinputcore.prototype._getcomboHeight = function () {
                return this.options.comboHeight || this.options.pickers.height;
            };
            wijinputcore.prototype._isComboListVisible = function () {
                if(!this._comboDiv) {
                    return false;
                }
                return this._comboDiv.wijpopup('isVisible');
            };
            wijinputcore.prototype._deleteComboDiv = function () {
                if(this._comboDiv == undefined) {
                    return;
                }
                this._comboDiv.wijlist("destroy");
                this._comboDiv.remove();
                delete this._comboDiv;
            };
            wijinputcore.prototype._createComboDiv = function () {
                var _this = this;
                if(this._comboDiv !== undefined) {
                    return;
                }
                this._comboDiv = $("<div></div>").appendTo(document.body).css('position', 'absolute');
                var content = this._normalize(this._getcomboItems());
                this._comboDiv.wijlist({
                    maxItemsCount: 5,
                    selected: function (event, ui) {
                        if(!_this.options.disableUserInput) {
                            _this._setData(ui.item.value);
                        }
                        _this._comboDiv.wijpopup('hide');
                        _this._trySetFocus();
                    }
                });
                this._comboDiv.wijlist('setItems', content);
                this._comboDiv.wijlist('renderList');
            };
            wijinputcore.prototype._popupComboList = function () {
                var _this = this;
                if(!this._hasComboItems()) {
                    return false;
                }
                if(!this._allowEdit()) {
                    return false;
                }
                var divWidth = this.outerDiv.width();
                var comboWidth = this._getcomboWidth();
                var comboHeight = this._getcomboHeight();
                if(this._comboDiv != undefined) {
                    if(comboWidth && parseInt(comboWidth) !== this._comboDiv.width()) {
                        this._deleteComboDiv();
                    }
                }
                this._createComboDiv();
                // dimensions
                this._comboDiv.width(divWidth);
                this._comboDiv.wijlist("option", "autoSize", !comboHeight);
                if(comboHeight) {
                    this._comboDiv.height(comboHeight);
                }
                if(comboWidth) {
                    this._comboDiv.width(comboWidth);
                }
                this._comboDiv.wijlist("refreshSuperPanel");
                this._comboDiv.wijpopup({
                    autoHide: true,
                    hidden: function () {
                        _this._trigger('dropDownClose');
                        _this._wasPopupShowing = false;
                        _this._comboDiv.wijlist("unselectItems");
                        _this._comboDiv.wijlist("deactivate");
                    },
                    shown: function () {
                        _this._trigger('dropDownOpen');
                        _this._wasPopupShowing = true;
                    }
                });
                this.outerDiv.attr('aria-expanded', true);
                this._comboDiv.wijpopup('show', {
                    of: this.outerDiv,
                    offset: '0 4',
                    hidden: function () {
                        _this.outerDiv.attr('aria-expanded', false);
                    }
                });
                return true;
            };
            wijinputcore.prototype._normalize = function (items) {
                // assume all items have the right format when the first item is complete
                if(items.length && items[0].label && items[0].value) {
                    return items;
                }
                return $.map(items, function (item) {
                    if(typeof item === "string") {
                        return {
                            label: item,
                            value: item
                        };
                    }
                    return $.extend({
                        label: item.label || item.value,
                        value: item.value || item.label
                    }, item);
                });
            };
            wijinputcore.prototype._processLeftRightKey = function (isLeft) {
                return false;
            };
            wijinputcore.prototype._processTabKey = function (e) {
                return false;
            };
            wijinputcore.prototype._moveControl = function (currentElement, isForward, isUseLeftRightKey) {
                var elements = Utility.GetElements();
                var ret = null;
                var retInfo = {
                };
                if(elements.length < 2) {
                    return null;
                }
                var nextElement = Utility.GetNextFocusableControl(currentElement, elements, isForward);
                var self = this;
                setTimeout(function () {
                    Utility.SetElementFocus(nextElement);
                    self._trigger("keyExit");
                }, 0);
            };
            wijinputcore.prototype._processClearButton = function () {
            };
            return wijinputcore;
        })(wijmo.wijmoWidget);
        input.wijinputcore = wijinputcore;        
        ;
        var wijinputClass = "wijmo-wijinput", classPrefix = wijinputClass + "-";
        var wijinputcore_options = (function () {
            function wijinputcore_options() {
                this.wijCSS = {
                    wijinput: wijinputClass,
                    wijinputInput: classPrefix + "input",
                    wijinputWrapper: classPrefix + "wrapper",
                    wijinputWrapperSpinnerLeft: classPrefix + "wrapper-spinner-left",
                    wijinputWrapperSpinnerRight: classPrefix + "wrapper-spinner-right",
                    wijinputTrigger: classPrefix + "trigger",
                    wijinputSpinnerLeft: classPrefix + "spinner-left",
                    wijinputSpinnerRight: classPrefix + "spinner-right",
                    wijinputButton: classPrefix + "button",
                    wijinputSpin: classPrefix + "spin",
                    wijinputSpinUp: classPrefix + "spinup",
                    wijinputSpinDown: classPrefix + "spindown",
                    glyphIcon: "glyphicon",
                    glyphIconPlus: "glyphicon-plus",
                    glyphIconMinus: "glyphicon-minus",
                    iconPlus: "ui-icon-plus",
                    iconMinus: "ui-icon-minus"
                };
                /** Determines the input method setting of widget.
                * Possible values are: 'auto', 'active', 'inactive', 'disabled'
                * @remarks
                * This property only take effect on IE and firefox browser.
                */
                this.imeMode = "";
                /** Determines the culture used to show values in the wijinput widget.
                */
                this.culture = '';
                /** The CSS class applied to the widget when an invalid value is entered.
                * @remarks
                * For some property of the css, such as the color, because wijmo has set default style,
                * and it may be has a higher priority, so custom need to user a higher priority than the defualt.
                * @example
                * // This example sets the invalidClass option to "invalid".
                * .wijmo-wijinput.invalid {
                * color: red !important;
                * background-color: green !important;
                * font-size: xx-large;
                * }
                * $(".selector").wijinputcore("option", "invalidClass" "invalid");
                */
                this.invalidClass = $.wijmo.wijCSS.stateError;
                /** Determines the text displayed when the widget is blank and contains no initial text.
                * Obsoleted, use placeholder instead.
                * @ignore
                */
                this.nullText = undefined;
                /** Determines the text displayed when the widget is blank and contains no initial text.
                * @remarks
                * when the option's value is empty, the empty value will display, when the value is null, then the placeholder will not show.
                */
                this.placeholder = undefined;
                /** Shows the nullText value if the widget is blank and loses focus.
                * Obsoleted, when placeholder proerty has value, it will show the placeholder value, else not.
                * @ignore
                */
                this.showNullText = false;
                /** If true, then the browser response is disabled when the ENTER key is pressed.
                */
                this.hideEnter = false;
                /** Determines whether a user can enter a value in the wijinputdate widget.
                * Obsoleted, use readonly instead.
                * @ignore
                */
                this.disableUserInput = false;
                /** Determines whether a user can enter a value in the wijinput widget.
                * If readonly is true, user can't input value to the wijinput widget by ui operation, such as spin, pick value from pickers.
                */
                this.readonly = false;
                /** Determines the side, left or right, where the trigger or spinner buttons appear.
                * Possible values are: 'left', 'right'
                * Obsoleted, Use dropdownButtonAlign instead.
                * @ignore
                */
                this.buttonAlign = null;
                /** Determines the side, left or right, where the dropdown button appear.
                * Possible values are: 'left', 'right'
                */
                this.dropDownButtonAlign = 'right';
                /** Determines whether dropdown button is displayed.
                */
                this.showDropDownButton = false;
                /** Determines whether trigger button is displayed.
                * Obsoleted, use showDropDownButton instead.
                * @ignore
                */
                this.showTrigger = undefined;
                /** Determines whether spinner button is displayed.
                */
                this.showSpinner = false;
                /** Array of data items used to populate the drop-down list.
                * Obsoleted, use picker.list instead.
                * @ignore
                */
                this.comboItems = undefined;
                /** Determines the width of the drop-down list.
                * Obsoleted, use picker.width instead.
                * @ignore
                */
                this.comboWidth = undefined;
                /** Determines the height of the drop-down list.
                * Obsoleted, use picker.height instead.
                * @ignore
                */
                this.comboHeight = undefined;
                /** Determines whether the focus automatically moves to the next or previous
                * tab ordering control when pressing the left, right arrow keys.
                * Possible values are "none", "left", "right", "both".
                * The default value is "none".
                */
                this.blurOnLeftRightKey = "none";
                /** Determines the side, left or right, where the spinner button appear.
                * Possible values are: 'vertialLeft', 'verticalRight', 'horizontalDownLeft', 'horizontalUpLeft'.
                * The default value is 'verticalRight'.
                */
                this.spinnerAlign = "verticalRight";
                /** Determines whether the spin behavior can wrap when reaching a maximum or minimum limit.
                */
                this.allowSpinLoop = false;
                /** An object contains the settings for the dropdown list.
                * @example
                *  $(".selector").wijinputmask({
                *      pickers: {
                *          list: [
                *              { label: 'item1', value: 1 },
                *              { label: 'item2', value: 2 }
                *          ],
                *          width: 100,
                *          height: 130
                *      }
                *  });
                */
                this.pickers = {
                    list: undefined,
                    width: undefined,
                    height: undefined
                };
                /** The dropdownOpen event handler.
                * A function called before the widget's dropdown opened.
                * @event
                */
                this.dropDownOpen = null;
                /** The dropdownClose event handler.
                * A function called before the widget's dropdown closed.
                * @event
                */
                this.dropDownClose = null;
                /** The initializing event handler.
                * A function called before the widget is initialized.
                * @event
                */
                this.initializing = null;
                /** The initialized event handler.
                * A function called after the widget is initialized.
                * @event
                */
                this.initialized = null;
                /** The triggerMouseDown event handler. A function called
                * when the mouse is pressed down on the trigger button.
                * Obsoleted, use dropDownButtonMouseDown instead.
                * @ignore
                * @event
                */
                this.triggerMouseDown = null;
                /** The triggerMouseUp event handler. A function called
                * when the mouse is released on the trigger button.
                * Obsoleted, use dropDownButtonMouseUp instead.
                * @ignore
                * @event
                */
                this.triggerMouseUp = null;
                /** The dropdownButtonMouseDown event handler. A function called
                * when the mouse is pressed down on the dropdown button.
                * @event
                */
                this.dropDownButtonMouseDown = null;
                /** The dropdownButtonMouseUp event handler. A function called
                * when the mouse is released on the dropdown button.
                * @event
                */
                this.dropDownButtonMouseUp = null;
                /** Fired when the widget text is changed.
                * @event
                * @dataKey {String} text The new text.
                */
                this.textChanged = null;
                /** The invalidInput event handler. A function called
                * when invalid charactor is typed.
                * @event
                * @dataKey {String} char The newly input character.
                * @dataKey widget The widget object itself.
                */
                this.invalidInput = null;
                /** Fired when the widget lost focus and caused by the keyboard behavior.
                * @event
                */
                this.keyExit = null;
            }
            return wijinputcore_options;
        })();        
        wijinputcore.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijinputcore_options());
        /** @ignore */
        var Utility = (function () {
            function Utility() { }
            Utility.IdCounter = 0;
            Utility.EditFieldSuffix = "_EidtField";
            Utility.MaskValChar = "\ufeff";
            Utility.Hold = "g-C2";
            Utility.FireEvent = //static FireEvent(oControl, eventHandler, eArgs: any, eventName: string) {
            //    oControl.owner._trigger(eventName, null, eArgs);
            //}
            function FireEvent(oControl, eventHandler, eArgs, eventName) {
                if(!eventHandler) {
                    return false;
                }
                try  {
                    // DaryLuo 2012/10/29 fix bug 837 in IM Web 7.0.
                    eventHandler.call(window, oControl, eArgs);
                } catch (ex) {
                    return false;
                }
                return true;
            };
            Utility.FindIMControl = function FindIMControl(id) {
            };
            Utility.ArrayIndexOf = function ArrayIndexOf(array, obj) {
                if(array.indeOf) {
                    return array.indexOf(obj);
                } else {
                    for(var i = 0; i < array.length; i++) {
                        if(array[i] === obj) {
                            return i;
                        }
                    }
                }
                return -1;
            };
            Utility.AttachEvent = function AttachEvent(element, type, handler, useCapture) {
                if(element !== null && element !== undefined) {
                    if(element.addEventListener) {
                        element.addEventListener(type, handler, useCapture);
                    } else if(element.attachEvent) {
                        element.attachEvent("on" + type, handler);
                    }
                }
            };
            Utility.AttachFocusEventOfDocument = function AttachFocusEventOfDocument() {
                if(Utility.IsIE8OrBelow()) {
                    Utility.AttachEvent(document, "beforeactivate", function (evt) {
                        Utility.FocusControlUpdate(evt);
                    }, true);
                } else {
                    Utility.AttachEvent(document, "focus", function (evt) {
                        Utility.FocusControlUpdate(evt);
                    }, true);
                }
            };
            Utility.FocusControlUpdate = function FocusControlUpdate(evt) {
                Utility.PreviousFocusControl = Utility.FocusControl;
                Utility.FocusControl = evt.target || evt.srcElement;
            };
            Utility.ToString = function ToString(value, length, ch, position) {
                var val = value + "";
                //It is same as String.PadLeft(int, char) in C#.
                if(ch != null) {
                    while(val.length < length) {
                        if(position) {
                            val = val + ch;
                        } else {
                            val = ch + val;
                        }
                    }
                    return val;
                }
                //add the value length times.
                while(val.length < length) {
                    val += value + "";
                }
                return val;
            };
            Utility.GetSelectionEndPosition = //Added by Jeff Wu. For CursorPosition Test
            function GetSelectionEndPosition(obj) {
                // Add comments by Yang
                // For test firefox
                if(!Utility.IsIE() || Utility.IsIE11OrLater()) {
                    //Commented by Kevin, Feb 17, 2009
                    //bug#1890
                    //return obj.selectionEnd;
                    var endS = 0;
                    endS = obj.selectionEnd;
                    if(obj.value) {
                        var text = obj.value.substring(0, endS);
                        endS = text.GetLength();
                    }
                    //Commented by Kevin, Feb 18, 2009
                    //bug#1894
                    var startS = 0;
                    startS = obj.selectionStart;
                    if(obj.value) {
                        var text = obj.value.substring(0, startS);
                        startS = text.GetLength();
                    }
                    if(startS > endS) {
                        endS = startS;
                    }
                    //end by Kevin
                    return endS;
                    //end by Kevin
                                    }
                // End by Yang
                return Utility.GetSelectionStartPosition(obj) + document.selection.createRange().text.GetLength();
            };
            Utility.GetSelectionStartPosition = function GetSelectionStartPosition(obj) {
                if(obj.selectionStart != null) {
                    var startS = 0;
                    startS = obj.selectionStart;
                    if(obj.value) {
                        var text = obj.value.substring(0, startS);
                        startS = text.GetLength();
                    }
                    var endS = 0;
                    endS = obj.selectionEnd;
                    if(obj.value) {
                        var text = obj.value.substring(0, endS);
                        endS = text.GetLength();
                    }
                    if(endS < startS) {
                        startS = endS;
                    }
                    return startS;
                }
                try  {
                    var rng = obj.createTextRange();
                    var sng = document.selection.createRange();
                    var length = obj.value.GetLength();
                    var start = 0;
                    var end = length;
                    var i = 0;
                    while(start < end) {
                        i = Math.floor((start + end) / 2);
                        rng = obj.createTextRange();
                        var s = i;
                        var text = obj.value.Substring(0, i);
                        while(1) {
                            var index = text.IndexOf("\r\n");
                            if(index != -1) {
                                s--;
                                text = text.Substring(index + 2, text.GetLength());
                            } else {
                                break;
                            }
                        }
                        var gap = i - s;
                        s = i - gap;
                        rng.moveStart("character", s);
                        if(rng.offsetTop > sng.offsetTop) {
                            end = i;
                        } else if(rng.offsetTop < sng.offsetTop) {
                            if(start == i) {
                                return end;
                            }
                            start = i;
                        } else if(rng.offsetLeft > sng.offsetLeft) {
                            end = i;
                        } else if(rng.offsetLeft < sng.offsetLeft) {
                            if(start == i) {
                                return end;
                            }
                            start = i;
                        } else {
                            if(obj.value.Substring(i - 1, i) == "\r") {
                                i++;
                            }
                            return i;
                        }
                    }
                    return length;
                } catch (e) {
                    return 0;
                }
            };
            Utility.GetCursorPosition = function GetCursorPosition(obj, isPropertyChange) {
                if(obj == null) {
                    return -1;
                }
                // Add comments by Yang
                // For test firefox
                if(!Utility.IsIE() || Utility.IsIE11OrLater()) {
                    //Commented by Kevin, Feb 17, 2009
                    //bug#1890
                    //return obj.selectionStart;
                    var startS = 0;
                    startS = obj.selectionStart;
                    if(obj.value) {
                        var text = obj.value.substring(0, startS);
                        startS = text.GetLength();
                    }
                    return startS;
                    //end by Kevin
                                    }
                // End by Yang
                // Frank Liu fixed bug 629 at 2013/06/20.
                var caretPos = 0;// IE Support
                
                if(document.selection) {
                    obj.focus();
                    var sel = document.selection.createRange();
                    sel.moveStart('character', -obj.value.length);
                    caretPos = sel.text.length;
                }
                return (caretPos);
            };
            Utility.GetPasteData = function GetPasteData(useClipboard) {
                // Add comments by Yang
                // For test firefox
                return Utility.GetDataFromClipboard(useClipboard);
            };
            Utility.GetDataFromClipboard = function GetDataFromClipboard(useClipboard) {
                if(useClipboard == false) {
                    return Utility.SavedText;
                }
                if(window.clipboardData) {
                    return (window.clipboardData.getData('Text'));
                } else if(Utility.CutCopyPasteEventObject !== null) {
                    if(Utility.CutCopyPasteEventObject.clipboardData !== undefined) {
                        return Utility.CutCopyPasteEventObject.clipboardData.getData("text");
                    }
                }
                //else if (window.netscape) {
                //    try {
                //        netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
                //        var clip = Components.classes['@mozilla.org/widget/clipboard;1'].createInstance(Components.interfaces.nsIClipboard);
                //        if (!clip) {
                //            return;
                //        }
                //        var trans = Components.classes['@mozilla.org/widget/transferable;1'].createInstance(Components.interfaces.nsITransferable);
                //        if (!trans) {
                //            return;
                //        }
                //        trans.addDataFlavor('text/unicode');
                //        clip.getData(trans, clip.kGlobalClipboard);
                //        var str = new Object();
                //        var len = new Object();
                //        try {
                //            trans.getTransferData('text/unicode', str, len);
                //        }
                //        catch (error) {
                //            return null;
                //        }
                //        if (str) {
                //            if (Components.interfaces.nsISupportsWString) {
                //                str = str.value.QueryInterface(Components.interfaces.nsISupportsWString);
                //            }
                //            else if (Components.interfaces.nsISupportsString) {
                //                str = str.value.QueryInterface(Components.interfaces.nsISupportsString);
                //            }
                //            else {
                //                str = null;
                //            }
                //        }
                //        if (str) {
                //            return (str.data.substring(0, len.value / 2));
                //        }
                //    }
                //    catch (e) {
                //        window.status = "about:config signed.applets.codebase_principal_support true";
                //    }
                //}
                return null;
            };
            Utility.ClearSelection = function ClearSelection(inputElement) {
                if(Utility.IsIE() && !Utility.IsIE11OrLater()) {
                    if(document.selection.createRange().text != "") {
                        document.selection.empty();
                    }
                } else {
                    if(Utility.GetSelectionText(inputElement) != "") {
                        inputElement.selectionStart = inputElement.value.length;
                        inputElement.selectionEnd = inputElement.selectionStart;
                    }
                }
            };
            Utility.GetSelectionText = function GetSelectionText(obj) {
                if(obj.selectionStart != null) {
                    return obj.value.substring(obj.selectionStart, obj.selectionEnd);
                } else if(document.selection != null) {
                    return document.selection.createRange().text;
                } else if(document.activeElement !== null) {
                    var obj = document.activeElement;
                    //var start = Math.Min(document.activeElement.selectionStart,document.activeElement.selectionEnd);
                    //var end = Math.Max(document.activeElement.selectionStart,document.activeElement.selectionEnd);
                    var start = obj.selectionStart;
                    var end = obj.selectionEnd;
                    return obj.value.substring(start, end);
                }
                return "";
            };
            Utility.GetNextFocusableControl = function GetNextFocusableControl(currentElement, elements, isForward) {
                if(typeof currentElement === "string") {
                    currentElement = document.getElementById(currentElement);
                }
                var index = 0;
                for(var i = 0; i < elements.length; i++) {
                    if(currentElement === elements[i]) {
                        if(isForward) {
                            index = (i + 1) % (elements.length);
                        } else {
                            index = (i - 1 + elements.length) % (elements.length);
                        }
                        break;
                    }
                }
                return elements[index];
            };
            Utility.FireSystemEvent = function FireSystemEvent(obj, eventName) {
                if(Utility.IsIE()) {
                    obj.fireEvent(eventName);
                } else {
                    var evt = document.createEvent('HTMLEvents');
                    //We must remove the eventName's first two characters "on". For example,
                    //we should remove the "onchange" to "change".
                    evt.initEvent(eventName.substring(2, eventName.length), true, true);
                    obj.dispatchEvent(evt);
                }
            };
            Utility.GetTextBoxScrollWidth = function GetTextBoxScrollWidth(input, unuse) {
                return Utility.MeasureText(input.value, input).Width;
            };
            Utility.MoveFocus = function MoveFocus(curID, isForward) {
                var elements = Utility.GetElements();
                var nextID = Utility.GetNextFocusableControl(curID, elements, isForward);
                Utility.SetElementFocus(nextID);
                return nextID;
            };
            Utility.SetElementFocus = function SetElementFocus(element) {
                element.focus();
            };
            Utility.GetAllElements = function GetAllElements() {
                if(document.body.querySelectorAll) {
                    return document.body.querySelectorAll("button, input, object, select, textarea");
                }
                if(document.body.all) {
                    return document.body.all;
                }
                return document.body.getElementsByTagName("*");
            };
            Utility.GetElements = function GetElements() {
                var elements = [];
                var obj = Utility.GetAllElements();
                var index = 0;
                var rfocusable = /^(?:button|input|object|select|textarea)$/i;
                for(var i = 0; i < obj.length; i++) {
                    if((!document.body.querySelectorAll || Utility.IsIE()) && !rfocusable.test(obj[i].tagName.toLowerCase())) {
                        continue;
                    }
                    var c3 = !obj[i].disabled;
                    var c4 = obj[i].style.visibility !== "hidden";
                    var c5 = obj[i].type != "hidden" && obj[i].tabIndex != -1;
                    var c6 = obj[i].tagName.toLowerCase() == "textarea" && obj[i].tabIndex != -1;
                    var c7 = c5 || c6;
                    if(c3 && c4 && c7) {
                        //var element = { ID: "", TabIndex: 0 };
                        //if (obj[i].id == null || obj[i].id == "") {
                        //    obj[i].id = "GCTempID" + i.toString();
                        //}
                        //element.ID = obj[i].id;
                        //element.TabIndex = obj[i].tabIndex;
                        elements[index++] = obj[i];
                    }
                }
                for(var i = 0; i < elements.length - 1; i++) {
                    for(var j = i + 1; j < elements.length; j++) {
                        if(elements[j].tabIndex < elements[i].tabIndex) {
                            var temp = elements[i];
                            elements[i] = elements[j];
                            elements[j] = temp;
                        }
                    }
                }
                return elements;
            };
            Utility.CheckInt = function CheckInt(value, min, max) {
                var intValue = parseInt(value);
                if(isNaN(intValue)) {
                    throw "value is invalid";
                }
                if(intValue < min || intValue > max) {
                    throw value + " is out of range, should between " + min + " and " + max;
                }
                return intValue;
            };
            Utility.CheckFloat = function CheckFloat(value, min, max) {
                var intValue = parseFloat(value);
                if(isNaN(intValue)) {
                    throw "value is invalid";
                }
                if(value < min || value > max) {
                    throw value + " is out of range, should between " + min + " and " + max;
                }
                return intValue;
            };
            Utility.CheckDate = function CheckDate(value, min, max) {
                if(!(value instanceof Date)) {
                    throw "Type is invalid";
                }
                if(isNaN(value)) {
                    throw "Date is a invalid date";
                }
                if(max != undefined) {
                    if(value < min || value > max) {
                        throw value + " is out of range, should between " + min + " and " + max;
                    }
                }
            };
            Utility.CheckBool = function CheckBool(boolValue) {
                if(typeof (boolValue) === "string") {
                    if(boolValue.toLowerCase() === "true") {
                        return true;
                    }
                }
                return boolValue == true;
            };
            Utility.CheckFunction = function CheckFunction(fun) {
                if(fun === undefined || fun === null) {
                    return null;
                }
                if(typeof fun == "string") {
                    fun = Utility.Trim(fun);
                    if(fun.length == 0) {
                        return null;
                    }
                    try  {
                        eval("fun =" + fun);
                    } catch (e) {
                    }
                }
                if(typeof fun == "function") {
                    return fun;
                } else {
                    throw "The value is not a valid function";
                }
            };
            Utility.GetCheckElement = function GetCheckElement() {
                if(Utility.CheckElement == null) {
                    var div = document.createElement("div");
                    Utility.CheckElement = div;
                    div.style.display = "none";
                }
                return Utility.CheckElement;
            };
            Utility.CheckString = function CheckString(str) {
                if(str === undefined || (typeof (str) != "string" && !(str instanceof String))) {
                    throw str + " type is not a string.";
                }
                if(str == null) {
                    str = "";
                }
                return str.toString();
            };
            Utility.GetCSSLength = function GetCSSLength(length) {
                var intValue = parseInt(length);
                if(isNaN(intValue)) {
                    return 0;
                }
                return intValue;
            };
            Utility.CheckCSSLength = function CheckCSSLength(length) {
                length = Utility.CheckInt(length, 0, Math.pow(2, 31));
                if(parseInt(length) == length) {
                    length += "px";
                }
                Utility.GetCheckElement().style.width = "";
                Utility.GetCheckElement().style.width = length;
                return Utility.GetCheckElement().style.width;
            };
            Utility.CheckFontSizeValue = function CheckFontSizeValue(length) {
                if(parseInt(length) == length) {
                    length += "px";
                }
                Utility.GetCheckElement().style.fontSize = "";
                Utility.GetCheckElement().style.fontSize = length;
                return Utility.GetCheckElement().style.fontSize;
            };
            Utility.CheckColor = function CheckColor(color) {
                Utility.GetCheckElement().style.backgroundColor = "";
                Utility.GetCheckElement().style.backgroundColor = color;
                return Utility.GetCheckElement().style.backgroundColor;
            };
            Utility.CheckImageUrl = function CheckImageUrl(url) {
                return Utility.CheckString(url);
            };
            Utility.GetCssImageUrl = function GetCssImageUrl(url) {
                if(url.startWith("url(\"")) {
                    //IE
                    url = url.substring(5, url.length - 2);
                } else if(url.startWith("url(")) {
                    //Chrome, FF
                    url = url.substring(4, url.length - 1);
                }
                return url;
            };
            Utility.CheckCssImageUrl = function CheckCssImageUrl(url) {
                if(url.length > 0 && !url.startWith("url(")) {
                    url = "url(" + url + ")";
                }
                Utility.GetCheckElement().style.backgroundImage = "";
                Utility.GetCheckElement().style.backgroundImage = url;
                return Utility.GetCheckElement().style.backgroundImage;
            };
            Utility.CheckEnum = function CheckEnum(type, value) {
                for(var item in type) {
                    if(type[item] == value || type[item] == value.toLowerCase()) {
                        return type[item];
                    }
                }
                throw "Enum value is invalid";
            };
            Utility.CheckChar = function CheckChar(value) {
                value = Utility.CheckString(value);
                // Frank Liu fixed bug 678 at 2013/06/14.
                if(value.length !== 1) {
                    // Frank Liu fixed bug 865 at 2013/06/26.
                    throw "Invalid value";
                    //value = value.Substring(0, 1);
                                    }
                return value;
            };
            Utility.GetMultipleStringEnum = function GetMultipleStringEnum(value) {
                var valueList = value.split(" ");
                valueList.sort();
                return valueList.join(",");
            };
            Utility.CheckMultipleStringEnum = function CheckMultipleStringEnum(type, value) {
                var valueList = value.split(",");
                var result = [];
                for(var i = 0; i < valueList.length; i++) {
                    result.push(Utility.CheckEnum(type, Utility.Trim(valueList[i])));
                }
                return result.join(" ");
            };
            Utility.EncodingToHTML = function EncodingToHTML(text) {
                if(text.IndexOf("&") != -1) {
                    var tempDispText = text;
                    var tempText = "";
                    while(tempDispText.IndexOf("&") != -1) {
                        var findPosition = tempDispText.IndexOf("&");
                        tempDispText = tempDispText.replace("&", "&amp;");
                        tempText += tempDispText.Substring(0, findPosition + 5);
                        tempDispText = tempDispText.Substring(findPosition + 5, tempDispText.GetLength());
                    }
                    if(tempDispText.IndexOf("&") == -1 && tempDispText != "") {
                        tempText += tempDispText;
                    }
                    text = tempText;
                }
                //Modified by shenyuan at 2006-02-20 for bug #5308.
                while(text.IndexOf(' ') != -1) {
                    text = text.replace(" ", "&nbsp;");
                }
                while(text.IndexOf("<") != -1) {
                    text = text.replace("<", "&lt;");
                }
                while(text.IndexOf(">") != -1) {
                    text = text.replace(">", "&gt;");
                }
                return text;
            };
            Utility.DecodingFromHTML = function DecodingFromHTML(text) {
                //Modified by shenyuan at 2006-02-23 for bug #5348.
                while(text.IndexOf("&nbsp;") != -1) {
                    text = text.replace("&nbsp;", " ");
                }
                //Modified by shenyuan at 2006-02-08 for bug #5180.
                while(text.IndexOf("&lt;") != -1) {
                    text = text.replace("&lt;", "<");
                }
                while(text.IndexOf("&gt;") != -1) {
                    text = text.replace("&gt;", ">");
                }
                //Modified by shenyuan at 2006-02-10 for bug #5206.
                if(text.IndexOf("&amp;") != -1) {
                    var tmpText = text;
                    var tmpResult = "";
                    while(tmpText.IndexOf("&amp;") != -1) {
                        var temPos = tmpText.IndexOf("&amp;");
                        tmpText = tmpText.replace("&amp;", "&");
                        tmpResult += tmpText.Substring(0, temPos + 1);
                        tmpText = tmpText.Substring(temPos + 1, tmpText.GetLength());
                    }
                    if(tmpText.IndexOf("&amp;") == -1 && tmpText != "") {
                        tmpResult += tmpText;
                    }
                    text = tmpResult;
                }
                return text;
            };
            Utility.IsStandCompliantModeOn = function IsStandCompliantModeOn() {
                //Commented by Kevin, Nov 11, 2008
                //fix bug#10414
                //return document.compatMode == "CSS1Compat";
                if(!Utility.IsIE()) {
                    return document.compatMode == "CSS1Compat" || document.compatMode == "BackCompat";
                }
                return document.compatMode == "CSS1Compat";
                //end by Kevin
                            };
            Utility.GetPageZoomRate = function GetPageZoomRate() {
                // add by Sean Huang at 2008.11.13, for bug 10129, 10368 -->
                if(Utility.IsIE() && Utility.engine === 8) {
                    return screen.deviceXDPI / screen.logicalXDPI;
                }
                // add by Sean Huang at 2008.11.13, for bug 10129, 10368 -->
                var normalPosition = document.getElementById("gcsh_standard_control_for_get_normal_position");
                if(typeof (normalPosition) != "undefined" && normalPosition != null) {
                    return document.getElementById("gcsh_standard_control_for_get_normal_position").offsetLeft / 100;
                } else {
                    var div = document.createElement("div");
                    document.body.appendChild(div);
                    div.id = "gcsh_standard_control_for_get_normal_position";
                    div.style.visibility = "hidden";
                    div.style.left = "100px";
                    div.style.top = "1px";
                    div.style.width = "1px";
                    div.style.height = "1px";
                    div.style.position = "absolute";
                    return document.getElementById("gcsh_standard_control_for_get_normal_position").offsetLeft / 100;
                    // return 1;
                                    }
            };
            Utility.GetElementPosition = function GetElementPosition(id) {
                // Frank Liu fixed bug 612 at 2013/06/09.
                // HelenLiu 2013/07/02 fix bug 742 in IM HTML5.
                if(Utility.IsIE() || Utility.chrome || Utility.safari) {
                    // change by Sean Huang at 2009.04.10, for bug 2125 -->
                    //return Utility.GetElementPositionForIE(id);
                    //modified by sj for bug 12220
                    //if (Utility.engine == 8)
                    if(Utility.engine >= 8)//end by sj
                     {
                        var pos1 = Utility.GetElementPositionForIE8(id);
                        // DaryLuo 2012.09/10 fix bug 561 in IMWeb 7.0.
                        if(pos1.Left == 0 && pos1.Top == 0) {
                            var pos2 = Utility.GetElementPositionForFireFox(id);
                            return pos2;
                        } else {
                            return pos1;
                        }
                    } else {
                        var posIE7 = Utility.GetElementPositionForIE(id);
                        //  var posIE8 = Utility.GetElementPositionForIE8(id);
                        //  var posFF = Utility.GetElementPositionForFireFox(id);
                        // DaryLuo 2012.09/10 fix bug 561 in IMWeb 7.0.
                        //  var left = Utility.ChooseMiddle(posIE7.Left, posIE8.Left, posFF.Left);
                        //  var top = Utility.ChooseMiddle(posIE7.Top, posIE8.Top, posFF.Top);
                        return {
                            Left: posIE7.Left,
                            Top: posIE7.Top
                        };
                    }
                    // end of Sean Huang <--
                                    }
                return Utility.GetElementPositionForFireFox(id);
            };
            Utility.GetElementPositionForIE8 = function GetElementPositionForIE8(id) {
                var element = id;
                if(typeof id == "string") {
                    element = document.getElementById(id);
                }
                var top = 0;
                var left = 0;
                if(element == null || element.self || element.nodeType === 9) {
                    return {
                        Left: left,
                        Top: top
                    };
                }
                var clientRect = element.getBoundingClientRect();
                if(!clientRect) {
                    return {
                        Left: left,
                        Top: top
                    };
                }
                var documentElement = element.ownerDocument.documentElement;
                var left = clientRect.left + documentElement.scrollLeft;
                var top = clientRect.top + documentElement.scrollTop;
                try  {
                    var f = element.ownerDocument.parentWindow.frameElement || null;
                    if(f) {
                        var offset = (f.frameBorder === "0" || f.frameBorder === "no") ? 2 : 0;
                        left += offset;
                        top += offset;
                    }
                } catch (ex) {
                }
                return {
                    Left: left,
                    Top: top
                };
            };
            Utility.GetElementPositionForIE = function GetElementPositionForIE(id) {
                var oElement = id;
                if(typeof id == "string") {
                    oElement = document.getElementById(id);
                }
                // For bug 3696.
                var top = 0;//document.body.scrollTop;
                
                var left = 0;//document.body.scrollLeft;
                
                if(oElement == null) {
                    return {
                        Left: left,
                        Top: top
                    };
                }
                if(oElement.offsetParent) {
                    while(oElement.offsetParent != null) {
                        var parent = oElement.offsetParent;
                        var parentTagName = parent.tagName.toLowerCase();
                        if(parentTagName != "table" && parentTagName != "body" && parentTagName != "html" && // Add comments by Yang at 14:40 Dec. 12th 2008
                        // For fix the bug 1187(TP)
                        //			    parentTagName != "div" &&
                        // End by Yang
                        parent.clientTop && parent.clientLeft) {
                            left += parent.clientLeft;
                            top += parent.clientTop;
                        }
                        // add by Sean Huang at 2008.11.12, for bug 10064
                        // change by Sean Huang at 2008.11.13, for bug 10445 -->
                        //if (Utility.IsIE7() && parent.style.position.toLowerCase() == "relative")
                        if(Utility.engine == 7 && parent.style.position.toLowerCase() == "relative")// end of Sean Huang <--
                         {
                            left += oElement.offsetLeft - oElement.scrollLeft;
                            top += oElement.offsetTop;
                            // add by Sean Huang at 2009.01.07, for bug 856 -->
                            var zoom = Utility.GetPageZoomRate();
                            if(zoom == 1)// end of Sean Huang <--
                             {
                                var offset = oElement.offsetTop;
                                for(var i = 0; i < parent.children.length; i++) {
                                    var o = parent.children[i];
                                    if(o == oElement) {
                                        break;
                                    } else if(o.offsetTop) {
                                        offset = o.offsetTop;
                                        break;
                                    }
                                }
                                top -= offset;
                            }
                        } else // end of Sean Huang <--
                        // change by Sean Huang at 2008.11.13, for bug 10445 -->
                        //else if (Utility.IsStandCompliantModeOn() && Utility.IsIE7()
                        if(Utility.IsStandCompliantModeOn() && Utility.engine == 7 && // end of Sean Huang <--
                        (oElement.style.position.toLowerCase() == "absolute" || oElement.style.position.toLowerCase() == "relative")) {
                            // change by Sean Huang at 2009.01.07, for bug 856 -->
                            // [original] -->
                            //  // change by Sean Huang at 2008.12.18, for bug 896 -->
                            //  //top  += (oElement.offsetTop - oElement.scrollTop) / Utility.GetPageZoomRate();
                            //  //left += (oElement.offsetLeft - oElement.scrollLeft) / Utility.GetPageZoomRate();
                            //  top  += (oElement.offsetTop - oElement.scrollTop);
                            //  left += (oElement.offsetLeft - oElement.scrollLeft);
                            //  // end of Sean Huang <--
                            // <-- [original]
                            var zoom = Utility.GetPageZoomRate();
                            top += (oElement.offsetTop - oElement.scrollTop) / zoom;
                            left += (oElement.offsetLeft - oElement.scrollLeft) / zoom;
                            // end of Sean Huang, for bug 856 <--
                                                    } else {
                            //Add by Jiang at Dec. 10 2008
                            //For fixed bug773
                            if((oElement.tagName.toLowerCase() == "input" && oElement.type.toLowerCase() == "text") || oElement.tagName.toLowerCase() == "textarea") {
                                top += oElement.offsetTop;
                                left += oElement.offsetLeft;
                            } else {
                                top += oElement.offsetTop - oElement.scrollTop;
                                left += oElement.offsetLeft - oElement.scrollLeft;
                            }
                            //End by Jiang Changcheng
                                                    }
                        oElement = parent;
                        //end by Ryan Wu.
                                            }
                } else if(oElement.left && oElement.top) {
                    left += oElement.left;
                    top += oElement.top;
                } else {
                    if(oElement.x) {
                        left += oElement.x;
                    }
                    if(oElement.y) {
                        top += oElement.y;
                    }
                }
                //Add by Ryan Wu at 11:13, Nov 2 2005. For in VS2005, body has also an offset value.
                if(oElement.style.position.toLowerCase() != "relative" && oElement.style.position.toLowerCase() != "absolute" && oElement.tagName.toLowerCase() == "body" && Utility.IsStandCompliantModeOn()) {
                    //Add comments by Ryan Wu at 9:54 Nov. 15 2006.
                    //Fix bug#6695.
                    //	    top  += oElement.offsetTop;
                    //		left += oElement.offsetLeft;
                    // change by Sean Huang at 2008.11.13, for bug 10445 -->
                    //if (!Utility.IsIE7())
                    if(Utility.engine != 7)// end of Sean Huang <--
                     {
                        top += oElement.offsetTop;
                        left += oElement.offsetLeft;
                    } else {
                        // Add comments by Yang at 13:23 July 16th 2008
                        // For fix the bug 9755
                        //            top  += parseInt(oElement.currentStyle.marginTop);
                        //		    left += parseInt(oElement.currentStyle.marginLeft);
                        var tempTop = parseInt(oElement.currentStyle.marginTop);
                        var tempLeft = parseInt(oElement.currentStyle.marginLeft);
                        if(isNaN(tempTop)) {
                            tempTop = 0;
                        }
                        if(isNaN(tempLeft)) {
                            tempLeft = 0;
                        }
                        top += tempTop;
                        left += tempLeft;
                        // End by Yang
                                            }
                    //end by Ryan Wu.
                                    }
                return {
                    Left: left,
                    Top: top
                };
            };
            Utility.GetElementPositionForFireFox = function GetElementPositionForFireFox(id) {
                var oElement = id;
                if(typeof id == "string") {
                    oElement = document.getElementById(id);
                }
                // For bug 3696.
                var top = 0;//document.body.scrollTop;
                
                var left = 0;//document.body.scrollLeft;
                
                var scrollLeft = 0;
                var scrollTop = 0;
                if(oElement == null) {
                    return {
                        Left: left,
                        Top: top
                    };
                }
                //Gets the offsetTop and offsetLeft.
                if(oElement.offsetParent) {
                    while(oElement.offsetParent != null) {
                        var parentTagName = oElement.offsetParent.tagName.toLowerCase();
                        if(parentTagName != "table" && parentTagName != "body" && parentTagName != "html" && parentTagName != "div" && oElement.offsetParent.clientTop && oElement.offsetParent.clientLeft) {
                            left += oElement.offsetParent.clientLeft;
                            top += oElement.offsetParent.clientTop;
                        }
                        top += oElement.offsetTop;
                        left += oElement.offsetLeft;
                        oElement = oElement.offsetParent;
                    }
                } else if(oElement.left && oElement.top) {
                    left += oElement.left;
                    top += oElement.top;
                } else {
                    if(oElement.x) {
                        left += oElement.x;
                    }
                    if(oElement.y) {
                        top += oElement.y;
                    }
                }
                //Gets the scrollTop and scrollLeft.
                oElement = id;
                if(typeof id === "string") {
                    oElement = document.getElementById(id);
                }
                if(oElement.parentElement) {
                    while(oElement.parentElement != null && oElement.tagName.toLowerCase() != "html") {
                        scrollTop += oElement.scrollTop;
                        scrollLeft += oElement.scrollLeft;
                        oElement = oElement.parentElement;
                    }
                }
                top -= scrollTop;
                left -= scrollLeft;
                //Add by Ryan Wu at 11:13, Nov 2 2005. For in VS2005, body has also an offset value.
                if(oElement.style.position.toLowerCase() != "relative" && oElement.style.position.toLowerCase() != "absolute" && oElement.tagName.toLowerCase() == "body" && Utility.IsStandCompliantModeOn()) {
                    top += oElement.offsetTop;
                    left += oElement.offsetLeft;
                }
                return {
                    Left: left,
                    Top: top
                };
            };
            Utility.MeasureText = function MeasureText(text, domElement) {
                if(Utility.MeasureElement === undefined) {
                    var div = document.createElement("div");
                    div.style.position = "absolute";
                    div.style.border = "solid 0px";
                    div.style.left = "-100000px";
                    div.style.top = "-100000px";
                    var textNode = window.document.createTextNode("");
                    div.appendChild(textNode);
                    document.body.appendChild(div);
                    Utility.MeasureElement = div;
                    Utility.MeasureTextElement = textNode;
                }
                var div = Utility.MeasureElement;
                var textNode = Utility.MeasureTextElement;
                if(document != null) {
                    var containsElement = document.body.contains(domElement);
                    if(!containsElement) {
                        document.body.appendChild(domElement);
                    }
                    var currentStyle = domElement.currentStyle || window.getComputedStyle(domElement, null);
                    div.style.fontFamily = currentStyle.fontFamily;
                    div.style.fontSize = currentStyle.fontSize;
                    div.style.fontStyle = currentStyle.fontStyle;
                    div.style.fontWeight = currentStyle.fontWeight;
                    if(!containsElement) {
                        document.body.removeChild(domElement);
                    }
                }
                var result = null;
                if(typeof (text) == "string") {
                    textNode.nodeValue = text;
                    result = {
                        Width: div.clientWidth,
                        Height: div.clientHeight
                    };
                } else {
                    result = [];
                    for(var i = 0; i < text.length; i++) {
                        textNode.nodeValue = text[i];
                        result.push({
                            Width: div.clientWidth,
                            Height: div.clientHeight
                        });
                    }
                }
                return result;
            };
            Utility.GetOSDefaultFontFamily = function GetOSDefaultFontFamily() {
                switch(Utility.GetClientOS().toLowerCase()) {
                    case "winxp":
                        return "MS UI Gothic";
                    case "vista":
                        return "";
                    case "win7":
                        return "";
                    case "win8":
                        return "Meiryo UI";
                    case "win2003":
                        return "MS UI Gothic";
                    case "win2000":
                        return "MS UI Gothic";
                }
                return "MS UI Gothic";
            };
            Utility.IsTouchSupport = function IsTouchSupport() {
                return window.navigator.userAgent.toLowerCase().indexOf("touch") != -1;
            };
            Utility.DisabledHoldVisual = function DisabledHoldVisual(element) {
                if(element !== null && element !== undefined && Utility.IsTouchSupport() && Utility.IsIE10OrLater()) {
                    element.addEventListener("MSHoldVisual", function (e) {
                        e.preventDefault();
                    }, false);
                    element.addEventListener("MSGestureHold", function (e) {
                        e.preventDefault();
                    }, false);
                    // Disables visual
                    element.addEventListener("contextmenu", function (e) {
                        e.preventDefault();
                    }, false);
                }
            };
            Utility.IsMouseDownOnClearButton = function IsMouseDownOnClearButton(evt) {
                if(!Utility.IsIE10OrLater()) {
                    return false;
                }
                for(var i = 0; i < document.styleSheets.length; i++) {
                    var styleSheets = document.styleSheets[i];
                    for(var j = 0; j < styleSheets.cssRules.length; j++) {
                        if(styleSheets.cssRules[j].selectorText == "::-ms-clear") {
                            if(styleSheets.cssRules[j].style.display == "none") {
                                return false;
                            }
                        }
                    }
                }
                var x = evt.offsetX;
                var y = evt.offsetY;
                var textbox = evt.srcElement || evt.target;
                var width = textbox.clientWidth;
                var height = textbox.clientHeight;
                var paddingLeft = parseInt(textbox.currentStyle.paddingLeft);
                var paddingRight = parseInt(textbox.currentStyle.paddingRight);
                if(textbox.readOnly || evt.button != MouseButton.Left) {
                    return false;
                }
                // DaryLuo 2012/09/06 fix bug 576, include padding.
                if(width - height + paddingLeft + paddingRight < Utility.GetClearButtonShowThreshold(textbox)) {
                    return false;
                }
                var xx = width - height;
                if(x > xx && x <= width && y >= 0 && y < height) {
                    return true;
                } else {
                    return false;
                }
            };
            Utility.GetClearButtonShowThreshold = function GetClearButtonShowThreshold(textinput) {
                // DaryLuo 2012/11/05 fix bug 861 in IM Web 7.0.
                // Previous I return this function to the harded value 66, in fact, it is incorrect.
                // After researched it, this value should be changed with the font.
                // The changed rule is linear.
                // When the font's unit is pixel, I got the following value.
                // The x indicated font's height, use meature method to get it.
                // The y indicated the clear button's show/hidden threshold value.
                // The I use matlab to get the changed rule. input the following script into matlabe, you will get the result.
                //x=[12 17 23  29 35  40 46 52 58 63 69 75 80],
                //y= [50 75 100 125 150 175 200 225 250 275 300 325 350],
                //p=polyfit(x,y,1),
                //xx=0:.1:100,
                //plot(x,y,'o',xx,polyval(p,xx)) ,poly2sym(p,'x')
                //r = poly2sym(p,'x')
                //vpa(r,8)
                // When the font's unit is Point, I got the following value.
                //x=[8 15 23 31 38 46 54 61 69 77 84],
                //y= [33 67 100 133 167 200 233 267 300 333 367],
                //p=polyfit(x,y,1),
                //xx=0:.1:100,
                //plot(x,y,'o',xx,polyval(p,xx)) ,poly2sym(p,'x')
                //r = poly2sym(p,'x')
                //vpa(r,8)
                var height = Utility.MeasureText("ABCDQ", textinput).Height;
                var result = 4.3604432 * height - 0.76207324;
                result = Math.round(result);
                return result;
            };
            Utility.IsFocusFromIMControl = function IsFocusFromIMControl(id, evt) {
                try  {
                    //return event.fromElement.className.IndexOf(Utility.DefaultControlStyle) != -1;
                    var src = evt.fromElement;
                    while(src != null) {
                        // change by Sean Huang at 2008.08.14, for bug 614 and 644 (ttp)-->
                        //if (src.id.Substring(0, id.length) == id)
                        //modified by sj for bug 2149
                        //if (src.id == id ||  src.id == id + this.Hold + "_DropDownObj" || src.id == id + "DropDown_Container" || src.id == id+ "_ContextMenu")
                        if(src.id == id || src.id == id + this.Hold + "_DropDownObj" || src.id == id + "_DropDown_Container" || src.id == id + "_ContextMenu" || src.id == id + "_HistoryList" || src.id == id + "_EditField" || src.id == id + "_BorderContainer" || src.id == id + "_DropDown_EditField")//end by sj
                        // end of Sean huang <--
                         {
                            return true;
                        }
                        //Add comments by Ryan Wu at 11:28 Mar. 15 2007.
                        //For test FireFox.
                        //src = src.parentElement;
                        src = src.parentNode;
                        //end by Ryan Wu.
                                            }
                    return false;
                } catch (e) {
                    return false;
                }
            };
            Utility.IsFocusToIMControl = function IsFocusToIMControl(id, evt) {
                try  {
                    //	return event.toElement.className.IndexOf(Utility.DefaultControlStyle) != -1;
                    var src = evt.toElement;
                    //var src = event.toElement;
                    //evt.target;
                    while(src != null) {
                        //Add comments by Ryan Wu at 17:13 Aug. 22 2007.
                        //For fix the bug8990.
                        //if (src.id && src.id.substring(0, id.length) == id)
                        //add by chris for 12215 (bugzilla) 2010/12/17 16:30
                        //			// change by Sean Huang at 2008.08.14, for bug 614 and 644 (ttp)-->
                        //			//if (src.id && src.id == id)
                        //			//modified by sj for bug 2149
                        //			//if (src.id == id || src.id == id + this.Hold + "_DropDownObj" || src.id == id + "DropDown_Container" || src.id == id+ "_ContextMenu")
                        //			if (src.id == id || src.id == id + this.Hold + "_DropDownObj" || src.id == id + "DropDown_Container" || src.id == id + "_ContextMenu" || src.id == id + "_HistoryList")
                        //			//end by sj
                        //			// end of Sean Huang <--
                        if(src.id == id || src.id == id + this.Hold + "_DropDownObj" || src.id == id + "_DropDown_Container" || src.id == id + "_ContextMenu" || src.id == id + "_HistoryList" || src.id == id + this.Hold + "_DropDownObj_PopupMonth" || src.id == id + "_EditField" || src.id == id + "_BorderContainer" || src.id == id + "_DropDown_EditField")//end by chris for 12215 (bugzilla) 2010/12/17 16:30
                         {
                            return true;
                        }
                        //end by Ryan Wu.
                        //Add comments by Ryan Wu at 11:28 Mar. 15 2007.
                        //For test FireFox.
                        //src = src.parentElement;
                        src = src.parentNode;
                        //end by Ryan Wu.
                                            }
                    return false;
                } catch (e) {
                    return false;
                }
            };
            Utility.Trim = function Trim(value) {
                if(value == "") {
                    return "";
                }
                var beginIndex = 0;
                var endIndex = 0;
                for(var i = 0; i < value.length; i++) {
                    if(value.CharAt(i) != " " && value.CharAt(i) != "") {
                        beginIndex = i;
                        break;
                    }
                }
                for(var i = value.length - 1; i >= 0; i--) {
                    if(value.CharAt(i) != " " && value.CharAt(i) != "") {
                        endIndex = i + 1;
                        break;
                    }
                }
                try  {
                    var s = value.Substring(beginIndex, endIndex);
                    return s;
                } catch (e) {
                    return value;
                }
            };
            Utility.GetBrowserType = // add by Sean Huang at 2008.10.27, for support IE8 -->
            function GetBrowserType() {
                var ua = navigator.userAgent.toLowerCase();
                if(ua.indexOf("msie") != -1) {
                    Utility.ie = ua.match(/msie ([\d.]+)/)[1];
                } else //change by sj for supporting firefox 3.6 (bug 2956)
                //else if (document.getBoxObjectFor)
                if(ua.indexOf("chrome") != -1) {
                    Utility.chrome = ua.match(/chrome\/([\d.]+)/)[1];
                } else if(ua.indexOf("safari") != -1) {
                    var version = ua.match(/version\/([\d.]+)/);
                    if(version) {
                        Utility.safari = version[1];
                    }
                } else if(ua.indexOf("firefox") != -1) {
                    Utility.firefox = ua.match(/firefox\/([\d.]+)/)[1];
                } else if(ua.indexOf("opera") != -1) {
                    Utility.opera = ua.match(/opera.([\d.]+)/)[1];
                }
                if(ua.indexOf("ipad") != -1) {
                    Utility.IPad = true;
                }
                // add by Sean Huang at 2008.11.13, for bug 10445 -->
                Utility.engine = null;
                if(window.navigator.appName == "Microsoft Internet Explorer") {
                    // This is an IE browser. What mode is the engine in?
                    if(document.documentMode) {
                        // IE8
                        Utility.engine = document.documentMode;
                    } else// IE 5-7
                     {
                        Utility.engine = 5// Assume quirks mode unless proven otherwise
                        ;
                        if(document.compatMode) {
                            if(document.compatMode == "CSS1Compat") {
                                Utility.engine = 7;
                            }// standards mode
                            
                        }
                        if(Utility.ie && Utility.ie.indexOf("6") == 0) {
                            Utility.engine = 6;
                        }
                    }
                    // the engine variable now contains the document compatibility mode.
                                    }
                if(ua.indexOf("rv:") !== -1 && ua.indexOf("firefox") === -1) {
                    // Support IE 11.
                    Utility.ie = Utility.engine = ua.match(/rv:([\d.]+)/)[1];
                }
            };
            Utility.GetTouchPath = function GetTouchPath(beginY, endY) {
                if(beginY === -1 || endY === -1) {
                    return "Error";
                }
                if(beginY > endY) {
                    return beginY - endY > 20 ? "ToTop" : "NotMove";
                } else if(beginY < endY) {
                    return endY - beginY > 20 ? "ToBottom" : "NotMove";
                }
                return "NotMove";
            };
            Utility.IsPad = function IsPad() {
                var result = Utility.IPad || Utility.GetClientOS().toLowerCase() == "android";
                return result;
            };
            Utility.IsJapan = function IsJapan() {
                if(navigator.userLanguage) {
                    return navigator.userLanguage.indexOf('ja') != -1;
                } else if(navigator["language"]) {
                    return navigator["language"].indexOf('ja') != -1;
                }
                return false;
            };
            Utility.IsFireFox4OrLater = // end of Sean Huang <--
            //Add comments by Yang at 15:27 April 29th 2011 for supporting Firefox 4 or later.
            function IsFireFox4OrLater() {
                return Utility.firefox != null && parseFloat(Utility.firefox) >= 4.0;
            };
            Utility.IsIE11OrLater = function IsIE11OrLater() {
                return Utility.IsIE() && Utility.engine >= 11;
            };
            Utility.IsIE10OrLater = function IsIE10OrLater() {
                return Utility.IsIE() && Utility.engine >= 10;
            };
            Utility.IsIE9OrLater = function IsIE9OrLater() {
                return Utility.IsIE() && Utility.engine >= 9;
            };
            Utility.IsIE8OrLater = function IsIE8OrLater() {
                return Utility.IsIE() && Utility.engine >= 8;
            };
            Utility.IsIE8OrBelow = function IsIE8OrBelow() {
                return Utility.IsIE() && Utility.engine <= 8;
            };
            Utility.IsIE8 = function IsIE8() {
                return Utility.IsIE() && Utility.engine == 8;
            };
            Utility.IsIE7 = function IsIE7() {
                return Utility.IsIE() && Utility.engine == 7;
            };
            Utility.IsIE7OrLater = function IsIE7OrLater() {
                return Utility.IsIE() && Utility.engine >= 7;
            };
            Utility.IsIE = function IsIE() {
                return Utility.ie !== undefined;
            };
            Utility.IsIE9 = function IsIE9() {
                return Utility.IsIE() && Utility.engine == 9;
            };
            Utility.GetClientOS = function GetClientOS() {
                // Add comments by Yang at 11:04 Sep. 6th 2007
                // For Get os information in firefox is different from IE.
                //var appVersion = navigator.appVersion;
                var appVersion;
                if(!Utility.IsIE()) {
                    var osVersion = navigator.userAgent;
                    var start = osVersion.indexOf("(");
                    var end = osVersion.indexOf(")");
                    appVersion = osVersion.substring(start + 1, end);
                } else {
                    appVersion = navigator.appVersion;
                }
                // End by Yang
                if(appVersion.indexOf("NT 6.0") != -1) {
                    return "vista";
                } else if(appVersion.indexOf("NT 5.2") != -1) {
                    return "win2003";
                } else if(appVersion.indexOf("NT 5.1") != -1) {
                    return "winxp";
                } else if(appVersion.indexOf("NT 5.0") != -1) {
                    return "win2000";
                } else if(appVersion.indexOf("NT 6.1") != -1) {
                    return "Win7";
                } else if(appVersion.indexOf("NT 6.2") != -1) {
                    return "Win8";
                } else if(appVersion.indexOf("NT 6.3") != -1) {
                    // Windows 8.1
                    return "Win8";
                } else if(appVersion.indexOf("Android") != -1) {
                    return "Android";
                }
                return "unknow";
            };
            Utility.CreateStyleElement = function CreateStyleElement(id) {
                var style = document.createElement("style");
                style.id = id;
                //add commnets by Jason.Zhou at 14:23 November 26 2007
                //for style.type="text/css" is used in css file used by linking file type, this sytle is only in dom tree.
                style.type = "text/css";
                //end by Jason.Zhou
                return style;
            };
            Utility.CreateClassStyle = function CreateClassStyle(className) {
                return Utility.CreateSelectorStyle("." + className);
            };
            Utility.CreateSelectorStyle = function CreateSelectorStyle(selectorName) {
                var tableStyle = document.getElementById("tableStyle");
                if(tableStyle == null) {
                    //tableStyle = GrapeCity.IM.Utility.CreateStyleElement("tableStyle");
                    tableStyle = this.CreateStyleElement("tableStyle");
                    document.body.appendChild(tableStyle);
                }
                var sheet = tableStyle.sheet || tableStyle.styleSheet;
                var rules = sheet.cssRules || sheet.rules;
                if(sheet.insertRule) {
                    sheet.insertRule(selectorName + "{ }", rules.length);
                } else {
                    sheet.addRule(selectorName, "{ }", rules.length);
                }
                return rules.item(rules.length - 1);
            };
            Utility.SetSelection = function SetSelection(element, start, end, multiLine) {
                $(element).wijtextselection(Math.min(start, end), Math.max(start, end));
            };
            Utility.PreventDefault = function PreventDefault(evt) {
                if(evt.preventDefault) {
                    evt.preventDefault();
                } else {
                    evt.returnValue = false;
                }
            };
            Utility.CancelBubble = function CancelBubble(evt) {
                if(evt.cancelBubble !== undefined) {
                    evt.cancelBubble = true;
                } else {
                    evt.stopPropagation();
                }
            };
            Utility.DragDrop = function DragDrop(obj) {
                try  {
                    obj.dragDrop(true);
                } catch (e) {
                }
            };
            Utility.GetMouseButton = function GetMouseButton(evt) {
                var mouseButton = MouseButton.Default;
                var leftKey = Utility.IsIE8OrBelow() ? 1 : 0;
                if(evt.button == leftKey) {
                    mouseButton = MouseButton.Left;
                } else if(evt.button == 1) {
                    mouseButton = MouseButton.Middle;
                } else if(evt.button == 2) {
                    mouseButton = MouseButton.Right;
                }
                return mouseButton;
            };
            Utility.GetMouseWheelValue = /**
            * Gets the value after mouse wheel.
            * @param value - the initial value before mousewheel.
            * @returns Returns the value after mouse wheel.
            */
            function GetMouseWheelValue(value, evt) {
                //Add comments by Ryan Wu at 9:50 Aug. 13 2007.
                //For Firefox doesn't support the event.wheelDelta to get the mouse wheel value.
                //I don't know why the event.detail is also 3 or -3, so we must divide 3.
                if(Utility.IsFireFox4OrLater()) {
                    return -evt.detail / 3;
                }
                //end by Ryan Wu.
                if(evt.wheelDelta >= 120) {
                    value++;
                } else if(evt.wheelDelta <= -120) {
                    value--;
                }
                return value;
            };
            Utility.SetCopy = function SetCopy(text, useClipboard) {
                // Add comments by Yang
                // For test firefox
                var selText;
                try  {
                    // add by Sean Huang at 2009.04.29, for bug 2209 -->
                    if(text == null || text == "")// end of Sean Huang <--
                     {
                        if(document.selection) {
                            selText = document.selection.createRange().text;
                        }
                        if(selText == "") {
                            return;
                        }
                    }
                } catch (e) {
                }
                ;
                if(text != null) {
                    selText = text;
                }
                Utility.CopyDataToClipBoard(selText, useClipboard);
            };
            Utility.CopyDataToClipBoard = function CopyDataToClipBoard(copytext, useClipboard) {
                if(useClipboard == false) {
                    Utility.SavedText = copytext;
                    return;
                }
                if(window.clipboardData) {
                    // change by Sean Huang at 2009.01.13, for bug 1582 -->
                    //window.clipboardData.setData("Text", copytext);
                    // change by Sean Huang at 2009.02.19, for bug 1903 -->
                    //setTimeout('window.clipboardData.setData("Text", "' + copytext + '");', 0);
                    // change by Sean Huang at 2009.05.26, for sometimes throw exception in auto test ==-->
                    //setTimeout(function () {window.clipboardData.setData("Text", copytext);}, 0);
                    setTimeout(function () {
                        try  {
                            window.clipboardData.setData("Text", copytext);
                        } catch (ex) {
                        }
                    }, 0);
                    // end of Sean Huang, for auto test <--==
                    // end of Sean Huang <--
                    // end of Sean Huang <--
                                    } else if(Utility.CutCopyPasteEventObject !== null) {
                    if(Utility.CutCopyPasteEventObject.clipboardData !== undefined) {
                        Utility.CutCopyPasteEventObject.clipboardData.setData("text", copytext);
                    }
                }
                //else if (window.netscape) {
                //    try {
                //        netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
                //        var clip = Components.classes['@mozilla.org/widget/clipboard;1'].createInstance(Components.interfaces.nsIClipboard);
                //        if (!clip) {
                //            return;
                //        }
                //        var trans = Components.classes['@mozilla.org/widget/transferable;1'].createInstance(Components.interfaces.nsITransferable);
                //        if (!trans) {
                //            return;
                //        }
                //        trans.addDataFlavor('text/unicode');
                //        var str = new Object();
                //        var len = new Object();
                //        var str = Components.classes["@mozilla.org/supports-string;1"].createInstance(Components.interfaces.nsISupportsString);
                //        str.data = copytext;
                //        trans.setTransferData("text/unicode", str, copytext.length * 2);
                //        var clipid = Components.interfaces.nsIClipboard;
                //        if (!clip) {
                //            return false;
                //        }
                //        clip.setData(trans, null, clipid.kGlobalClipboard);
                //    } catch (e) {
                //    }
                //}
                            };
            Utility.SetZoomStyle = function SetZoomStyle(element, value, align) {
                if(element === undefined || element === null) {
                    return;
                }
                var zoomOrigin = "top left";
                if(align === DropDownAlign.Right) {
                    zoomOrigin = "top right";
                }
                if(Utility.firefox) {
                    element.style.MozTransformOrigin = value === "" ? "" : zoomOrigin;
                    element.style.MozTransform = value === "" ? "" : "scale(" + value + ")";
                    element.setAttribute("ZoomValue", value);
                } else {
                    if(Utility.chrome || Utility.safari) {
                        if(value !== "") {
                            element.style.MozTransform = "scale(" + value + ")";
                            element.style.WebkitTransform = "scale(" + value + ")";
                            element.style.webkitTransformOrigin = zoomOrigin;
                        } else {
                            element.style.MozTransform = "";
                            element.style.WebkitTransform = "";
                            element.style.WebkitTransformOrigin = "";
                        }
                    } else if(Utility.IsIE9OrLater()) {
                        if(value !== "") {
                            element.style.msTransform = "scale(" + value + ")";
                            element.style.msTransformOrigin = zoomOrigin;
                        } else {
                            element.style.msTransform = "";
                            element.style.msTransformOrigin = "";
                        }
                    } else {
                        element.style.zoom = value;
                    }
                }
            };
            Utility.FilterText = function FilterText(includeText, intext) {
                if(intext.GetLength() == 0) {
                    return "";
                }
                var filterText = "";
                var j = 0;
                var i = 0;
                for(j = 0; j < intext.GetLength(); j++) {
                    var valid = false;
                    for(i = 0; i < includeText.GetLength(); i++) {
                        if(intext.Substring(j, j + 1) == includeText.Substring(i, i + 1)) {
                            valid = true;
                        }
                    }
                    if(valid == true) {
                        filterText += intext.Substring(j, j + 1);
                    }
                }
                return filterText;
            };
            Utility.IndexOfAny = function IndexOfAny(str, anyOf, startIndex) {
                if(startIndex >= str.length) {
                    return -1;
                }
                for(var i = startIndex; i < str.length; i++) {
                    for(var j = 0; j < anyOf.length; j++) {
                        if(str.charAt(i) == anyOf[j]) {
                            return i;
                        }
                    }
                }
                return -1;
            };
            return Utility;
        })();
        input.Utility = Utility;        
        Utility.GetBrowserType();
        (function (FocusType) {
            FocusType._map = [];
            FocusType.None = 0;
            FocusType.Click = 1;
            FocusType.ContextMenu = 2;
            FocusType.ClientEvent = 3;
            FocusType.KeyExit = 4;
            FocusType.Default = 5;
            FocusType.SpinButton = 6;
            FocusType.DropDown = 7;
            FocusType.ImeInput = 8;
            FocusType.Left = 9;
            FocusType.Right = 10;
            FocusType.DragDrop = 11;
        })(input.FocusType || (input.FocusType = {}));
        var FocusType = input.FocusType;
        ;
        /** @ignore */
        (function (DateCursorPosition) {
            DateCursorPosition._map = [];
            DateCursorPosition.Default = 0;
            DateCursorPosition.Era = 1;
            DateCursorPosition.Year = 2;
            DateCursorPosition.Month = 3;
            DateCursorPosition.Day = 4;
            DateCursorPosition.AMPM = 5;
            DateCursorPosition.Hour = 6;
            DateCursorPosition.Minute = 7;
            DateCursorPosition.Second = 8;
        })(input.DateCursorPosition || (input.DateCursorPosition = {}));
        var DateCursorPosition = input.DateCursorPosition;
        ;
        /**
        * Defines the CrLf mode which describes how to process the CrLf char.
        * @type {{NoControl: string, Filter: string, Cut: string}}
        */
        (function (CrLfMode) {
            CrLfMode._map = [];
            /**
            * Accepts all CrLf characters in copied, cut, or pasted strings.
            */
            CrLfMode.NoControl = 0;
            /**
            * Removes all CrLf characters in copied, cut, or pasted strings.
            */
            CrLfMode.Filter = 1;
            /**
            * Cuts the following strings from the first CrLf character in copied, cut, and pasted strings.
            */
            CrLfMode.Cut = 2;
        })(input.CrLfMode || (input.CrLfMode = {}));
        var CrLfMode = input.CrLfMode;
        ;
        /**
        * Specifies how the literal in content is held in the clipboard.
        * @type {{IncludeLiterals: string, ExcludeLiterals: string}}
        */
        (function (ClipContent) {
            ClipContent._map = [];
            /**
            * Literals are included.
            */
            ClipContent.IncludeLiterals = 0;
            /**
            * Literals are excluded.
            */
            ClipContent.ExcludeLiterals = 1;
        })(input.ClipContent || (input.ClipContent = {}));
        var ClipContent = input.ClipContent;
        ;
        (function (EditMode) {
            EditMode._map = [];
            EditMode.Insert = 0;
            EditMode.Overwrite = 1;
            EditMode.FixedInsert = 2;
            EditMode.FixedOverwrite = 3;
        })(input.EditMode || (input.EditMode = {}));
        var EditMode = input.EditMode;
        ;
        (function (ShowLiterals) {
            ShowLiterals._map = [];
            ShowLiterals.Always = 1;
            ShowLiterals.PostDisplay = 2;
            ShowLiterals.PreDisplay = 3;
        })(input.ShowLiterals || (input.ShowLiterals = {}));
        var ShowLiterals = input.ShowLiterals;
        ;
        (function (ExitOnLeftRightKey) {
            ExitOnLeftRightKey._map = [];
            ExitOnLeftRightKey.None = 0;
            ExitOnLeftRightKey.Left = 1;
            ExitOnLeftRightKey.Right = 2;
            ExitOnLeftRightKey.Both = 3;
        })(input.ExitOnLeftRightKey || (input.ExitOnLeftRightKey = {}));
        var ExitOnLeftRightKey = input.ExitOnLeftRightKey;
        ;
        /**
        * Specifies the type of selection text in control.
        * @type {{None: string, Field: string, All: string}}
        */
        (function (HighlightText) {
            HighlightText._map = [];
            /**
            * No selection specified.
            */
            HighlightText.None = 0;
            /**
            * Select the specified field.
            */
            HighlightText.Field = 1;
            /**
            * Select all the text.
            */
            HighlightText.All = 2;
        })(input.HighlightText || (input.HighlightText = {}));
        var HighlightText = input.HighlightText;
        ;
        (function (MouseButton) {
            MouseButton._map = [];
            MouseButton.Default = -1;
            MouseButton.Left = 0;
            MouseButton.Middle = 1;
            MouseButton.Right = 2;
        })(input.MouseButton || (input.MouseButton = {}));
        var MouseButton = input.MouseButton;
        ;
        (function (DropDownAlign) {
            DropDownAlign._map = [];
            DropDownAlign.Left = 1;
            DropDownAlign.Right = 2;
        })(input.DropDownAlign || (input.DropDownAlign = {}));
        var DropDownAlign = input.DropDownAlign;
        (function (ScrollBarMode) {
            ScrollBarMode._map = [];
            ScrollBarMode._map[0] = "Automatic";
            ScrollBarMode.Automatic = 0;
            ScrollBarMode._map[1] = "Fixed";
            ScrollBarMode.Fixed = 1;
        })(input.ScrollBarMode || (input.ScrollBarMode = {}));
        var ScrollBarMode = input.ScrollBarMode;
        (function (ScrollBars) {
            ScrollBars._map = [];
            ScrollBars._map[0] = "None";
            ScrollBars.None = 0;
            ScrollBars._map[1] = "Horizontal";
            ScrollBars.Horizontal = 1;
            ScrollBars._map[2] = "Vertical";
            ScrollBars.Vertical = 2;
            ScrollBars._map[3] = "Both";
            ScrollBars.Both = 3;
        })(input.ScrollBars || (input.ScrollBars = {}));
        var ScrollBars = input.ScrollBars;
        (function (ControlStatus) {
            ControlStatus._map = [];
            ControlStatus.Normal = 0;
            ControlStatus.Hover = 1;
            ControlStatus.Pressed = 2;
            ControlStatus.Focused = 4;
            ControlStatus.Disabled = 8;
        })(input.ControlStatus || (input.ControlStatus = {}));
        var ControlStatus = input.ControlStatus;
        (function (ExitKeys) {
            ExitKeys._map = [];
            ExitKeys.Tab = 1;
            ExitKeys.ShiftTab = 2;
            ExitKeys.NextControl = 3;
            ExitKeys.PreviousControl = 4;
            ExitKeys.Right = 5;
            ExitKeys.Left = 6;
            ExitKeys.CtrlRight = 7;
            ExitKeys.CtrlLeft = 8;
            ExitKeys.CharInput = 9;
        })(input.ExitKeys || (input.ExitKeys = {}));
        var ExitKeys = input.ExitKeys;
        ;
        (function (TabAction) {
            TabAction._map = [];
            TabAction.Control = 0;
            TabAction.Field = 1;
        })(input.TabAction || (input.TabAction = {}));
        var TabAction = input.TabAction;
        ;
        (function (Key) {
            Key._map = [];
            Key.BackSpace = 8;
            Key.Tab = 9;
            Key.Clear = 12;
            Key.Enter = 13;
            Key.Shift = 16;
            Key.Control = 17;
            Key.Alt = 18;
            Key.Pause = 19;
            Key.Caps_Lock = 20;
            Key.Escape = 27;
            Key.Space = 32;
            Key.PageUp = 33;
            Key.PageDown = 34;
            Key.End = 35;
            Key.Home = 36;
            Key.Left = 37;
            Key.Up = 38;
            Key.Right = 39;
            Key.Down = 40;
            Key.Select = 41;
            Key.Print = 42;
            Key.Execute = 43;
            Key.Insert = 45;
            Key.Delete = 46;
            Key.Help = 47;
            Key.equalbraceright = 48;
            Key.exclamonesuperior = 49;
            Key.quotedbltwosuperior = 50;
            Key.sectionthreesuperior = 51;
            Key.dollar = 52;
            Key.percent = 53;
            Key.ampersand = 54;
            Key.slashbraceleft = 55;
            Key.parenleftbracketleft = 56;
            Key.parenrightbracketright = 57;
            Key.A = 65;
            Key.B = 66;
            Key.C = 67;
            Key.D = 68;
            Key.E = 69;
            Key.F = 70;
            Key.G = 71;
            Key.H = 72;
            Key.I = 73;
            Key.J = 74;
            Key.K = 75;
            Key.L = 76;
            Key.M = 77;
            Key.N = 78;
            Key.O = 79;
            Key.P = 80;
            Key.Q = 81;
            Key.R = 82;
            Key.S = 83;
            Key.T = 84;
            Key.U = 85;
            Key.V = 86;
            Key.W = 87;
            Key.X = 88;
            Key.Y = 89;
            Key.Z = 90;
            Key.KP_0 = 96;
            Key.KP_1 = 97;
            Key.KP_2 = 98;
            Key.KP_3 = 99;
            Key.KP_4 = 100;
            Key.KP_5 = 101;
            Key.KP_6 = 102;
            Key.KP_7 = 103;
            Key.KP_8 = 104;
            Key.KP_9 = 105;
            Key.KP_Multiply = 106;
            Key.KP_Add = 107;
            Key.KP_Separator = 108;
            Key.KP_Subtract = 109;
            Key.KP_Decimal = 110;
            Key.KP_Divide = 111;
            Key.F1 = 112;
            Key.F2 = 113;
            Key.F3 = 114;
            Key.F4 = 115;
            Key.F5 = 116;
            Key.F6 = 117;
            Key.F7 = 118;
            Key.F8 = 119;
            Key.F9 = 120;
            Key.F10 = 121;
            Key.F11 = 122;
            Key.F12 = 123;
            Key.F13 = 124;
            Key.F14 = 125;
            Key.F15 = 126;
            Key.F16 = 127;
            Key.F17 = 128;
            Key.F18 = 129;
            Key.F19 = 130;
            Key.F20 = 131;
            Key.F21 = 132;
            Key.F22 = 133;
            Key.F23 = 134;
            Key.F24 = 135;
            Key.Num_Lock = 136;
            Key.Scroll_Lock = 137;
        })(input.Key || (input.Key = {}));
        var Key = input.Key;
        ;
        /** @ignore */
        var BaseUIProcess = (function () {
            function BaseUIProcess() {
                this.isMulSelected = false;
                this.isDblClick = false;
                this.isTriClick = false;
                this.isOverWrite = false;
                this.moveFocusExitOnLastChar = false;
            }
            BaseUIProcess.prototype.GetInputElement = function () {
                return this.Owner.GetInputElement();
            };
            BaseUIProcess.prototype.GetElementId = function () {
                return this.Owner.GetInputElement().id;
            };
            BaseUIProcess.prototype.GetShowLiterals = function () {
                if(this.Owner.GetShowLiterals !== undefined) {
                    return this.Owner.GetShowLiterals();
                }
                return ShowLiterals.Always;
            };
            BaseUIProcess.prototype.SetCursorPositionAndSelection = /**
            * Get cursor start and end position according to the specified highlighttext and current text.
            */
            function (highlightText, text, cursorPos, startPos) {
                var retInfo = {
                };
                if(highlightText == true || highlightText == HighlightText.All) {
                    retInfo.SelectionStart = 0;
                    retInfo.SelectionEnd = text.GetLength();
                }
                return retInfo;
            };
            BaseUIProcess.prototype.Clear = /**
            * Clear the current value of the control.
            */
            function () {
                return null;
            };
            BaseUIProcess.prototype.Focus = /**
            * Handle the onfocus event.
            */
            function (data) {
                var text = data.Text;
                var displayText = data.DisplayText;
                var focusType = data.FocusType;
                var oText = data.Element;
                var highlightText = data.HighlightText;
                var cursorPos = data.CursorPosition;
                var retInfo = {
                };
                //Add comments by Ryan Wu at 19:22 Dec 7, 2005.
                //Maybe this is a bug? for we press tab key to get focus. If the original state is
                //selection then the current state is also state, thus this.isMulSelected is true.????
                this.isMulSelected = false;
                //the focusType is used to distribute the get focus type by Left key
                // or Right key or something else.
                if(focusType == FocusType.Click) {
                    retInfo.SelectionStart = Utility.GetCursorPosition(oText);
                    retInfo.SelectionEnd = retInfo.SelectionStart;
                }
                //when get the focus, display the format.
                retInfo.Text = text;
                //Press tab key will set cursor start position to less than zero
                if(retInfo.SelectionStart == -1) {
                    retInfo.SelectionStart = 0;
                    retInfo.SelectionEnd = 0;
                } else //for example: Format is "yy/MM/dd", displayformat is "yyyy/MM/dd"
                if(retInfo.SelectionStart > retInfo.Text.GetLength()) {
                    retInfo.SelectionStart = retInfo.Text.GetLength();
                    retInfo.SelectionEnd = retInfo.Text.GetLength();
                } else if(retInfo.SelectionStart == displayText.GetLength()) {
                    retInfo.SelectionStart = retInfo.Text.GetLength();
                    retInfo.SelectionEnd = retInfo.Text.GetLength();
                }
                //the focusType is FocusType.Left it means that the focus is set by press the left key.
                // change by Sean Huang at 2008.12.05, for bug 992 -->
                //if (focusType == FocusType.Left)
                if(focusType == FocusType.Left && cursorPos == DateCursorPosition.Default)// end of Sean Huang <--
                 {
                    retInfo.SelectionStart = 0;
                    retInfo.SelectionEnd = 0;
                    //update by wuhao 2008-1-8 for fix bug 1362
                    //return retInfo;
                    //end by wuhao 2008-1-8 for fix bug 1362
                                    } else // change by Sean Huang at 2008.12.05, for bug 992 -->
                //else if (focusType == FocusType.Right)
                if(focusType == FocusType.Right && cursorPos == DateCursorPosition.Default)// end of Sean Huang <--
                 {
                    retInfo.SelectionStart = retInfo.Text.GetLength();
                    retInfo.SelectionEnd = retInfo.Text.GetLength();
                    //update by wuhao 2008-1-8 for fix bug 1362
                    //return retInfo;
                    //end by wuhao 2008-1-8 for fix bug 1362
                                    }
                //The selection is not determined by the HighlightText and CursorPosition property.
                if(highlightText == HighlightText.None && cursorPos == DateCursorPosition.Default) {
                    return retInfo;
                }
                //Add comments by Ryan Wu at 9:23 Oct. 18 2007.
                //For fix the bug#9065.
                if(focusType == FocusType.ContextMenu) {
                    return retInfo;
                }
                //end by Ryan Wu.
                //Add comments by Ryan Wu at 14:38 Oct. 11 2007.
                //For fix the bug#8998.
                //    //According to the HighlightText property and CursorPosition property to set the
                //	//selection.
                //	var ret = this.SetCursorPositionAndSelection(highlightText, retInfo.Text, cursorPos, retInfo.SelectionStart);
                var startPos = retInfo.SelectionStart == null ? data.SelectionStart : retInfo.SelectionStart;
                var ret = this.SetCursorPositionAndSelection(highlightText, retInfo.Text, cursorPos, startPos);
                //end by Ryan Wu.
                if(ret != null) {
                    retInfo.SelectionStart = ret.SelectionStart;
                    retInfo.SelectionEnd = ret.SelectionEnd;
                    retInfo.IsSelectionDeterminedByHighlightText = true;
                }
                //Add comments by Ryan Wu at 9:13 Oct. 18 2007.
                //For removing the useless code.
                //	//the focusType is FocusType.ClientEvent it means that the focus is set by ourself.
                //	if (focusType == FocusType.ClientEvent)
                //	{
                //		return retInfo;
                //	}
                //end by Ryan Wu.
                return retInfo;
            };
            BaseUIProcess.prototype.LoseFocus = /**
            * Handle the onblur event.
            */
            function (data) {
            };
            BaseUIProcess.prototype.MouseDown = /**
            * Handle the onmousedown event.
            */
            function (mouseButton) {
                var retInfo = {
                };
                this.isTriClick = false;
                //for triple click
                if(this.isDblClick && !Utility.GrapeCityTimeout && mouseButton == MouseButton.Left) {
                    this.isTriClick = true;
                    retInfo = this.SelectAll();
                }
                this.isDblClick = false;
                return retInfo;
            };
            BaseUIProcess.prototype.MouseUp = /**
            * Handle the onmouseup event.
            */
            // Frank Liu added the parameter "ctrlPressed" at 2013/06/27 for bug 881.
            function (obj, start, end, mouseButton, ctrlPressed) {
                var retInfo = {
                };
                if(this.isTriClick) {
                    Utility.SetSelection(obj, start, end);
                    return null;
                }
                //Add comments by Ryan Wu at 10:13 Sep. 13 2007.
                //For fix the bug "17. Ctrl+Click(select all text) will take no effects.".
                // Frank Liu fixed bug 881 at 2013/06/27.
                //if (!Utility.IsIE() && Utility.FuncKeysPressed.Ctrl) {
                if(ctrlPressed) {
                    retInfo = this.SelectAll();
                    Utility.SetSelection(obj, retInfo.SelectionStart, retInfo.SelectionEnd);
                    return retInfo;
                }
                //end by Ryan Wu.
                retInfo.SelectionStart = start;
                retInfo.SelectionEnd = end;
                if(mouseButton == MouseButton.Left) {
                    //bug#5675
                    //retInfo = GrapeCity_InputMan_GetCursorEndPos(obj, start);
                    retInfo.SelectionStart = Utility.GetSelectionStartPosition(obj);
                    retInfo.SelectionEnd = Utility.GetSelectionEndPosition(obj);
                }
                if(retInfo.SelectionStart != retInfo.SelectionEnd) {
                    this.isMulSelected = true;
                } else {
                    this.isMulSelected = false;
                }
                return retInfo;
            };
            BaseUIProcess.prototype.ProcessShortcutKey = /**
            * Handle the shortcut key event.
            */
            function (keyAction, readOnly, end, start) {
                var retInfo = {
                };
                //ShortCuts
                switch(keyAction) {
                    case "Clear":
                        //Clear
                        if(readOnly) {
                            retInfo.System = false;
                            return retInfo;
                        }
                        return this.Clear();
                    case "NextControl":
                        //NextControl
                        var ret = this.MoveControl(this.GetInputElement(), true, false, "NextControl");
                        if(ret != null) {
                            retInfo.EventInfo = ret.EventInfo;
                            retInfo.FocusType = ret.FocusType;
                            retInfo.FocusExit = true;
                        }
                        retInfo.System = false;
                        return retInfo;
                    case "PreviousControl":
                        //PreviousControl
                        var ret = this.MoveControl(this.GetInputElement(), false, false, "PreviousControl");
                        if(ret != null) {
                            retInfo.EventInfo = ret.EventInfo;
                            retInfo.FocusType = ret.FocusType;
                            retInfo.FocusExit = true;
                        }
                        retInfo.System = false;
                        return retInfo;
                    case "NextField":
                        //NextField
                        retInfo = this.MoveField(end, true);
                        return retInfo;
                    case "PreviousField":
                        //PreviousField
                        retInfo = this.MoveField(end, false);
                        return retInfo;
                    case "NextField/NextControl":
                        //NextField/NextControl
                        var retInfo = this.MoveFieldAndControl(end, true);
                        return retInfo;
                    case "PreviousField/PreviousControl":
                        //PreviousField/PreviousControl
                        var retInfo = this.MoveFieldAndControl(end, false);
                        return retInfo;
                }
            };
            BaseUIProcess.prototype.ProcessCharKeyInput = /**
            * Process char key input.
            */
            function (k, start, end, isExitOnLastChar, text) {
                return null;
            };
            BaseUIProcess.prototype.ProcessNavigatorKeyInput = /**
            * Prcess navigator key input.
            */
            function (k, editMode, clipContent, text, start, end, exitOnLeftRightKey, isExitOnLastChar) {
                var retInfo = {
                };
                switch(k) {
                    case //Insert
                    45:
                        if(editMode == EditMode.FixedInsert) {
                            this.isOverWrite = false;
                        } else if(editMode == EditMode.FixedOverwrite) {
                            this.isOverWrite = true;
                        } else {
                            this.isOverWrite = !this.isOverWrite;
                        }
                        retInfo.Overwrite = this.isOverWrite;
                        retInfo.System = false;
                        if(this.Format.Fields.fieldCount == 0) {
                            retInfo.System = true;
                        }
                        return retInfo;
                        //BackSpace
                                            case 8:
                        //Add comments by Ryan Wu at 14:23 Jul. 19 2006.
                        //Add text param only for number to judge whether the current text is zero.
                        //retInfo = this.ProcessBackSpace(start, end);
                        retInfo = this.ProcessBackSpace(start, end, text);
                        //end by Ryan Wu.
                        retInfo.System = false;
                        break;
                        //Delete
                        //note: when we use the viewinbrowser mode, we can't get the del keycode,but if
                        //we use the runtime mode ,we can get the del keycode. why????
                                            case 46:
                        //Add comments by Ryan Wu at 14:23 Jul. 19 2006.
                        //Add text param only for number to judge whether the current text is zero.
                        //retInfo = this.ProcessDelete(start, end);
                        retInfo = this.ProcessDelete(start, end, text);
                        //end by Ryan Wu.
                        retInfo.System = false;
                        break;
                        //Shift + Ctrl + End
                                            case 196643:
                        //Shift + Ctrl + Home
                                            case 196644:
                        //Shift + Ctrl + Left
                                            case 196645:
                        //Shift + Ctrl + Right
                                            case 196647:
                        //Shift + Pageup
                                            case 65569:
                        //Shift + Ctrl + Pageup
                                            case 196641:
                        //Shift + Pagedown
                                            case 65570:
                        //Shift + Ctrl + Pagedown
                                            case 196642:
                        if(k == 65569 || k == 196641) {
                            k = 196644;
                        } else if(k == 65570 || k == 196642) {
                            k = 196643;
                        }
                        //perform the Shift+Ctrl+Left,Shift+Ctrl+Right,Shift+Ctrl+Home,Shift+Ctrl+End action
                        retInfo.SelectionEnd = this.GetCaretPosition(end, k);
                        this.isMulSelected = true;
                        retInfo.System = false;
                        break;
                        //Shift + Delete
                        // Shift + Backspace  DaryLuo 2012/10/16 fix bug 797 in IM Web 7.0.
                                            case 65582:
                    case 65544:
                        if(this.isMulSelected)//same as cut Action
                         {
                            if(this.Owner._isSupportClipBoard()) {
                                retInfo = this.Cut(clipContent, start, end);
                            } else {
                                retInfo.System = true;
                                break;
                            }
                        } else//the action of backspace
                         {
                            retInfo = this.ProcessBackSpace(start, end);
                        }
                        retInfo.System = false;
                        break;
                        //Shift + Insert  : Paste
                                            case 65581:
                        //Ctrl + V
                                            case 131158:
                        if(this.Owner._isSupportClipBoard()) {
                            var pasteData = Utility.GetPasteData(this.Owner ? this.Owner.GetUseClipboard() : true);
                            retInfo = this.Paste(start, end, pasteData, isExitOnLastChar);
                            retInfo.System = false;
                        } else {
                            retInfo.System = true;
                        }
                        break;
                        //Shift + End
                                            case 65571:
                        //Shift + Home
                                            case 65572:
                        //Shift + Left
                                            case 65573:
                        //Shift + Right
                                            case 65575:
                        // add by Jiang Changcheng at Aug 11 16:13, for bug#388 -->
                        // Shift + Up
                                            case 65574:
                        // Shift + Down
                                            case 65576:
                        // end by Jiang Changcheng <--
                        this.isMulSelected = true;
                        //perform the Shift+Left,Shift+Right,Shift+Home,Shift+End action
                        retInfo.SelectionEnd = this.GetCaretPosition(end, k);
                        retInfo.System = false;
                        break;
                        //Ctrl + C
                                            case 131139:
                        //Ctrl + Insert
                                            case 131117:
                        if(this.Owner._isSupportClipBoard()) {
                            this.Copy(clipContent, start, end);
                            retInfo.System = false;
                        } else {
                            retInfo.System = true;
                        }
                        break;
                        //Ctrl + Delete
                                            case 131118:
                        if(!this.isMulSelected) {
                            end = this.GetCaretPosition(end, k);
                        }
                        retInfo = this.ProcessDelete(start, end);
                        retInfo.System = false;
                        break;
                        //Ctrl + BackSpace  Ctrl + Shift + BackSpace Key
                                            case 131080:
                    case 196616:
                        if(!this.isMulSelected) {
                            end = this.GetCaretPosition(end, k);
                        }
                        retInfo = this.ProcessBackSpace(start, end);
                        retInfo.System = false;
                        break;
                        //Ctrl + A
                                            case 131137:
                        retInfo = this.SelectAll();
                        retInfo.System = false;
                        break;
                        //Ctrl + X
                                            case 131160:
                        if(this.Owner._isSupportClipBoard()) {
                            retInfo = this.Cut(clipContent, start, end);
                            retInfo.System = false;
                        } else {
                            retInfo.System = true;
                        }
                        break;
                        //Ctrl + Z
                                            case 131162:
                        //Need add undo methods by Ryan wu.
                        retInfo = this.Undo();
                        retInfo.System = false;
                        break;
                        //Ctrl + Left
                                            case 131109:
                        //Left
                                            case 37:
                        //Move to previous control
                        if(start == 0 && (exitOnLeftRightKey == ExitOnLeftRightKey.Both || exitOnLeftRightKey == ExitOnLeftRightKey.Left)) {
                            var exitType = k == 37 ? "Left" : "CtrlLeft";
                            var ret = this.MoveControl(this.GetInputElement(), false, true, exitType);
                            if(ret != null) {
                                retInfo.EventInfo = ret.EventInfo;
                                retInfo.FocusType = ret.FocusType;
                                retInfo.FocusExit = true;
                            }
                            return retInfo;
                        }
                        //Ctrl + Home
                                            case 131108:
                        // add by Sean Huang at 2009.04.16, for bug 2046 -->
                        //Ctrl + Up
                                            case 131110:
                        // end of Sean Huang <--
                        //Home
                                            case 36:
                        //PageUp
                                            case 33:
                        //Ctrl + PageUp
                                            case 131105:
                        if(k == 33 || k == 131105) {
                            k = 131108;
                        }
                        retInfo = this.ProcessLeftDirection(start, end, k);
                        retInfo.System = false;
                        break;
                        //Ctrl + Right
                                            case 131111:
                        //Right
                                            case 39:
                        //Move to next control
                        if(start == text.GetLength() && (exitOnLeftRightKey == ExitOnLeftRightKey.Both || exitOnLeftRightKey == ExitOnLeftRightKey.Right)) {
                            var exitType = k == 39 ? "Right" : "CtrlRight";
                            var ret = this.MoveControl(this.GetInputElement(), true, true, exitType);
                            if(ret != null) {
                                retInfo.EventInfo = ret.EventInfo;
                                retInfo.FocusType = ret.FocusType;
                                retInfo.FocusExit = true;
                            }
                            return retInfo;
                        }
                        //Ctrl + End
                                            case 131107:
                        // add by Sean Huang at 2009.03.30, for bug 2046 -->
                        //Ctrl + Down
                                            case 131112:
                        // end of Sean Huang <--
                        //End
                                            case 35:
                        //PageDown
                                            case 34:
                        //Ctrl + PageDown
                                            case 131106:
                        if(k == 34 || k == 131106) {
                            k = 131107;
                        }
                        retInfo = this.ProcessRightDirection(start, end, k);
                        retInfo.System = false;
                        break;
                    default:
                        retInfo = null;
                        break;
                }
                return retInfo;
            };
            BaseUIProcess.prototype.ProcessLeftDirection = function (start, end, k) {
            };
            BaseUIProcess.prototype.ProcessRightDirection = function (start, end, k) {
            };
            BaseUIProcess.prototype.KeyDown = /**
            * Handle the onkeydown event.
            */
            function (data) {
                var k = data.KeyCode;
                var start = data.SelectionStart;
                var end = data.SelectionEnd;
                var text = data.Text;
                var editMode = data.EditMode;
                var keyAction = data.KeyAction;
                var readOnly = data.ReadOnly;
                var clipContent = data.ClipContent;
                //var funcKeysPressed	   = data.FuncKeysPressed;
                var isExitOnLastChar = data.ExitOnLastChar;
                var exitOnLeftRightKey = data.ExitOnLeftRightKey;
                var tabAction = data.TabAction;
                var retInfo = {
                };
                switch(editMode) {
                    case EditMode.Insert:
                        this.isOverWrite = false;
                        break;
                    case EditMode.Overwrite:
                        this.isOverWrite = true;
                        break;
                    case EditMode.FixedInsert:
                        this.isOverWrite = false;
                        break;
                    case EditMode.FixedOverwrite:
                        this.isOverWrite = true;
                        break;
                }
                if(start != end) {
                    this.isMulSelected = true;
                } else {
                    this.isMulSelected = false;
                }
                //Why we must process tab key first. Because in IE we use the system's tab action and the default shortcuts has tab action.
                //So we must process tab key before processing the shortcuts
                switch(k) {
                    case 9:
                        retInfo = this.ProcessTabKey(end, true, tabAction);
                        return retInfo;
                    case 65545:
                        retInfo = this.ProcessTabKey(end, false, tabAction);
                        return retInfo;
                }
                //ShortCuts
                if(keyAction != null) {
                    return this.ProcessShortcutKey(keyAction, readOnly, end, start);
                }
                //The ReadOnly property is set to true
                if(readOnly) {
                    //When readonly is true, Escape, Alt + Up, Alt + Down, Up, Down can also take effect.
                    //If return null, then in BaseInputControl will handle the Escape, Alt + Up and Alt + Down action.
                    if(k == 27 || k == 262182 || k == 262184 || k == 38 || k == 40) {
                        return null;
                    }
                    //we only let the Ctrl+C and Ctrl+Insert and ShortCut to work when we set
                    //ReadOnly property to true.
                    // change by Sean Huang at 2008.08.13, for bug 28 (ttp)-->
                    //if (k != 131117 && k != 131139)
                    if(k != 131117 && k != 131139 && k != 9 && k != 65545 && k != 131081 && k != 196617 && //Ctrl+A
                    k != 131137 && //left, right, up, down
                    k != 37 && k != 39 && k != 38 && k != 40)// end of Sean Huang <--
                     {
                        return retInfo;
                    }
                }
                //the DateFormat has no Pattern property, we use the system's keydown action
                if(this.Format.Fields.fieldCount == 0) {
                    //Why I move the following code here from the end part of the method? It is because
                    //when there is no format we must invoke the editstatuschanged event and the ExitOnLeftRightKey
                    //property also takes effect.
                    switch(k) {
                        case //Insert
                        45:
                            if(editMode == EditMode.FixedInsert) {
                                this.isOverWrite = false;
                            } else if(editMode == EditMode.FixedOverwrite) {
                                this.isOverWrite = true;
                            } else {
                                this.isOverWrite = !this.isOverWrite;
                            }
                            retInfo.Overwrite = this.isOverWrite;
                            if(this.Format.Fields.fieldCount == 0) {
                                retInfo.System = true;
                            }
                            return retInfo;
                            //Left
                                                    case 37:
                            //Ctrl + Left
                                                    case 131109:
                            //Move to previous control
                            if(start == 0 && (exitOnLeftRightKey == ExitOnLeftRightKey.Both || exitOnLeftRightKey == ExitOnLeftRightKey.Left)) {
                                var exitType = k == 37 ? "Left" : "CtrlLeft";
                                var ret = this.MoveControl(this.GetInputElement(), false, true, exitType);
                                if(ret != null) {
                                    retInfo.EventInfo = ret.EventInfo;
                                    retInfo.FocusType = ret.FocusType;
                                    retInfo.FocusExit = true;
                                }
                                return retInfo;
                            }
                            break;
                            //Right
                                                    case 39:
                            //Ctrl + Right
                                                    case 131111:
                            //Move to next control
                            if(start == text.GetLength() && (exitOnLeftRightKey == ExitOnLeftRightKey.Both || exitOnLeftRightKey == ExitOnLeftRightKey.Right)) {
                                var exitType = k == 39 ? "Right" : "CtrlRight";
                                var ret = this.MoveControl(this.GetInputElement(), true, true, exitType);
                                if(ret != null) {
                                    retInfo.EventInfo = ret.EventInfo;
                                    retInfo.FocusType = ret.FocusType;
                                    retInfo.FocusExit = true;
                                }
                                return retInfo;
                            }
                            break;
                    }
                    return null;
                }
                //Process char key input.
                var processInfo = this.ProcessCharKeyInput(k, start, end, isExitOnLastChar, text);
                if(processInfo != null) {
                    return processInfo;
                }
                retInfo = this.ProcessNavigatorKeyInput(k, editMode, clipContent, text, start, end, exitOnLeftRightKey, isExitOnLastChar);
                return retInfo;
            };
            BaseUIProcess.prototype.KeyPress = /**
            * Handle the onkeypress event.
            */
            function (e) {
            };
            BaseUIProcess.prototype.KeyUp = /**
            * Handle the onkeyup event.
            */
            function (e) {
            };
            BaseUIProcess.prototype.ShowContextMenu = /**
            * Handle the oncontextmenu event.
            */
            function (oText, selText) {
                var retInfo = {
                };
                //If there's no text selected
                if(selText == "") {
                    retInfo.SelectionStart = Utility.GetCursorPosition(oText);
                    retInfo.SelectionEnd = retInfo.SelectionStart;
                }
                return retInfo;
            };
            BaseUIProcess.prototype.SelectStart = /**
            * Handle the onselectstart event.
            */
            function (obj, selText, mouseButton) {
                var retInfo = {
                };
                if(selText == "" && !this.isTriClick && !this.isDblClick && mouseButton != MouseButton.Default) {
                    retInfo.SelectionStart = Utility.GetCursorPosition(obj);
                    retInfo.SetFalse = true;
                }
                return retInfo;
            };
            BaseUIProcess.prototype.DoubleClick = /**
            * Handle the ondblclick event.
            */
            function (pos) {
                var retInfo = {
                };
                //Get current field range
                var fieldIndex = this.Format.Fields.GetFieldIndexByPos(pos);
                var fieldPos = this.Format.Fields.GetFieldRange(fieldIndex.index);
                retInfo.SelectionStart = fieldPos.start;
                retInfo.SelectionEnd = fieldPos.length + fieldPos.start;
                //set timer for tripple click
                Utility.GrapeCityTimeout = false;
                this.isDblClick = true;
                this.isMulSelect = true;
                setTimeout(function () {
                    Utility.GrapeCityTimeout = true;
                }, 300);
                return retInfo;
            };
            BaseUIProcess.prototype.Undo = /**
            * Handle the undo actions.
            */
            function () {
            };
            BaseUIProcess.prototype.Cut = /**
            * Handle the cut actions.
            * @param clipContent - The copy mode.
            * @param start - The start cursor position.
            * @param end   - The end cursor position.
            * @returns Returns the cursor position.
            */
            function (clipContent, start, end) {
                var retInfo = {
                };
                if(start == end) {
                    return retInfo;
                }
                this.FireClientEvent("OnBeforeCut");
                this.Copy(clipContent, start, end);
                retInfo = this.ProcessDelete(start, end);
                this.FireClientEvent("OnCut");
                return retInfo;
            };
            BaseUIProcess.prototype.Copy = /**
            * Handle the oncopy event.
            * @param clipContent - The copy mode.
            * @param start - The start cursor position.
            * @param end   - The end cursor position.
            */
            function (clipContent, start, end) {
                var text = null;
                var useClipboard = true;
                if(clipContent == ClipContent.ExcludeLiterals) {
                    var length = Math.abs(start - end);
                    var start = Math.min(start, end);
                    if(length == 0) {
                        return;
                    }
                    text = this.Format.Fields.GetNonLiteralsText(start, length);
                } else //Add comments by Ryan Wu at 16:44 Aug. 13 2007.
                //For Firefox can't get the hightlight text using document.selection.
                if(!Utility.IsIE() || Utility.IsIE11OrLater()) {
                    text = Utility.GetSelectionText(this.Owner.GetInputElement());
                } else// add by Sean Huang at 2009.04.29, for bug 2209 -->
                 {
                    text = document.selection.createRange().text;
                }
                // end of Sean Huang <--
                //end by Ryan Wu.
                if(this.Owner) {
                    text = BaseUIProcess.UpdateCrLfString(text, this.Owner.GetAcceptsCrlf());
                    useClipboard = this.Owner.GetUseClipboard();
                }
                // change by Sean Huang at 2009.04.29, for bug 2209 -->
                //Utility.SetCopy(text);
                if(Utility.IsIE()) {
                    setTimeout(function () {
                        Utility.SetCopy(text, useClipboard);
                    });
                } else {
                    Utility.SetCopy(text, useClipboard);
                }
                // end of Sean Huang <--
                            };
            BaseUIProcess.prototype.Paste = /**
            * Handle the onpaste event.
            */
            function (start, end, text, exitonlastChar) {
            };
            BaseUIProcess.prototype.SelectAll = /**
            * Select all the content.
            * @returns Returns the cursor position.
            */
            function () {
                var retInfo = {
                    SelectionStart: 0,
                    SelectionEnd: 0
                };
                retInfo.SelectionStart = 0;
                //modified by sj 2008.8.13 for bug 243
                var ShowLiterals;
                if(this.ID) {
                    ShowLiterals = this.GetShowLiterals();
                }
                if(ShowLiterals == 'PostDisplay' || ShowLiterals == 'PreDisplay') {
                    retInfo.SelectionEnd = Utility.FindIMControl(this.ID).GetText().GetLength();
                } else {
                    retInfo.SelectionEnd = this.Format.Fields.GetLength();
                }
                //retInfo.SelectionEnd   = this.Format.Fields.GetLength();
                //end by sj
                this.isMulSelected = true;
                return retInfo;
            };
            BaseUIProcess.prototype.FireEvent = //Add comments by Ryan Wu at 9:31 Apr. 5 2007.
            //For support Aspnet Ajax 1.0.
            ///*
            //* This Function should be called when an event needs to be fired.
            //* @param oControl - the javascript object representation of our control.
            //* @param eName    - the name of the function that should handle this event.
            //* @param eArgs    - the argument of the function that should handle this event.
            //*/
            //FireEvent (oControl, eName, eArgs)
            //{
            //	//Because when we fire client event we may be invoke the lose focus event,
            //	//so we must return the current focus type of getting focus.
            //	//No event will be fired
            //	if (eName == null || eName == "")
            //	{
            //		return null;
            //	}
            //
            //	if (Utility.FireEvent(oControl, eName, eArgs))
            //	{
            //		return FocusType.ClientEvent;
            //	}
            //};
            /*
            * This Function should be called when an event needs to be fired.
            * @param oControl - the javascript object representation of our control.
            * @param eName    - the name of the function that should handle this event.
            * @param eArgs    - the argument of the function that should handle this event.
            */
            function (oControl, eName, eArgs, eType) {
                //Because when we fire client event we may be invoke the lose focus event,
                //so we must return the current focus type of getting focus.
                //No event will be fired
                //if (eName == null || eName == "") {
                //    return null;
                //}
                if(Utility.FireEvent(oControl, eName, eArgs, eType)) {
                    return FocusType.ClientEvent;
                }
            };
            BaseUIProcess.prototype.ProcessCharKey = //end by Ryan Wu.
            /**
            * Process the input char key action.
            * @param start - The specified start cursor position.
            * @param end - The specified end cursor position.
            * @param charInput - The specified char will be input.
            * @returns Returns action result includes cursor position and if succeed after the process and whether we fire a client event.
            */
            function (start, end, charInput, isExitOnLastChar) {
                var processInfo = {
                };
                //get the selection information.
                var selectionStart = Math.min(start, end);
                var selectionLength = Math.abs(end - start);
                var retInfo = {
                };
                processInfo.start = selectionStart;
                processInfo.success = false;
                //none action.
                if(this.Format.Fields.GetFieldIndex(selectionStart).index == -1) {
                    //we input an invalid char, so invoke the InvalidInput Event
                    var eventInfo = {
                    };
                    eventInfo.Name = this.Owner.InvalidInputEvent;
                    eventInfo.Args = null;
                    //Add comments by Ryan Wu at 10:27 Apr. 5 2007.
                    //For support Aspnet Ajax 1.0.
                    eventInfo.Type = "invalidInput";
                    //end by Ryan Wu.
                    processInfo.EventInfo = eventInfo;
                    return processInfo;
                }
                var text = charInput.toString();
                if(selectionLength == 0 && !this.isOverWrite) {
                    retInfo = this.Format.Fields.Insert(selectionStart, text, false);
                } else if(selectionLength == 0) {
                    if(selectionStart == this.Format.Fields.GetLength()) {
                        retInfo = this.Format.Fields.Insert(selectionStart, text, false);
                    } else {
                        var isReplace = false;
                        var posInfo = this.Format.Fields.GetFieldIndexByPos(selectionStart);
                        var fieldIndex = posInfo.index;
                        var fieldOffset = posInfo.offset;
                        //var fieldsLength = selectionStart - fieldOffset;
                        var fieldRange = this.Format.Fields.GetFieldRange(fieldIndex);
                        if(this.Format.Fields.GetFieldByIndex(fieldIndex).fieldLabel == "PromptField") {
                            if(selectionStart - fieldOffset + fieldRange.length == this.Format.Fields.GetLength()) {
                                isReplace = false;
                            } else {
                                isReplace = true;
                                selectionLength = fieldRange.length - fieldOffset + 1;
                            }
                        } else {
                            isReplace = true;
                            // DaryLuo 2013/07/15 fix bug 1014 in IM HTML 5.
                            selectionLength = charInput.GetLength();
                        }
                        //none action.
                        if(this.Format.Fields.GetFieldIndexByPos(selectionStart + selectionLength).index == -1) {
                            //we input an invalid char, so invoke the InvalidInput Event
                            var eventInfo = {
                            };
                            eventInfo.Name = this.Owner.InvalidInputEvent;
                            eventInfo.Args = null;
                            //Add comments by Ryan Wu at 10:27 Apr. 5 2007.
                            //For support Aspnet Ajax 1.0.
                            eventInfo.Type = "invalidInput";
                            //end by Ryan Wu.
                            processInfo.EventInfo = eventInfo;
                            return processInfo;
                        }
                        if(isReplace) {
                            retInfo = this.Format.Fields.Replace(selectionStart, selectionLength, text, false);
                        } else {
                            retInfo = this.Format.Fields.Insert(selectionStart, text, false);
                        }
                    }
                } else {
                    retInfo = this.Format.Fields.Replace(selectionStart, selectionLength, text, false);
                }
                selectionStart = retInfo.cursorPos;
                //we input an invalid char, so invoke the InvalidInput Event
                if(retInfo.text != "") {
                    var eventInfo = {
                    };
                    eventInfo.Name = this.Owner.InvalidInputEvent;
                    eventInfo.Args = null;
                    //Add comments by Ryan Wu at 10:27 Apr. 5 2007.
                    //For support Aspnet Ajax 1.0.
                    eventInfo.Type = "invalidInput";
                    //end by Ryan Wu.
                    processInfo.EventInfo = eventInfo;
                    processInfo.start = selectionStart;
                    processInfo.success = false;
                    return processInfo;
                }
                //judge if the focus should exit on last char.
                if(isExitOnLastChar == true) {
                    if(selectionStart == this.Format.Fields.GetLength()) {
                        this.moveFocusExitOnLastChar = true;
                    } else {
                        var posInfo = this.Format.Fields.GetFieldIndexByPos(selectionStart);
                        var fieldIndex = posInfo.index;
                        var fieldOffset = posInfo.offset;
                        if(fieldIndex == this.Format.Fields.fieldCount - 1 && fieldOffset == 0 && this.Format.Fields.GetFieldByIndex(fieldIndex).fieldLabel == "PromptField") {
                            this.moveFocusExitOnLastChar = true;
                        }
                    }
                }
                processInfo.start = selectionStart;
                processInfo.success = true;
                return processInfo;
            };
            BaseUIProcess.prototype.ProcessDeleteKey = /**
            * Process the Delete key down action.
            * @param start - The specified start cursor position.
            * @param end - The specified end cursor position.
            * @returns Returns the cursor position after the process.
            */
            function (start, end) {
                //get the selection information.
                var selectionStart = Math.min(start, end);
                var selectionLength = Math.abs(start - end);
                var retInfo = {
                };
                if(selectionStart == this.Format.Fields.GetLength() && selectionLength == 0) {
                    return retInfo;
                }
                //var startFieldOffset;
                var startFieldIndex;
                var fieldPosInfo = this.Format.Fields.GetFieldIndexByPos(selectionStart);
                startFieldIndex = fieldPosInfo.index;
                //startFieldOffset = fieldPosInfo.offset;
                //none action.
                if(startFieldIndex == -1) {
                    return retInfo;
                }
                //if the selectionlength = 0, do the delete action for one post char.
                if(selectionLength == 0) {
                    //none action.
                    if(this.Format.Fields.GetFieldByIndex(startFieldIndex).fieldLabel == "PromptField") {
                        return retInfo;
                    }
                    selectionStart = this.Format.Fields.Delete(selectionStart, 1).cursorPos;
                    retInfo.SelectionStart = selectionStart;
                    retInfo.SelectionEnd = retInfo.SelectionStart;
                } else//if the selectionlength != 0, do the delete action for the selection range..
                 {
                    var endFieldOffset;
                    var endFieldIndex;
                    fieldPosInfo = this.Format.Fields.GetFieldIndexByPos(selectionStart + selectionLength);
                    endFieldOffset = fieldPosInfo.offset;
                    endFieldIndex = fieldPosInfo.index;
                    //none action.
                    if(endFieldIndex == -1) {
                        return retInfo;
                    }
                    if(endFieldOffset == 0) {
                        endFieldIndex--;
                    }
                    //none action
                    if(startFieldIndex == endFieldIndex && this.Format.Fields.GetFieldByIndex(startFieldIndex).fieldLabel == "PromptField") {
                        return retInfo;
                    }
                    var info = this.Format.Fields.Delete(selectionStart, selectionLength);
                    //The same as BackSpace. ("20005[/)02/24" press delete)
                    if(!info.isSucceed) {
                        return retInfo;
                    }
                    retInfo.SelectionStart = info.cursorPos;
                    if(retInfo.SelectionStart == 0 && this.Format.Fields.GetFieldByIndex(0).fieldLabel == "PromptField") {
                        retInfo.SelectionStart = this.Format.Fields.GetFieldByIndex(0).GetLength();
                    }
                    retInfo.SelectionEnd = retInfo.SelectionStart;
                    //Accordingto the changed information, generate BehaviorInfo and invoke UpdateBehavior to finsihed the correlative action.
                    var currentFieldOffset;
                    var currentFieldIndex;
                    var currentFieldInfo = this.Format.Fields.GetFieldIndexByPos(retInfo.SelectionStart);
                    currentFieldIndex = currentFieldInfo.index;
                    currentFieldOffset = currentFieldInfo.offset;
                    if(currentFieldOffset != 0 && this.Format.Fields.GetFieldByIndex(currentFieldIndex).fieldLabel == "PromptField") {
                        retInfo.SelectionStart = retInfo.SelectionStart - currentFieldOffset + this.Format.Fields.GetFieldByIndex(currentFieldIndex).GetLength();
                        retInfo.SelectionEnd = retInfo.SelectionStart;
                    }
                }
                return retInfo;
            };
            BaseUIProcess.prototype.ProcessBackSpace = /**
            * Perform the delete keydown event.
            * @param start - The start cursor position.
            * @param end   - The start end position.
            */
            function (start, end, text) {
            };
            BaseUIProcess.prototype.ProcessDelete = /**
            * Perform the delete keydown event.
            * @param start - The start cursor position.
            * @param end   - The start end position.
            */
            function (start, end, text) {
            };
            BaseUIProcess.prototype.GetCaretPosition = /**
            * Get the next caret position according to the special cursor position and keycode(processType).
            * @param cursorPos - The current cursor position.
            * @param keyCode   - The keyCode indicate the key action.
            * @returns Return the cursor position after the key action.
            */
            function (cursorPos, keyCode, startPos, endPos, literalFieldLabel) {
                var fields = this.Format.Fields;
                var fieldPosInfo = fields.GetFieldIndexByPos(cursorPos);
                var fieldIndex = fieldPosInfo.index;
                var fieldOffset = fieldPosInfo.offset;
                var fieldRange;
                var startPos;
                var endPos;
                var i = 0;
                switch(keyCode) {
                    case //Home key pressed
                    36:
                        //Shift + Home
                                            case 65572:
                        // add by Jiang Changcheng at Aug 11 16:13, for bug#388 -->
                        // Shift + Up
                                            case 65574:
                        // end by Jiang Changcheng <--
                        if(cursorPos <= startPos) {
                            return 0;
                        } else {
                            return startPos;
                        }
                        //End key pressed
                                            case 35:
                        //Shift + End
                                            case 65571:
                        // add by Jiang Changcheng at Aug 11 16:13, for bug#388 -->
                        // Shift + Down
                                            case 65576:
                        // end by Jiang Changcheng <--
                        if(cursorPos >= endPos) {
                            return fields.GetLength();
                        } else {
                            return endPos;
                        }
                        //Left key
                                            case 37:
                        if(cursorPos == 0) {
                            return 0;
                        }
                        if(fields.GetFieldByIndex(fieldIndex).fieldLabel == literalFieldLabel) {
                            if(fieldOffset > 0) {
                                cursorPos -= fieldOffset;
                            } else {
                                cursorPos--;
                            }
                        } else {
                            //aaaggg|eebbbMMccddee
                            if(fieldOffset == 0 && fields.GetFieldByIndex(fieldIndex - 1).fieldLabel == literalFieldLabel) {
                                cursorPos -= fields.GetFieldRange(fieldIndex - 1).length;
                            } else {
                                cursorPos--;
                            }
                        }
                        break;
                        //Right key
                                            case 39:
                        if(cursorPos == fields.GetLength()) {
                            return cursorPos;
                        }
                        if(fields.GetFieldByIndex(fieldIndex).fieldLabel == literalFieldLabel) {
                            fieldRange = fields.GetFieldRange(fieldIndex);
                            startPos = fieldRange.start;
                            endPos = startPos + fieldRange.length;
                            if(cursorPos < endPos) {
                                return endPos;
                            }
                        } else {
                            cursorPos++;
                        }
                        break;
                        //Ctrl + Left arrow key
                                            case 131109:
                        if(cursorPos == 0 || fieldIndex == 0) {
                            return 0;
                        }
                        if(fields.GetFieldByIndex(fieldIndex).fieldLabel == literalFieldLabel) {
                            fieldRange = fields.GetFieldRange(fieldIndex - 1);
                            cursorPos = fieldRange.start;
                        } else {
                            if(fieldOffset == 0) {
                                for(i = fieldIndex - 1; i >= 0; i--) {
                                    //find the edit field before the current field
                                    if(fields.GetFieldByIndex(i).fieldLabel != literalFieldLabel) {
                                        fieldRange = fields.GetFieldRange(i);
                                        return fieldRange.start;
                                    }
                                }
                                //if the former field is PromptField, then return 0
                                return 0;
                            } else {
                                cursorPos -= fieldOffset;
                            }
                        }
                        break;
                        //Ctrl + Shift + Left key
                                            case 196645:
                        if(cursorPos == 0 || fieldIndex == 0) {
                            return 0;
                        }
                        if(fieldOffset == 0) {
                            fieldRange = fields.GetFieldRange(fieldIndex - 1);
                            cursorPos = fieldRange.start;
                        } else {
                            cursorPos -= fieldOffset;
                        }
                        break;
                        //Ctrl + Right arrow key
                                            case 131111:
                        if(cursorPos == fields.GetLength() || fieldIndex == fields.fieldCount - 1) {
                            return fields.GetLength();
                        }
                        if(fields.GetFieldByIndex(fieldIndex).fieldLabel == literalFieldLabel) {
                            fieldRange = fields.GetFieldRange(fieldIndex + 1);
                            cursorPos = fieldRange.start;
                        } else {
                            for(i = fieldIndex + 1; i < fields.fieldCount; i++) {
                                //find the edit field after the current field
                                if(fields.GetFieldByIndex(i).fieldLabel != literalFieldLabel) {
                                    fieldRange = fields.GetFieldRange(i);
                                    return fieldRange.start;
                                }
                            }
                            //if the latter field is PromptField, then return fieldcollection length
                            return fields.GetLength();
                        }
                        break;
                        //Ctrl + Shift + Right key
                                            case 196647:
                        if(cursorPos == fields.GetLength() || fieldIndex == fields.fieldCount - 1) {
                            return fields.GetLength();
                        }
                        //if the current caret is in the last field then return the fields' length
                        fieldRange = fields.GetFieldRange(fieldIndex + 1);
                        cursorPos = fieldRange.start;
                        break;
                        //Ctrl + Delete key
                                            case 131118:
                        if(cursorPos == fields.GetLength() || fields.GetFieldByIndex(fieldIndex).fieldLabel == literalFieldLabel) {
                            return cursorPos;
                        } else {
                            fieldRange = fields.GetFieldRange(fieldIndex);
                            return fieldRange.start + fieldRange.length;
                        }
                        //Ctrl + BackSpace key  Ctrl + Shift + BackSpace Key
                                            case 131080:
                    case 196616:
                        if(cursorPos == 0 || (fields.GetFieldByIndex(fieldIndex).fieldLabel == literalFieldLabel && fieldIndex == 0)) {
                            return cursorPos;
                        } else if(fields.GetFieldByIndex(fieldIndex).fieldLabel == literalFieldLabel) {
                            return fields.GetFieldRange(fieldIndex - 1).start;
                        } else {
                            if(fieldOffset == 0) {
                                for(i = fieldIndex - 1; i >= 0; i--) {
                                    //find the edit field before the current field
                                    if(fields.GetFieldByIndex(i).fieldLabel != literalFieldLabel) {
                                        fieldRange = fields.GetFieldRange(i);
                                        return fieldRange.start;
                                    }
                                }
                                //if there is no edit field before the current field
                                return cursorPos;
                            } else {
                                cursorPos -= fieldOffset;
                            }
                        }
                        break;
                        //Ctrl + Shift + End key
                                            case 196643:
                        //Ctrl + End key
                                            case 131107:
                        // add by Sean Huang at 2009.03.30, for bug 2046 -->
                        //Ctrl + Down arrow key
                                            case 131112:
                        // end of Sean Huang <--
                        return fields.GetLength();
                        //Ctrl + Shift + Home key
                                            case 196644:
                        //Ctrl + Home key
                                            case 131108:
                        // add by Sean Huang at 2009.03.30, for bug 2046 -->
                        //Ctrl + Up arrow key
                                            case 131110:
                        // end of Sean Huang <--
                        return 0;
                        //Shift + Left key
                                            case 65573:
                        if(cursorPos == 0) {
                            return 0;
                        } else {
                            return --cursorPos;
                        }
                        //Shift + Right key
                                            case 65575:
                        if(cursorPos == fields.GetLength()) {
                            return cursorPos;
                        } else {
                            return ++cursorPos;
                        }
                }
                return cursorPos;
            };
            BaseUIProcess.prototype.CompareShortcut = /**
            * Compare the specified keycode with the shortcut array passed from server side.
            * @param keyCode - The keyCode indicate the key action.
            * @param shortcut - The shortcut text passed from server side.
            * @returns Return true if keycode in the shortcuts array otherwise return false.
            */
            function (keyCode, shortcut) {
                if(shortcut.toString().IndexOf("|") == -1) {
                    if(shortcut == keyCode) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    var index = null;
                    while(index != -1) {
                        index = shortcut.toString().IndexOf("|");
                        var length = shortcut.toString().GetLength();
                        if(shortcut.Substring(0, index == -1 ? length : index) == keyCode) {
                            return true;
                        } else {
                            shortcut = shortcut.Substring(index + 1, length);
                        }
                    }
                    return false;
                }
            };
            BaseUIProcess.prototype.MoveControl = /**
            * Move the focus from one control to another.
            * @param elementID - The current element id.
            * @param isForward - The bool value indicate if we move focus to the next control according to the tabindex value.
            * @param isUseLeftRightKey - The bool value indicate if we move focus to the next control by left or right key.
            * @param exitType - The exit type.
            */
            function (currentElement, isForward, isUseLeftRightKey, exitType) {
                var elements = Utility.GetElements();
                var ret = null;
                var retInfo = {
                };
                //Add by Ryan Wu at 10:24 Jan. 20 2006.
                //For fix bug#4965.
                if(elements.length < 2) {
                    return null;
                }
                //Add comments by Ryan Wu at 14:08 Aug. 28 2007.
                //For the sequence of the onfocus, onblur, onkeydown event in firefox is not same as IE
                //when we use the focus method in keydown.
                //in IE: onkeydown --> onblur --> onfocus.
                //in Firefox: onblur --> onfocus --> onkeydown.
                //So we must split the MoveFocus into two methods. Firstly, We must get the next control's id.
                //Then if we use the ExitOnLeftRightKey to move focus, we should set the next control's FocusType to FocusType.Left/FocusType.Right.
                //Lastly we can invoke the obj.focus method to set focus to the next control.
                //	var nextID = Utility.MoveFocus(elementID, elements, isForward);
                //
                //	if (isUseLeftRightKey == true)
                //	{
                //		try
                //		{
                //		    var index = nextID.LastIndexOf("_EditField");
                //
                //		    if (index != -1)
                //		    {
                //		        var conID = nextID.Substring(0, index);
                //		        var nextObj = FindIMControl(conID);
                //		        nextObj.FocusType = isForward ? FocusType.Left : FocusType.Right;
                //		    }
                //		}
                //		catch(e)
                //		{}
                //    }
                var nextElement = Utility.GetNextFocusableControl(currentElement, elements, isForward);
                // TODO:
                //if (isUseLeftRightKey == true) {
                //    try {
                //        var index = nextID.LastIndexOf("_EditField");
                //        if (index != -1) {
                //            var conID = nextID.Substring(0, index);
                //            var nextObj = FindIMControl(conID);
                //            nextObj.FocusType = isForward ? FocusType.Left : FocusType.Right;
                //        }
                //        else {
                //            var nextObj = FindIMControl(nextID);
                //            if (nextObj) {
                //                if (nextObj.IsjQueryControl == true) {
                //                    nextObj.FocusType = isForward ? FocusType.Left : FocusType.Right;
                //                }
                //            }
                //        }
                //    }
                //    catch (e)
                //    { }
                //}
                // change by Sean Huang at 2008.12.16, for bug 1054 -->
                //Utility.SetElementFocus(nextID);
                // change by Sean Huang at 2009.01.04, for bug 1402 -->
                //if (exitType == "CharInput")
                // change by Sean Huang at 2009.02.16, for bug 1863, 1865 -->
                //if (exitType == "CharInput" || (!isIE && isUseLeftRightKey))
                if(exitType == "CharInput" || (!Utility.IsIE()))// end of Sean Huang <--
                // end of Sean Huang <--
                 {
                    Utility.NextID = nextElement;
                    setTimeout(function () {
                        Utility.SetElementFocus(nextElement);
                    }, 0);
                } else {
                    Utility.SetElementFocus(nextElement);
                }
                // end of Sean Huang <--
                // add by Sean Huang at 2008.12.09, for bug 1057, 1058 -->
                // set the cursor position of the standard text box while it is get focus
                // by using the left right key.
                if(isUseLeftRightKey) {
                    var obj = document.getElementById(nextElement);
                    if(obj != null && (obj.tagName.toLowerCase() == "textarea" || obj.type == "text")) {
                        if(Utility.IsIE()) {
                            var range = obj.createTextRange();
                            if(exitType == "Left" || exitType == "CtrlLeft") {
                                // move the cursor position to the end
                                range.moveStart('character', obj.value.length);
                                range.select();
                            }
                            //else if (exitType == "Right" || exitType == "CtrlRight")
                            //{
                            //    // ie will move the cusor position to the begin by default
                            //}
                                                    }
                        // HelenLiu 2013/06/24 fix bug 743 in IM HTML5.
                        //else {
                        //    if (exitType == "Left" || exitType == "CtrlLeft") {
                        //        // move the cursor to the end
                        //        var len = obj.value.length;
                        //        obj.setSelectionRange(len, len);
                        //    }
                        //else if (exitType == "Right" || exitType == "CtrlRight") {
                        //     //move the cursor to the begin
                        //    obj.setSelectionRange(0, 0);
                        //}
                        //}
                                            }
                }
                // end of Sean Huang, for bug 1057, 1058<--
                //end by Ryan Wu.
                //invoke the KeyExit Event if it exit
                var eArgs = {
                    Key: ExitKeys.CharInput
                };
                //Add items to the ExitKeys.
                /*if (isForward)
                {
                eArgs.Key = ExitKeys.Right;
                }
                else
                {
                eArgs.Key = ExitKeys.Left;
                }*/
                switch(exitType) {
                    case "NextControl":
                        eArgs.Key = ExitKeys.NextControl;
                        break;
                    case "PreviousControl":
                        eArgs.Key = ExitKeys.PreviousControl;
                        break;
                    case "Right":
                        eArgs.Key = ExitKeys.Right;
                        break;
                    case "Left":
                        eArgs.Key = ExitKeys.Left;
                        break;
                    case "CtrlRight":
                        eArgs.Key = ExitKeys.CtrlRight;
                        break;
                    case "CtrlLeft":
                        eArgs.Key = ExitKeys.CtrlLeft;
                        break;
                    case "CharInput":
                        eArgs.Key = ExitKeys.CharInput;
                        break;
                }
                ret = {
                };
                ret.Name = this.Owner.KeyExitEvent;
                ret.Args = eArgs;
                //Add comments by Ryan Wu at 10:27 Apr. 5 2007.
                //For support Aspnet Ajax 1.0.
                ret.Type = "KeyExit";
                //end by Ryan Wu.
                if(ret != null) {
                    retInfo.EventInfo = ret;
                }
                return retInfo;
            };
            BaseUIProcess.prototype.MoveField = /**
            * Move the caret from one field to another in the control.
            * @param pos - The current caret position.
            * @param isForward - The bool value indicate if we move caret to the next field or previous field.
            */
            function (pos, isForward) {
                var nextPos = this.Format.Fields.MoveField(pos, isForward);
                var retInfo = {
                };
                if(nextPos == -1) {
                    retInfo.NextPos = nextPos;
                    return retInfo;
                }
                retInfo.SelectionStart = nextPos;
                retInfo.SelectionEnd = nextPos;
                return retInfo;
            };
            BaseUIProcess.prototype.ProcessTabKey = /**
            * Process Tab key press event.
            * @param isForward - The bool value indicate if we move caret to the forward or backward.
            */
            function (pos, isForward, tabAction) {
                //invoke the KeyExit Event if it exit
                var eArgs = {
                    Key: ExitKeys.Tab
                };
                var retInfo = {
                };
                if(isForward) {
                    eArgs.Key = ExitKeys.Tab;
                } else {
                    eArgs.Key = ExitKeys.ShiftTab;
                }
                var eventInfo = {
                };
                eventInfo.Name = this.Owner.KeyExitEvent;
                eventInfo.Args = eArgs;
                //Add comments by Ryan Wu at 10:27 Apr. 5 2007.
                //For support Aspnet Ajax 1.0.
                eventInfo.Type = "KeyExit";
                //end by Ryan Wu.
                retInfo.EventInfo = eventInfo;
                retInfo.FocusType = FocusType.KeyExit;
                retInfo.System = true;
                return retInfo;
            };
            BaseUIProcess.prototype.MoveFieldAndControl = /**
            * Move caret between fields then move focus to the next control if caret is in the edge
            * of the control.
            * @param isForward - The bool value indicate if we move caret to the forward or backward.
            */
            function (pos, isForward) {
                var retInfo = this.MoveField(pos, isForward);
                //retInfo.NextPos == -1 indicate that we have move the caret to the edge of the control.
                if(retInfo.NextPos != -1) {
                    return retInfo;
                }
                var exitType = isForward ? "NextControl" : "PreviousControl";
                var ret = this.MoveControl(this.GetInputElement(), isForward, false, exitType);
                if(ret != null) {
                    retInfo.EventInfo = ret.EventInfo;
                    retInfo.FocusType = ret.FocusType;
                    retInfo.FocusExit = true;
                }
                return retInfo;
            };
            BaseUIProcess.prototype.DragStart = /**
            * Handle the ondragstart event.
            */
            function () {
            };
            BaseUIProcess.prototype.DragEnd = /**
            * Handle the ondragend event.
            */
            function () {
            };
            BaseUIProcess.prototype.Drop = /**
            * Handle the ondrop event.
            */
            function () {
            };
            BaseUIProcess.prototype.DragOver = /**
            * Handle the ondragover event.
            */
            function () {
            };
            BaseUIProcess.prototype.GetKeyActionName = /**
            * Parse the shortcutsString and judge whether the key user pressed
            * is a shortcutkey defined by deveploper.
            * not replace indexOf, substring method, because autotest is slow
            * @param keyCode - The specified keyCode will be checked.
            * @param strShortcut - The shortcuts string passed from the server side.
            * @returns Returns the shortcut's keyAction Name if contains the specified
            *          keyCode action; else return null.
            */
            function (keyCode, strShortcut) {
                if(strShortcut == null) {
                    return null;
                }
                var s = strShortcut;
                var shortcuts = new Array();
                var index = s.IndexOf(",");
                var i = 0;
                if(strShortcut != "") {
                    while(index != -1) {
                        shortcuts[i++] = s.Substring(0, index);
                        s = s.Substring(index + 1, s.GetLength());
                        index = s.IndexOf(",");
                    }
                    shortcuts[i++] = s;
                    for(var j = 0; j < i; j = j + 2) {
                        if(this.IsKeyCodeContained(keyCode, shortcuts[j + 1])) {
                            return shortcuts[j];
                        }
                    }
                }
                return null;
            };
            BaseUIProcess.prototype.IsKeyCodeContained = /**
            * Judge whether the keyCode is contained in the shortcuts's item.
            * @param keyCode - The specified keyCode will be checked.
            * @param shortcut - The shortcuts's item.
            * @returns Returns true if contains the specified keyCode action; else return false.
            */
            function (keyCode, shortcut) {
                var s = shortcut;
                var index = s.IndexOf("|");
                while(index != -1) {
                    if(s.Substring(0, index) == keyCode) {
                        return true;
                    }
                    s = s.Substring(index + 1, s.GetLength());
                    index = s.IndexOf("|");
                }
                if(s == keyCode) {
                    return true;
                }
                return false;
            };
            BaseUIProcess.prototype.FireClientEvent = /**
            *fire event
            */
            function (evenType) {
                // TODO:
                            };
            BaseUIProcess.prototype.PerformSpin = function (curpos, increment, wrap) {
            };
            BaseUIProcess.UpdateCrLfString = /**
            * update crlf string for AcceptsCrLf property
            */
            function UpdateCrLfString(text, crlfMode) {
                var ret = text;
                if(text) {
                    if(crlfMode == CrLfMode.Filter) {
                        ret = text.replace(new RegExp("[\r\n]", "g"), "");
                    } else if(crlfMode == CrLfMode.Cut) {
                        // Frank Liu fixed bug 569 at 2013/06/05.
                        var splits = text.split(new RegExp("[\r\n]", "g"));
                        if(splits.length > 0) {
                            ret = splits[0];
                        } else {
                            ret = "";
                        }
                    }
                }
                return ret;
            };
            BaseUIProcess.FilterReturnChar = function FilterReturnChar(text) {
                if(text != null) {
                    text = text.replace(new RegExp("[\r]", "g"), "");
                }
                return text;
            };
            return BaseUIProcess;
        })();
        input.BaseUIProcess = BaseUIProcess;        
        /** @ignore */
        var InputUIUpdate = (function () {
            function InputUIUpdate(owner) {
                this.Owner = owner;
            }
            InputUIUpdate.prototype.SetLastClientValues = function (text) {
                //var obj = document.getElementById(this.ID + Utility.LastClientValuesID);
                //if (obj != null) {
                //    obj.value = text;
                //}
                //this.lastclientvalues = text;
                            };
            InputUIUpdate.prototype.GetText = function () {
                if(this.Owner.GetInputElement() != null) {
                    return this.Owner.GetInputElement().value;
                }
            };
            InputUIUpdate.prototype.SetText = function (text) {
                if(this.GetText() == null) {
                    return;
                }
                if(this.GetText().replace(/\r\n/g, "\n") == text.replace(/\r\n/g, "\n")) {
                    return;
                }
                if(this.Owner.GetInputElement() != null) {
                    this.Owner.GetInputElement().value = text;
                }
            };
            InputUIUpdate.prototype.SetFocus = function () {
                try  {
                    if(this.Owner.GetInputElement() != null) {
                        this.Owner.GetInputElement().focus();
                    }
                } catch (e) {
                }
            };
            InputUIUpdate.prototype.GetTextHAlign = function () {
                if(this.Owner.GetInputElement() !== null) {
                    return this.Owner.GetInputElement().style.textAlign;
                }
                return "";
            };
            InputUIUpdate.prototype.SetTextHAlign = function (value) {
                if(this.Owner.GetInputElement() !== null) {
                    this.Owner.GetInputElement().style.textAlign = value;
                    if(Utility.IsIE()) {
                        // Change the width to trigger the layout, to make this property take affect immediately.
                        var old = this.Owner.GetInputElement().style.width;
                        var length = parseInt(old);
                        if(isNaN(length)) {
                            length = 120;
                        }
                        this.Owner.GetInputElement().style.width = length + 1 + "px";
                        var self = this;
                        setTimeout(function () {
                            self.InputElement.style.width = old;
                        }, 0);
                    }
                }
            };
            InputUIUpdate.prototype.SetForeColor = function (foreColor) {
                if(this.Owner.GetInputElement() != null) {
                    this.Owner.GetInputElement().style.color = foreColor;
                }
            };
            InputUIUpdate.prototype.WriteCssStyle = function (style) {
                try  {
                    var styleContainer = document.getElementById('gcsh_InputManWeb_Style_Container');
                    if(Utility.IsIE()) {
                        styleContainer.styleSheet.cssText = style;
                    } else {
                        var sheet = styleContainer.sheet;
                        for(var i = sheet.cssRules.length - 1; i >= 0; i--) {
                            sheet.deleteRule(i);
                        }
                        var ruleLines = style.split('}');
                        for(var j = 0; j < ruleLines.length; j++) {
                            var rule = ruleLines[j];
                            var index = rule.indexOf('{');
                            if(index == -1) {
                                continue;
                            }
                            var style = rule.substring(index + 1);
                            if(style.length != 0) {
                                var selector = rule.substring(0, index);
                                sheet.insertRule(selector + '{' + style + '}', sheet.cssRules.length);
                            }
                        }
                    }
                } catch (e) {
                }
            };
            InputUIUpdate.prototype.ClearCssStyle = function () {
            };
            return InputUIUpdate;
        })();
        input.InputUIUpdate = InputUIUpdate;        
        /** @ignore */
        var GlobalEventHandler = (function () {
            function GlobalEventHandler() { }
            GlobalEventHandler.OnKeyDown = function OnKeyDown(control, evt, forShortcutExtender) {
                if(control.ImeMode === true && !Utility.IsIE8OrBelow()) {
                    return;
                }
                // debugger;
                var k = evt.keyCode;
                //Add comments by Jiang Changcheng at Sep. 9 2008
                //Add the fake key for Shortcut Extender
                if(forShortcutExtender) {
                    k |= 524288;
                }
                //End by Jiang Changcheng
                var funcKeysPressed = {
                };
                funcKeysPressed.Shift = false;
                funcKeysPressed.Ctrl = false;
                funcKeysPressed.Alt = false;
                if(evt.shiftKey) {
                    funcKeysPressed.Shift = true;
                }
                if(evt.ctrlKey) {
                    funcKeysPressed.Ctrl = true;
                }
                if(evt.altKey) {
                    funcKeysPressed.Alt = true;
                }
                var useSystem = null;
                //Add comments by Ryan Wu at 16:55 Sep. 11 2007.
                //For fix the bug "17. Ctrl+Click(select all text) will take no effects(firefox).".
                Utility.FuncKeysPressed = funcKeysPressed;
                //end by Ryan Wu.
                try  {
                    useSystem = control.KeyDown(evt);
                } catch (e) {
                }//Added by Jeff for Edit
                
                if(useSystem != null && useSystem.KeyCode != null) {
                    // Add comments by Yang at 11:44 Sep. 5th 2007
                    // For event.keyCode is readonly in firefox.
                    // Firefox doesn't support some shortcuts.
                    //event.keyCode = useSystem.KeyCode;
                    if(Utility.IsIE()) {
                        evt.keyCode = useSystem.KeyCode;
                    }
                    // End by Yang
                    //Add comments by Ryan Wu at 15:35 Aug. 13 2007.
                    //For in firefox, even if we set the event.returnValue = false in keydown event,
                    //the keypress event will also be invoked while in IE will not.
                    if(!Utility.IsIE()) {
                        Utility.ShouldInvokeKeyPress = false;
                    }
                    //end by Ryan Wu.
                    return;
                }
                //Add comments by Ryan Wu at 15:35 Aug. 13 2007.
                //For in firefox, even if we set the event.returnValue = false in keydown event,
                //the keypress event will also be invoked while in IE will not.
                //	if (!useSystem)
                //	{
                //		event.returnValue = false;
                //	    //event.cancelBubble = true;
                //	}
                if(!useSystem) {
                    Utility.PreventDefault(evt);
                    //event.cancelBubble = true;
                    if(!Utility.IsIE()) {
                        Utility.ShouldInvokeKeyPress = false;
                    }
                } else {
                    if(!Utility.IsIE()) {
                        Utility.ShouldInvokeKeyPress = true;
                    } else if(evt != null) {
                        evt.returnValue = true;
                    }
                }
            };
            GlobalEventHandler.OnKeyPress = function OnKeyPress(control, evt) {
                // Ctrl + X, Ctrl + V, Ctrl + C.
                if((evt.charCode === 118 || evt.charCode === 120 || evt.charCode === 99) && evt.ctrlKey) {
                    // Fire fox 's paste behavior will run at here.
                    return;
                }
                if(Utility.IPad && evt.charCode > 256) {
                    // DaryLuo 2013/05/22 fix bug 414, on the ipad, when the charCode is greater than 256, the compoistion event will fired, so here we don't process.
                    return;
                }
                if(evt.keyCode == 46 && evt.shiftKey) {
                    // FireFox Shift + Delete will run at here.  Cut operation.
                    return;
                }
                if(control.ImeMode === true) {
                    return;
                }
                var obj = control;
                if(!Utility.IsIE() && (evt.charCode == 0 || !Utility.ShouldInvokeKeyPress)) {
                    if(!Utility.ShouldInvokeKeyPress || ((evt.keyCode == 38 || evt.keyCode == 40) && obj.Type != "Edit")) {
                        Utility.ShouldInvokeKeyPress = true;
                        Utility.PreventDefault(evt);
                        // Add comments by Yang at 20:15 October 15th 2007
                        // For fix the bug 9047
                        if(obj != null && obj.Type == "Edit" && obj.DropDownObj != null && obj.DropDownObj.IsKeyFromDropDown) {
                            obj.DropDownObj.IsKeyFromDropDown = false;
                        }
                        // End by Yang
                        return;
                    } else // Add comments by Yang at 16:08 Sep. 12th 2007
                    // For fix the bug 8805
                    if(!(evt.keyCode == 13 && obj.Type == "Edit"))//else if (!(event.keyCode == 13 && event.ctrlKey && obj.Type == "Edit"))
                    // End by Yang
                     {
                        return;
                    }
                }
                var keyCode = evt.keyCode || evt.charCode;
                if(keyCode != 13 || obj.Type == "Edit")// End by Yang
                 {
                    var str = String.fromCharCode(keyCode);
                    try  {
                        if(input.CharProcess.CharEx.IsSurrogate(str.charAt(0))) {
                            // DaryLuo 2012/09/17 fix bug 630 in IM Web 7.0, do it in keyup.
                            obj.IsSurrogateKeyPressing = true;
                            return;
                        }
                    } catch (e) {
                    }
                    if(str != null) {
                        var useSystem = null;
                        try  {
                            useSystem = control.KeyPress(str, evt);
                        } catch (e) {
                        }
                    }
                    if(!useSystem) {
                        Utility.PreventDefault(evt);
                        //event.cancelBubble = true;
                        return;
                    }
                }
            };
            GlobalEventHandler.OnKeyUp = function OnKeyUp(control, evt) {
                if(control.ImeMode === true && !Utility.IsIE8OrBelow()) {
                    return;
                }
                try  {
                    var imControl = control;
                    if(imControl.IsSurrogateKeyPressing) {
                        try  {
                            if(imControl.InputElement != null) {
                                var value = imControl.InputElement.value;
                                var selectionStart = imControl.InputElement.selectionStart;
                                var str = value.substr(selectionStart - 2, selectionStart);
                                imControl.KeyPress(str, evt);
                            }
                        }finally {
                            imControl.IsSurrogateKeyPressing = false;
                        }
                    }
                    //Add comments by Ryan Wu at 16:55 Sep. 11 2007.
                    //For fix the bug "17. Ctrl+Click(select all text) will take no effects(firefox).".
                    Utility.FuncKeysPressed = {
                        Shift: evt.shiftKey,
                        Ctrl: evt.ctrlKey,
                        Alt: evt.altKey
                    };
                    //end by Ryan Wu.
                    imControl.KeyUp(evt);
                    //event.cancelBubble = true;
                                    } catch (e) {
                }
            };
            GlobalEventHandler.OnCompositionStart = function OnCompositionStart(control, evt) {
                try  {
                    control.CompositionStart(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnCompositionUpdate = function OnCompositionUpdate(control, evt) {
                try  {
                    control.CompositionUpdate(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnCompositionEnd = function OnCompositionEnd(control, evt) {
                try  {
                    control.CompositionEnd(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnWebkitEditableContentChanged = function OnWebkitEditableContentChanged(control, evt) {
                try  {
                    control.WebkitEditableContentChanged(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnMouseOver = function OnMouseOver(control, evt) {
                try  {
                    if(control.MouseOver) {
                        control.MouseOver();
                    }
                } catch (e) {
                }
            };
            GlobalEventHandler.OnMouseOut = function OnMouseOut(control, evt) {
                try  {
                    control.MouseOut();
                } catch (e) {
                }
            };
            GlobalEventHandler.OnMouseMove = function OnMouseMove(control, evt) {
                try  {
                    if(control.MouseMove) {
                        control.MouseMove(evt);
                    }
                } catch (e) {
                }
            };
            GlobalEventHandler.OnMouseDown = function OnMouseDown(control, evt) {
                if(control.ImeMode && control.ImeMode === true && !Utility.IsIE8OrBelow()) {
                    return;
                }
                try  {
                    control.MouseDown(evt);
                    if(!Utility.IsIE()) {
                        Utility.DragStartElementID = control;
                    }
                } catch (e) {
                }
            };
            GlobalEventHandler.OnMouseUp = function OnMouseUp(imControl, evt) {
                if(imControl.ImeMode && imControl.ImeMode === true && !Utility.IsIE8OrBelow()) {
                    return;
                }
                try  {
                    // DaryLuo 2013/07/12 fix bug 933, 934 in IM HTML 5.
                    if(imControl.MouseUpPointerType != null && imControl.MouseUpPointerType !== 4 && imControl.MouseUpPointerType !== "mouse") {
                        var evtClone = {
                        };
                        for(var item in evt) {
                            evtClone[item] = evt[item];
                        }
                        setTimeout(function (parameters) {
                            imControl.MouseUp(evtClone);
                        }, 300);
                    } else {
                        imControl.MouseUp(evt);
                    }
                    if(!Utility.IsIE()) {
                        Utility.DragStartElementID = "";
                    }
                } catch (e) {
                }
            };
            GlobalEventHandler.OnSelectStart = function OnSelectStart(control, evt) {
                if(Utility.InnerSelect === true && Utility.ShouldFireOnSelectStart == false) {
                    Utility.CancelBubble(evt);
                }
                var selText = Utility.GetSelectionText(control.GetInputElement());
                if(typeof (selText) == "undefined" || selText == null) {
                    selText = "";
                }
                var useSystem = null;
                try  {
                    useSystem = control.SelectStart(selText);
                } catch (e) {
                }
                if(useSystem == false) {
                    Utility.PreventDefault(evt);
                }
            };
            GlobalEventHandler.OnDblClick = function OnDblClick(control, evt) {
                var useSystem = null;
                try  {
                    useSystem = control.DoubleClick();
                } catch (e) {
                }
                if(!useSystem) {
                    Utility.PreventDefault(evt);
                }
            };
            GlobalEventHandler.OnHTML5BeforeCopy = function OnHTML5BeforeCopy(control, evt) {
                try  {
                    Utility.CutCopyPasteEventObject = evt ? evt.originalEvent : evt;
                    control.Copy(evt);
                } catch (e) {
                }finally {
                    Utility.CutCopyPasteEventObject = null;
                }
            };
            GlobalEventHandler.OnHTML5Cut = function OnHTML5Cut(control, evt) {
                try  {
                    var input = control.GetInputElement();
                    var text = input.value;
                    var selStart = input.selectionStart;
                    var selEnd = input.selectionEnd;
                    setTimeout(function () {
                        input.value = text;
                        input.selectionStart = selStart;
                        input.selectionEnd = selEnd;
                        control.Cut(evt);
                    }, 0);
                    // Let browser do it.
                                    } catch (e) {
                }
            };
            GlobalEventHandler.OnHTML5Paste = function OnHTML5Paste(control, evt) {
                try  {
                    // DaryLuo 2013/05/21, the paste operation doesn't take effect on the android chrome.
                    if(Utility.chrome && Utility.GetClientOS().toLowerCase() !== "android") {
                        Utility.CutCopyPasteEventObject = evt ? evt.originalEvent : evt;
                        control.Paste(Utility.GetDataFromClipboard(true));
                        Utility.PreventDefault(evt);
                    } else {
                        var selStart = control.SelectionStart;
                        var selEnd = control.SelectionEnd;
                        setTimeout(function () {
                            if(Utility.GetClientOS().toLowerCase() === "android") {
                                // DaryLuo 2013/05/27 fix bug 371 in IM HTML5.0.
                                control.SelectionStart = selStart;
                                control.SelectionEnd = selEnd;
                            }
                            control.isPasting = true;
                            // Firefox & android chrome will run at here.
                            control.ImeInput("DirectInput");
                        }, 0);
                    }
                } catch (e) {
                }finally {
                    Utility.CutCopyPasteEventObject = null;
                }
            };
            GlobalEventHandler.OnMouseWheel = function OnMouseWheel(control, evt) {
                try  {
                    control.MouseWheel(evt);
                    if(control.ShouldCancelMouseWheelDefaultBehavior()) {
                        Utility.PreventDefault(evt);
                    }
                } catch (e) {
                }
            };
            GlobalEventHandler.OnDragStart = function OnDragStart(control, evt) {
                try  {
                    control.DragStart();
                } catch (e) {
                }
            };
            GlobalEventHandler.OnDragEnd = function OnDragEnd(control, evt) {
                try  {
                    control.DragEnd(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnDrop = function OnDrop(control, evt) {
                try  {
                    var text = evt.originalEvent.dataTransfer.getData("Text");
                    control.DragDrop(text, evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnTouchStart = function OnTouchStart(control, evt) {
                Utility.TouchStartTime = new Date();
                Utility.TouchStartEvt = evt;
            };
            GlobalEventHandler.OnTouchEnd = function OnTouchEnd(control, evt) {
                if(Utility.TouchStartTime !== undefined) {
                    Utility.TouchEndTime = new Date();
                    var offset = Utility.TouchEndTime.valueOf() - Utility.TouchStartTime.valueOf();
                    if(offset > 1000) {
                        var text = "";
                        try  {
                            text = Utility.GetSelectionText(control.GetInputElement());
                        } catch (e) {
                        }
                        control.ShowContextMenu(text, Utility.TouchStartEvt);
                        if(control.GetEnabled()) {
                            Utility.PreventDefault(evt);
                        }
                    }
                    Utility.TouchStartTime = undefined;
                    Utility.TouchEndTime = undefined;
                }
            };
            GlobalEventHandler.OnDragEnter = function OnDragEnter(control, evt) {
                try  {
                    control.DragEnter();
                } catch (e) {
                }
            };
            GlobalEventHandler.OnDragLeave = function OnDragLeave(control, evt) {
                try  {
                    control.DragLeave();
                } catch (e) {
                }
            };
            GlobalEventHandler.OnSelect = function OnSelect(control, evt) {
                try  {
                    if(control && control.Focused) {
                        control.Select();
                    }
                } catch (e) {
                }
            };
            GlobalEventHandler.OnPropertyChanged = function OnPropertyChanged(control, evt) {
                try  {
                    control.PropertyChange(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnMSPointerUp = function OnMSPointerUp(control, evt) {
                control.MSPointerUp(evt);
            };
            GlobalEventHandler.OnMSPointerDown = function OnMSPointerDown(control, evt) {
                try  {
                    control.MSPointerDown(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnMSGestureTap = function OnMSGestureTap(control, evt) {
                try  {
                    control.MSGestureTap(evt);
                } catch (e) {
                }
            };
            GlobalEventHandler.OnEditFieldFocus = function OnEditFieldFocus(control, evt) {
                if(Utility.IsFocusFromIMControl(control._id, evt)) {
                    if(Utility.IsIE() || Utility.HasGetFocus) {
                        return;
                    }
                }
                //if (!Utility.firefox) {
                //    if (Utility.IsOnFocus) {
                //        if (GrapeCity.IM.Utility.IsIE() && Utility.IsOnActivate || Utility.HasGetFocus) {
                //            return;
                //        }
                //    }
                //}
                Utility.IsOnFocus = true;
                if(!Utility.IsIE()) {
                    Utility.HasGetFocus = true;
                }
                this.OnFocus(control, evt);
                //onFocus(id);
                //Utility.FireEvent(document.getElementById(id), eventName, null);
                // end of Sean Huang <--
                            };
            GlobalEventHandler.OnEditFieldLoseFocus = function OnEditFieldLoseFocus(control, evt) {
                try  {
                    //function gcsh_InputManWeb_onLoseFocus(eventName, id) {
                    var obj = control;
                    if(obj != null && obj.Type == "Edit" && obj.IsFocusToDropDownEdit) {
                        obj.IsFocusToDropDownEdit = false;
                        return;
                    }
                    // Temporarily comment at 2013/08/13.
                    //if (!Utility.IsIE() && obj != null && obj.IMControlType == "Date" && obj.DropDownObj != null) {
                    //    if (Utility.IsFireFox4OrLater()) {
                    //        if (obj.DropDownObj.IsNavigateMouseDown) {
                    //            obj.DropDownObj.IsNavigateMouseDown = null;
                    //            return;
                    //        }
                    //        if (obj.DropDownObj.IsZoomButtonMouseDown) {
                    //            obj.DropDownObj.IsZoomButtonMouseDown = null;
                    //            return;
                    //        }
                    //    }
                    //    if (obj.DropDownObj.IsHeaderMouseDown) {
                    //        obj.DropDownObj.IsHeaderMouseDown = null;
                    //        return;
                    //    }
                    //}
                    if(Utility.IsFocusToIMControl(control._id, evt)) {
                        return;
                    }
                    if(Utility.firefox) {
                        if(Utility.IsOnFocus && Utility.IsIE() && Utility.IsOnActivate && Utility.IsOnActivateControlID == control._id) {
                            if(Utility.FocusToBorder != null && Utility.FocusToBorder == true) {
                                Utility.FocusToBorder = false;
                                obj.SetInnerFocus();
                            }
                            return;
                        }
                        Utility.FocusToBorder = false;
                        if(!Utility.IsIE()) {
                            Utility.HasGetFocus = false;
                        } else {
                            Utility.IsOnFocus = false;
                        }
                    }
                    GlobalEventHandler.OnLostFocus(control, evt);
                    Utility.FuncKeysPressed = {
                        Shift: false,
                        Ctrl: false,
                        Alt: false
                    };
                    //Utility.FireEvent(control, "LoseFocus", null);
                                    } catch (e) {
                }
            };
            GlobalEventHandler.OnFocusOut = function OnFocusOut(control, evt) {
                Utility.FocusToBorder = false;
                if(Utility.IsIE()) {
                    if(evt.toElement) {
                        var toID = evt.toElement.id;
                        if(toID == control._id + "_Inside_Div_Container") {
                            Utility.FocusToBorder = true;
                        }
                    }
                }
                if(Utility.IsFocusToIMControl(control._id, evt)) {
                    if(Utility.IsIE() && Utility.engine >= 9) {
                        Utility.IsOnActivate = true;
                        Utility.IsOnActivateControlID = control._id;
                        Utility.IsOnFocus = true;
                    }
                    return;
                }
                if(Utility.IsIE() && Utility.IsOnActivate) {
                    Utility.IsOnActivate = false;
                    Utility.IsOnActivateControlID = "";
                }
                if(Utility.IsOnFocus) {
                    Utility.IsOnFocus = false;
                }
            };
            GlobalEventHandler.OnActivate = function OnActivate(control, evt) {
                Utility.IsOnActivate = true;
                Utility.IsOnActivateControlID = control._id;
                if(Utility.IsFocusFromIMControl(control._id, evt)) {
                    return;
                }
                Utility.IsOnActivate = true;
                Utility.IsOnActivateControlID = control._id;
            };
            GlobalEventHandler.OnDeActivate = function OnDeActivate(control, evt) {
                if(Utility.IsFocusToIMControl(control._id, evt)) {
                    return;
                }
                Utility.IsOnActivate = false;
                Utility.IsOnActivateControlID = "";
                Utility.IsOnFocus = false;
            };
            GlobalEventHandler.OnFocus = function OnFocus(control, evt) {
                try  {
                    var handler = function () {
                        control.Focus();
                        control.Focused = true;
                        if(Utility.IsPad()) {
                            // DaryLuo 2013/05/27 fix bug 412 in IM HTML 5.0.
                            control.IPadSelectionRefreshTimer = setInterval(function () {
                                control.Select();
                            }, 400);
                        }
                    };
                    if(Utility.IsIE()) {
                        handler.call(this);
                    } else {
                        setTimeout(handler, 0);
                    }
                } catch (e) {
                }
            };
            GlobalEventHandler.OnLostFocus = function OnLostFocus(control, evt) {
                try  {
                    control.LoseFocus(evt);
                    control.Focused = false;
                    if(Utility.IsPad()) {
                        clearInterval(control.IPadSelectionRefreshTimer);
                    }
                } catch (e) {
                }
            };
            return GlobalEventHandler;
        })();
        input.GlobalEventHandler = GlobalEventHandler;        
    })(wijmo.input || (wijmo.input = {}));
    var input = wijmo.input;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../External/declarations/jquery.d.ts"/>
    /// <reference path="../External/declarations/globalize.d.ts"/>
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
    /*
    * Depends:
    *	jquery-1.9.1.js
    *	globalize.js
    *  jquery.wijmo.wijutil.js
    *
    */
    (function (input) {
        "use strict";
        function paddingZero(val, aCount) {
            if (typeof aCount === "undefined") { aCount = 2; }
            var text = '' + val + '';
            if(text.length > aCount) {
                text = text.substr(text.length - aCount);
            } else {
                while(text.length < aCount) {
                    text = '0' + text;
                }
            }
            return text;
        }
        input.paddingZero = paddingZero;
        (function (DescriptorType) {
            DescriptorType._map = [];
            DescriptorType.liternal = -1;
            DescriptorType.OneDigitYear = 1;
            DescriptorType.TwoDigitYear = 2;
            DescriptorType.FourDigitYear = 10;
            DescriptorType.TwoDigitMonth = 20;
            DescriptorType.Month = 25;
            DescriptorType.AbbreviatedMonthNames = 26;
            DescriptorType.MonthNames = 27;
            DescriptorType.EraYear = 70;
            DescriptorType.TwoEraYear = 71;
            DescriptorType.EraName = 72;
            DescriptorType.TwoEraName = 73;
            DescriptorType.ThreeEraName = 74;
            DescriptorType.EraYearBig = 75;
            DescriptorType.AD = 80;
            DescriptorType.TwoDigityDayOfMonth = 30;
            DescriptorType.DayOfMonth = 31;
            DescriptorType.AbbreviatedDayNames = 100;
            DescriptorType.DayNames = 101;
            DescriptorType.h = 45;
            DescriptorType.hh = 46;
            DescriptorType.H = 47;
            DescriptorType.HH = 48;
            DescriptorType.ShortAmPm = 250;
            DescriptorType.AmPm = 251;
            DescriptorType.mm = 50;
            DescriptorType.m = 51;
            DescriptorType.ss = 60;
            DescriptorType.s = 61;
        })(input.DescriptorType || (input.DescriptorType = {}));
        var DescriptorType = input.DescriptorType;
        ////////////////////////////////////////////////////////////////////////////////
        // _iDateDescriptor
        /** @ignore */
        var _iDateDescriptor = (function () {
            function _iDateDescriptor(textProvider, id) {
                this.id = id;
                this.startIndex = 0;
                this.name = null;
                this.type = DescriptorType.liternal;
                this.maxLen = 2;
                this.formatString = "";
                this._txtProvider = textProvider;
                this.startIndex = 0;
            }
            _iDateDescriptor.prototype.getText = function () {
                return null;
            };
            _iDateDescriptor.prototype.getRealText = function (text) {
                if(this._txtProvider.inputWidget.options.date == null) {
                    return this.formatString;
                }
                return text;
            };
            _iDateDescriptor.prototype.setText = function (value, allowchangeotherpart, result, isSmartInputMode) {
                return false;
            };
            _iDateDescriptor.prototype.inc = function () {
            };
            _iDateDescriptor.prototype.dec = function () {
            };
            _iDateDescriptor.prototype.needAdjustInsertPos = function () {
                return true;
            };
            _iDateDescriptor.prototype.reachMaxLen = function () {
                var t = this.getText();
                do {
                    if(t.charAt(0) === '0') {
                        t = t.slice(1);
                    } else {
                        break;
                    }
                }while(t.length > 0);
                return t.length >= this.maxLen;
            };
            return _iDateDescriptor;
        })();
        input._iDateDescriptor = _iDateDescriptor;        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor
        var _dateDescriptor = (function (_super) {
            __extends(_dateDescriptor, _super);
            function _dateDescriptor(owner, id) {
                        _super.call(this, owner, id);
                this.liternal = '';
                this.maxLen = 100;
            }
            _dateDescriptor.prototype.getText = function () {
                return this.liternal;
            };
            return _dateDescriptor;
        })(_iDateDescriptor);        
        var EraYearDescriptor = (function (_super) {
            __extends(EraYearDescriptor, _super);
            function EraYearDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            EraYearDescriptor.prototype.inc = function () {
                var date = this._txtProvider.getDate();
                var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                if(DateTimeInfo.Equal(date, maxDate)) {
                    if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                        this._txtProvider.setDate(new Date(minDate.valueOf()));
                    }
                } else {
                    var increment = this._txtProvider.inputWidget._getInnerIncrement();
                    this._txtProvider.setYear(this._txtProvider.getYear() + increment, null, true);
                    if(this._txtProvider.getDate() > maxDate) {
                        this._txtProvider.setDate(new Date(maxDate.valueOf()));
                    }
                }
            };
            EraYearDescriptor.prototype.dec = function () {
                var date = this._txtProvider.getDate();
                var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                if(DateTimeInfo.Equal(date, minDate)) {
                    if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                        this._txtProvider.setDate(new Date(maxDate.valueOf()));
                    }
                } else {
                    var increment = this._txtProvider.inputWidget._getInnerIncrement();
                    this._txtProvider.setYear(this._txtProvider.getYear() - increment, null, true);
                    if(this._txtProvider.getDate() < minDate) {
                        this._txtProvider.setDate(new Date(minDate.valueOf()));
                    }
                }
            };
            return EraYearDescriptor;
        })(_iDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor70
        var _dateDescriptor70 = (function (_super) {
            __extends(_dateDescriptor70, _super);
            function _dateDescriptor70(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Era Year';
                this.formatString = "e";
                this.type = DescriptorType.EraYear;
            }
            _dateDescriptor70.prototype.getText = function () {
                var eraDate = DateTimeInfo.GetEraDate(this._txtProvider.getDate());
                if(eraDate.eraYear === -1) {
                    return "";
                }
                eraDate.eraYear = eraDate.eraYear > 99 ? 99 : eraDate.eraYear;
                return this.getRealText(String(eraDate.eraYear));
            };
            _dateDescriptor70.prototype.setText = function (value, allowchangeotherpart, result) {
                if(isNaN(parseInt(value))) {
                    return false;
                }
                var date = this._txtProvider.getDate();
                var eraDate = DateTimeInfo.GetEraDate(date);
                if(eraDate.eraYear !== -1) {
                    var eraYear = parseInt(value);
                    if(eraYear >= DateTimeInfo.GetEraYears()[eraDate.era]) {
                        eraYear = DateTimeInfo.GetEraYears()[eraDate.era];
                    }
                    var nullFlag = this._txtProvider.inputWidget.options.date == null;
                    if(nullFlag) {
                        eraYear = parseInt(value);
                    }
                    var newDate = DateTimeInfo.ConvertToGregorianDate(eraDate.era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), false);
                    if(eraDate.era < DateTimeInfo.GetEraCount() - 1) {
                        var maxEraDate = DateTimeInfo.GetEraDates()[eraDate.era + 1];
                        if(newDate > maxEraDate) {
                            eraYear = DateTimeInfo.GetEraYears()[eraDate.era] - 1;
                            newDate = DateTimeInfo.ConvertToGregorianDate(eraDate.era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), false);
                        }
                    }
                    this._txtProvider.setDate(newDate);
                    return true;
                }
                return false;
            };
            return _dateDescriptor70;
        })(EraYearDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor71
        var _dateDescriptor71 = (function (_super) {
            __extends(_dateDescriptor71, _super);
            function _dateDescriptor71(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Two Era Year';
                this.formatString = "ee";
                this.type = DescriptorType.TwoEraYear;
            }
            _dateDescriptor71.prototype.getText = function () {
                var eraDate = DateTimeInfo.GetEraDate(this._txtProvider.getDate());
                if(eraDate.eraYear === -1) {
                    return "";
                }
                eraDate.eraYear = eraDate.eraYear > 99 ? 99 : eraDate.eraYear;
                return this.getRealText(paddingZero(eraDate.eraYear, 2));
            };
            _dateDescriptor71.prototype.setText = function (value, allowchangeotherpart, result) {
                if(isNaN(parseInt(value))) {
                    return false;
                }
                var date = this._txtProvider.getDate();
                var eraDate = DateTimeInfo.GetEraDate(date);
                if(eraDate.eraYear !== -1) {
                    var newValue = String(eraDate.eraYear) + value;
                    var eraYear = parseInt(newValue.substring(newValue.length - 2, newValue.length));
                    if(eraYear > DateTimeInfo.GetEraYears()[eraDate.era]) {
                        eraYear = DateTimeInfo.GetEraYears()[eraDate.era];
                    }
                    var nullFlag = this._txtProvider.inputWidget.options.date == null;
                    if(nullFlag) {
                        eraYear = parseInt(value);
                    }
                    var newDate = DateTimeInfo.ConvertToGregorianDate(eraDate.era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), false);
                    if(eraDate.era < DateTimeInfo.GetEraCount() - 1) {
                        var maxEraDate = DateTimeInfo.GetEraDates()[eraDate.era + 1];
                        if(newDate > maxEraDate) {
                            eraYear = DateTimeInfo.GetEraYears()[eraDate.era] - 1;
                            newDate = DateTimeInfo.ConvertToGregorianDate(eraDate.era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), false);
                        }
                    }
                    this._txtProvider.setDate(newDate);
                    return true;
                }
                return false;
            };
            return _dateDescriptor71;
        })(EraYearDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor75
        var _dateDescriptor75 = (function (_super) {
            __extends(_dateDescriptor75, _super);
            function _dateDescriptor75(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Era Year Big';
                this.formatString = "E";
                this.type = DescriptorType.EraYearBig;
            }
            _dateDescriptor75.prototype.getText = function () {
                var result = _super.prototype.getText.call(this);
                return result == 1 ? "\u5143" : result;
            };
            return _dateDescriptor75;
        })(_dateDescriptor70);        
        var EraNameDescriptor = (function (_super) {
            __extends(EraNameDescriptor, _super);
            function EraNameDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            EraNameDescriptor.prototype.inc = function () {
                var date = this._txtProvider.getDate();
                var eraDate = DateTimeInfo.GetEraDate(date);
                if(eraDate.era === -1) {
                    return;
                }
                var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                if(DateTimeInfo.Equal(date, maxDate)) {
                    if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                        this._txtProvider.setDate(new Date(minDate.valueOf()));
                    }
                } else {
                    if(eraDate.era >= DateTimeInfo.GetEraCount() - 1) {
                        this._txtProvider.setDate(new Date(maxDate.valueOf()));
                    } else {
                        var era = eraDate.era + this._txtProvider.inputWidget._getInnerIncrement();
                        era = era > DateTimeInfo.GetEraCount() - 1 ? DateTimeInfo.GetEraCount() - 1 : era;
                        var eraYear = eraDate.eraYear > DateTimeInfo.GetEraYears()[era] ? DateTimeInfo.GetEraYears()[era] : eraDate.eraYear;
                        var newDate = DateTimeInfo.ConvertToGregorianDate(era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), true);
                        newDate = newDate == null ? DateTimeInfo.GetEraDates()[era] : newDate;
                        if(newDate > maxDate) {
                            this._txtProvider.setDate(new Date(maxDate.valueOf()));
                        } else {
                            this._txtProvider.setDate(newDate);
                        }
                    }
                }
            };
            EraNameDescriptor.prototype.dec = function () {
                var date = this._txtProvider.getDate();
                var eraDate = DateTimeInfo.GetEraDate(date);
                if(eraDate.era === -1) {
                    return;
                }
                var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                if(DateTimeInfo.Equal(date, minDate)) {
                    if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                        this._txtProvider.setDate(new Date(maxDate.valueOf()));
                    }
                } else {
                    if(eraDate.era == 0) {
                        this._txtProvider.setDate(new Date(minDate.valueOf()));
                    } else {
                        var era = eraDate.era - this._txtProvider.inputWidget._getInnerIncrement();
                        era = era < 0 ? 0 : era;
                        var eraYear = eraDate.eraYear > DateTimeInfo.GetEraYears()[era] ? DateTimeInfo.GetEraYears()[era] : eraDate.eraYear;
                        var newDate = DateTimeInfo.ConvertToGregorianDate(era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), true);
                        if(newDate == null) {
                            newDate = new Date(DateTimeInfo.GetEraDates()[era + 1]);
                            ;
                            newDate.setDate(newDate.getDate() - 1);
                        }
                        if(newDate > maxDate) {
                            this._txtProvider.setDate(new Date(minDate.valueOf()));
                        } else {
                            this._txtProvider.setDate(newDate);
                        }
                    }
                }
            };
            return EraNameDescriptor;
        })(_iDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor72
        var _dateDescriptor72 = (function (_super) {
            __extends(_dateDescriptor72, _super);
            function _dateDescriptor72(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Era Name';
                this.formatString = "g";
                this.type = DescriptorType.EraName;
            }
            _dateDescriptor72.prototype.getText = function () {
                var eraDate = DateTimeInfo.GetEraDate(this._txtProvider.getDate());
                if(eraDate.era === -1) {
                    return "";
                }
                return this.getRealText(DateTimeInfo.GetEraSymbols()[eraDate.era]);
            };
            _dateDescriptor72.prototype.setText = function (value, allowchangeotherpart, result) {
                var singleValue = value.substr(value.length - 1, 1);
                var era = 0;
                for(era = 0; era < DateTimeInfo.GetEraCount(); era++) {
                    if((singleValue.toLowerCase() === DateTimeInfo.GetEraShortcuts()[era].toLowerCase()) || (value.toLowerCase() === DateTimeInfo.GetEraShortNames()[era].toLowerCase())) {
                        break;
                    }
                }
                if(era == DateTimeInfo.GetEraCount()) {
                    return true;
                }
                var date = this._txtProvider.getDate();
                var eraDate = DateTimeInfo.GetEraDate(date);
                if(eraDate.era === -1) {
                    return true;
                }
                var eraYear = eraDate.eraYear > DateTimeInfo.GetEraYears()[era] ? DateTimeInfo.GetEraYears()[era] : eraDate.eraYear;
                var newDate = DateTimeInfo.ConvertToGregorianDate(era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), true);
                newDate = newDate == null ? DateTimeInfo.GetEraDates()[era] : newDate;
                if(era < DateTimeInfo.GetEraCount() - 1) {
                    var maxEraDate = DateTimeInfo.GetEraDates()[era + 1];
                    newDate = newDate > maxEraDate ? maxEraDate : newDate;
                }
                this._txtProvider.setDate(newDate);
                return true;
            };
            return _dateDescriptor72;
        })(EraNameDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor73
        var _dateDescriptor73 = (function (_super) {
            __extends(_dateDescriptor73, _super);
            function _dateDescriptor73(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Two Era Name';
                this.formatString = "gg";
                this.type = DescriptorType.TwoEraName;
            }
            _dateDescriptor73.prototype.getText = function () {
                var eraDate = DateTimeInfo.GetEraDate(this._txtProvider.getDate());
                if(eraDate.era === -1) {
                    return "";
                }
                return this.getRealText(DateTimeInfo.GetEraAbbreviations()[eraDate.era]);
            };
            _dateDescriptor73.prototype.setText = function (value, allowchangeotherpart, result) {
                var singleValue = value.substr(value.length - 1, 1);
                var era = 0;
                for(era = 0; era < DateTimeInfo.GetEraCount(); era++) {
                    if((singleValue.toLowerCase() === DateTimeInfo.GetEraShortcuts()[era].toLowerCase()) || (value.toLowerCase() === DateTimeInfo.GetEraShortNames()[era].toLowerCase()) || (value.toLowerCase() === DateTimeInfo.GetEraAbbreviations()[era].toLowerCase())) {
                        break;
                    }
                }
                if(era == DateTimeInfo.GetEraCount()) {
                    return true;
                }
                var date = this._txtProvider.getDate();
                var eraDate = DateTimeInfo.GetEraDate(date);
                if(eraDate.era === -1) {
                    return true;
                }
                var eraYear = eraDate.eraYear > DateTimeInfo.GetEraYears()[era] ? DateTimeInfo.GetEraYears()[era] : eraDate.eraYear;
                var newDate = DateTimeInfo.ConvertToGregorianDate(era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), true);
                newDate = newDate == null ? DateTimeInfo.GetEraDates()[era] : newDate;
                if(era < DateTimeInfo.GetEraCount() - 1) {
                    var maxEraDate = DateTimeInfo.GetEraDates()[era + 1];
                    newDate = newDate > maxEraDate ? maxEraDate : newDate;
                }
                this._txtProvider.setDate(newDate);
                return true;
            };
            return _dateDescriptor73;
        })(EraNameDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor74
        var _dateDescriptor74 = (function (_super) {
            __extends(_dateDescriptor74, _super);
            function _dateDescriptor74(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Three Era Name';
                this.formatString = "ggg";
                this.type = DescriptorType.ThreeEraName;
            }
            _dateDescriptor74.prototype.getText = function () {
                var eraDate = DateTimeInfo.GetEraDate(this._txtProvider.getDate());
                if(eraDate.era === -1) {
                    return "";
                }
                return this.getRealText(DateTimeInfo.GetEraNames()[eraDate.era]);
            };
            _dateDescriptor74.prototype.setText = function (value, allowchangeotherpart, result) {
                var singleValue = value.substr(value.length - 1, 1);
                var era = 0;
                for(era = 0; era < DateTimeInfo.GetEraCount(); era++) {
                    if((singleValue.toLowerCase() === DateTimeInfo.GetEraShortcuts()[era].toLowerCase()) || (value.toLowerCase() === DateTimeInfo.GetEraShortNames()[era].toLowerCase()) || (value.toLowerCase() === DateTimeInfo.GetEraAbbreviations()[era].toLowerCase()) || (value.toLowerCase() === DateTimeInfo.GetEraNames()[era].toLowerCase())) {
                        break;
                    }
                }
                if(era == DateTimeInfo.GetEraCount()) {
                    return false;
                }
                var date = this._txtProvider.getDate();
                var eraDate = DateTimeInfo.GetEraDate(date);
                if(eraDate.era === -1) {
                    return true;
                }
                var eraYear = eraDate.eraYear > DateTimeInfo.GetEraYears()[era] ? DateTimeInfo.GetEraYears()[era] : eraDate.eraYear;
                var newDate = DateTimeInfo.ConvertToGregorianDate(era, eraYear, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), true);
                newDate = newDate == null ? DateTimeInfo.GetEraDates()[era] : newDate;
                if(era < DateTimeInfo.GetEraCount() - 1) {
                    var maxEraDate = DateTimeInfo.GetEraDates()[era + 1];
                    newDate = newDate > maxEraDate ? maxEraDate : newDate;
                }
                this._txtProvider.setDate(newDate);
                return true;
            };
            return _dateDescriptor74;
        })(EraNameDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor80
        var _dateDescriptor80 = (function (_super) {
            __extends(_dateDescriptor80, _super);
            function _dateDescriptor80(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'AD';
                this.formatString = "A";
                this.type = DescriptorType.AD;
            }
            _dateDescriptor80.prototype.getText = function () {
                return "A.D.";
            };
            return _dateDescriptor80;
        })(_iDateDescriptor);        
        var MonthDateDescriptor = (function (_super) {
            __extends(MonthDateDescriptor, _super);
            function MonthDateDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            MonthDateDescriptor.prototype.inc = function () {
                _super.prototype.inc.call(this);
                var date = this._txtProvider.getDate();
                var year = date.getFullYear();
                var month = date.getMonth();
                var day = date.getDate();
                var hour = date.getHours();
                var minute = date.getMinutes();
                var second = date.getSeconds();
                var newMonth = month + this._txtProvider.inputWidget._getInnerIncrement();
                var dayCount = DateTimeInfo.DaysInMonth(year, newMonth + 1);
                if(day > dayCount) {
                    day = dayCount;
                }
                var newDate = new Date(year, newMonth, day, hour, minute, second);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate >= maxDate) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), maxDate)) {
                            this._txtProvider.setDate(maxDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), maxDate)) {
                            this._txtProvider.setDate(maxDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            MonthDateDescriptor.prototype.dec = function () {
                _super.prototype.inc.call(this);
                var date = this._txtProvider.getDate();
                var year = date.getFullYear();
                var month = date.getMonth();
                var day = date.getDate();
                var hour = date.getHours();
                var minute = date.getMinutes();
                var second = date.getSeconds();
                var newMonth = month - this._txtProvider.inputWidget._getInnerIncrement();
                var dayCount = DateTimeInfo.DaysInMonth(year, newMonth + 1);
                if(day > dayCount) {
                    day = dayCount;
                }
                var newDate = new Date(year, newMonth, day, hour, minute, second);
                if(year == 1) {
                    newDate.setFullYear(1);
                    if(newMonth < 0) {
                        newDate.setMonth(newMonth);
                    }
                }
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate < minDate) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), minDate)) {
                            this._txtProvider.setDate(minDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), minDate)) {
                            this._txtProvider.setDate(minDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            MonthDateDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                if(parseInt(value) > 12) {
                    value = value.substr(value.length - 1, 1);
                }
                var returnResult = this._txtProvider.setMonth(value, allowchangeotherpart, result);
                if(returnResult) {
                    if(this._txtProvider._isEraFormatExist()) {
                        var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                        var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                        var date = this._txtProvider.getDate();
                        if(date > maxDate) {
                            this._txtProvider.setDate(maxDate);
                        } else if(date < minDate) {
                            this._txtProvider.setDate(minDate);
                        }
                    }
                }
                return returnResult;
            };
            return MonthDateDescriptor;
        })(_iDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor20
        var _dateDescriptor20 = (function (_super) {
            __extends(_dateDescriptor20, _super);
            function _dateDescriptor20(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Two-digit month';
                this.formatString = "MM";
                this.type = DescriptorType.TwoDigitMonth;
            }
            _dateDescriptor20.prototype.getText = function () {
                var m = '' + this._txtProvider.getMonth() + '';
                return this.getRealText(m.length === 1 ? ('0' + m) : m);
            };
            _dateDescriptor20.prototype.setText = function (value, allowchangeotherpart, result) {
                if(value === "0") {
                    return true;
                }
                return _super.prototype.setText.call(this, value, allowchangeotherpart, result);
            };
            return _dateDescriptor20;
        })(MonthDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor25
        var _dateDescriptor25 = (function (_super) {
            __extends(_dateDescriptor25, _super);
            function _dateDescriptor25(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'month';
                this.formatString = "M";
                this.type = DescriptorType.Month;
            }
            _dateDescriptor25.prototype.getText = function () {
                var m = '' + this._txtProvider.getMonth() + '';
                return this.getRealText(m);
            };
            return _dateDescriptor25;
        })(MonthDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor26
        var _dateDescriptor26 = (function (_super) {
            __extends(_dateDescriptor26, _super);
            function _dateDescriptor26(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'AbbreviatedMonthNames';
                this.formatString = "MMM";
                this.type = DescriptorType.AbbreviatedMonthNames;
                this.maxLen = DescriptorType.AbbreviatedMonthNames;
            }
            _dateDescriptor26.prototype.getText = function () {
                var m = this._txtProvider.getMonth(), culture = this._txtProvider._getCulture();
                return this.getRealText(culture.calendars.standard.months.namesAbbr[m - 1]);
            };
            _dateDescriptor26.prototype.setText = function (value, allowchangeotherpart, result) {
                var m = -1, cf = this._txtProvider.inputWidget._getCulture().calendars.standard;
                m = this._txtProvider.findAlikeArrayItemIndex(cf.months.namesAbbr, value);
                if(m === -1) {
                    return false;
                }
                return this._txtProvider.setMonth(m + 1, allowchangeotherpart, result);
            };
            return _dateDescriptor26;
        })(MonthDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor27
        var _dateDescriptor27 = (function (_super) {
            __extends(_dateDescriptor27, _super);
            function _dateDescriptor27(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'MonthNames';
                this.formatString = "MMMM";
                this.type = DescriptorType.MonthNames;
                this.maxLen = 100;
            }
            _dateDescriptor27.prototype.getText = function () {
                var m = this._txtProvider.getMonth(), culture = this._txtProvider._getCulture();
                return this.getRealText(culture.calendars.standard.months.names[m - 1]);
            };
            _dateDescriptor27.prototype.setText = function (value, allowchangeotherpart, result) {
                var m = -1, culture;
                if(result && result.isfullreset) {
                    m = 1;
                } else {
                    culture = this._txtProvider._getCulture();
                    m = this._txtProvider.findAlikeArrayItemIndex(culture.calendars.standard.months.names, value);
                    if(m === -1) {
                        return false;
                    }
                }
                return this._txtProvider.setMonth(m + 1, allowchangeotherpart, result);
            };
            return _dateDescriptor27;
        })(MonthDateDescriptor);        
        var DayOfMonthDescriptor = (function (_super) {
            __extends(DayOfMonthDescriptor, _super);
            function DayOfMonthDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            DayOfMonthDescriptor.prototype.inc = function () {
                var newDay = this._txtProvider.getDayOfMonth() + this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setDate(newDay);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate > maxDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            DayOfMonthDescriptor.prototype.dec = function () {
                var newDay = this._txtProvider.getDayOfMonth() - this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setDate(newDay);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate < minDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            DayOfMonthDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                var date = this._txtProvider.getDate();
                var dayCount = DateTimeInfo.DaysInMonth(date.getFullYear(), date.getMonth() + 1);
                if(parseInt(value) > dayCount) {
                    value = dayCount + "";
                }
                var returnResult = this._txtProvider.setDayOfMonth(value, allowchangeotherpart, result);
                if(returnResult) {
                    if(this._txtProvider._isEraFormatExist()) {
                        var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                        var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                        var date = this._txtProvider.getDate();
                        if(date > maxDate) {
                            this._txtProvider.setDate(maxDate);
                        } else if(date < minDate) {
                            this._txtProvider.setDate(minDate);
                        }
                    }
                }
                return returnResult;
            };
            return DayOfMonthDescriptor;
        })(_iDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor30
        var _dateDescriptor30 = (function (_super) {
            __extends(_dateDescriptor30, _super);
            function _dateDescriptor30(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Two-digit day of month';
                this.formatString = "dd";
                this.type = DescriptorType.TwoDigityDayOfMonth;
            }
            _dateDescriptor30.prototype.getText = function () {
                return this.getRealText(paddingZero(this._txtProvider.getDayOfMonth()));
            };
            _dateDescriptor30.prototype.setText = function (value, allowchangeotherpart, result) {
                if(value === "0") {
                    return true;
                }
                return _super.prototype.setText.call(this, value, allowchangeotherpart, result);
            };
            return _dateDescriptor30;
        })(DayOfMonthDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor31
        var _dateDescriptor31 = (function (_super) {
            __extends(_dateDescriptor31, _super);
            function _dateDescriptor31(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Day of month';
                this.formatString = "d";
                this.type = DescriptorType.DayOfMonth;
            }
            _dateDescriptor31.prototype.getText = function () {
                var dom = this._txtProvider.getDayOfMonth();
                return this.getRealText('' + dom + '');
            };
            return _dateDescriptor31;
        })(DayOfMonthDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor100
        var _dateDescriptor100 = (function (_super) {
            __extends(_dateDescriptor100, _super);
            function _dateDescriptor100(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'AbbreviatedDayNames';
                this.formatString = "ddd";
                this.type = DescriptorType.AbbreviatedDayNames;
                this.maxLen = 100;
            }
            _dateDescriptor100.prototype.getText = function () {
                var dw = this._txtProvider.getDayOfWeek(), culture = this._txtProvider._getCulture();
                return this.getRealText(culture.calendars.standard.days.namesAbbr[dw - 1]);
            };
            _dateDescriptor100.prototype.setText = function (value, allowchangeotherpart, result) {
                var dw = -1, culture = this._txtProvider._getCulture();
                dw = this._txtProvider.findAlikeArrayItemIndex(culture.calendars.standard.days.namesShort, value);
                if(dw === -1) {
                    return false;
                }
                return this._txtProvider.setDayOfWeek(dw + 1);
            };
            _dateDescriptor100.prototype.needAdjustInsertPos = function () {
                return false;
            };
            return _dateDescriptor100;
        })(DayOfMonthDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor101
        var _dateDescriptor101 = (function (_super) {
            __extends(_dateDescriptor101, _super);
            function _dateDescriptor101(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'DayNames';
                this.formatString = "dddd";
                this.type = DescriptorType.DayNames;
                this.maxLen = 100;
            }
            _dateDescriptor101.prototype.getText = function () {
                var dw = this._txtProvider.getDayOfWeek(), culture = this._txtProvider._getCulture();
                return this.getRealText(culture.calendars.standard.days.names[dw - 1]);
            };
            _dateDescriptor101.prototype.setText = function (value, allowchangeotherpart, result) {
                var dw = -1, culture = this._txtProvider._getCulture();
                dw = this._txtProvider.findAlikeArrayItemIndex(culture.calendars.standard.days.names, value);
                if(dw === -1) {
                    return false;
                }
                return this._txtProvider.setDayOfWeek(dw + 1);
            };
            _dateDescriptor101.prototype.needAdjustInsertPos = function () {
                return false;
            };
            return _dateDescriptor101;
        })(DayOfMonthDescriptor);        
        var YearDateDescriptor = (function (_super) {
            __extends(YearDateDescriptor, _super);
            function YearDateDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            YearDateDescriptor.prototype.inc = function () {
                var newYear = this._txtProvider.getYear() + this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setFullYear(newYear);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate > maxDate) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), maxDate)) {
                            this._txtProvider.setDate(maxDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), maxDate)) {
                            this._txtProvider.setDate(maxDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            YearDateDescriptor.prototype.dec = function () {
                var newYear = this._txtProvider.getYear() - +this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setFullYear(newYear);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate < minDate) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), minDate)) {
                            this._txtProvider.setDate(minDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(!DateTimeInfo.Equal(this._txtProvider.getDate(), minDate)) {
                            this._txtProvider.setDate(minDate);
                        } else if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            return YearDateDescriptor;
        })(_iDateDescriptor);        
        var TwoDigitYearDescriptor = (function (_super) {
            __extends(TwoDigitYearDescriptor, _super);
            function TwoDigitYearDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            TwoDigitYearDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                value = paddingZero(value);
                var y = paddingZero(this._txtProvider.getYear(), 4), m, dom, h, min, s;
                if(value === '00') {
                    m = this._txtProvider.getMonth();
                    dom = this._txtProvider.getDayOfMonth();
                    h = this._txtProvider.getHours();
                    min = this._txtProvider.getMinutes();
                    s = this._txtProvider.getSeconds();
                    if(m === 1 && dom === 1 && !h && !min && !s) {
                        y = '0001';
                        value = '01';
                    }
                }
                if(y.length >= 2) {
                    y = y.substr(0, 2) + value.substr(0, 2);
                }
                return this._txtProvider.setYear(parseInt(y), result, false);
            };
            return TwoDigitYearDescriptor;
        })(YearDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor10
        var _dateDescriptor10 = (function (_super) {
            __extends(_dateDescriptor10, _super);
            function _dateDescriptor10(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Four-digit year';
                this.formatString = "yyyy";
                this.type = DescriptorType.FourDigitYear;
                this.maxLen = 4;
            }
            _dateDescriptor10.prototype.getText = function () {
                return this.getRealText(paddingZero(this._txtProvider.getYear(), 4));
            };
            _dateDescriptor10.prototype.setText = function (value, allowchangeotherpart, result, isSmartInputMode) {
                if(isSmartInputMode && result) {
                    value = value * 1;
                    value = value % 100;
                    var startYear = 1900 + 100;
                    if(this._txtProvider.inputWidget.options.startYear) {
                        startYear = this._txtProvider.inputWidget.options.startYear;
                    }
                    var lastYear = startYear % 100;
                    var firstYear = startYear - lastYear;
                    if(value >= lastYear) {
                        value = firstYear + value;
                    } else {
                        value = firstYear + value + 100;
                    }
                    //    startYearStr: string,
                    //    endYear, curDate, thisYear, inputNum, century, addYear, s;
                    //endYear = startYear + 100 - 1;
                    //startYearStr = this._txtProvider.paddingZero(startYear, 4);
                    //endYear = this._txtProvider.paddingZero(endYear, 4);
                    //if (result.pos === 0 || result.pos === 1) {
                    //    curDate = new Date();
                    //    thisYear = this._txtProvider
                    //        .paddingZero(this._txtProvider.getYear(), 4);
                    //    if (thisYear.charAt(0) === '0' &&
                    //        thisYear.charAt(1) === '0' && result.pos <= 1) {
                    //        inputNum = result.val;
                    //        century = '00';
                    //        if (inputNum >= 5) {
                    //            century = startYearStr.slice(0, 2);
                    //        }
                    //        else {
                    //            century = endYear.slice(0, 2);
                    //        }
                    //        addYear = result.val + thisYear.slice(3, 4);
                    //        s = century + addYear;
                    //        result.offset = 2 - result.pos;
                    //        this._txtProvider.setYear(s, result);
                    //        return true;
                    //    }
                    //}
                                    }
                return this._txtProvider.setYear(value, result, false);
            };
            return _dateDescriptor10;
        })(YearDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor1
        var _dateDescriptor1 = (function (_super) {
            __extends(_dateDescriptor1, _super);
            function _dateDescriptor1(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'One-digit year';
                this.formatString = "y";
                this.type = DescriptorType.OneDigitYear;
            }
            _dateDescriptor1.prototype.getText = function () {
                var y = paddingZero(this._txtProvider.getYear());
                if(y[0] === '0') {
                    y = y[1];
                }
                return this.getRealText(y);
            };
            return _dateDescriptor1;
        })(TwoDigitYearDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor2
        var _dateDescriptor2 = (function (_super) {
            __extends(_dateDescriptor2, _super);
            function _dateDescriptor2(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'Two-digit year';
                this.formatString = "yy";
                this.type = DescriptorType.TwoDigitYear;
            }
            _dateDescriptor2.prototype.getText = function () {
                if(this._txtProvider.inputWidget.isFocused() && this._txtProvider.inputWidget.options.date == null) {
                    return "yy";
                }
                return this.getRealText(paddingZero(this._txtProvider.getYear(), 2));
            };
            return _dateDescriptor2;
        })(TwoDigitYearDescriptor);        
        var HourDescriptor = (function (_super) {
            __extends(HourDescriptor, _super);
            function HourDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            HourDescriptor.prototype.inc = function () {
                var newHour = this._txtProvider.getHours() + this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setHours(newHour);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate > maxDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            HourDescriptor.prototype.dec = function () {
                var newHour = this._txtProvider.getHours() - this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setHours(newHour);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate < minDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            return HourDescriptor;
        })(_iDateDescriptor);        
        var TwelveHourDescriptor = (function (_super) {
            __extends(TwelveHourDescriptor, _super);
            function TwelveHourDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            TwelveHourDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                var h = this._txtProvider.getHours();
                if(h > 12) {
                    value = ((value * 1) + 12);
                }
                return this._txtProvider.setHours(value, allowchangeotherpart);
            };
            return TwelveHourDescriptor;
        })(HourDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor45
        var _dateDescriptor45 = (function (_super) {
            __extends(_dateDescriptor45, _super);
            function _dateDescriptor45(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'h';
                this.formatString = "h";
                this.type = DescriptorType.h;
            }
            _dateDescriptor45.prototype.getText = function () {
                if(this._txtProvider.inputWidget.isFocused() && this._txtProvider.inputWidget.options.date == null) {
                    return "h";
                }
                var h = this._txtProvider.getHours();
                if(h > 12) {
                    h = h - 12;
                } else if(h === 0) {
                    h = 12;
                }
                if(h == 12 && this._txtProvider.inputWidget.options.hour12As0) {
                    h = 0;
                }
                return this.getRealText('' + h + '');
            };
            return _dateDescriptor45;
        })(TwelveHourDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor46
        var _dateDescriptor46 = (function (_super) {
            __extends(_dateDescriptor46, _super);
            function _dateDescriptor46(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'hh';
                this.formatString = "hh";
                this.type = DescriptorType.hh;
            }
            _dateDescriptor46.prototype.getText = function () {
                var h = this._txtProvider.getHours();
                if(h > 12) {
                    h -= 12;
                } else if(h === 0) {
                    h = 12;
                }
                if(h == 12 && this._txtProvider.inputWidget.options.hour12As0) {
                    h = 0;
                }
                return this.getRealText(paddingZero(h, 2));
            };
            return _dateDescriptor46;
        })(TwelveHourDescriptor);        
        var TwentyFourHourDescriptor = (function (_super) {
            __extends(TwentyFourHourDescriptor, _super);
            function TwentyFourHourDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            TwentyFourHourDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                return this._txtProvider.setHours(value, allowchangeotherpart);
            };
            return TwentyFourHourDescriptor;
        })(HourDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor47
        var _dateDescriptor47 = (function (_super) {
            __extends(_dateDescriptor47, _super);
            function _dateDescriptor47(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'H';
                this.formatString = "H";
                this.type = DescriptorType.H;
            }
            _dateDescriptor47.prototype.getText = function () {
                var h = this._txtProvider.getHours();
                if(h == 0 && !this._txtProvider.inputWidget.options.midnightAs0) {
                    h = 24;
                }
                return this.getRealText('' + h + '');
            };
            return _dateDescriptor47;
        })(TwentyFourHourDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor48
        var _dateDescriptor48 = (function (_super) {
            __extends(_dateDescriptor48, _super);
            function _dateDescriptor48(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'HH';
                this.formatString = "HH";
                this.type = DescriptorType.HH;
            }
            _dateDescriptor48.prototype.getText = function () {
                var h = this._txtProvider.getHours();
                if(h == 0 && !this._txtProvider.inputWidget.options.midnightAs0) {
                    h = 24;
                }
                return this.getRealText(paddingZero(h, 2));
            };
            return _dateDescriptor48;
        })(TwentyFourHourDescriptor);        
        var AmPmDescriptor = (function (_super) {
            __extends(AmPmDescriptor, _super);
            function AmPmDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            AmPmDescriptor.prototype.inc = function () {
                var h = (this._txtProvider.getHours() + 12) % 24;
                this._txtProvider.setHours(h, true);
            };
            AmPmDescriptor.prototype.dec = function () {
                var h = (this._txtProvider.getHours() + 12) % 24;
                this._txtProvider.setHours(h, true);
            };
            AmPmDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                var h;
                if(value.toLowerCase().indexOf('a') >= 0) {
                    h = this._txtProvider.getHours() % 12;
                    this._txtProvider.setHours(h, true);
                } else if(value.toLowerCase().indexOf('p') >= 0) {
                    h = this._txtProvider.getHours() % 12 + 12;
                    this._txtProvider.setHours(h, true);
                }
                return true;
            };
            return AmPmDescriptor;
        })(_iDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor250
        var _dateDescriptor250 = (function (_super) {
            __extends(_dateDescriptor250, _super);
            function _dateDescriptor250(owner, id) {
                        _super.call(this, owner, id);
                this.name = 't';
                this.formatString = "t";
                this.type = DescriptorType.ShortAmPm;
            }
            _dateDescriptor250.prototype.getText = function () {
                var hours = this._txtProvider.getHours();
                var culture = this._txtProvider._getCulture();
                var am = this._txtProvider.inputWidget._getInnerAmDesignator();
                var pm = this._txtProvider.inputWidget._getInnerPmDesignator();
                var designator = hours < 12 ? am : pm;
                return this.getRealText(designator.charAt(0) || " ");
            };
            return _dateDescriptor250;
        })(AmPmDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor251
        var _dateDescriptor251 = (function (_super) {
            __extends(_dateDescriptor251, _super);
            function _dateDescriptor251(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'tt';
                this.formatString = "tt";
                this.type = DescriptorType.AmPm;
            }
            _dateDescriptor251.prototype.getText = function () {
                var hours = this._txtProvider.getHours();
                var culture = this._txtProvider._getCulture();
                var am = this._txtProvider.inputWidget._getInnerAmDesignator();
                var pm = this._txtProvider.inputWidget._getInnerPmDesignator();
                var designator = hours < 12 ? am : pm;
                if(designator.length <= 0) {
                    designator = ' ';
                }
                return this.getRealText(designator);
            };
            return _dateDescriptor251;
        })(AmPmDescriptor);        
        var MinuteDescriptor = (function (_super) {
            __extends(MinuteDescriptor, _super);
            function MinuteDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            MinuteDescriptor.prototype.inc = function () {
                var newMinute = this._txtProvider.getMinutes() + this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setMinutes(newMinute);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate > maxDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            MinuteDescriptor.prototype.dec = function () {
                var newMinite = this._txtProvider.getMinutes() - this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setMinutes(newMinite);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate < minDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            MinuteDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                if(result && result.isfullreset) {
                    value = '0';
                }
                return this._txtProvider.setMinutes(value, allowchangeotherpart);
            };
            return MinuteDescriptor;
        })(_iDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor50
        var _dateDescriptor50 = (function (_super) {
            __extends(_dateDescriptor50, _super);
            function _dateDescriptor50(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'mm';
                this.formatString = "mm";
                this.type = DescriptorType.mm;
            }
            _dateDescriptor50.prototype.getText = function () {
                return this.getRealText(paddingZero(this._txtProvider.getMinutes()));
            };
            return _dateDescriptor50;
        })(MinuteDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor51
        var _dateDescriptor51 = (function (_super) {
            __extends(_dateDescriptor51, _super);
            function _dateDescriptor51(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'm';
                this.formatString = "m";
                this.type = DescriptorType.m;
                this.delta = 12;
            }
            _dateDescriptor51.prototype.getText = function () {
                return this.getRealText(this._txtProvider.getMinutes().toString());
            };
            return _dateDescriptor51;
        })(MinuteDescriptor);        
        var SecondDescriptor = (function (_super) {
            __extends(SecondDescriptor, _super);
            function SecondDescriptor(owner, id) {
                        _super.call(this, owner, id);
            }
            SecondDescriptor.prototype.inc = function () {
                var newSecond = this._txtProvider.getSeconds() + this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setSeconds(newSecond);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate > maxDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(minDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            SecondDescriptor.prototype.dec = function () {
                var newSecond = this._txtProvider.getSeconds() - this._txtProvider.inputWidget._getInnerIncrement();
                var newDate = new Date(this._txtProvider.getDate().valueOf());
                newDate.setSeconds(newSecond);
                if(this._txtProvider._isEraFormatExist()) {
                    var minDate = this._txtProvider.inputWidget._getRealEraMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealEraMaxDate();
                    if(newDate < minDate) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                } else {
                    var minDate = this._txtProvider.inputWidget._getRealMinDate();
                    var maxDate = this._txtProvider.inputWidget._getRealMaxDate();
                    if(!this._txtProvider.inputWidget._isValidDate(newDate, true)) {
                        if(this._txtProvider.inputWidget._getAllowSpinLoop()) {
                            this._txtProvider.setDate(maxDate);
                        }
                    } else {
                        this._txtProvider.setDate(newDate);
                    }
                }
            };
            SecondDescriptor.prototype.setText = function (value, allowchangeotherpart, result) {
                if(result && result.isfullreset) {
                    value = '0';
                }
                return this._txtProvider.setSeconds(value, allowchangeotherpart);
            };
            return SecondDescriptor;
        })(_iDateDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor60
        var _dateDescriptor60 = (function (_super) {
            __extends(_dateDescriptor60, _super);
            function _dateDescriptor60(owner, id) {
                        _super.call(this, owner, id);
                this.name = 'ss';
                this.formatString = "ss";
                this.type = DescriptorType.ss;
            }
            _dateDescriptor60.prototype.getText = function () {
                return this.getRealText(paddingZero(this._txtProvider.getSeconds()));
            };
            return _dateDescriptor60;
        })(SecondDescriptor);        
        ////////////////////////////////////////////////////////////////////////////////
        // _dateDescriptor61
        var _dateDescriptor61 = (function (_super) {
            __extends(_dateDescriptor61, _super);
            function _dateDescriptor61(owner, id) {
                        _super.call(this, owner, id);
                this.name = 's';
                this.formatString = "s";
                this.type = DescriptorType.s;
            }
            _dateDescriptor61.prototype.getText = function () {
                return this.getRealText(this._txtProvider.getSeconds().toString());
            };
            return _dateDescriptor61;
        })(SecondDescriptor);        
        /** @ignore */
        var DateTimeInfo = (function () {
            function DateTimeInfo() { }
            DateTimeInfo.EraDates = new Array(new Date(1868, 9 - 1, 8), new Date(1912, 7 - 1, 30), new Date(1926, 12 - 1, 25), new Date(1989, 1 - 1, 8));
            DateTimeInfo.EraCount = 4;
            DateTimeInfo.EraYears = new Array(45, 15, 64, 99);
            DateTimeInfo.EraMax = new Date(2087, 12 - 1, 31, 23, 59, 59);
            DateTimeInfo.EraMin = new Date(1868, 9 - 1, 8);
            DateTimeInfo.EraKeys = new Array("1", "2", "3", "4", "m", "t", "s", "h");
            DateTimeInfo.EraIndices = new Array(0, 1, 2, 3, 0, 1, 2, 3);
            DateTimeInfo.DateLongFormat = "yyyyMMddHHmmss";
            DateTimeInfo.EraNames = new Array("M", "T", "S", "H", "\u660E", "\u5927", "\u662D", "\u5E73", "\u660E\u6CBB", "\u5927\u6B63", "\u662D\u548C", "\u5E73\u6210");
            DateTimeInfo.WeekDays = new Array("\u65e5\u66dc\u65e5", "\u6708\u66dc\u65e5", "\u706b\u66dc\u65e5", "\u6c34\u66dc\u65e5", "\u6728\u66dc\u65e5", "\u91d1\u66dc\u65e5", "\u571f\u66dc\u65e5");
            DateTimeInfo.MonthNames = new Array("\u0031\u6708", "\u0032\u6708", "\u0033\u6708", "\u0034\u6708", "\u0035\u6708", "\u0036\u6708", "\u0037\u6708", "\u0038\u6708", "\u0039\u6708", "\u0031\u0030\u6708", "\u0031\u0031\u6708", "\u0031\u0032\u6708");
            DateTimeInfo.ShortWeekDays = new Array("\u65e5", "\u6708", "\u706b", "\u6c34", "\u6728", "\u91d1", "\u571f");
            DateTimeInfo.ShortMonthNames = new Array("\u0031", "\u0032", "\u0033", "\u0034", "\u0035", "\u0036", "\u0037", "\u0038", "\u0039", "\u0031\u0030", "\u0031\u0031", "\u0031\u0032");
            DateTimeInfo.RokuyouTextArray = new Array("\u5148\u52dd", "\u53cb\u5f15", "\u5148\u8ca0", "\u4ecf\u6ec5", "\u5927\u5b89", "\u8d64\u53e3");
            DateTimeInfo.RokuyouTextArrayEn = new Array("Senshou", "Tomobiki", "Senbu", "Butsumetsu", "Taian", "Shakkou");
            DateTimeInfo.DefaultTwoDigitYear = 2029;
            DateTimeInfo.Digits = 2;
            DateTimeInfo.EraYearMax = 99;
            DateTimeInfo.RokuyouMin = new Date(1960, 0, 28);
            DateTimeInfo.RokuyouMax = new Date(2050, 0, 22);
            DateTimeInfo.LunarInfo = new Array(0x0aea6, 0x0ab50, 0x04d60, 0x0aae4, 0x0a570, 0x05270, 0x07263, 0x0d950, 0x06b57, 0x056a0, 0x09ad0, 0x04dd5, 0x04ae0, 0x0a4e0, 0x0d4d4, 0x0d250, 0x0d598, 0x0b540, 0x0d6a0, 0x0195a6, 0x095b0, 0x049b0, 0x0a9b4, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0b756, 0x02b60, 0x095b0, 0x04b75, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06d98, 0x055d0, 0x02b60, 0x096e5, 0x092e0, 0x0c960, 0x0e954, 0x0d4a0, 0x0da50, 0x07552, 0x056c0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5, 0x0a950, 0x0b4a0, 0x1b4a3, 0x0b550, 0x055d9, 0x04ba0, 0x0a5b0, 0x05575, 0x052b0, 0x0a950, 0x0b954, 0x06aa0, 0x0ad50, 0x06b52, 0x04b60, 0x0a6e6, 0x0a570, 0x05270, 0x06a65, 0x0d930, 0x05aa0, 0x0b6a3, 0x096d0, 0x04bd7, 0x04ae0, 0x0a4d0, 0x01d0d6, 0x0d250, 0x0d520, 0x0dd45, 0x0b6a0, 0x096d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0b250, 0x01b255, 0x06d40, 0x0ada0);
            DateTimeInfo.IsValidEraDate = function IsValidEraDate(date) {
                if(date < this.GetEraMin() || date > this.GetEraMax()) {
                    return false;
                }
                return true;
            };
            DateTimeInfo.ConvertToGregorianYear = function ConvertToGregorianYear(era, eraYear, strict) {
                if(era < 0 || era >= this.GetEraCount() || eraYear < 1 || strict && eraYear > this.GetEraYears()[era]) {
                    return -1;
                }
                return this.GetEraDates()[era].getFullYear() + eraYear - 1;
            };
            DateTimeInfo.GetEraDates = function GetEraDates() {
                if(window.eras != undefined) {
                    var eraDates = new Array();
                    for(var i = 0; i < window.eras.length; i++) {
                        var date = new Date(window.eras[i].startDate.replace(/-/g, "/"));
                        eraDates[i] = date;
                    }
                    return eraDates;
                }
                return this.EraDates;
            };
            DateTimeInfo.GetEraNames = function GetEraNames() {
                var eraNames = new Array();
                if(window.eras != undefined) {
                    for(var i = 0; i < window.eras.length; i++) {
                        eraNames[i] = window.eras[i].name;
                    }
                    return eraNames;
                }
                for(var i = 0; i < this.EraCount; i++) {
                    eraNames[i] = this.EraNames[i + 2 * this.EraCount];
                }
                return eraNames;
            };
            DateTimeInfo.GetEraSymbols = function GetEraSymbols() {
                var eraSymbol = new Array();
                if(window.eras != undefined) {
                    for(var i = 0; i < window.eras.length; i++) {
                        eraSymbol[i] = window.eras[i].symbol;
                    }
                    return eraSymbol;
                }
                for(var i = 0; i < this.EraCount; i++) {
                    eraSymbol[i] = this.EraNames[i];
                    ;
                }
                return eraSymbol;
            };
            DateTimeInfo.GetEraAbbreviations = function GetEraAbbreviations() {
                var eraAbbreviation = new Array();
                if(window.eras != undefined) {
                    for(var i = 0; i < window.eras.length; i++) {
                        eraAbbreviation[i] = window.eras[i].abbreviation;
                    }
                    return eraAbbreviation;
                }
                for(var i = 0; i < this.EraCount; i++) {
                    eraAbbreviation[i] = this.EraNames[i + this.EraCount];
                }
                return eraAbbreviation;
            };
            DateTimeInfo.GetEraShortNames = function GetEraShortNames() {
                var eraShortName = new Array();
                if(window.eras != undefined) {
                    for(var i = 0; i < window.eras.length; i++) {
                        eraShortName[i] = window.eras[i].shortcuts.split(',')[1];
                    }
                    return eraShortName;
                }
                for(var i = 0; i < this.EraCount; i++) {
                    eraShortName[i] = this.EraNames[i];
                }
                return eraShortName;
            };
            DateTimeInfo.GetEraShortcuts = function GetEraShortcuts() {
                var eraShortcuts = new Array();
                if(window.eras != undefined) {
                    for(var i = 0; i < window.eras.length; i++) {
                        eraShortcuts[i] = window.eras[i].shortcuts.split(',')[0];
                    }
                    return eraShortcuts;
                }
                for(var i = 0; i < this.EraCount; i++) {
                    eraShortcuts[i] = this.EraKeys[i];
                }
                return eraShortcuts;
            };
            DateTimeInfo.GetEraMax = function GetEraMax() {
                if(window.eras != undefined) {
                    if(window.eras.length > 0) {
                        var date = new Date(window.eras[window.eras.length - 1].startDate.replace(/-/g, "/"));
                        date.setFullYear(date.getFullYear() + 99);
                        return date;
                    }
                }
                return this.EraMax;
            };
            DateTimeInfo.GetEraMin = function GetEraMin() {
                if(window.eras != undefined) {
                    if(window.eras.length > 0) {
                        var date = new Date(window.eras[0].startDate.replace(/-/g, "/"));
                        return date;
                    }
                }
                return this.EraMin;
            };
            DateTimeInfo.GetEraCount = function GetEraCount() {
                if(window.eras != undefined) {
                    return window.eras.length;
                }
                return this.EraCount;
            };
            DateTimeInfo.GetEraYears = function GetEraYears() {
                if(window.eras != undefined) {
                    var eraYears = new Array();
                    for(var i = 1; i < window.eras.length; i++) {
                        var date1 = new Date(window.eras[i - 1].startDate.replace(/-/g, "/"));
                        var date2 = new Date(window.eras[i].startDate.replace(/-/g, "/"));
                        eraYears[i - 1] = date2.getFullYear() - date1.getFullYear() + 1;
                    }
                    eraYears[i - 1] = 99;
                    return eraYears;
                }
                return this.EraYears;
            };
            DateTimeInfo.ConvertToGregorianDate = function ConvertToGregorianDate(era, eraYear, month, day, hour, minute, second, strict) {
                var year = this.ConvertToGregorianYear(era, eraYear, strict);
                if(year < 1 || year > 9999) {
                    return null;
                }
                if(month < 1 || month > 12) {
                    return null;
                }
                var maxdays = this.DaysInMonth(year, month);
                if(day < 1 || day > maxdays) {
                    return null;
                }
                if(hour < 0 || hour > 23) {
                    return null;
                }
                if(minute < 0 || minute > 59) {
                    return null;
                }
                if(second < 0 || second > 59) {
                    return null;
                }
                var dateTime = new Date(year, month - 1, day, hour, minute, second);
                if(strict) {
                    var startDate = this.GetEraDates()[era];
                    var endDate = era + 1 != this.GetEraCount() ? this.AddMilliseconds(this.GetEraDates()[era + 1], -1) : this.GetEraMax();
                    if(dateTime < startDate || dateTime > endDate) {
                        return null;
                    }
                }
                return dateTime;
            };
            DateTimeInfo.String2Date = function String2Date(value) {
                if(value == null || value.Length == 0) {
                    return null;
                }
                var date = new Date(Date.parse(value));
                return date;
            };
            DateTimeInfo.ToString = function ToString(value, length, ch, position) {
                var val = value + "";
                //It is same as String.PadLeft(int, char) in C#.
                if(ch != null) {
                    while(val.length < length) {
                        if(position) {
                            val = val + ch;
                        } else {
                            val = ch + val;
                        }
                    }
                    return val;
                }
                //add the value length times.
                while(val.length < length) {
                    val += value + "";
                }
                return val;
            };
            DateTimeInfo.Date2String = function Date2String(date, isJapan, IsjqDate, IsjqTime) {
                var strDate = "";
                try  {
                    if(isJapan == true) {
                        if(IsjqDate == true) {
                            strDate = date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
                        } else if(IsjqTime == true) {
                            strDate = date.getHours() + ":" + DateTimeInfo.ToString(date.getMinutes(), 2, "0") + ":" + DateTimeInfo.ToString(date.getSeconds(), 2, "0");
                        } else {
                            strDate = date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate() + " " + date.getHours() + ":" + DateTimeInfo.ToString(date.getMinutes(), 2, "0") + ":" + DateTimeInfo.ToString(date.getSeconds(), 2, "0");
                        }
                    } else {
                        if(IsjqDate == true) {
                            strDate = (date.getMonth() + 1) + "/" + date.getDate() + "/" + date.getFullYear();
                        } else if(IsjqTime == true) {
                            strDate = date.getHours() + ":" + DateTimeInfo.ToString(date.getMinutes(), 2, "0") + ":" + DateTimeInfo.ToString(date.getSeconds(), 2, "0");
                        } else {
                            strDate = (date.getMonth() + 1) + "/" + date.getDate() + "/" + date.getFullYear() + " " + date.getHours() + ":" + DateTimeInfo.ToString(date.getMinutes(), 2, "0") + ":" + DateTimeInfo.ToString(date.getSeconds(), 2, "0");
                        }
                    }
                } catch (ex) {
                    strDate = "";
                }
                return strDate;
            };
            DateTimeInfo.Date2Long = function Date2Long(date) {
                try  {
                    return (date.getFullYear() * 100 + date.getMonth() + 1) * 100 + date.getDate();
                } catch (ex) {
                    return 0;
                }
            };
            DateTimeInfo.Date2Number = function Date2Number(date) {
                if(date == null) {
                    return 0;
                }
                return ((((date.getFullYear() * 100 + date.getMonth() + 1) * 100 + date.getDate()) * 100 + date.getHours()) * 100 + date.getMinutes()) * 100 + date.getSeconds();
            };
            DateTimeInfo.Long2Date = function Long2Date(value) {
                return new Date(Math.floor(value / 10000), Math.floor((value % 10000) / 100) - 1, value % 100);
            };
            DateTimeInfo.GetEraDate = function GetEraDate(date) {
                var eraDate = new Object();
                eraDate.era = -1;
                eraDate.eraYear = -1;
                if(!this.IsValidEraDate(date)) {
                    return eraDate;
                }
                for(var i = 0; i < this.GetEraCount(); i++) {
                    var nextDate = i + 1 != this.GetEraCount() ? this.GetEraDates()[i + 1] : this.AddMilliseconds(this.GetEraMax(), 1);
                    if(date < nextDate) {
                        eraDate.era = i;
                        eraDate.eraYear = date.getFullYear() - this.GetEraDates()[i].getFullYear() + 1;
                        break;
                    }
                }
                return eraDate;
            };
            DateTimeInfo.MakeDate = function MakeDate(era, erayear, month, day) {
                var date = new Date();
                date = this.ConvertToGregorianDate(era, erayear, month, day, 0, 0, 0, true);
                if(date == null) {
                    return -1;
                }
                return date;
            };
            DateTimeInfo.GetValidMonthRange = function GetValidMonthRange(era, eraYear) {
                var monthRange = {
                };
                monthRange.min = 1;
                monthRange.max = 12;
                if(era == -1 || eraYear == -1) {
                    return monthRange;
                }
                if(eraYear == 1) {
                    monthRange.min = this.GetEraDates()[era].getMonth() + 1;
                } else if(eraYear == this.EraYears[era] && era < this.EraCount - 1) {
                    monthRange.max = this.AddMilliseconds(this.GetEraDates()[era + 1], -1).getMonth() + 1;
                }
                return monthRange;
            };
            DateTimeInfo.GetValidDayRange = function GetValidDayRange(era, eraYear, month) {
                var dayRange = new Object();
                dayRange.min = 1;
                dayRange.max = this.DaysInMonth(this.ConvertToGregorianYear(era, eraYear, true), month);
                var eraMin = this.GetEraDates()[era];
                var eraMax = era < this.GetEraCount() - 1 ? this.AddMilliseconds(this.GetEraDates()[era + 1], -1) : this.GetEraMax();
                if(era == -1 || eraYear == -1) {
                    return dayRange;
                }
                if(eraYear == 1 && month == eraMin.getMonth() + 1) {
                    dayRange.min = eraMin.getDate();
                } else if(eraYear == this.EraYears[era] && month == eraMax.getMonth() + 1) {
                    dayRange.max = eraMax.getDate();
                }
                return dayRange;
            };
            DateTimeInfo.IsLeapYear = function IsLeapYear(year) {
                if((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
                    return true;
                } else {
                    return false;
                }
            };
            DateTimeInfo.DayOfYear = function DayOfYear(year, month, day) {
                var sum = 0;
                for(var i = 1; i < month; i++) {
                    sum = sum + this.DaysInMonth(year, i);
                }
                sum = sum + day;
                return sum;
            };
            DateTimeInfo.DaysInMonth = function DaysInMonth(year, month) {
                if(month > 12) {
                    year += Math.floor(month / 12);
                    month = month % 12;
                } else if(month < 0) {
                    var zMonth = month * (-1);
                    year -= Math.ceil(zMonth / 12);
                    month = 12 - zMonth % 12;
                }
                switch(month) {
                    case 2:
                        if(this.IsLeapYear(year)) {
                            return 29;
                        } else {
                            return 28;
                        }
                        break;
                    case 4:
                    case 6:
                    case 9:
                    case 11:
                        return 30;
                        break;
                    default:
                        return 31;
                        break;
                }
            };
            DateTimeInfo.Equal = function Equal(date1, date2, strict) {
                if(date1 == null && date2 == null) {
                    return true;
                } else if(date1 == null) {
                    return false;
                } else if(date2 == null) {
                    return false;
                }
                try  {
                    if(!strict) {
                        if(date1.getFullYear() == date2.getFullYear() && date1.getMonth() == date2.getMonth() && date1.getDate() == date2.getDate()) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                    if(date1.getFullYear() == date2.getFullYear() && date1.getMonth() == date2.getMonth() && date1.getDate() == date2.getDate() && date1.getHours() == date2.getHours() && date1.getMinutes() == date2.getMinutes() && date1.getSeconds() == date2.getSeconds()) {
                        return true;
                    } else {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
            };
            DateTimeInfo.YearMonthEqual = function YearMonthEqual(date1, date2) {
                if(date1 == null && date2 == null) {
                    return true;
                } else if(date1 == null) {
                    return false;
                } else if(date2 == null) {
                    return false;
                }
                try  {
                    if(date1.getFullYear() == date2.getFullYear() && date1.getMonth() == date2.getMonth()) {
                        return true;
                    } else {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
            };
            DateTimeInfo.SetDate = function SetDate(year, month, day) {
                var newDate = new Date();
                var maxMonth = 9999 * 12 + 12;
                if(year * 12 + month > maxMonth) {
                    newDate = new Date(9999, 11, 31);
                } else if(year * 12 + month < 100) {
                    newDate = new Date(100, 0, 1);
                } else {
                    var days = this.DaysInMonth(year, month);
                    if(day > days) {
                        day = days;
                    }
                    newDate = new Date(year, month - 1, day);
                }
                return newDate;
            };
            DateTimeInfo.SetFullDate = function SetFullDate(year, month, day) {
                var newDate = new Date();
                newDate.setDate(1);
                var maxMonth = 9999 * 12 + 12;
                var days = this.DaysInMonth(year, month);
                if((month > 0) && (month < 12) && (day > days)) {
                    day = days;
                }
                newDate.setFullYear(year);
                newDate.setMonth(month - 1);
                newDate.setDate(day);
                return newDate;
            };
            DateTimeInfo.SetFullDateByDate = function SetFullDateByDate(date) {
                var newDate = new Date();
                newDate.setDate(1);
                newDate.setFullYear(date.getFullYear());
                newDate.setMonth(date.getMonth());
                newDate.setDate(date.getDate());
                newDate.setHours(0, 0, 0, 0);
                return newDate;
            };
            DateTimeInfo.LYearDays = function LYearDays(y) {
                var i, sum = 348;
                for(i = 0x8000; i > 0x8; i >>= 1) {
                    sum += (this.LunarInfo[y - 1960] & i) ? 1 : 0;
                }
                return (sum + this.leapDays(y));
            };
            DateTimeInfo.leapDays = function leapDays(y) {
                if(this.LeapMonth(y)) {
                    return ((this.LunarInfo[y - 1960] & 0x10000) ? 30 : 29);
                } else {
                    return (0);
                }
            };
            DateTimeInfo.LeapDays = function LeapDays(y) {
                if(this.LeapMonth(y)) {
                    return ((this.LunarInfo[y - 1960] & 0x10000) ? 30 : 29);
                } else {
                    return (0);
                }
            };
            DateTimeInfo.LeapMonth = function LeapMonth(y) {
                return (this.LunarInfo[y - 1960] & 0xf);
            };
            DateTimeInfo.MonthDays = function MonthDays(y, m) {
                return ((this.LunarInfo[y - 1960] & (0x10000 >> m)) ? 30 : 29);
            };
            DateTimeInfo.GetRokuyou = function GetRokuyou(date) {
                if((date - this.RokuyouMin) < 0 || (date - this.RokuyouMax) > 0) {
                    return;
                }
                var i, leap = 0, temp = 0;
                var baseDate = new Date(1960, 0, 28);
                var offset = Math.round((date - baseDate) / 86400000);
                for(i = 1960; i < 2050 && offset > 0; i++) {
                    temp = this.LYearDays(i);
                    offset -= temp;
                }
                if(offset < 0) {
                    offset += temp;
                    i--;
                }
                this.year = i;
                leap = this.LeapMonth(i);
                this.isLeap = false;
                for(i = 1; i < 13 && offset > 0; i++) {
                    if(leap > 0 && i == (leap + 1) && this.isLeap == false) {
                        --i;
                        this.isLeap = true;
                        temp = this.LeapDays(this.year);
                    } else {
                        temp = this.MonthDays(this.year, i);
                    }
                    if(this.isLeap == true && i == (leap + 1)) {
                        this.isLeap = false;
                    }
                    offset -= temp;
                }
                if(offset == 0 && leap > 0 && i == leap + 1) {
                    if(this.isLeap) {
                        this.isLeap = false;
                    } else {
                        this.isLeap = true;
                        --i;
                    }
                }
                if(offset < 0) {
                    offset += temp;
                    --i;
                }
                this.month = i;
                this.day = offset + 1;
                var index = (this.month + this.day - 2) % 6;
                var errorRange1Min = new Date(1996, 6, 15);
                var errorRange1Max = new Date(1996, 7, 13);
                if(this.IsDateInRange(date, errorRange1Min, errorRange1Max)) {
                    index = (6 + index - 1) % 6;
                }
                var errorRange2Min = new Date(1996, 8, 12);
                var errorRange2Max = new Date(1996, 9, 11);
                if(this.IsDateInRange(date, errorRange2Min, errorRange2Max)) {
                    index = (6 + index - 1) % 6;
                }
                var errorRange3Min = new Date(2033, 7, 25);
                var errorRange3Max = new Date(2033, 11, 21);
                if(this.IsDateInRange(date, errorRange3Min, errorRange3Max)) {
                    index = (index + 1) % 6;
                }
                if(this.Equal(date, errorRange1Min)) {
                    index = (6 + index - 1) % 6;
                }
                if(this.Equal(date, errorRange2Min)) {
                    index = (6 + index - 1) % 6;
                }
                var rokuyou;
                //switch (index) {
                //    case 0:
                //        rokuyou = GrapeCity.IM.Rokuyou.Senshou;
                //        break;
                //    case 1:
                //        rokuyou = GrapeCity.IM.Rokuyou.Tomobiki;
                //        break;
                //    case 2:
                //        rokuyou = GrapeCity.IM.Rokuyou.Senbu;
                //        break;
                //    case 3:
                //        rokuyou = GrapeCity.IM.Rokuyou.Butsumetsu;
                //        break;
                //    case 4:
                //        rokuyou = GrapeCity.IM.Rokuyou.Taian;
                //        break;
                //    case 5:
                //        rokuyou = GrapeCity.IM.Rokuyou.Shakkou;
                //        break;
                //    default:
                //        break;
                //}
                return rokuyou;
            };
            DateTimeInfo.IsDateInRange = function IsDateInRange(dt, min, max) {
                var dtYear = dt.getYear();
                var minYear = min.getYear();
                var maxYear = max.getYear();
                var dtMonth = dt.getMonth();
                var minMonth = min.getMonth();
                var maxMonth = max.getMonth();
                var dtDay = dt.getDate();
                var minDay = min.getDate();
                var maxDay = max.getDate();
                var dtValue = dtYear * 10000 + dtMonth * 100 + dtDay;
                var minValue = minYear * 10000 + minMonth * 100 + minDay;
                var maxValue = maxYear * 10000 + maxMonth * 100 + maxDay;
                return dtValue >= minValue && dtValue <= maxValue;
            };
            DateTimeInfo.GetRokuyouText = function GetRokuyouText(rokuyou) {
                var rokuyouArray = new Array();
                //if (GrapeCity.IM.Localization.Region == "ja") {
                rokuyouArray = this.RokuyouTextArray.slice(0);
                //}
                //else {
                //    rokuyouArray = this.RokuyouTextArrayEn.slice(0);
                //}
                switch(rokuyou) {
                    default:
                        //case GrapeCity.IM.Rokuyou.None:
                        //    return "";
                        //    break;
                        //case GrapeCity.IM.Rokuyou.Senshou:
                        //    return rokuyouArray[0];
                        //    break;
                        //case GrapeCity.IM.Rokuyou.Tomobiki:
                        //    return rokuyouArray[1];
                        //    break;
                        //case GrapeCity.IM.Rokuyou.Senbu:
                        //    return rokuyouArray[2];
                        //    break;
                        //case GrapeCity.IM.Rokuyou.Butsumetsu:
                        //    return rokuyouArray[3];
                        //    break;
                        //case GrapeCity.IM.Rokuyou.Taian:
                        //    return rokuyouArray[4];
                        //    break;
                        //case GrapeCity.IM.Rokuyou.Shakkou:
                        //    return rokuyouArray[5];
                        //    break;
                        return "";
                        break;
                }
            };
            DateTimeInfo.DaysInSpecialWeek = function DaysInSpecialWeek(year, month, weekFlay) {
                var selections = new Array();
                var days = this.DaysInMonth(year, month + 1);
                var date = new Date(year, month, 1);
                var firstDateOfWeekTitle;
                //Get the firstDateOfWeekTitle, then break
                for(var i = 1; i <= days; i++) {
                    date.setDate(i);
                    if(date.getDay() == weekFlay) {
                        var selectedDate = new Date(year, month, i);
                        selections.push(selectedDate);
                        firstDateOfWeekTitle = i;
                        break;
                    }
                }
                firstDateOfWeekTitle += 7;
                while(firstDateOfWeekTitle <= days) {
                    date.setDate(firstDateOfWeekTitle);
                    var followSelectedDate = new Date(year, month, firstDateOfWeekTitle);
                    selections.push(followSelectedDate);
                    firstDateOfWeekTitle += 7;
                }
                return selections;
            };
            DateTimeInfo.GetDaysByFirstWeekday = function GetDaysByFirstWeekday(firstWeekday) {
                var days = new Array();
                days.push(firstWeekday);
                var date = new Date(firstWeekday);
                while(date.getDate() + 7 <= this.DaysInMonth(firstWeekday.getFullYear(), firstWeekday.getMonth() + 1)) {
                    date = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 7);
                    days.push(date);
                }
                return days;
            };
            DateTimeInfo.AddMilliseconds = function AddMilliseconds(date, msec) {
                var newDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
                newDate.setMilliseconds(newDate.getMilliseconds() + msec);
                return new Date(newDate.valueOf());
            };
            DateTimeInfo.GetWeekIndexByDate = function GetWeekIndexByDate(date) {
                return Math.floor(date.getDate() / 7);
            };
            return DateTimeInfo;
        })();
        input.DateTimeInfo = DateTimeInfo;        
        /** @ignore */
        var wijDateTextFormatter = (function () {
            function wijDateTextFormatter(inputWidget, format, isDisplayFormat) {
                this.inputWidget = inputWidget;
                this.maskPartsCount = 0;
                this.isDisplayFormat = true;
                this.pattern = 'M/d/yyyy';
                this.descriptors = new Array(0);
                this.desPostions = new Array(0);
                this.fields = new Array(0);
                this.isDisplayFormat = isDisplayFormat;
                this._setFormat(format);
            }
            wijDateTextFormatter.prototype._parseFormat = function (pattern) {
                var descriptors = [];
                var curPattern = '', prevCh = '', isBegin = false, liternalNext = false, i, ch;
                for(i = 0; i < pattern.length; i++) {
                    ch = pattern.charAt(i);
                    if(liternalNext) {
                        descriptors.push(this.createDescriptor(-1, ch));
                        curPattern = '';
                        liternalNext = false;
                        continue;
                    }
                    if(ch === '\\') {
                        liternalNext = true;
                        if(curPattern.length > 0) {
                            if(!this.handlePattern(curPattern, descriptors)) {
                                descriptors.push(this.createDescriptor(-1, prevCh));
                            }
                            curPattern = '';
                        }
                        continue;
                    }
                    if(ch === '\'') {
                        if(isBegin) {
                            isBegin = false;
                            curPattern = '';
                        } else {
                            isBegin = true;
                            if(curPattern.length > 0) {
                                if(!this.handlePattern(curPattern, descriptors)) {
                                    descriptors.push(this.createDescriptor(-1, prevCh));
                                }
                                curPattern = '';
                            }
                        }
                        continue;
                    }
                    if(isBegin) {
                        descriptors.push(this.createDescriptor(-1, ch));
                        curPattern = '';
                        continue;
                    }
                    if(!i) {
                        prevCh = ch;
                    }
                    if(prevCh !== ch && curPattern.length > 0) {
                        if(!this.handlePattern(curPattern, descriptors)) {
                            descriptors.push(this.createDescriptor(-1, prevCh));
                        }
                        curPattern = '';
                    }
                    curPattern += ch;
                    prevCh = ch;
                }
                if(curPattern.length > 0) {
                    if(!this.handlePattern(curPattern, descriptors)) {
                        descriptors.push(this.createDescriptor(-1, prevCh));
                    }
                }
                return descriptors;
            };
            wijDateTextFormatter.prototype._parseFormatToPattern = function (format) {
                var cf = this.inputWidget._getCulture().calendars.standard, pattern = cf.patterns.d;
                if(format.length <= 1) {
                    switch(format) {
                        case "":
                        case "d":
                            // ShortDatePattern
                            pattern = cf.patterns.d;
                            break;
                        case "D":
                            // LongDatePattern
                            pattern = cf.patterns.D;
                            break;
                        case "f":
                            // Full date and time (long date and short time)
                            pattern = cf.patterns.D + " " + cf.patterns.t;
                            break;
                        case "F":
                            // Full date and time (long date and long time)
                            pattern = cf.patterns.D + " " + cf.patterns.T;
                            break;
                        case "g":
                            // General (short date and short time)
                            pattern = cf.patterns.d + " " + cf.patterns.t;
                            break;
                        case "G":
                            // General (short date and long time)
                            pattern = cf.patterns.d + " " + cf.patterns.T;
                            break;
                        case "m":
                            // MonthDayPattern
                            pattern = cf.patterns.M;
                            break;
                        case "M":
                            // monthDayPattern
                            pattern = cf.patterns.M;
                            break;
                        case "s":
                            // SortableDateTimePattern
                            pattern = cf.patterns.S;
                            break;
                        case "t":
                            // shortTimePattern
                            pattern = cf.patterns.t;
                            break;
                        case "T":
                            // LongTimePattern
                            pattern = cf.patterns.T;
                            break;
                        case "u":
                            // UniversalSortableDateTimePattern
                            pattern = cf.patterns.S;
                            break;
                        case "U":
                            // Full date and time (long date and long time) using universal time
                            pattern = cf.patterns.D + " " + cf.patterns.T;
                            break;
                        case "y":
                            // YearMonthPattern
                            pattern = cf.patterns.Y;
                            break;
                        case "Y":
                            // yearMonthPattern
                            pattern = cf.patterns.Y;
                            break;
                        case "r":
                            // RFC1123Pattern
                                                    case "R":
                            pattern = "ddd, dd MMM yyyy HH:mm:ss G\\M\\T";
                            break;
                    }
                } else {
                    pattern = format;
                }
                return pattern;
            };
            wijDateTextFormatter.prototype.createDescriptor = function (t, liternal) {
                var desc = null, id = this.maskPartsCount++;
                switch(t) {
                    case -1:
                        desc = new _dateDescriptor(this, id);
                        desc.liternal = liternal;
                        break;
                    case 20:
                        desc = new _dateDescriptor20(this, id);
                        break;
                    case 25:
                        desc = new _dateDescriptor25(this, id);
                        break;
                    case 26:
                        desc = new _dateDescriptor26(this, id);
                        break;
                    case 27:
                        desc = new _dateDescriptor27(this, id);
                        break;
                    case 30:
                        desc = new _dateDescriptor30(this, id);
                        break;
                    case 31:
                        desc = new _dateDescriptor31(this, id);
                        break;
                    case 100:
                        desc = new _dateDescriptor100(this, id);
                        break;
                    case 101:
                        desc = new _dateDescriptor101(this, id);
                        break;
                    case 10:
                        desc = new _dateDescriptor10(this, id);
                        break;
                    case 1:
                        desc = new _dateDescriptor1(this, id);
                        break;
                    case 2:
                        desc = new _dateDescriptor2(this, id);
                        break;
                    case 45:
                        desc = new _dateDescriptor45(this, id);
                        break;
                    case 46:
                        desc = new _dateDescriptor46(this, id);
                        break;
                    case 47:
                        desc = new _dateDescriptor47(this, id);
                        break;
                    case 48:
                        desc = new _dateDescriptor48(this, id);
                        break;
                    case 250:
                        desc = new _dateDescriptor250(this, id);
                        break;
                    case 251:
                        desc = new _dateDescriptor251(this, id);
                        break;
                    case 50:
                        desc = new _dateDescriptor50(this, id);
                        break;
                    case 51:
                        desc = new _dateDescriptor51(this, id);
                        break;
                    case 60:
                        desc = new _dateDescriptor60(this, id);
                        break;
                    case 61:
                        desc = new _dateDescriptor61(this, id);
                        break;
                    case 70:
                        desc = new _dateDescriptor70(this, id);
                        break;
                    case 71:
                        desc = new _dateDescriptor71(this, id);
                        break;
                    case 72:
                        desc = new _dateDescriptor72(this, id);
                        break;
                    case 73:
                        desc = new _dateDescriptor73(this, id);
                        break;
                    case 74:
                        desc = new _dateDescriptor74(this, id);
                        break;
                    case 75:
                        desc = new _dateDescriptor75(this, id);
                        break;
                    case 80:
                        desc = new _dateDescriptor80(this, id);
                        break;
                    default:
                        break;
                }
                return desc;
            };
            wijDateTextFormatter.prototype.handlePattern = function (p, descriptors) {
                var reg = new RegExp('y{3,4}'), suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(10));
                    return true;
                }
                reg = new RegExp('y{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(2));
                    return true;
                }
                reg = new RegExp('y{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(1));
                    return true;
                }
                reg = new RegExp('d{4,4}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(101));
                    return true;
                }
                reg = new RegExp('d{3,3}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(100));
                    return true;
                }
                reg = new RegExp('d{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(30));
                    return true;
                }
                reg = new RegExp('d{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(31));
                    return true;
                }
                reg = new RegExp('M{4,4}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(27));
                    return true;
                }
                reg = new RegExp('M{3,3}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(26));
                    return true;
                }
                reg = new RegExp('M{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(20));
                    return true;
                }
                reg = new RegExp('M{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(25));
                    return true;
                }
                reg = new RegExp('h{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(46));
                    return true;
                }
                reg = new RegExp('h{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(45));
                    return true;
                }
                reg = new RegExp('H{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(48));
                    return true;
                }
                reg = new RegExp('H{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(47));
                    return true;
                }
                reg = new RegExp('m{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(50));
                    return true;
                }
                reg = new RegExp('m{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(51));
                    return true;
                }
                reg = new RegExp('s{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(60));
                    return true;
                }
                reg = new RegExp('s{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(61));
                    return true;
                }
                reg = new RegExp('t{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(251));
                    return true;
                }
                reg = new RegExp('t{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(250));
                    return true;
                }
                reg = new RegExp('e{2,10}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(71));
                    return true;
                }
                reg = new RegExp('e{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(70));
                    return true;
                }
                reg = new RegExp('g{3,10}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(74));
                    return true;
                }
                reg = new RegExp('g{2,2}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(73));
                    return true;
                }
                reg = new RegExp('g{1,1}');
                suc = reg.test(p);
                if(suc) {
                    descriptors.push(this.createDescriptor(72));
                    return true;
                }
                if(this.isDisplayFormat) {
                    reg = new RegExp('E{1,10}');
                    suc = reg.test(p);
                    if(suc) {
                        descriptors.push(this.createDescriptor(75));
                        return true;
                    }
                    reg = new RegExp('A{1,1}');
                    suc = reg.test(p);
                    if(suc) {
                        descriptors.push(this.createDescriptor(80));
                        return true;
                    }
                }
                return false;
            };
            wijDateTextFormatter.prototype.daysInMonth = function (m, y) {
                m = m - 1;
                var d = new Date(y, ++m, 1, -1).getDate();
                return d;
            };
            wijDateTextFormatter.prototype._isDigitString = function (s) {
                s = $.trim(s);
                if(s.length === 0) {
                    return true;
                }
                var c = s.charAt(0), f, t;
                if(c === '+' || c === '-') {
                    s = s.substr(1);
                    s = $.trim(s);
                }
                if(s.length === 0) {
                    return true;
                }
                try  {
                    f = parseFloat(s);
                    t = f.toString();
                    return t === s;
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype._internalSetDate = function (date) {
                if(this.inputWidget) {
                    this.inputWidget._internalSetDate(date);
                }
            };
            wijDateTextFormatter.prototype._isValidDate = function (dt) {
                return this.inputWidget._isValidDate(dt);
            };
            wijDateTextFormatter.prototype._setFormat = function (format) {
                var culture = this.inputWidget._getCulture();
                if(culture == null) {
                    return;
                }
                this.pattern = this._parseFormatToPattern(format);
                this.descriptors = this._parseFormat(this.pattern);
                this.fields = $.grep(this.descriptors, function (d) {
                    return d.type !== -1;
                });
            };
            wijDateTextFormatter.prototype._isEraFormatExist = function () {
                for(var i = 0; i < this.descriptors.length; i++) {
                    if(this.descriptors[i].type >= 70 && this.descriptors[i].type <= 75) {
                        return true;
                    }
                }
                return false;
            };
            wijDateTextFormatter.prototype.getDate = function () {
                return (!!this.inputWidget) ? new Date(this.inputWidget._safeGetDate(true).getTime()) : undefined;
            };
            wijDateTextFormatter.prototype.setDate = function (value) {
                if(this.inputWidget) {
                    this.inputWidget._setData(value);
                }
            };
            wijDateTextFormatter.prototype.getYear = function () {
                return this.getDate().getFullYear();
            };
            wijDateTextFormatter.prototype.setYear = function (val, resultObj, chkBounds) {
                try  {
                    if(resultObj && resultObj.isfullreset) {
                        resultObj.offset = 1;
                        val = '1970';
                    }
                    if(typeof val === 'string') {
                        if(!this._isDigitString(val)) {
                            return false;
                        }
                    }
                    val = val * 1;
                    var o = this.inputWidget.options, minYear = 1, maxYear = 9999, currentDate, testDate, mmm;
                    if(chkBounds) {
                        if(o.minDate) {
                            minYear = Math.max(minYear, o.minDate.getFullYear());
                        }
                        if(o.maxDate) {
                            maxYear = Math.min(maxYear, o.maxDate.getFullYear());
                        }
                    }
                    if(resultObj && resultObj.isreset) {
                        val = minYear;
                    }
                    if(val < minYear) {
                        val = minYear;
                    }
                    if(val > maxYear) {
                        val = maxYear;
                    }
                    currentDate = this.getDate();
                    testDate = new Date(currentDate.getTime());
                    testDate.setFullYear(val);
                    if(this._isValidDate(testDate)) {
                        mmm = this.daysInMonth(this.getMonth(), this.getYear());
                        if(mmm === currentDate.getDate()) {
                            testDate = new Date(currentDate.getTime());
                            testDate.setDate(1);
                            testDate.setFullYear(val);
                            //mmm = this.daysInMonth((testDate.getMonth() + 1),
                            //   testDate.getFullYear());
                            testDate.setDate(mmm);
                            if(this._isValidDate(testDate)) {
                                this._internalSetDate(testDate);
                                return true;
                            } else {
                                return false;
                            }
                        }
                        currentDate.setFullYear(val);
                        this._internalSetDate(currentDate);
                        return true;
                    } else {
                        if(resultObj && resultObj.isreset) {
                            currentDate.setFullYear(1);
                            this._internalSetDate(currentDate);
                            return true;
                        }
                        return false;
                    }
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype.getMonth = function () {
                return (this.getDate().getMonth() + 1);
            };
            wijDateTextFormatter.prototype.setMonth = function (val, allowChangeOtherParts, resultObj) {
                try  {
                    if(resultObj && resultObj.isfullreset) {
                        val = '1';
                    }
                    val = val * 1;
                    var currentDate = this.getDate(), mmm, testDate;
                    if(typeof (allowChangeOtherParts) !== 'undefined' && !allowChangeOtherParts) {
                        if(val > 12 || val < 1) {
                            if(resultObj && resultObj.isreset) {
                                val = 1;
                            } else {
                                return false;
                            }
                        }
                    }
                    mmm = this.daysInMonth(this.getMonth(), this.getYear());
                    if(mmm === this.getDate().getDate()) {
                        testDate = new Date(currentDate.getTime());
                        testDate.setDate(1);
                        testDate.setMonth(val - 1);
                        mmm = this.daysInMonth((testDate.getMonth() + 1), testDate.getFullYear());
                        testDate.setDate(mmm);
                        if(this._isValidDate(testDate)) {
                            this._internalSetDate(testDate);
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        testDate = new Date(currentDate.getTime());
                        testDate.setMonth(val - 1);
                        if(this._isValidDate(testDate)) {
                            this._internalSetDate(testDate);
                            return true;
                        } else {
                            return false;
                        }
                    }
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype.getHours = function () {
                return this.getDate().getHours();
            };
            wijDateTextFormatter.prototype.setHours = function (val, allowChangeOtherParts) {
                try  {
                    val = val * 1;
                    if(typeof (allowChangeOtherParts) !== 'undefined' && !allowChangeOtherParts) {
                        if(val > 24) {
                            return false;
                        }
                    }
                    var testDate = new Date(this.getDate().getTime());
                    testDate.setHours(val);
                    if(this._isValidDate(testDate)) {
                        this._internalSetDate(testDate);
                        return true;
                    } else {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype.getMinutes = function () {
                return this.getDate().getMinutes();
            };
            wijDateTextFormatter.prototype.setMinutes = function (val, allowChangeOtherParts) {
                try  {
                    val = val * 1;
                    if(typeof (allowChangeOtherParts) !== 'undefined' && !allowChangeOtherParts) {
                        if(val > 60) {
                            return false;
                        }
                    }
                    var testDate = new Date(this.getDate().getTime());
                    testDate.setMinutes(val);
                    if(this._isValidDate(testDate)) {
                        this._internalSetDate(testDate);
                        return true;
                    } else {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype.getSeconds = function () {
                return this.getDate().getSeconds();
            };
            wijDateTextFormatter.prototype.setSeconds = function (val, allowChangeOtherParts) {
                try  {
                    val = val * 1;
                    if(typeof (allowChangeOtherParts) !== 'undefined' && !allowChangeOtherParts) {
                        if(val > 60) {
                            return false;
                        }
                    }
                    var testDate = new Date(this.getDate().getTime());
                    testDate.setSeconds(val);
                    if(this._isValidDate(testDate)) {
                        this._internalSetDate(testDate);
                        return true;
                    } else {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype.getDayOfMonth = function () {
                return this.getDate().getDate();
            };
            wijDateTextFormatter.prototype.setDayOfMonth = function (val, allowChangeOtherParts, resultObj) {
                try  {
                    if(resultObj && resultObj.isfullreset) {
                        return this.setDayOfMonth(1, allowChangeOtherParts);
                    }
                    var currentDate = this.getDate(), mmm, testDate;
                    val = val * 1;
                    if(typeof (allowChangeOtherParts) !== 'undefined' && !allowChangeOtherParts) {
                        mmm = this.daysInMonth(this.getMonth(), this.getYear());
                        if(val > mmm || val < 1) {
                            if(resultObj && resultObj.isreset) {
                                return this.setDayOfMonth(1, allowChangeOtherParts, resultObj);
                            }
                            return false;
                        }
                    }
                    testDate = new Date(currentDate.getTime());
                    testDate.setDate(val);
                    if(this._isValidDate(testDate)) {
                        this._internalSetDate(testDate);
                        return true;
                    } else {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype.getDayOfWeek = function () {
                return (this.getDate().getDay() + 1);
            };
            wijDateTextFormatter.prototype.setDayOfWeek = function (val) {
                try  {
                    val = val * 1;
                    var aDif = val - this.getDayOfWeek();
                    return this.setDayOfMonth(this.getDayOfMonth() + aDif, true);
                } catch (e) {
                    return false;
                }
            };
            wijDateTextFormatter.prototype._getCulture = function () {
                return this.inputWidget._getCulture();
            };
            wijDateTextFormatter.prototype.findAlikeArrayItemIndex = function (arr, txt) {
                var index = -1, pos = 99999, i, k;
                for(i = 0; i < arr.length; i++) {
                    k = arr[i].toLowerCase().indexOf(txt.toLowerCase());
                    if(k !== -1 && k < pos) {
                        pos = k;
                        index = i;
                    }
                }
                return index;
            };
            wijDateTextFormatter.prototype.toString = function () {
                if(this._isEraFormatExist()) {
                    if(this.inputWidget.options.date != null) {
                        var minDate = this.inputWidget._getRealEraMinDate();
                        var maxDate = this.inputWidget._getRealEraMaxDate();
                        if(this.inputWidget.options.date < minDate || this.inputWidget.options.date > maxDate) {
                            return "";
                        }
                    }
                }
                var s = '', l = 0, i, txt, j;
                this.desPostions = new Array(0);
                for(i = 0; i < this.descriptors.length; i++) {
                    this.descriptors[i].startIndex = s.length;
                    txt = '' || this.descriptors[i].getText();
                    s += txt;
                    for(j = 0; j < txt.length; j++) {
                        this.desPostions.push({
                            desc: this.descriptors[i],
                            pos: j,
                            text: txt,
                            length: txt.length
                        });
                        l++;
                        if(this.desPostions.length !== l) {
                            throw 'Fatal Error !!!!!!!!!!!!!!!';
                        }
                    }
                }
                return s;
            };
            return wijDateTextFormatter;
        })();
        input.wijDateTextFormatter = wijDateTextFormatter;        
        ;
        //#region format library
        var wijInputDateImpl = (function () {
            function wijInputDateImpl(options) {
                this.options = options;
                options.format = options.format || "M/d/yyyy";
                options.amDesignator = options.amDesignator || "";
                options.pmDesignator = options.pmDesignator || "";
                if(options.hour12As0 === undefined) {
                    options.hour12As0 = false;
                }
                if(options.midnightAs0 === undefined) {
                    options.midnightAs0 = true;
                }
            }
            wijInputDateImpl.prototype._getInnerIncrement = function () {
                return 1;
            };
            wijInputDateImpl.prototype._getCulture = function () {
                return Globalize.findClosestCulture(this.options.culture);
            };
            wijInputDateImpl.prototype._getRealEraMaxDate = function () {
                if(this.options.maxDate) {
                    return DateTimeInfo.GetEraMax() < this.options.maxDate ? DateTimeInfo.GetEraMax() : this.options.maxDate;
                }
                return DateTimeInfo.GetEraMax();
            };
            wijInputDateImpl.prototype._getRealEraMinDate = function () {
                if(this.options.minDate) {
                    return DateTimeInfo.GetEraMin() > this.options.minDate ? DateTimeInfo.GetEraMin() : this.options.minDate;
                }
                return DateTimeInfo.GetEraMin();
            };
            wijInputDateImpl.prototype._safeGetDate = function (ignoreCheckRange) {
                var date = this.options.date;
                if(date == null) {
                    date = new Date();
                }
                if(!ignoreCheckRange) {
                    date = this._checkRange(date);
                }
                return date;
            };
            wijInputDateImpl.prototype._safeSetDate = function (date, ignoreCheckRange) {
                var cache = date;
                if(!ignoreCheckRange) {
                    date = this._checkRange(date);
                }
                if(isNaN(date)) {
                    date = cache;
                }
                this.options.date = date;
                return true;
            };
            wijInputDateImpl.prototype._getAllowSpinLoop = function () {
                return false;
            };
            wijInputDateImpl.prototype._getRealMinDate = function () {
                if(this.options.minDate) {
                    return this.options.minDate;
                }
                var minDate = new Date(1, 0, 1, 0, 0, 0);
                minDate.setFullYear(1);
                return minDate;
            };
            wijInputDateImpl.prototype._getRealMaxDate = function () {
                return this.options.maxDate ? this.options.maxDate : new Date(9999, 11, 31, 23, 59, 59);
            };
            wijInputDateImpl.prototype._setData = function (val) {
                this.options.date = val;
            };
            wijInputDateImpl.prototype._isValidDate = function (date, chkBounds) {
                if(date === undefined) {
                    return false;
                }
                if(isNaN(date)) {
                    return false;
                }
                if(date.getFullYear() < 1 || date.getFullYear() > 9999) {
                    return false;
                }
                if(chkBounds) {
                    if(this.options.minDate) {
                        if(date < this.options.minDate) {
                            return false;
                        }
                    }
                    if(this.options.maxDate) {
                        if(date > this.options.maxDate) {
                            return false;
                        }
                    }
                }
                return true;
            };
            wijInputDateImpl.prototype._getInnerAmDesignator = function () {
                return this.options.amDesignator == "" ? this._getStandardAMPM("AM") : this.options.amDesignator;
            };
            wijInputDateImpl.prototype._getInnerPmDesignator = function () {
                return this.options.pmDesignator == "" ? this._getStandardAMPM("PM") : this.options.pmDesignator;
            };
            wijInputDateImpl.prototype.isFocused = function () {
                return false;
            };
            wijInputDateImpl.prototype._internalSetDate = function (date) {
            };
            wijInputDateImpl.prototype._checkRange = function (date) {
                if(date) {
                    if(this.options.minDate && date < this.options.minDate) {
                        date = new Date(Math.max(this.options.minDate.valueOf(), date.valueOf()));
                    }
                    if(this.options.maxDate && date > this.options.maxDate) {
                        date = new Date(Math.min(this.options.maxDate.valueOf(), date.valueOf()));
                    }
                }
                return date;
            };
            wijInputDateImpl.prototype._getStandardAMPM = function (value) {
                var culture = this._getCulture();
                if(culture && culture.calendar) {
                    var tmp = culture.calendars.standard[value];
                    if(tmp) {
                        return tmp[0];
                    }
                }
                return value;
            };
            return wijInputDateImpl;
        })();
        input.wijInputDateImpl = wijInputDateImpl;        
        function dateFormatter(date, format, options) {
            if(!(date instanceof Date)) {
                return "";
            }
            if(!format) {
                format = 'd';
            }
            if(!options) {
                if(typeof format === "string") {
                    //$.wijinputcore.format(new Date(2013,8,12), "yyyy/MM/dd");
                    options = {
                    };
                } else {
                    //$.wijinputcore.format(new Date(2013, 8, 12), { format: "yyyy/MM/dd" });
                    options = format;
                }
            }
            if(typeof format === "string") {
                //$.wijinputcore.format(new Date(2013, 8, 12), "yyyy/MM/dd", { culture: "ja-JP" });
                options.format = format;
            }
            options.date = date;
            var wijInputDate = new wijInputDateImpl(options);
            var _formatter = new wijDateTextFormatter(wijInputDate, options.format, true);
            return _formatter.toString();
        }
        var $ = jQuery;
        $.wijinputcore = $.wijinputcore || {
        };
        $.wijinputcore.formatdate = $.wijinputcore.formatdate || dateFormatter;
        //#endregion
        //#region parse library
        function dateParser(value, format, culture) {
            if(Globalize.findClosestCulture(format)) {
                culture = format;
                format = undefined;
            }
            var cf = Globalize.findClosestCulture(culture).calendars.standard, pattern = cf.patterns.d;
            if(format) {
                if(format.length <= 1) {
                    pattern = parseShortPattern(format, cf.patterns);
                } else {
                    pattern = format;
                }
            } else {
                pattern = cf.patterns.d;
            }
            var wijInputDate = new wijInputDateImpl({
            });
            var _formatter = new wijDateTextFormatter(wijInputDate, pattern, true);
            if(hasEraYear(_formatter.descriptors)) {
                return parseEraDate(value, _formatter, cf);
            } else {
                return Globalize.parseDate(value, pattern, culture);
            }
        }
        function hasEraYear(descriptors) {
            for(var i = 0; i < descriptors.length; i++) {
                if(descriptors[i].type === DescriptorType.EraYear || descriptors[i].type === DescriptorType.TwoEraYear || descriptors[i].type === DescriptorType.EraName || descriptors[i].type === DescriptorType.TwoEraName || descriptors[i].type === DescriptorType.ThreeEraName || descriptors[i].type === DescriptorType.EraYearBig) {
                    return true;
                }
            }
            return false;
        }
        function parseEraDate(value, _formatter, cultureFormat) {
            var ch = "", chs = "", charIndex = 0;
            var era = 0, eraYear = 1, month = 1, date = 1, hour = 0, minute = 0, second = 0;
            var isNextReachSeparator = function () {
                return (charIndex < value.length && i + 1 < _formatter.descriptors.length && _formatter.descriptors[i + 1].type === DescriptorType.liternal && value.charAt(charIndex) !== (_formatter.descriptors[i + 1]).liternal || i === _formatter.descriptors.length - 1 && charIndex + 1 <= value.length);
            };
            for(var i = 0; i < _formatter.descriptors.length; i++) {
                var breakToNextDesc = false;
                for(; charIndex < value.length; ) {
                    ch = value.charAt(charIndex++);
                    chs += ch;
                    for(var j = 0; j < DateTimeInfo.GetEraCount(); j++) {
                        var isMatched_g = chs.toLocaleLowerCase() === DateTimeInfo.GetEraShortNames()[j].toLowerCase() && _formatter.descriptors[i].type === DescriptorType.EraName;
                        var isMatched_gg = chs.toLocaleLowerCase() === DateTimeInfo.GetEraAbbreviations()[j].toLowerCase() && _formatter.descriptors[i].type === DescriptorType.TwoEraName;
                        var isMatched_ggg = chs.toLocaleLowerCase() === DateTimeInfo.GetEraNames()[j].toLowerCase() && _formatter.descriptors[i].type === DescriptorType.ThreeEraName;
                        if(isMatched_g || isMatched_gg || isMatched_ggg) {
                            era = j;
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        }
                    }
                    if(breakToNextDesc) {
                        break;
                    }
                    if(_formatter.descriptors[i].type === DescriptorType.liternal && (_formatter.descriptors[i]).liternal === chs) {
                        chs = "";
                        break;
                    }
                    switch(_formatter.descriptors[i].type) {
                        case DescriptorType.EraYear:
                        case DescriptorType.TwoEraYear:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            eraYear = parseInt(chs, 10);
                            if(isNaN(eraYear)) {
                                eraYear = 1;
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.EraYearBig:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            if(chs === '\u5143') {
                                eraYear = 1;
                            } else {
                                eraYear = parseInt(chs, 10);
                                if(isNaN(eraYear)) {
                                    eraYear = 1;
                                }
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.TwoDigitMonth:
                        case DescriptorType.Month:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            month = parseInt(chs, 10);
                            if(isNaN(month)) {
                                month = 1;
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.AbbreviatedMonthNames:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            for(var m = 0; m < cultureFormat.months.namesAbbr.length; m++) {
                                if(chs.toLocaleLowerCase() === cultureFormat.months.namesAbbr[m]) {
                                    month = m + 1;
                                    chs = "";
                                    break;
                                }
                            }
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.MonthNames:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            for(var k = 0; k < cultureFormat.months.names.length; k++) {
                                if(chs.toLocaleLowerCase() === cultureFormat.months.names[k]) {
                                    month = k + 1;
                                    chs = "";
                                    break;
                                }
                            }
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.TwoDigityDayOfMonth:
                        case DescriptorType.DayOfMonth:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            date = parseInt(chs, 10);
                            if(isNaN(date)) {
                                date = 1;
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.h:
                        case DescriptorType.hh:
                        case DescriptorType.H:
                        case DescriptorType.HH:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            hour = parseInt(chs, 10);
                            if(isNaN(hour)) {
                                hour = 1;
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.m:
                        case DescriptorType.mm:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            minute = parseInt(chs, 10);
                            if(isNaN(minute)) {
                                minute = 1;
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.s:
                        case DescriptorType.ss:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            second = parseInt(chs, 10);
                            if(isNaN(second)) {
                                second = 1;
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.ShortAmPm:
                        case DescriptorType.AmPm:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            for(var l = 0; l < cultureFormat.PM.length; l++) {
                                if(chs.toLocaleLowerCase() === cultureFormat.PM[l]) {
                                    hour += 12;
                                    break;
                                }
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        case DescriptorType.OneDigitYear:
                        case DescriptorType.TwoDigitYear:
                        case DescriptorType.FourDigitYear:
                        case DescriptorType.AbbreviatedDayNames:
                        case DescriptorType.DayNames:
                        case DescriptorType.AD:
                            if(isNextReachSeparator()) {
                                break;
                            }
                            chs = "";
                            breakToNextDesc = true;
                            break;
                        default:
                    }
                    if(breakToNextDesc) {
                        break;
                    }
                }
            }
            return DateTimeInfo.ConvertToGregorianDate(era, eraYear, month, date, hour, minute, second, false);
        }
        function parseShortPattern(shortPattern, culturePatterns) {
            var pattern = shortPattern;
            if(shortPattern && shortPattern.length <= 1) {
                switch(shortPattern) {
                    case "":
                    case "d":
                        // ShortDatePattern
                        pattern = culturePatterns.patterns.d;
                        break;
                    case "D":
                        // LongDatePattern
                        pattern = culturePatterns.patterns.D;
                        break;
                    case "f":
                        // Full date and time (long date and short time)
                        pattern = culturePatterns.patterns.D + " " + culturePatterns.patterns.t;
                        break;
                    case "F":
                        // Full date and time (long date and long time)
                        pattern = culturePatterns.patterns.D + " " + culturePatterns.patterns.T;
                        break;
                    case "g":
                        // General (short date and short time)
                        pattern = culturePatterns.patterns.d + " " + culturePatterns.patterns.t;
                        break;
                    case "G":
                        // General (short date and long time)
                        pattern = culturePatterns.patterns.d + " " + culturePatterns.patterns.T;
                        break;
                    case "m":
                        // MonthDayPattern
                        pattern = culturePatterns.patterns.M;
                        break;
                    case "M":
                        // monthDayPattern
                        pattern = culturePatterns.patterns.M;
                        break;
                    case "s":
                        // SortableDateTimePattern
                        pattern = culturePatterns.patterns.S;
                        break;
                    case "t":
                        // shortTimePattern
                        pattern = culturePatterns.patterns.t;
                        break;
                    case "T":
                        // LongTimePattern
                        pattern = culturePatterns.patterns.T;
                        break;
                    case "u":
                        // UniversalSortableDateTimePattern
                        pattern = culturePatterns.patterns.S;
                        break;
                    case "U":
                        // Full date and time (long date and long time) using universal time
                        pattern = culturePatterns.patterns.D + " " + culturePatterns.patterns.T;
                        break;
                    case "y":
                        // YearMonthPattern
                        pattern = culturePatterns.patterns.Y;
                        break;
                    case "Y":
                        // yearMonthPattern
                        pattern = culturePatterns.patterns.Y;
                        break;
                    case "r":
                        // RFC1123Pattern
                                            case "R":
                        pattern = "ddd, dd MMM yyyy HH:mm:ss G\\M\\T";
                        break;
                }
            }
            return pattern;
        }
        $.wijinputcore.parseDate = $.wijinputcore.parseDate || dateParser;
        //#endregion
        //#region validate library
        function dateValidator(value, minDate, maxDate, format, culture) {
            var dateValue = dateParser(value, format, culture);
            return dateValue >= minDate && dateValue <= maxDate;
        }
        $.wijinputcore.validateDate = $.wijinputcore.validateDate || dateValidator;
        //#endregion
            })(wijmo.input || (wijmo.input = {}));
    var input = wijmo.input;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 * ----
 * Credits: Wijmo includes some MIT-licensed software, see copyright notices below.
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts"/>
    /// <reference path="../External/declarations/jquery.cookie.d.ts" />
    /*globals $, jQuery, document, window, location, wijmoASPNetParseOptions*/
    /*
    * Depends:
    *	jquery-1.4.2.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.ui.position.js
    *	jquery.effects.core.js
    *	jquery.cookie.js
    *  jquery.wijmo.wijsuperpanel.js
    *	jquery.wijmo.wijutil.js
    */
    (function (tabs) {
        "use strict";
        var $ = jQuery;
        var tabId = 0, listId = 0, effects = $.effects ? $.effects : $, effectsSave = effects.save, effectsRestore = effects.restore, effectsCreateWrapper = effects.createWrapper, effectsRemoveWrapper = effects.removeWrapper, getNextTabId = function () {
            return ++tabId;
        }, getNextListId = function () {
            return ++listId;
        };
        /** @widget*/
        var wijtabs = (function (_super) {
            __extends(wijtabs, _super);
            function wijtabs() {
                _super.apply(this, arguments);

            }
            wijtabs.prototype._setOption = function (key, value) {
                _super.prototype._setOption.call(this, key, value);
                switch(key) {
                    case 'selected':
                        if(this.options.collapsible && value === this.options.selected) {
                            return;
                        }
                        this.select(value);
                        break;
                    case 'alignment':
                        this._innerDestroy(true);
                        this._tabify(true);
                        break;
                    case 'scrollable':
                        if(!value) {
                            this._removeScroller();
                        }
                        this._tabify(false);
                        break;
                    default:
                        this._tabify(false);
                        break;
                }
            };
            wijtabs.prototype._create = function () {
                var _this = this;
                var o = this.options;
                if(this.element.is(":hidden") && this.element.wijAddVisibilityObserver) {
                    this.element.wijAddVisibilityObserver(function () {
                        if(_this.element.wijRemoveVisibilityObserver) {
                            _this.element.wijRemoveVisibilityObserver();
                        }
                        var dataObj = _this.element.data("wijtabs"), wijmoDataObj = _this.element.data("wijmo-wijtabs");
                        _this._innerDestroy(true);
                        _this.element.data("wijtabs", dataObj);
                        _this.element.data("wijmo-wijtabs", wijmoDataObj);
                        _this._tabify(true);
                    }, "wijtabs");
                }
                this._tabify(true);
                if(o.disabledstate || o.disabled) {
                    this.disable();
                }
                _super.prototype._create.call(this);
            };
            wijtabs.prototype.destroy = /** The destroy() method will remove the wijtabs functionality completely
            * and will return the element to its pre-init state.
            */
            function () {
                this._innerDestroy();
                _super.prototype.destroy.call(this);
            };
            wijtabs.prototype._tabify = function (init) {
                this.list = this.element.children('ol,ul').eq(0);
                this.lis = $('li:has(a)', this.list);
                this.anchors = this.lis.map(function () {
                    return $('a', this)[0];
                });
                this.panels = $([]);
                var self = this, o = self.options, fragmentId = /^#.+/, tabsAlign, panelCorner, content, i, li, addState, removeState, showTab, hideTab;
                // Safari 2 reports '#' for an empty hash
                $.each(self.anchors, function (i, a) {
                    var href = $(a).attr('href') || "", hrefBase = // For dynamically created HTML that contains a hash as href IE < 8
                    // expands such href to the full page url with hash and then
                    // misinterprets tab as ajax.
                    // Same consideration applies for an added tab with a fragment identifier
                    // since a[href=#fragment-identifier] does unexpectedly not match.
                    // Thus normalize href attribute...
                    href.split('#')[0], baseEl, id, $panel;
                    //if (hrefBase && (hrefBase === location.toString().split('#')[0] ||
                    if(hrefBase && (hrefBase === location.toString().split('#')[0] || (baseEl = $('base')[0]) && hrefBase === baseEl.href)) {
                        href = a.hash;
                        a.href = href;
                    }
                    // inline tab
                    if(fragmentId.test(href)) {
                        self.panels = self.panels.add(self._sanitizeSelector(href), self.element);
                    } else // remote tab
                    // prevent loading the page itself if href is just "#"
                    if(href !== '#') {
                        $.data(a, 'href.tabs', href)// required for restore on destroy
                        ;
                        $.data(a, 'load.tabs', href.replace(/#.*$/, ''))// mutable data
                        ;
                        id = self._tabId(a);
                        a.href = '#' + id;
                        $panel = $('#' + id);
                        if(!$panel.length) {
                            $panel = $(o.panelTemplate || self._defaults.panelTemplate).attr('id', id).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerBottom).insertAfter(self.panels[i - 1] || self.list);
                            $panel.data('destroy.tabs', true);
                        }
                        self.panels = self.panels.add($panel);
                    } else// invalid tab href
                     {
                        o.disabledIndexes.push(i);
                    }
                    //for fixing issue 41786, keep same as jqueryui tabs widget.
                    $(a).prop("tabindex", "-1");
                });
                tabsAlign = this._getAlignment(true);
                panelCorner = this._getAlignment(false);
                // initialization from scratch
                if(init) {
                    // ARIA
                    this.list.attr("role", "tablist");
                    this.lis.attr("role", "tab");
                    this.panels.attr("role", "tabpanel");
                    this.element.addClass(o.wijCSS.tabs).addClass(o.wijCSS.wijtabs).addClass(o.wijCSS.widget).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS["tabs" + tabsAlign]);
                    this.list.addClass(o.wijCSS.tabsNav).addClass(o.wijCSS.helperReset).addClass(o.wijCSS.helperClearFix).addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll);
                    this.lis.addClass(o.wijCSS.stateDefault).addClass(o.wijCSS["corner" + tabsAlign]);
                    this.panels.addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS["corner" + panelCorner]);
                    // attach necessary classes for styling
                    switch(tabsAlign) {
                        case 'Bottom':
                            this.list.appendTo(this.element);
                            break;
                        case 'Left':
                            content = $('<div/>').addClass(o.wijCSS.wijtabsContent).appendTo(this.element);
                            this.panels.appendTo(content);
                            break;
                        case 'Right':
                            content = $('<div/>').addClass(o.wijCSS.wijtabsContent).insertBefore(this.list);
                            this.panels.appendTo(content);
                            break;
                        case 'Top':
                            this.list.prependTo(this.element);
                            break;
                    }
                    if(o.sortable && this.list.sortable) {
                        this._createSortable(tabsAlign);
                    }
                    // Selected tab
                    // use "selected" option or try to retrieve:
                    // 1. from fragment identifier in url
                    // 2. from cookie
                    // 3. from selected class attribute on <li>
                    if(o.selected === undefined) {
                        if(location.hash) {
                            $.each(this.anchors, function (i, a) {
                                if(a.hash === location.hash) {
                                    o.selected = i;
                                    return false;// break
                                    
                                }
                            });
                        }
                        if(typeof o.selected !== 'number' && o.cookie) {
                            o.selected = parseInt(self._cookie(undefined, undefined), 10);
                        }
                        if(typeof o.selected !== 'number' && this.lis.filter('.' + o.wijCSS.tabsActive).length) {
                            o.selected = this.lis.index(this.lis.filter('.' + o.wijCSS.tabsActive));
                        }
                        o.selected = o.selected || (this.lis.length ? 0 : -1);
                    } else if(o.selected === null) {
                        // usage of null is deprecated, TODO remove in next release
                        o.selected = -1;
                    }
                    // sanity check - default to first tab...
                    o.selected = ((o.selected >= 0 && this.anchors[o.selected]) || o.selected < 0) ? o.selected : 0;
                    // Take disabling tabs via class attribute from HTML
                    // into account and update option properly.
                    // A selected tab cannot become disabled.
                    o.disabledIndexes = $.unique(o.disabledIndexes.concat($.map(this.lis.filter('.' + o.wijCSS.stateDisabled), function (n, i) {
                        return self.lis.index(n);
                    }))).sort();
                    if($.inArray(o.selected, o.disabledIndexes) !== -1) {
                        o.disabledIndexes.splice($.inArray(o.selected, o.disabledIndexes), 1);
                    }
                    // highlight selected tab
                    this.panels.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                    this.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                    // check for length avoids error when initializing empty list
                    if(o.selected >= 0 && this.anchors.length) {
                        this.panels.eq(o.selected).removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                        this.lis.eq(o.selected).addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                        // seems to be expected behavior that the show callback is fired
                        self.element.queue("tabs", function () {
                            if(self.element.wijTriggerVisibility) {
                                $(self.panels[o.selected]).wijTriggerVisibility();
                            }
                            self._trigger('show', null, self._ui(self.anchors[o.selected], self.panels[o.selected]));
                        });
                        this.load(o.selected);
                    }
                    // clean up to avoid memory leaks in certain versions of IE 6
                    $(window).bind('unload.wijtabs', function () {
                        if(self.lis) {
                            self.lis.add(self.anchors).unbind('.tabs');
                        }
                        self.lis = self.anchors = self.panels = null;
                    });
                } else {
                    // update selected after add/remove
                    o.selected = this.lis.index(this.lis.filter('.' + o.wijCSS.tabsActive));
                    if(this.list.data("ui-sortable")) {
                        if(this.list.sortable) {
                            if(o.sortable) {
                                this.list.sortable('enable');
                            } else {
                                this.list.sortable('disable');
                            }
                        }
                    } else {
                        if(o.sortable && this.list.sortable) {
                            this._createSortable(tabsAlign);
                        }
                    }
                }
                // update collapsible
                this.element[o.collapsible ? 'addClass' : 'removeClass'](o.wijCSS.tabsCollapsible);
                // set or update cookie after init and add/remove respectively
                if(o.cookie) {
                    this._cookie(o.selected, o.cookie);
                }
                // disable tabs
                //for (i = 0; (li = this.lis[i]); i++) {
                for(i = 0; i < this.lis.length; i++) {
                    li = this.lis[i];
                    $(li)[$.inArray(i, o.disabledIndexes) !== -1 && !$(li).hasAllClasses(o.wijCSS.tabsActive) ? 'addClass' : 'removeClass'](o.wijCSS.stateDisabled);
                    if($(li).hasAllClasses(o.wijCSS.stateDisabled)) {
                        $(li).attr('aria-disabled', true);
                    }
                }
                // reset cache if switching from cached to not cached
                if(o.cache === false) {
                    this.anchors.removeData('cache.tabs');
                }
                // remove all handlers before, tabify may run on existing tabs
                // after add or option change
                this.lis.add(this.anchors).unbind('.tabs');
                if(!o.disabledState && !o.disabled && o.event !== 'mouseover') {
                    addState = function (state, el) {
                        if(el.is(':not(.' + o.wijCSS.stateDisabled + ')')) {
                            el.addClass(state);
                        }
                    };
                    removeState = function (state, el) {
                        el.removeClass(state);
                    };
                    this.lis.bind('mouseover.tabs', function () {
                        addState(o.wijCSS.stateHover, $(this));
                    });
                    this.lis.bind('mouseout.tabs', function () {
                        removeState(o.wijCSS.stateHover, $(this));
                    });
                    this.anchors.bind('focus.tabs', function () {
                        self.lis.filter("." + o.wijCSS.stateFocus).removeClass(o.wijCSS.stateFocus);
                        addState(o.wijCSS.stateFocus, $(this).closest('li'));
                    });
                    this.anchors.bind('blur.tabs', function () {
                        removeState(o.wijCSS.stateFocus, $(this).closest('li'));
                    });
                }
                if(o.showOption === undefined || o.showOption === null) {
                    o.showOption = {
                    };
                }
                this._normalizeBlindOption(o.showOption);
                if(o.hideOption === undefined || o.hideOption === null) {
                    o.hideOption = {
                    };
                }
                this._normalizeBlindOption(o.hideOption);
                // Show a tab...
                showTab = ((o.showOption.blind || o.showOption.fade) && o.showOption.duration > 0) ? function (clicked, $show) {
                    $(clicked).closest('li').addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                    self._showContent();
                    $show.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    if(tabsAlign === 'Top' || tabsAlign === 'Bottom') {
                        var props = {
                            duration: o.showOption.duration,
                            height: 'toggle',
                            opacity: 'toggle'
                        };
                        if(!o.showOption.blind) {
                            delete props.height;
                        }
                        if(!o.showOption.fade) {
                            delete props.opacity;
                        }
                        // avoid flicker that way
                        $show.hide().removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false).animate(props, o.showOption.duration || 'normal', function () {
                            self._resetStyle($show);
                            if($show.wijTriggerVisibility) {
                                $show.wijTriggerVisibility();
                            }
                            self._trigger('show', null, self._ui(clicked, $show[0]));
                        });
                    } else {
                        self._showContent();
                        self._blindPanel($show, 'show');
                    }
                } : function (clicked, $show) {
                    $(clicked).closest('li').addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                    self._showContent();
                    $show.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    if($show.wijTriggerVisibility) {
                        $show.wijTriggerVisibility();
                    }
                    self._trigger('show', null, self._ui(clicked, $show[0]));
                };
                // Hide a tab, $show is optional...
                hideTab = ((o.hideOption.blind || o.hideOption.fade) && o.hideOption.duration > 0) ? function (clicked, $hide) {
                    if(tabsAlign === 'Top' || tabsAlign === 'Bottom') {
                        var props = {
                            duration: o.hideOption.duration,
                            height: 'toggle',
                            opacity: 'toggle'
                        };
                        if(!o.hideOption.blind) {
                            delete props.height;
                        }
                        if(!o.hideOption.fade) {
                            delete props.opacity;
                        }
                        $hide.animate(props, o.hideOption.duration || 'normal', function () {
                            self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                            $hide.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                            self._resetStyle($hide);
                            self.element.dequeue("tabs");
                        });
                    } else {
                        self._saveLayout();
                        self._blindPanel($hide, 'hide');
                    }
                } : function (clicked, $hide, $show) {
                    self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                    self._hideContent();
                    $hide.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                    self.element.dequeue("tabs");
                };
                // attach tab event handler, unbind to avoid duplicates from former tabifying
                if(!o.disabledState && !o.disabled) {
                    this.anchors.bind(o.event + '.tabs', function () {
                        var el = this, $li = $(this).closest('li'), $hide = self.panels.filter(':not(.' + o.wijCSS.wijtabsHide + ')'), $show = $(self._sanitizeSelector(this.hash), self.element);
                        // If tab is already selected and not collapsible or tab disabled or
                        // or is already loading or click callback returns false stop here.
                        // Check if click handler returns false last so that it is not
                        // executed for a disabled or loading tab!
                        if(($li.hasAllClasses(o.wijCSS.tabsActive) && !o.collapsible) || $li.hasAllClasses(o.wijCSS.stateDisabled) || $li.hasAllClasses(o.wijCSS.tabsLoading) || self._trigger('select', null, self._ui(this, $show[0])) === false) {
                            this.blur();
                            return false;
                        }
                        o.selected = self.anchors.index(this);
                        self.abort();
                        // if tab may be closed
                        if(o.collapsible) {
                            if($li.hasAllClasses(o.wijCSS.tabsActive)) {
                                o.selected = -1;
                                if(o.cookie) {
                                    self._cookie(o.selected, o.cookie);
                                }
                                self.element.queue("tabs", function () {
                                    hideTab(el, $hide);
                                }).dequeue("tabs");
                                this.blur();
                                return false;
                            } else if(!$hide.length) {
                                if(o.cookie) {
                                    self._cookie(o.selected, o.cookie);
                                }
                                self.element.queue("tabs", function () {
                                    showTab(el, $show);
                                });
                                // TODO make passing in node possible,
                                // see also http://dev.jqueryui.com/ticket/3171
                                self.load(self.anchors.index(this));
                                this.blur();
                                return false;
                            }
                        }
                        if(o.cookie) {
                            self._cookie(o.selected, o.cookie);
                        }
                        // show new tab
                        if($show.length) {
                            if($hide.length) {
                                self.element.queue("tabs", function () {
                                    hideTab(el, $hide);
                                });
                            }
                            self.element.queue("tabs", function () {
                                showTab(el, $show);
                            });
                            self.load(self.anchors.index(this));
                        } else {
                            throw 'jQuery UI Tabs: Mismatching fragment identifier.';
                        }
                        // Prevent IE from keeping other link focussed when using
                        // the back button and remove dotted border from clicked link.
                        // This is controlled via CSS in modern browsers;
                        // blur() removes focus from address bar in Firefox which can
                        // become a usability and annoying problem with tabs('rotate').
                        if($.browser.msie) {
                            this.blur();
                        }
                    });
                }
                this._initScroller();
                // disable click in any case
                this.anchors.bind('click.tabs', function () {
                    return false;
                });
            };
            wijtabs.prototype._createSortable = function (tabsAlign) {
                var self = this;
                self.list.sortable({
                    update: function (e, ui) {
                        self.lis = $('li:has(a)', self.list);
                        self.anchors = self.lis.map(function () {
                            return $('a', this)[0];
                        });
                        var href = ui.item.find("a").attr("href"), panel = self.panels.filter(href), panelIndex = self.panels.index(panel), newIndex = self.lis.index(ui.item);
                        if(panelIndex > newIndex) {
                            $(self.panels[newIndex]).before(panel);
                        } else {
                            $(self.panels[newIndex]).after(panel);
                        }
                        self.panels = $("." + self.options.wijCSS.tabsPanel, self.element);
                    },
                    axis: (tabsAlign === 'Top' || tabsAlign === 'Bottom') ? "x" : "y"
                });
            };
            wijtabs.prototype._blindPanel = function (panel, mode) {
                var self = this, o = self.options, content = panel.parent('.' + o.wijCSS.wijtabsContent), props = [
                    'position', 
                    'top', 
                    'left', 
                    'width'
                ], blindOption = mode === 'show' ? o.showOption : o.hideOption, wrapper, a, listWidth;
                if(!content.length) {
                    return;
                }
                self.list.width(self.list.width());
                //$.effects.save(panel, props);
                if(effectsSave) {
                    effectsSave(panel, props);
                }
                panel.show()// Save & Show
                ;
                if(mode === 'show') {
                    // Show
                    panel.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    panel.width(self.element.data('panel.width'));
                } else {
                    panel.width(panel.width());
                }
                // Create Wrapper
                //wrapper = $.effects.createWrapper(panel).css({ overflow: 'hidden' });
                if(effectsCreateWrapper) {
                    wrapper = effectsCreateWrapper(panel).css({
                        overflow: 'hidden'
                    });
                } else {
                    wrapper = $('<div></div>');
                }
                if(mode === 'show') {
                    // Shift
                    wrapper.css($.extend({
                        width: 0
                    }, blindOption.fade ? {
                        opacity: 0
                    } : {
                    }));
                }
                // Animation
                a = $.extend({
                    width: mode === 'show' ? self.element.data('panel.outerWidth') : 0
                }, blindOption.fade ? {
                    opacity: mode === 'show' ? 1 : 0
                } : {
                });
                listWidth = self.list.outerWidth(true);
                // Animate
                wrapper.animate(a, {
                    duration: blindOption.duration,
                    step: function () {
                        var ww = wrapper.outerWidth(true);
                        self.element.width(listWidth + ww);
                        content.width(Math.max(0, self.element.innerWidth() - listWidth - 6));
                    },
                    complete: function () {
                        if(mode === 'hide') {
                            self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                            // Hide
                            panel.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                        } else {
                            panel.css('width', '');
                        }
                        ////$.effects.restore(panel, props);
                        //$.effects.removeWrapper(panel); // Restore
                        if(effectsRemoveWrapper) {
                            effectsRemoveWrapper(panel);
                        }
                        if(mode === 'show') {
                            self._restoreLayout();
                        }
                        self._resetStyle(panel);
                        panel.dequeue();
                        self.element.dequeue("tabs");
                    }
                });
            };
            wijtabs.prototype._hideContent = function () {
                var wijCSS = this.options.wijCSS, content = this.element.find('.' + wijCSS.wijtabsContent);
                if(content.length) {
                    this._saveLayout();
                    content.addClass(wijCSS.wijtabsHide).attr('aria-hidden', true);
                    this.element.width(this.list.outerWidth(true));
                }
            };
            wijtabs.prototype._showContent = function () {
                var wijCSS = this.options.wijCSS, content = this.element.find('.' + wijCSS.wijtabsContent);
                if(content.length) {
                    this._restoreLayout();
                    content.removeClass(wijCSS.wijtabsHide).attr('aria-hidden', false);
                }
            };
            wijtabs.prototype._saveLayout = function () {
                var wijCSS = this.options.wijCSS, props = [
                    'width', 
                    'height', 
                    'overflow'
                ], $hide = this.panels.filter(':not(.' + wijCSS.wijtabsHide + ')');
                //$.effects.save(self.element, props);
                //$.effects.save(self.list, props);
                //$.effects.save(self.element.find('.' + wijCSS.wijtabsContent), props);
                if(effectsSave) {
                    effectsSave(this.element, props);
                    effectsSave(this.list, props);
                    effectsSave(this.element.find('.' + wijCSS.wijtabsContent), props);
                }
                this.list.width(this.list.width());
                this.element.data('panel.width', $hide.width());
                this.element.data('panel.outerWidth', $hide.outerWidth(true));
            };
            wijtabs.prototype._restoreLayout = function () {
                var wijCSS = this.options.wijCSS, props = [
                    'width', 
                    'height', 
                    'overflow'
                ];
                //$.effects.restore(self.element, props);
                //$.effects.restore(self.list, props);
                //$.effects.restore(self.element.find('.' + wijCSS.wijtabsContent), props);
                if(effectsRestore) {
                    effectsRestore(this.element, props);
                    effectsRestore(this.list, props);
                    effectsRestore(this.element.find('.' + wijCSS.wijtabsContent), props);
                }
            };
            wijtabs.prototype._resetStyle = // Reset certain styles left over from animation
            // and prevent IE's ClearType bug...
            function ($el) {
                $el.css({
                    display: ''
                });
                if(!$.support.opacity) {
                    $el[0].style.removeAttribute('filter');
                }
            };
            wijtabs.prototype._normalizeBlindOption = function (o) {
                if(o.blind === undefined) {
                    o.blind = false;
                }
                if(o.fade === undefined) {
                    o.fade = false;
                }
                if(o.duration === undefined) {
                    o.duration = 200;
                }
                if(typeof o.duration === 'string') {
                    try  {
                        o.duration = parseInt(o.duration, 10);
                    } catch (e) {
                        o.duration = 200;
                    }
                }
            };
            wijtabs.prototype._initScroller = function () {
                var _this = this;
                var horz = $.inArray(this._getAlignment(true), [
                    'Top', 
                    'Bottom'
                ]) !== -1, width = 0;
                if(!horz) {
                    return;
                }
                $.each(this.lis, function (idx, li) {
                    // In IE, the render width has decimals. but the jQuery get's width doesn't contains decimals.
                                        var item = $(li), link, itemWidth = 0, iefix = 0;
                    if($.browser.msie && !!_this.options.scrollable) {
                        //item.width(item.css("width"));
                        // when the li item contains icon, the a element will contains decimals, the icon will show at the second line.
                        // strange things, the width can't contains decimals in other browsers, but margin can has decimals value, and can use
                        // outerWidth(true) to get it. for this case, the item's width will be sum of the children's outer width.
                        $.each(item.children(), function (i, ele) {
                            var jqEle = $(ele);
                            if(jqEle.is("a")) {
                                jqEle.width(jqEle.width());
                            }
                            itemWidth += jqEle.outerWidth(true);
                        });
                        iefix = itemWidth - item.width();
                        item.width(itemWidth);
                    }
                    width += _this._getLiWidth($(li)) + iefix;
                });
                if(!!this.options.scrollable && this.element.innerWidth() < width) {
                    if(this.scrollWrap === undefined) {
                        this.list.wrap("<div class='scrollWrap'></div>");
                        this.scrollWrap = this.list.parent();
                        //$.effects.save(this.list, ['width', 'height', 'overflow']);
                        if(effectsSave) {
                            effectsSave(this.list, [
                                'width', 
                                'height', 
                                'overflow'
                            ]);
                        }
                    }
                    this.list.width(Math.ceil(width) + 2);
                    this.scrollWrap.height(this.list.outerHeight(true));
                    this.scrollWrap.wijsuperpanel({
                        allowResize: false,
                        hScroller: {
                            scrollMode: 'edge'
                        },
                        vScroller: {
                            scrollBarVisibility: 'hidden'
                        }
                    });
                } else {
                    this._removeScroller();
                }
            };
            wijtabs.prototype._ui = function (tab, panel) {
                return {
                    tab: tab,
                    panel: panel,
                    index: this.anchors.index(tab)
                };
            };
            wijtabs.prototype._tabId = function (a) {
                var $a = $(a), tabId, hrefParams;
                if($a.data && $a.data("tabid")) {
                    return $a.data("tabid");
                }
                if(a.href && a.href.length) {
                    hrefParams = this._getURLParameters(a.href);
                    if(hrefParams.tabId) {
                        tabId = hrefParams.tabId;
                        $a.data("tabid", tabId);
                        return tabId;
                    }
                }
                tabId = a.title && a.title.replace(/\s/g, '_').replace(/[^A-Za-z0-9\-_:\.]/g, '') || this.options.idPrefix + getNextTabId();
                $a.data("tabid", tabId);
                return tabId;
            };
            wijtabs.prototype._getURLParameters = function (url) {
                var params = {
                }, parametersString, parameters;
                if(url.indexOf('?') > -1) {
                    parametersString = url.split('?')[1];
                    parameters = parametersString.split('&');
                    $.each(parameters, function (i, param) {
                        var p = param.split('=');
                        if(p.length > 1) {
                            params[p[0]] = p[1];
                        }
                    });
                }
                return params;
            };
            wijtabs.prototype._getAlignment = function (tabs) {
                var align = this.options.alignment || 'top';
                if(tabs) {
                    return align.charAt(0).toUpperCase() + align.substr(1);
                }
                switch(align) {
                    case 'top':
                        align = 'Bottom';
                        break;
                    case 'bottom':
                        align = 'Top';
                        break;
                    case 'left':
                        align = 'Right';
                        break;
                    case 'right':
                        align = 'Left';
                        break;
                }
                return align;
            };
            wijtabs.prototype._sanitizeSelector = function (hash) {
                // we need this because an id may contain a ":"
                return hash.replace(/:/g, '\\:');
            };
            wijtabs.prototype._innerDestroy = function (keepAddedItems) {
                var o = this.options, content = $('.' + o.wijCSS.wijtabsContent);
                this.abort();
                this._removeScroller();
                this.element.unbind('.tabs').removeClass(o.wijCSS.wijtabs).removeClass(o.wijCSS.tabsTop).removeClass(o.wijCSS.tabsBottom).removeClass(o.wijCSS.tabsLeft).removeClass(o.wijCSS.tabsRight).removeClass(o.wijCSS.tabs).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.content).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.tabsCollapsible).removeClass(o.wijCSS.helperClearFix).removeData('tabs').removeAttr('role');
                this.list.removeClass(o.wijCSS.tabsNav).removeClass(o.wijCSS.helperReset).removeClass(o.wijCSS.helperClearFix).removeClass(o.wijCSS.header).removeClass(o.wijCSS.cornerAll).removeAttr('role');
                $.each(this.anchors, function (idx, a) {
                    var $a = $(a), href = $a.data('href.tabs');
                    if(href) {
                        a.href = href;
                    }
                    $a.unbind('.tabs');
                    $.each([
                        'href', 
                        'load', 
                        'cache'
                    ], function (i, prefix) {
                        $a.removeData(prefix + '.tabs');
                    });
                });
                this.lis.unbind('.tabs').add(this.panels).each(function (idx, li) {
                    var $li = $(li);
                    if($li.data('destroy.tabs') && !keepAddedItems) {
                        $li.remove();
                    } else {
                        $li.removeClass(o.wijCSS.stateDefault).removeClass(o.wijCSS.cornerTop).removeClass(o.wijCSS.cornerBottom).removeClass(o.wijCSS.cornerLeft).removeClass(o.wijCSS.cornerRight).removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateFocus).removeClass(o.wijCSS.stateDisabled).removeClass(o.wijCSS.tabsPanel).removeClass(o.wijCSS.content).removeClass(o.wijCSS.wijtabsHide).css({
                            position: '',
                            left: '',
                            top: ''
                        }).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-selected').removeAttr('aria-disabled');
                    }
                });
                if(content.length) {
                    content.replaceWith(content.contents());
                }
                if(o.cookie) {
                    this._cookie(null, o.cookie);
                }
                this.list = null;
                this.anchors = null;
                this.lis = null;
                this.panels = null;
                $(window).unbind('unload.wijtabs');
                return this;
            };
            wijtabs.prototype._cleanup = function () {
                // restore all former loading tabs labels
                var wijCSS = this.options.wijCSS;
                this.lis.filter('.' + wijCSS.tabsLoading).removeClass(wijCSS.tabsLoading).find('span:data(label.tabs)').each(function () {
                    var el = $(this);
                    el.html(el.data('label.tabs')).removeData('label.tabs');
                });
            };
            wijtabs.prototype._removeScroller = function () {
                if(!this.scrollWrap) {
                    return;
                }
                this.scrollWrap.wijsuperpanel('destroy').replaceWith(this.scrollWrap.contents());
                this.scrollWrap = undefined;
                if(effectsRestore) {
                    effectsRestore(this.list, [
                        'width', 
                        'height', 
                        'overflow'
                    ]);
                }
            };
            wijtabs.prototype._cookie = function (index, cookie) {
                var c = this.cookie || (this.cookie = this.options.cookie.name || 'ui-tabs-' + getNextListId());
                return $.cookie.apply(null, [
                    c
                ].concat($.makeArray(arguments)));
            };
            wijtabs.prototype._getLiWidth = function (li) {
                return this._parsePxToNumber(li.css('margin-left')) + this._parsePxToNumber(li.css('border-left-width')) + this._parsePxToNumber(li.css('padding-left')) + this._parsePxToNumber(li.css('width')) + this._parsePxToNumber(li.css('margin-right')) + this._parsePxToNumber(li.css('border-right-width')) + this._parsePxToNumber(li.css('padding-right'));
            };
            wijtabs.prototype._parsePxToNumber = /** Parse string setting to number */
            function (px) {
                var pxIndex = px.indexOf("px");
                if(!pxIndex || pxIndex === -1) {
                    return 0;
                } else {
                    return parseFloat(px.substr(0, pxIndex));
                }
            };
            wijtabs.prototype.abort = /** Terminate all running tab ajax requests and animations.*/
            function () {
                this.element.queue([]);
                this.panels.stop(false, true);
                // "tabs" queue must not contain more than two elements,
                // which are the callbacks for the latest clicked tab...
                this.element.queue("tabs", this.element.queue("tabs").splice(-2, 2));
                // terminate pending requests from other tabs
                if(this.xhr) {
                    this.xhr.abort();
                    delete this.xhr;
                }
                // take care of tab labels
                this._cleanup();
                return this;
            };
            wijtabs.prototype.select = /** Selects a tab; for example, a clicked tab.
            * @param {number|string} index The zero-based index of the tab to be selected or
            * the id selector of the panel the tab is associated with.
            * @example
            * //Select the second tab.
            * $("#element").wijtabs('select', 1);
            */
            function (index) {
                if(typeof index === 'string') {
                    index = this.anchors.index(this.anchors.filter('[href$=' + index + ']'));
                } else if(index === null) {
                    // usage of null is deprecated, TODO remove in next release
                    index = -1;
                }
                if(index === -1 && this.options.collapsible) {
                    index = this.options.selected;
                }
                this.anchors.eq(index).trigger(this.options.event + '.tabs');
                return this;
            };
            wijtabs.prototype.load = /** Reload the content of an Ajax tab programmatically.
            * This method always loads the tab content from the remote location,
            * even if cache is set to true.
            * @param {number} index The zero-based index of the tab to be reloaded.
            * @example
            * //Reload the second tab.
            * $("#element").wijtabs('load', 1);
            */
            function (index) {
                var self = this, o = self.options, a = self.anchors.eq(index)[0], url = $.data(a, 'load.tabs'), span = $('span', a);
                self.abort();
                if(false === self._trigger('beforeShow', null, self._ui(self.anchors[index], self.panels[index]))) {
                    self.element.dequeue("tabs");
                    return;
                }
                // not remote or from cache
                if(!url || self.element.queue("tabs").length !== 0 && $.data(a, 'cache.tabs')) {
                    self.element.dequeue("tabs");
                    return;
                }
                // load remote from here on
                self.lis.eq(index).addClass(o.wijCSS.tabsLoading);
                if(o.spinner || self._defaults.spinner) {
                    span.data('label.tabs', span.html()).html(o.spinner || self._defaults.spinner);
                }
                self.xhr = $.ajax($.extend({
                }, o.ajaxOptions, {
                    url: url,
                    success: function (r, s) {
                        $(self._sanitizeSelector(a.hash), self.element).html(r);
                        // take care of tab labels
                        self._cleanup();
                        if(o.cache) {
                            // if loaded once do not load them again
                            $.data(a, 'cache.tabs', true);
                        }
                        // callbacks
                        self._trigger('load', null, self._ui(self.anchors[index], self.panels[index]));
                        try  {
                            o.ajaxOptions.success(r, s);
                        } catch (e1) {
                        }
                    },
                    error: function (xhr, s, e) {
                        // take care of tab labels
                        self._cleanup();
                        // callbacks
                        self._trigger('load', null, self._ui(self.anchors[index], self.panels[index]));
                        try  {
                            // Passing index avoid a race condition when this method is
                            // called after the user has selected another tab.
                            // Pass the anchor that initiated this request allows
                            // loadError to manipulate the tab content panel via $(a.hash)
                            o.ajaxOptions.error(xhr, s, index, a);
                        } catch (e2) {
                        }
                    }
                }));
                // last, so that load event is fired before show...
                self.element.dequeue("tabs");
                return self;
            };
            wijtabs.prototype.add = /** Add a new tab.
            * @param {string} url A URL consisting of a fragment identifier
            * only to create an in-page tab or a full url
            * (relative or absolute, no cross-domain support) to
            * turn the new tab into an Ajax (remote) tab.
            * @param {string} label The tab label.
            * @param {number} index Zero-based position where to insert the new tab.
            * @example
            * //Add a new tab to be a second tab.
            * $("#element").wijtabs('add', "http://wijmo.com/newTab", "NewTab", 1);
            */
            function (url, label, index) {
                if(index === undefined) {
                    index = this.anchors.length// append by default
                    ;
                }
                var self = this, o = self.options, $li = $((o.tabTemplate || self._defaults.tabTemplate).replace(/#\{href\}/g, url).replace(/#\{label\}/g, label)), id = !url.indexOf('#') ? url.replace('#', '') : self._tabId($('a', $li)[0]), tabsAlign = self._getAlignment(true), panelCorner = self._getAlignment(false), $panel = $('#' + id), $content;
                $li.addClass(o.wijCSS.stateDefault).addClass(o.wijCSS["corner" + tabsAlign]).data('destroy.tabs', true).attr('role', 'tab').attr('aria-selected', false);
                // try to find an existing element before creating a new one
                if(!$panel.length) {
                    $panel = $(o.panelTemplate || self._defaults.panelTemplate).attr('id', id).data('destroy.tabs', true).attr('role', 'tabpanel');
                }
                $panel.addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS["corner" + panelCorner] + ' ' + o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                if(index >= self.lis.length) {
                    $li.appendTo(self.list);
                    if(self.panels.length > 0) {
                        $panel.insertAfter(self.panels[self.panels.length - 1]);
                    } else {
                        $content = self.element.find('.' + o.wijCSS.wijtabsContent);
                        if($content.length === 0) {
                            $content = self.element;
                        }
                        $panel.appendTo($content);
                    }
                } else {
                    $li.insertBefore(self.lis[index]);
                    $panel.insertBefore(self.panels[index]);
                }
                o.disabledIndexes = $.map(o.disabledIndexes, function (n, i) {
                    return n >= index ? ++n : n;
                });
                self._removeScroller();
                self._tabify(false);
                if(self.anchors.length === 1) {
                    // after tabify
                    o.selected = 0;
                    $li.addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                    $panel.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    self.element.queue("tabs", function () {
                        if(self.element.wijTriggerVisibility) {
                            $(self.panels[0]).wijTriggerVisibility();
                        }
                        self._trigger('show', null, self._ui(self.anchors[0], self.panels[0]));
                    });
                    self.load(0);
                }
                // callback
                self._trigger('add', null, self._ui(self.anchors[index], self.panels[index]));
                return self;
            };
            wijtabs.prototype.remove = /** Removes a tab.
            * @param {number} index The zero-based index of the tab to be removed.
            * @example
            * //Removes the second tab
            * $("#element").wijtabs('remove', 1);
            */
            function (index) {
                var o = this.options, $li = this.lis.eq(index).remove(), $panel = this.panels.eq(index).remove();
                // If selected tab was removed focus tab to the right or
                // in case the last tab was removed the tab to the left.
                if($li.hasAllClasses(o.wijCSS.tabsActive) && this.anchors.length > 1) {
                    this.select(index + (index + 1 < this.anchors.length ? 1 : -1));
                }
                o.disabledIndexes = $.map($.grep(o.disabledIndexes, function (n, i) {
                    return n !== index;
                }, false), function (n, i) {
                    return n >= index ? --n : n;
                });
                this._removeScroller();
                this._tabify(false);
                // callback
                this._trigger('remove', null, this._ui($li.find('a')[0], $panel[0]));
                return this;
            };
            wijtabs.prototype.enableTab = /** Enable a disabled tab.
            * @param {number} index The zero-based index of the tab to be enabled.
            * @example
            * //Enables the second tab
            * $("#element").wijtabs('enableTab', 1);
            */
            function (index) {
                var o = this.options;
                if($.inArray(index, o.disabledIndexes) === -1) {
                    return;
                }
                this.lis.eq(index).removeClass(o.wijCSS.stateDisabled).removeAttr('aria-disabled');
                o.disabledIndexes = $.grep(o.disabledIndexes, function (n, i) {
                    return n !== index;
                }, false);
                // callback
                this._trigger('enable', null, this._ui(this.anchors[index], this.panels[index]));
                return this;
            };
            wijtabs.prototype.disableTab = /** Disabled a tab.
            * @param {number} index The zero-based index of the tab to be disabled.
            * @example
            * //Disables the second tab
            * $("#element").wijtabs('disableTab', 1);
            */
            function (index) {
                var o = this.options;
                if(index !== o.selected) {
                    // cannot disable already selected tab
                    this.lis.eq(index).addClass(o.wijCSS.stateDisabled).attr('aria-disabled', true);
                    o.disabledIndexes.push(index);
                    o.disabledIndexes.sort();
                    // callback
                    this._trigger('disable', null, this._ui(this.anchors[index], this.panels[index]));
                }
                return this;
            };
            wijtabs.prototype.url = /** Changes the url from which an Ajax (remote) tab will be loaded.
            * @param {number} index The zero-based index of the tab of which its URL is to be updated.
            * @param {string} url A URL the content of the tab is loaded from.
            * @remarks The specified URL will be used for subsequent loads.
            * Note that you can not only change the URL for an existing remote tab
            * with this method, but you can also turn an in-page tab into a remote tab.
            * @example
            * //Changes the second tab to a new tab url.
            * $("#element").wijtabs('url', 1, "http://wijmo.com/newTabUrl")
            */
            function (index, url) {
                this.anchors.eq(index).removeData('cache.tabs').data('load.tabs', url);
                return this;
            };
            wijtabs.prototype.length = /** Retrieve the number of tabs of the first matched tab pane.*/
            function () {
                return this.anchors.length;
            };
            return wijtabs;
        })(wijmo.wijmoWidget);
        tabs.wijtabs = wijtabs;        
        wijtabs.prototype._defaults = {
            panelTemplate: '<div></div>',
            spinner: '<em>Loading&#8230;</em>',
            tabTemplate: '<li><a href="#{href}"><span>#{label}</span></a></li>'
        };
        var wijtabs_options = (function () {
            function wijtabs_options() {
                /** All CSS classes used in widgets.
                * @ignore
                */
                this.wijCSS = {
                    wijtabs: "wijmo-wijtabs",
                    wijtabsContent: "wijmo-wijtabs-content",
                    wijtabsHide: "wijmo-wijtabs-hide"
                };
                /** @ignore */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-b",
                    content: "ui-content ui-body ui-body-b",
                    stateDefault: "ui-btn ui-btn-a",
                    stateActive: "ui-btn-down-b"
                };
                /** Determines the tabs' alignment in respect to the content.
                * @remarks Possible values are: 'top', 'bottom', 'left' and 'right'.
                */
                this.alignment = 'top';
                /** Determines whether the tab can be dragged to a new position.
                * @remarks This option only works when jQuery.ui.sortable is available
                * which means that it doesn't work in mobile mode.
                */
                this.sortable = false;
                /** Determines whether to wrap to the next line or enable scrolling
                * when the number of tabs exceeds the specified width.
                */
                this.scrollable = false;
                /** Additional Ajax options to consider when loading tab content (see $.ajax).
                * @type {object}
                * @remarks Please see following link for more details,
                * http://api.jquery.com/jQuery.ajax/ .
                */
                this.ajaxOptions = null;
                /** Determines whether or not to cache the remote tabs content,
                * for example, to load content only once or with every click.
                * @remarks Note that to prevent the actual Ajax requests from being cached
                * by the browser, you need to provide an extra cache:
                * false flag to ajaxOptions.
                */
                this.cache = false;
                /** Stores the latest selected tab in a cookie.
                * The cookie is then used to determine the initially selected tab
                * if the selected option is not defined.
                * This option requires a cookie plugin. The object needs to have key/value pairs
                * of the form the cookie plugin expects as options.
                * @example
                * //Set cookie to wijtabs.
                * $('.selector').wijtabs({cookie: {
                * expires: 7, path: '/', domain: 'jquery.com', secure: true }});
                */
                this.cookie = null;
                /** Determines whether a tab can be collapsed by a user.
                * When this is set to true, an already selected tab
                * will be collapsed upon reselection.
                */
                this.collapsible = false;
                /** This is an animation option for hiding the tab's panel content.
                * @type {object}
                * @example
                * //Set hide animation to blind/fade and duration to 200.
                * $('.selector').wijtabs({
                * hideOption: { blind: true, fade: true, duration: 200}});
                */
                this.hideOption = null;
                /** This is an animation option for showing the tab's panel content.
                * @type {object}
                * @example
                * //Set show animation to blind/fade and duration to 200.
                * $('.selector').wijtabs({
                * showOption: { blind: true, fade: true, duration: 200}});
                */
                this.showOption = null;
                /** An array containing the position of the tabs (zero-based index)
                * that should be disabled upon initialization.
                */
                this.disabledIndexes = [];
                /** The type of event to be used for selecting a tab. */
                this.event = 'click';
                /** If the remote tab, its anchor element that is, has no title attribute
                * to generate an id from,
                * an id/fragment identifier is created from this prefix and a unique id
                * returned by $.data(el), for example "ui-tabs-54".
                */
                this.idPrefix = 'ui-tabs-';
                /** This is the HTML template from which a new tab panel is created in case
                * a tab is added via the add method or
                * if a panel for a remote tab is created on the fly.
                */
                this.panelTemplate = '';
                /** The HTML content of this string is shown in a tab title
                * while remote content is loading.
                * Pass in an empty string to deactivate that behavior.
                * A span element must be present in the A tag of the title
                * for the spinner content to be visible.
                */
                this.spinner = '';
                /** HTML template from which a new tab is created and added.
                * The placeholders #{href} and #{label} are replaced with the url
                * and tab label that are passed as arguments to the add method.
                */
                this.tabTemplate = '';
                /** The add event handler. A function called when a tab is added.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.add = null;
                /** The remove event handler. A function called when a tab is removed.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.remove = null;
                /** The select event handler. A function called when clicking a tab.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.select = null;
                /** The beforeShow event handler. A function called before a tab is shown.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.beforeShow = null;
                /** The show event handler. A function called when a tab is shown.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.show = null;
                /** The load event handler.
                * A function called after the content of a remote tab has been loaded.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.load = null;
                /** The disable event handler. A function called when a tab is disabled.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.disable = null;
                /** The enable event handler. A function called when a tab is enabled.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.enable = null;
            }
            return wijtabs_options;
        })();        
        ;
        wijtabs.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijtabs_options());
        $.wijmo.registerWidget("wijtabs", wijtabs.prototype);
        ;
    })(wijmo.tabs || (wijmo.tabs = {}));
    var tabs = wijmo.tabs;
})(wijmo || (wijmo = {}));
 

 
 /*
 *
 * Wijmo Library 3.20141.34
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="jquery.wijmo.wijstringinfo.ts"/>
    /// <reference path="jquery.wijmo.wijinputcore.ts"/>
    /// <reference path="../wijcalendar/jquery.wijmo.wijcalendar.ts"/>
    /// <reference path="jquery.wijmo.wijinputdateformat.ts"/>
    /// <reference path="../wijtabs/jquery.wijmo.wijtabs.ts"/>
    /*globals  wijDateTextProvider wijinputcore wijInputResult window document Globalize jQuery*/
    /*
    * Depends:
    *	jquery-1.4.2.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.ui.position.js
    *	jquery.effects.core.js
    *	jquery.effects.blind.js
    *	globalize.js
    *	jquery.mousewheel.js
    *	jquery.wijmo.wijpopup.js
    *	jquery.wijmo.wijcalendar.js
    *	jquery.wijmo.wijcharex.js
    *	jquery.wijmo.wijstringinfo.js
    *	jquery.wijmo.wijinputcore.js
    *  jquery.wijmo.wijinputdateformat.js
    *  jquery.wijmo.wijtabs.js
    *
    */
    (function (input) {
        "use strict";
        var $ = jQuery, jqKeyCode = wijmo.getKeyCodeEnum();
        //	var wijdigits = {
        //		useDefault: -2,
        //		asIs: -1,
        //		zero: 0,
        //		one: 1,
        //		two: 2,
        //		three: 3,
        //		four: 4,
        //		five: 5,
        //		six: 6,
        //		seven: 7,
        //		eight: 8
        //	}
        /** @widget */ var wijinputdate = (function (_super) {
            __extends(wijinputdate, _super);
            function wijinputdate() {
                _super.apply(this, arguments);

            }
            wijinputdate.prototype._create = function () {
                if(input.Utility.chrome) {
                    this.element.attr("type", "text");
                }
                _super.prototype._create.call(this);
            };
            wijinputdate.prototype._createTextProvider = function () {
                this._textProvider = new wijDateTextProvider(this, this.options.dateFormat, this.options.displayFormat);
            };
            wijinputdate.prototype._strToDate = function (str) {
                return this._textProvider.parseDate(str);
            };
            wijinputdate.prototype._beginUpdate = function () {
                var strDate, date = null;
                _super.prototype._beginUpdate.call(this);
                if(this.options.minDate) {
                    if(typeof this.options.minDate === 'string') {
                        this.options.minDate = this._strToDate(this.options.minDate);
                    }
                }
                if(this.options.maxDate) {
                    if(typeof this.options.maxDate === 'string') {
                        this.options.maxDate = this._strToDate(this.options.maxDate);
                    }
                }
                if(this.options.date === undefined) {
                    if(!!this.element.data('elementValue')) {
                        strDate = this.element.data('elementValue');
                    }
                } else {
                    if(typeof this.options.date === 'string') {
                        strDate = this.options.date;
                    } else {
                        date = this.options.date;
                    }
                }
                if(this.options.date === undefined) {
                    this.options.date = new Date();
                }
                if(strDate) {
                    date = this._strToDate(strDate);
                    if(date === null) {
                        date = new Date();
                    }
                }
                if(date == null) {
                    date = this.options.date;
                }
                this._safeSetDate(date);
                var culture = this._getCulture();
                if(culture != null) {
                    if(this.options.amDesignator == "") {
                        this.options.amDesignator = this._getStandardAMPM("AM");
                    }
                    if(this.options.pmDesignator == "") {
                        this.options.pmDesignator = this._getStandardAMPM("PM");
                    }
                }
                this.element.data({
                    defaultDate: date === null ? date : new Date(date.getTime()),
                    preDate: date === null ? date : new Date(date.getTime())
                });
                this._resetTimeStamp();
                this._initPicker();
                this.element.addClass(this.options.wijCSS.wijinputdate).attr({
                    'aria-valuemin': new Date(1900, 1, 1),
                    'aria-valuemax': new Date(2099, 1, 1),
                    'aria-valuenow': this.options.date
                });
            };
            wijinputdate.prototype._endUpdate = function () {
                var _this = this;
                _super.prototype._endUpdate.call(this);
                this.element.bind("click.wijinput", function () {
                    if(!_this._allowEdit()) {
                        return;
                    }
                    var oldActiveField = _this.options.activeField;
                    var range = _this.element.wijtextselection();
                    _this._updateText();
                    _this.element.wijtextselection(range);
                    if(_this.element.data('ignoreHighLight') != true) {
                        _this._highLightCursor();
                    }
                    if(input.Utility.chrome) {
                        if(_this.element.data('needResoteActiveField') == true) {
                            _this._setOption('activeField', oldActiveField);
                        }
                    }
                    _this.element.data('ignoreHighLight', false);
                });
            };
            wijinputdate.prototype._getInnerNullText = function () {
                if(this.options.placeholder != null) {
                    return this.options.placeholder;
                }
                if(this.options.showNullText) {
                    return this.options.nullText;
                }
                return null;
            };
            wijinputdate.prototype._getInnerAmDesignator = function () {
                return this.options.amDesignator == "" ? this._getStandardAMPM("AM") : this.options.amDesignator;
            };
            wijinputdate.prototype._getInnerPmDesignator = function () {
                return this.options.pmDesignator == "" ? this._getStandardAMPM("PM") : this.options.pmDesignator;
            };
            wijinputdate.prototype._getInnerIncrement = function () {
                var increment = Number(this.options.increment);
                if(isNaN(increment)) {
                    increment = 1;
                }
                return increment;
            };
            wijinputdate.prototype._getAllowSpinLoop = function () {
                return !!this.options.allowSpinLoop;
            };
            wijinputdate.prototype._getRealMaxDate = function () {
                return this.options.maxDate ? this.options.maxDate : new Date(9999, 11, 31, 23, 59, 59);
            };
            wijinputdate.prototype._getRealMinDate = function () {
                if(this.options.minDate) {
                    return this.options.minDate;
                }
                var minDate = new Date(1, 0, 1, 0, 0, 0);
                minDate.setFullYear(1);
                return minDate;
            };
            wijinputdate.prototype._getRealEraMaxDate = function () {
                if(this.options.maxDate) {
                    return input.DateTimeInfo.GetEraMax() < this.options.maxDate ? input.DateTimeInfo.GetEraMax() : this.options.maxDate;
                }
                return input.DateTimeInfo.GetEraMax();
            };
            wijinputdate.prototype._getRealEraMinDate = function () {
                if(this.options.minDate) {
                    return input.DateTimeInfo.GetEraMin() > this.options.minDate ? input.DateTimeInfo.GetEraMin() : this.options.minDate;
                }
                return input.DateTimeInfo.GetEraMin();
            };
            wijinputdate.prototype._isEraFormatExist = function () {
                return this._textProvider._isEraFormatExist();
            };
            wijinputdate.prototype._checkDate = function () {
                var oldDate = this.options.date;
                var newDate = this._checkRange(this.options.date);
                if(!input.DateTimeInfo.Equal(oldDate, newDate)) {
                    this._setOption("date", newDate);
                    this._trigger('valueBoundsExceeded', null);
                }
            };
            wijinputdate.prototype._checkRange = function (date) {
                if(date) {
                    if(this.options.minDate && date < this.options.minDate) {
                        date = new Date(Math.max(this.options.minDate, date));
                    }
                    if(this.options.maxDate && date > this.options.maxDate) {
                        date = new Date(Math.min(this.options.maxDate, date));
                    }
                }
                return date;
            };
            wijinputdate.prototype._safeSetDate = function (date, ignoreCheckRange) {
                var cache = date;
                if(!ignoreCheckRange) {
                    date = this._checkRange(date);
                }
                if(isNaN(date)) {
                    date = cache;
                }
                this.options.date = date;
                return true;
            };
            wijinputdate.prototype._safeGetDate = function (ignoreCheckRange) {
                var date = this.options.date;
                if(date == null) {
                    date = new Date();
                }
                if(!ignoreCheckRange) {
                    date = this._checkRange(date);
                }
                return date;
            };
            wijinputdate.prototype._setOption = function (key, value) {
                _super.prototype._setOption.call(this, key, value);
                switch(key) {
                    case 'pickers':
                        this._reInitPicker();
                        break;
                    case 'minDate':
                    case 'maxDate':
                        if(typeof this.options[key] === 'string') {
                            this.options[key] = this._strToDate(value);
                        }
                        var date = this.options.date;
                        if(date === null) {
                            date = new Date();
                        }
                        var minDate = this._getRealMinDate();
                        var maxDate = this._getRealMaxDate();
                        if(date < minDate || date > maxDate) {
                            this._safeSetDate(date);
                        }
                        this._updateText();
                        this._highLightField();
                        break;
                    case 'date':
                        if(!!value) {
                            if(typeof value === "string") {
                                value = this._strToDate(value);
                            } else if(typeof value === "object") {
                                value = new Date(value.getTime());
                            } else {
                                value = new Date(value);
                            }
                            if(isNaN(value)) {
                                value = new Date();
                            }
                        }
                        this._safeSetDate(value);
                        this._updateText();
                        this._highLightField();
                        break;
                    case 'midnightAs0':
                    case 'hour12As0':
                    case 'amDesignator':
                    case 'pmDesignator':
                        this._updateText();
                        this._highLightField();
                        break;
                    case 'culture':
                        this._textProvider._setFormat(this.options.dateFormat);
                        var displayFormat = this.options.displayFormat == "" ? this.options.dateFormat : this.options.displayFormat;
                        this._textProvider._setDisplayFormat(displayFormat);
                        this.options.amDesignator = this._getStandardAMPM("AM");
                        this.options.pmDesignator = this._getStandardAMPM("PM");
                        this._updateText();
                        var calendar = this.element.data('calendar');
                        if(calendar) {
                            calendar.wijcalendar("option", key, value);
                        }
                        this._reInitPicker();
                        break;
                    case 'dateFormat':
                        this._textProvider._setFormat(this.options.dateFormat);
                        if(this.options.displayFormat == "") {
                            this._textProvider._setDisplayFormat(this.options.dateFormat);
                        }
                        if(this._isEraFormatExist() && this.options.date != null) {
                            var minYear = this._getRealEraMinDate();
                            var maxYear = this._getRealEraMaxDate();
                            if(this.options.date < minYear) {
                                this._setOption("date", minYear);
                            } else if(this.options.date > maxYear) {
                                this._setOption("date", maxYear);
                            }
                        }
                        this._updateText();
                        // update the calendar 's culture
                        var calendar = this.element.data('calendar');
                        if(calendar) {
                            calendar.wijcalendar("option", key, value);
                        }
                        this._reInitPicker();
                        break;
                    case 'displayFormat':
                        var displayFormat = this.options.displayFormat == "" ? this.options.dateFormat : this.options.displayFormat;
                        this._textProvider._setDisplayFormat(displayFormat);
                        this._updateText();
                        break;
                    case 'activeField':
                        value = Math.min(value, this._textProvider.getFieldCount() - 1);
                        value = Math.max(value, 0);
                        this.options.activeField = value;
                        this._checkDate();
                        if(this.element.data('ignoreHighLight') != true) {
                            this._highLightField();
                        }
                        this._resetTimeStamp();
                        break;
                        //add for localization(calendar's tooltip)
                                            case 'nextTooltip':
                    case 'prevTooltip':
                    case 'titleFormat':
                    case 'toolTipFormat':
                        // update the calendar 's tooltip
                        var calendar = this.element.data('calendar', calendar);
                        if(calendar) {
                            calendar.wijcalendar("option", key, value);
                        }
                        break;
                    case "comboItems":
                        this._reInitPicker();
                        break;
                }
            };
            wijinputdate.prototype._setData = function (val) {
                this.option('date', val);
            };
            wijinputdate.prototype._resetData = function () {
                var d = this.element.data('defaultDate');
                if(d === undefined || d === null) {
                    d = this.element.data('elementValue');
                    if(d !== undefined && d !== null && d !== "") {
                        this.setText(d);
                    } else {
                        this._setData(null);
                    }
                } else {
                    this._setData(d);
                }
            };
            wijinputdate.prototype._resetTimeStamp = function () {
                this.element.data('cursorPos', 0);
                this.element.data('timeStamp', new Date('1900/1/1'));
                this.element.data("lastInputChar", "");
            };
            wijinputdate.prototype.getPostValue = /** Gets the text value when the container form is posted back to server.
            */
            function () {
                if(!this._isInitialized()) {
                    return this.element.val();
                }
                if(_super.prototype._showNullText.call(this) && this.isDateNull()) {
                    return "";
                }
                var val = this._textProvider.toString();
                if(val === this.options.nullText) {
                    return "";
                }
                return val;
            };
            wijinputdate.prototype._highLightAllField = function () {
                if(this.isFocused()) {
                    var range = this._textProvider.getAllRange();
                    if(range) {
                        try  {
                            this.element.wijtextselection(range);
                        } catch (e) {
                        }
                    }
                }
            };
            wijinputdate.prototype._highLightField = function (index) {
                if (typeof index === "undefined") { index = this.options.activeField; }
                if(this.isFocused()) {
                    var range = this._textProvider.getFieldRange(index);
                    if(range) {
                        try  {
                            this.element.wijtextselection(range);
                        } catch (e) {
                        }
                    }
                }
            };
            wijinputdate.prototype._highLightCursor = function (pos) {
                if(this._isNullText()) {
                    return;
                }
                if(pos === undefined) {
                    pos = Math.max(0, this.element.wijtextselection().start);
                }
                var index = this._textProvider.getCursorField(pos);
                if(index < 0) {
                    return;
                }
                this._setOption('activeField', index);
            };
            wijinputdate.prototype._toNextField = function () {
                this._setOption('activeField', this.options.activeField + 1);
            };
            wijinputdate.prototype._toPrevField = function () {
                this._setOption('activeField', this.options.activeField - 1);
            };
            wijinputdate.prototype._toFirstField = function () {
                this._setOption('activeField', 0);
            };
            wijinputdate.prototype._toLastField = function () {
                this._setOption('activeField', this._textProvider.getFieldCount());
            };
            wijinputdate.prototype._clearField = function (index) {
                if (typeof index === "undefined") { index = this.options.activeField; }
                var range = this._textProvider.getFieldRange(index), rh, self = this;
                if(range) {
                    rh = new input.wijInputResult();
                    this._textProvider.removeAt(range.start, range.end, rh);
                    this._updateText();
                    window.setTimeout(function () {
                        self._highLightField();
                    }, 1);
                }
            };
            wijinputdate.prototype.spinUp = /** Performs spin up by the active field and increment value.
            */
            function () {
                this._doSpin(true, false);
            };
            wijinputdate.prototype.spinDown = /** Performs spin down by the active field and increment value.
            */
            function () {
                this._doSpin(false, false);
            };
            wijinputdate.prototype.drop = /** Open the dropdown window.
            */
            function () {
                _super.prototype._onTriggerClicked.call(this);
            };
            wijinputdate.prototype.focus = /** Set the focus to the widget.
            */
            function () {
                _super.prototype.focus.call(this);
                this._addState('focus', this.outerDiv);
                this._updateText();
                if(this.options.highlightText == "all") {
                    this._highLightAllField();
                } else {
                    this._highLightField();
                }
            };
            wijinputdate.prototype.isDateNull = /** Determines whether the date is a null value.
            */
            function () {
                return this.options.date === null || this.options.date === undefined;
            };
            wijinputdate.prototype._min = function (value1, value2) {
                if(value2 == undefined) {
                    return value1;
                }
                return value1 < value2 ? value1 : value2;
            };
            wijinputdate.prototype._max = function (value1, value2) {
                if(value2 == undefined) {
                    return value1;
                }
                return value1 > value2 ? value1 : value2;
            };
            wijinputdate.prototype._allowEdit = function () {
                return !this.option('disableUserInput');
            };
            wijinputdate.prototype._onFocus = function (e) {
                _super.prototype._onFocus.call(this, e);
                if(!this._allowEdit()) {
                    return;
                }
                this._updateText();
                if(this.element.data('IsInSelectTextMethod') == true) {
                    return;
                }
                if(input.Utility.chrome) {
                    var self = this;
                    self.element.data('needResoteActiveField', true);
                    window.setTimeout(function () {
                        self.element.data('needResoteActiveField', false);
                        if(self.options.highlightText == "all") {
                            self._highLightAllField();
                        } else {
                            self._highLightField();
                        }
                    }, 200);
                } else {
                    if(this.options.highlightText == "all") {
                        this._highLightAllField();
                        this.element.data('ignoreHighLight', true);
                    } else {
                        this._highLightField();
                    }
                }
            };
            wijinputdate.prototype._simulate = function (text) {
                var str = null;
                if(typeof text === "string") {
                    str = text;
                } else {
                    var range = this.element.wijtextselection();
                    var start = this.element.data('lastSelection').start;
                    var end = range.end;
                    if(end >= start) {
                        str = this.element.val().substring(start, end);
                    }
                }
                for(var era = 0; era < input.DateTimeInfo.GetEraCount(); era++) {
                    if((str.toLowerCase() === input.DateTimeInfo.GetEraShortNames()[era].toLowerCase()) || (str.toLowerCase() === input.DateTimeInfo.GetEraAbbreviations()[era].toLowerCase()) || (str.toLowerCase() === input.DateTimeInfo.GetEraSymbols()[era].toLowerCase()) || (str.toLowerCase() === input.DateTimeInfo.GetEraNames()[era].toLowerCase())) {
                        str = input.DateTimeInfo.GetEraShortNames()[era].toLowerCase();
                        break;
                    }
                }
                _super.prototype._simulate.call(this, str);
            };
            wijinputdate.prototype._doSpin = function (up, repeating) {
                var _this = this;
                if(!this._allowEdit()) {
                    return false;
                }
                if(repeating && this.element.data('breakSpinner')) {
                    return false;
                }
                if(up) {
                    this._trigger('spinUp', null);
                } else {
                    this._trigger('spinDown', null);
                }
                if(this.options.date == null) {
                    this._setDefaultDate(up);
                    return;
                }
                var spinResult = false;
                if(up) {
                    spinResult = this._textProvider.incEnumPart();
                } else {
                    spinResult = this._textProvider.decEnumPart();
                }
                if(spinResult) {
                    this._updateText();
                    this._highLightField();
                }
                if(repeating && !this.element.data('breakSpinner')) {
                    var spinTimer = window.setTimeout(function () {
                        return _this._doSpin(up, true);
                    }, this._calcSpinInterval());
                    this.element.data("spintimer", spinTimer);
                }
                return true;
            };
            wijinputdate.prototype._setDefaultDate = function (up) {
                if(up) {
                    this.options.date = this._isEraFormatExist() ? this._getRealEraMinDate() : this._getRealMinDate();
                } else {
                    this.options.date = this._isEraFormatExist() ? this._getRealEraMaxDate() : this._getRealMaxDate();
                }
                this._updateText();
                this._highLightField();
            };
            wijinputdate.prototype._onChange = function () {
            };
            wijinputdate.prototype._afterFocused = function () {
                if(this._isNullText()) {
                    this._doFocus();
                }
                //var hc = () => {
                //	this._highLightCursor();
                //	this._resetTimeStamp();
                //};
                // to fixed the issue 27522. remove this time out. by dail 2012-9-6
                //window.setTimeout(hc, 10);
                            };
            wijinputdate.prototype._onBlur = function (e) {
                _super.prototype._onBlur.call(this, e);
                this._checkDate();
                this._removeState('focus', this.outerDiv);
                this._updateText();
            };
            wijinputdate.prototype._keyDownPreview = function (e) {
                if(_super.prototype._keyDownPreview.call(this, e)) {
                    return true;
                }
                var key = e.keyCode || e.which, selRange;
                switch(key) {
                    case jqKeyCode.UP:
                    case jqKeyCode.DOWN:
                        if(e.altKey) {
                            this._onTriggerClicked();
                            return true;
                        } else {
                            if(this.element.data("pickerCurrentTab") != "List") {
                                this._doSpin(key == jqKeyCode.UP, false);
                                this._stopEvent(e);
                                return true;
                            }
                        }
                        break;
                    case jqKeyCode.LEFT:
                        if(this.options.activeField == 0 && (this.options.blurOnLeftRightKey.toLowerCase() == "left" || this.options.blurOnLeftRightKey.toLowerCase() == "both")) {
                            input.Utility.MoveFocus(this.element.get(0), false);
                            this._trigger('keyExit');
                        } else {
                            this._toPrevField();
                        }
                        return true;
                    case jqKeyCode.RIGHT:
                        if(this.options.activeField == this._textProvider.getFieldCount() - 1 && (this.options.blurOnLeftRightKey.toLowerCase() == "right" || this.options.blurOnLeftRightKey.toLowerCase() == "both")) {
                            input.Utility.MoveFocus(this.element.get(0), true);
                            this._trigger('keyExit');
                        } else {
                            this._toNextField();
                        }
                        return true;
                    case jqKeyCode.ENTER:
                        if(this._wasPopupShowing) {
                            if(this.element.data("pickerCurrentTab") == "Calendar") {
                                if(this.options.date == null) {
                                    this._setOption('date', new Date());
                                }
                            } else if(this.element.data("pickerCurrentTab") == "List") {
                                this._processKeyForDropDownList(e);
                            } else {
                                this._okButtonMouseDown(null, null);
                            }
                            this._hidePopup();
                            return true;
                        } else {
                            if(this.options.hideEnter) {
                                _super.prototype._stopEvent.call(this, e);
                            }
                        }
                        break;
                    case jqKeyCode.TAB:
                        if(this.options.tabAction !== "field" || this.options.highlightText !== "field") {
                            this._trigger('keyExit');
                            break;
                        }
                        selRange = this.element.wijtextselection();
                        if(selRange && selRange.end - selRange.start !== this.element.val().length) {
                            if(e.shiftKey) {
                                if(this.options.activeField > 0) {
                                    this._toPrevField();
                                } else {
                                    this._trigger('keyExit');
                                    break;
                                }
                            } else {
                                if(this.options.activeField < this._textProvider.getFieldCount() - 1) {
                                    this._toNextField();
                                } else {
                                    this._trigger('keyExit');
                                    break;
                                }
                            }
                        }
                        return true;
                    case jqKeyCode.SPACE:
                    case 188:
                        // ,
                                            case 190:
                        // .
                                            case 110:
                        // . on pad
                                            case 191:
                        // /
                        if(e.shiftKey) {
                            if(this.options.activeField > 0) {
                                this._toPrevField();
                                return true;
                            }
                        } else {
                            if(this.options.activeField < this._textProvider.getFieldCount() - 1) {
                                this._toNextField();
                                return true;
                            }
                        }
                        break;
                    case jqKeyCode.HOME:
                        if(e.ctrlKey) {
                            this._setOption('date', new Date());
                        } else {
                            this._toFirstField();
                        }
                        return true;
                    case jqKeyCode.END:
                        if(e.ctrlKey) {
                            this._processClearButton();
                        } else {
                            this._toLastField();
                        }
                        return true;
                    case jqKeyCode.BACKSPACE:
                    case jqKeyCode.DELETE:
                        if(this._allowEdit()) {
                            this._processDeleteKey();
                            return true;
                        }
                        break;
                }
                return false;
            };
            wijinputdate.prototype._processDeleteKey = function () {
                if(this.options.date == null) {
                    return;
                }
                var selRange = this.element.wijtextselection();
                if(selRange.end - selRange.start === this.element.val().length) {
                    var minDate = this._isEraFormatExist() ? this._getRealEraMinDate() : this._getRealMinDate();
                    if(this.options.date > minDate) {
                        this._setOption('date', minDate);
                        return;
                    }
                } else {
                    var activeField = this.options.activeField;
                    var oldText = this._textProvider.getFiledText(activeField);
                    this._clearField();
                    var newText = this._textProvider.getFiledText(activeField);
                    if(oldText != newText) {
                        return;
                    }
                }
                this._processClearButton();
            };
            wijinputdate.prototype._autoMoveToNextField = function (pos, ch) {
                if(!this.options.autoNextField) {
                    return;
                }
                if(this._textProvider.needToMove(this.options.activeField, pos, ch)) {
                    this._toNextField();
                }
            };
            wijinputdate.prototype._processClearButton = function () {
                if(this._allowEdit()) {
                    this._setOption('date', null);
                } else {
                    this._updateText();
                }
            };
            wijinputdate.prototype._autoMoveToNextControl = function (pos, ch, activeField) {
                if(!this.options.blurOnLastChar || activeField !== this._textProvider.getFieldCount() - 1) {
                    return;
                }
                if(this._textProvider.needToMove(activeField, pos, ch)) {
                    input.Utility.MoveFocus(this.element.get(0), true);
                    this._trigger('keyExit');
                }
            };
            wijinputdate.prototype._keyPressPreview = function (e) {
                var key = e.keyCode || e.which, range, ch, fieldSep, cursor, now, newAction, lastTime, pos, ret, input, lastInput;
                if(key === jqKeyCode.ENTER) {
                    if(this.isDateNull()) {
                        this._setOption("date", new Date());
                    }
                    return false;
                }
                range = this._textProvider.getFieldRange(this.options.activeField);
                if(range) {
                    if(key === jqKeyCode.TAB) {
                        return true;
                    }
                    if(key === jqKeyCode.SPACE) {
                        this._stopEvent(e);
                        return true;
                    }
                    ch = String.fromCharCode(key);
                    fieldSep = this._textProvider.isFieldSep(ch, this.options.activeField);
                    if(fieldSep) {
                        this._toNextField();
                        this._stopEvent(e);
                        return true;
                    }
                    cursor = this.element.data('cursorPos');
                    now = new Date();
                    lastTime = this.element.data('timeStamp');
                    lastInput = this.element.data('lastInput');
                    newAction = (now.getTime() - lastTime.getTime()) > this.options.keyDelay;
                    var input = ch;
                    if(newAction) {
                        cursor = 0;
                    } else if(lastInput) {
                        input = lastInput + input;
                    }
                    this.element.data({
                        timeStamp: now,
                        lastInput: input
                    });
                    pos = range.start + cursor;
                    this.element.data('cursorPos', ++cursor);
                    var nullFlag = this.options.date == null;
                    ret = this._textProvider.addToField(input, this.options.activeField, pos);
                    var activeField = this.options.activeField;
                    if(ret) {
                        this._updateText();
                        this._autoMoveToNextField(cursor, ch);
                        this._highLightField();
                        this._autoMoveToNextControl(cursor, ch, activeField);
                    } else {
                        if(nullFlag) {
                            this._setOption("date", null);
                        }
                        this._resetTimeStamp();
                        this._fireIvalidInputEvent();
                    }
                    if(activeField != this.options.activeField) {
                        this.element.data("lastInputChar", "");
                    } else {
                        this.element.data("lastInputChar", ch);
                    }
                    this._stopEvent(e);
                    return true;
                }
                return false;
            };
            wijinputdate.prototype._raiseDataChanged = function () {
                var d = this.options.date, prevDt = this.element.data('preDate');
                this.element.data('preDate', !d ? null : new Date(d.getTime()));
                if((!prevDt && d) || (prevDt && !d) || (prevDt && d && (prevDt.getTime() !== d.getTime()))) {
                    if(this._popupVisible()) {
                        // DaryLuo 2013/09/04, improve performance on IE7.
                        // Sync calendar will cost a lot of time.
                        this._syncCalendar();
                    }
                    this.element.attr('aria-valuenow', d);
                    this._trigger('dateChanged', null, {
                        date: d
                    });
                }
            };
            wijinputdate.prototype._isMinDate = function (date) {
                return date.getFullYear() === 1 && date.getMonth() === 0 && date.getDate() === 1;
            };
            wijinputdate.prototype._reInitPicker = function () {
                this._destroyPicker();
                this._initPicker();
            };
            wijinputdate.prototype._destroy = function () {
                _super.prototype._destroy.call(this);
                this._destroyPicker();
            };
            wijinputdate.prototype._destroyPicker = function () {
                var tablePicker = this.element.data('pickers');
                if(tablePicker != undefined) {
                    tablePicker.remove();
                    this.element.data('pickers', null);
                    this.element.data('calendar', null);
                    this.element.data('datePicker', null);
                    this.element.data('timePicker', null);
                    this._comboDiv = undefined;
                }
            };
            wijinputdate.prototype._initPicker = function () {
                var _this = this;
                var tablePicker = this.element.data('pickers');
                if(tablePicker != undefined) {
                    return;
                }
                var self = this;
                this._initPickerData();
                var pickerCount = this._getPickerCount();
                var pickerWidth = this.element.data('pickerWidth');
                var pickerHeight = this.element.data('pickerHeight');
                var pickerAreaHeight = this.element.data('pickerAreaHeight');
                if(pickerCount > 1) {
                    pickerHeight += 8;
                    pickerAreaHeight += 8;
                }
                var pickerDivHeight = pickerCount > 1 ? pickerHeight : pickerAreaHeight;
                tablePicker = $("<table/>").appendTo(document.body).attr({
                    "class": "ui-widget-content ui-corner-all",
                    "borderWidth": "0px",
                    "cellspacing": "0px",
                    "cellpadding": "0px",
                    "cursor": "default"
                }).css({
                    "font-size": "12px"
                });
                var trPicker = $("<tr/>").appendTo(tablePicker);
                var trButton = $("<tr/>").appendTo(tablePicker);
                var tdPicker = $("<td/>").appendTo(trPicker).css({
                    "width": "100%",
                    "height": "100%"
                });
                var tdButton = $("<td/>").appendTo(trButton).attr("align", "center").css({
                    "width": "100%",
                    "height": "30px",
                    "display": "none"
                });
                var divOK = $("<input type='button'/>").appendTo(tdButton).attr({
                    "class": "ui-state-active ui-widget",
                    "value": "OK"
                }).css({
                    "width": "80px",
                    "height": "26px",
                    "margin": "1px",
                    "text-align": "center",
                    "cursor": "pointer",
                    "visibility": "hidden"
                }).mousedown(function (e, arg) {
                    self._okButtonMouseDown(e, arg);
                });
                var divPickers = $("<div/>").appendTo(tdPicker).css({
                    "width": "100%",
                    "height": "100%",
                    "padding": "0px",
                    "margin": "0px",
                    "borderWidth": "0px",
                    "overflow": "hidden"
                });
                var ulPicker = $("<ul/>").css({
                    "line-height": "1px",
                    "font-size": "12px"
                });
                if(pickerCount > 1) {
                    ulPicker.appendTo(divPickers);
                }
                var currentTab = "";
                if(this._isCalendarPickerShown()) {
                    if(pickerCount > 1) {
                        this._addPickerTab(ulPicker, "Calendar", "#calendarDiv");
                    } else {
                        if(input.Utility.IsIE9()) {
                            tdPicker.css({
                                "width": ""
                            });
                            divPickers.css({
                                "width": ""
                            });
                        }
                    }
                    this._initCalendarPicker();
                    var calendar = this.element.data('calendar');
                    this._addPickerEditor(divPickers, calendar, "calendarDiv");
                    currentTab = "Calendar";
                }
                if(this._isListPickerShown()) {
                    if(pickerCount > 1) {
                        this._addPickerTab(ulPicker, "List", "#listDiv");
                    }
                    this._initListPicker();
                    this._addPickerEditor(divPickers, this._comboDiv, "listDiv");
                    currentTab = currentTab == "" ? "List" : currentTab;
                }
                if(this._isDatePickerShown()) {
                    if(pickerCount > 1) {
                        this._addPickerTab(ulPicker, "Date", "#dateDiv");
                    }
                    this._initDatePicker();
                    var datePicker = this.element.data('datePicker');
                    this._addPickerEditor(divPickers, datePicker, "dateDiv");
                    currentTab = currentTab == "" ? "Date" : currentTab;
                }
                if(this._isTimePickerShown()) {
                    if(pickerCount > 1) {
                        this._addPickerTab(ulPicker, "Time", "#timeDiv");
                    }
                    this._initTimePicker();
                    var timePicker = this.element.data('timePicker');
                    this._addPickerEditor(divPickers, timePicker, "timeDiv");
                    currentTab = currentTab == "" ? "Time" : currentTab;
                }
                if(currentTab == "Calendar") {
                    tablePicker.css({
                        "width": pickerWidth + "px",
                        "height": "",
                        "font-size": ""
                    });
                } else if(currentTab == "Date" || currentTab == "Time") {
                    tdButton.css({
                        "display": ""
                    });
                    tablePicker.css({
                        "width": pickerWidth + "px",
                        "height": pickerHeight + "px",
                        "font-size": "12px"
                    });
                    divPickers.css({
                        "height": pickerDivHeight + "px"
                    });
                }
                this.element.data("pickerCurrentTab", currentTab);
                var self = this;
                divPickers.wijtabs({
                    select: function (e, arg) {
                        var tabText = arg.tab.outerText || arg.tab.text;
                        tdButton.css({
                            "display": "none"
                        });
                        self.element.data("pickerCurrentTab", tabText);
                        if(tabText == "Calendar") {
                            self.focus();
                            tablePicker.css({
                                "width": pickerWidth + "px",
                                "height": "",
                                "font-size": ""
                            });
                            divPickers.css({
                                "height": "100%"
                            });
                        } else if(tabText == "List") {
                            var listWidth = self._getListPickerWidth();
                            self._comboDiv.wijlist("option", "width", listWidth);
                            tablePicker.css({
                                "width": listWidth,
                                "height": "",
                                "font-size": ""
                            });
                            divPickers.css({
                                "height": "100%"
                            });
                            self._comboDiv.wijlist('renderList');
                            self._comboDiv.focus();
                        } else {
                            self.focus();
                            if(tabText == "Time" || tabText == "Date") {
                                tdButton.css({
                                    "display": ""
                                });
                                tablePicker.css({
                                    "width": pickerWidth + "px",
                                    "height": pickerHeight + "px",
                                    "font-size": "12px"
                                });
                                divPickers.css({
                                    "height": pickerDivHeight + "px"
                                });
                            }
                        }
                    }
                });
                tablePicker.wijpopup({
                    autoHide: true,
                    hidden: function () {
                        _this._trigger('dropDownClose');
                        _this._wasPopupShowing = false;
                    },
                    shown: function () {
                        _this._trigger('dropDownOpen');
                        _this._wasPopupShowing = true;
                    }
                });
                this.element.data('pickers', tablePicker);
                this.element.data('divPickers', divPickers);
                this.element.data('divOK', divOK);
            };
            wijinputdate.prototype._initPickerData = function () {
                var tabWidth = 70;
                var tabHeight = 32;
                var listItemHeight = 26;
                var buttonHeight = 30;
                var minPickerWidth = 150;
                var minPickerHeight = 100;
                var minCalendarPickerWidth = 235;
                var minCalendarPickerHeight = 242;
                var minDateTimePickerWidth = 220;
                var minDateTimePickerHeight = 220;
                var pickerCount = this._getPickerCount();
                var minWidth = pickerCount * tabWidth;
                var minHeight = minPickerHeight;
                minWidth = minWidth < minPickerWidth ? minPickerWidth : minWidth;
                if(this._isCalendarPickerShown()) {
                    minWidth = minWidth < minCalendarPickerWidth ? minCalendarPickerWidth : minWidth;
                    minHeight = minHeight < minCalendarPickerHeight ? minCalendarPickerHeight : minHeight;
                }
                if(this._isListPickerShown()) {
                    var listItem = this._getcomboItems();
                    if(listItem != undefined) {
                        var minListHeight = listItem.length * listItemHeight;
                        minHeight = minHeight < minListHeight ? minListHeight : minHeight;
                    }
                }
                if(this._isDatePickerShown()) {
                    minWidth = minWidth < minDateTimePickerWidth ? minDateTimePickerWidth : minWidth;
                    minHeight = minHeight < minDateTimePickerWidth ? minDateTimePickerWidth : minHeight;
                    var pickerMinYear = this._getDatePickerMinYear();
                    var pickerMaxYear = this._getDatePickerMaxYear();
                    var defaultDateFormat = this._getDefaultDatePickerFormat();
                    var pickerFormat = this.options.pickers.datePicker.format != undefined ? this.options.pickers.datePicker.format : defaultDateFormat;
                    var pickerDateFormat = pickerFormat.split(',');
                    if(pickerDateFormat.length != 3) {
                        pickerDateFormat = defaultDateFormat.split(',');
                        this.options.pickers.datePicker.format = defaultDateFormat;
                    }
                    var yearFormat = this._getRollFormat(pickerDateFormat, "y");
                    var monthFormat = this._getRollFormat(pickerDateFormat, "M");
                    var dayFormat = this._getRollFormat(pickerDateFormat, "d");
                    if(!this._isValidatePickerFormat(yearFormat) || !this._isValidatePickerFormat(monthFormat) || !this._isValidatePickerFormat(dayFormat)) {
                        pickerDateFormat = defaultDateFormat.split(',');
                        yearFormat = this._getRollFormat(pickerDateFormat, "y");
                        monthFormat = this._getRollFormat(pickerDateFormat, "M");
                        dayFormat = this._getRollFormat(pickerDateFormat, "d");
                        this.options.pickers.datePicker.format = defaultDateFormat;
                    }
                    this.element.data('pickerDateYearFormat', yearFormat);
                    this.element.data('pickerDateMonthFormat', monthFormat);
                    this.element.data('pickerDateDayFormat', dayFormat);
                    this.element.data('pickerMinYear', pickerMinYear);
                    this.element.data('pickerMaxYear', pickerMaxYear);
                    this.element.data('pickerDateFormat', pickerDateFormat);
                }
                if(this._isTimePickerShown()) {
                    minWidth = minWidth < minDateTimePickerWidth ? minDateTimePickerWidth : minWidth;
                    minHeight = minHeight < minDateTimePickerWidth ? minDateTimePickerWidth : minHeight;
                    var defaultTimeFormat = this._getDefaultTimePickerFormat();
                    var format = this.options.pickers.timePicker.format != undefined ? this.options.pickers.timePicker.format : defaultTimeFormat;
                    var pickerTimeFormat = format.split(',');
                    if(pickerTimeFormat.length != 3) {
                        pickerTimeFormat = defaultTimeFormat.split(',');
                        this.options.pickers.timePicker.format = defaultTimeFormat;
                    }
                    var hourFormat = this._getRollFormat(pickerTimeFormat, "h");
                    var minuteFormat = this._getRollFormat(pickerTimeFormat, "m");
                    var amFormat = this._getRollFormat(pickerTimeFormat, "t");
                    if(!this._isValidatePickerFormat(hourFormat) || !this._isValidatePickerFormat(minuteFormat) || !this._isValidatePickerFormat(amFormat)) {
                        pickerTimeFormat = defaultTimeFormat.split(',');
                        hourFormat = this._getRollFormat(pickerTimeFormat, "h");
                        minuteFormat = this._getRollFormat(pickerTimeFormat, "m");
                        amFormat = this._getRollFormat(pickerTimeFormat, "t");
                        this.options.pickers.timePicker.format = defaultTimeFormat;
                    }
                    this.element.data('pickerTimeHourFormat', hourFormat);
                    this.element.data('pickerTimeMinuteFormat', minuteFormat);
                    this.element.data('pickerTimeAMFormat', amFormat);
                    this.element.data('pickerTimeFormat', pickerTimeFormat);
                }
                var pickerWidth = this.options.pickers.width != undefined ? this.options.pickers.width : 0;
                var pickerHeight = this.options.pickers.height != undefined ? this.options.pickers.height : 0;
                pickerWidth = pickerWidth < minWidth ? minWidth : pickerWidth;
                pickerHeight = pickerHeight < minHeight ? minHeight : pickerHeight;
                pickerHeight -= pickerCount > 1 ? tabHeight : 0;
                var pickerAreaHeight = pickerHeight - buttonHeight;
                var itemHeight = Math.floor(pickerAreaHeight / 5) + 1;
                var indicatorHeight = itemHeight * 2;
                var indicatorTranslateTop = itemHeight * 5 + 6;
                var indicatorTranslateDown = itemHeight * 4 - 3;
                var indicatorTranslateSelector = itemHeight * 2 + 2;
                var indicatorTranslateContent = itemHeight;
                this.element.data('itemHeight', itemHeight);
                this.element.data('indicatorHeight', indicatorHeight);
                this.element.data('pickerWidth', pickerWidth);
                this.element.data('pickerHeight', pickerHeight);
                this.element.data('pickerAreaHeight', pickerAreaHeight);
                this.element.data('indicatorTranslateTop', indicatorTranslateTop);
                this.element.data('indicatorTranslateDown', indicatorTranslateDown);
                this.element.data('indicatorTranslateSelector', indicatorTranslateSelector);
                this.element.data('indicatorTranslateContent', indicatorTranslateContent);
            };
            wijinputdate.prototype._initListPicker = function () {
                var _this = this;
                if(this._comboDiv !== undefined) {
                    return;
                }
                this._comboDiv = $("<div/>").css({
                    "overflow": "hidden",
                    "display": "block",
                    "left": "",
                    "top": "",
                    "position": ""
                });
                var content = this._normalize(this._getcomboItems());
                this._comboDiv.wijlist({
                    maxItemsCount: 5,
                    autoSize: true,
                    selected: function (event, ui) {
                        if(!_this.options.disableUserInput) {
                            _this._setData(ui.item.value);
                        }
                        var pickers = _this.element.data('pickers');
                        if(pickers != undefined) {
                            pickers.wijpopup('hide');
                        }
                        _this._trySetFocus();
                    }
                });
                this._comboDiv.wijlist('setItems', content);
                this._comboDiv.wijlist('renderList');
                if(input.Utility.IsIE7()) {
                    this._comboDiv.attr("align", "left");
                }
            };
            wijinputdate.prototype._initCalendarPicker = function () {
                var _this = this;
                var calendar = this.element.data('calendar');
                if(calendar != undefined) {
                    return;
                }
                var c = this.options.calendar;
                if(c === undefined || c === null) {
                    return;
                }
                if(typeof (c) === 'boolean' || c === 'default') {
                    c = $("<div/>");
                }
                calendar = $(c);
                if(calendar.length !== 1) {
                    return;
                }
                this.element.data('calendar', calendar);
                // if the localization from the resource files.
                if(this.options.localization) {
                    this.options.nextTooltip = this.options.localization.nextTooltip;
                    this.options.prevTooltip = this.options.localization.prevTooltip;
                    this.options.titleFormat = this.options.localization.titleFormat;
                    this.options.toolTipFormat = this.options.localization.toolTipFormat;
                }
                calendar.wijcalendar({
                    popupMode: true,
                    culture: this.options.culture,
                    nextTooltip: //add for localization(tooltip)
                    this.options.nextTooltip || 'Next',
                    prevTooltip: this.options.prevTooltip || 'Previous',
                    titleFormat: this.options.titleFormat || 'MMMM yyyy',
                    toolTipFormat: this.options.toolTipFormat || 'dddd, MMMM dd, yyyy',
                    selectedDatesChanged: function () {
                        var selDate = calendar.wijcalendar("getSelectedDate"), curDate = _this.option('date');
                        _super.prototype._wasPopupShowing = false;
                        var pickers = _this.element.data('pickers');
                        if(pickers != undefined) {
                            pickers.wijpopup('hide');
                        }
                        if(selDate) {
                            if(curDate) {
                                selDate.setHours(curDate.getHours());
                                selDate.setMinutes(curDate.getMinutes());
                                selDate.setSeconds(curDate.getSeconds());
                                selDate.setMilliseconds(curDate.getMilliseconds());
                            }
                            if(_this._allowEdit()) {
                                _this.option('date', selDate);
                                _this.selectText();
                            }
                        }
                        _this._trySetFocus();
                    }
                });
                calendar.css({
                    "display": "block",
                    "left": "",
                    "top": "",
                    "position": "",
                    "margin-bottom": "0px"
                });
                this._syncCalendar();
                this._updateCalendarPicker();
                // the bind event can't trigger.!!!
                //            calendar.bind('wijcalendarselectedDatesChanged', function () {
                //                var selDate = $(this).wijcalendar("getSelectedDate");
                //                $(this).wijcalendar("close");
                //                if (!!selDate) { self.option('date', selDate); }
                //                self._trySetFocus();
                //               });
                            };
            wijinputdate.prototype._initTimePicker = function () {
                var timePicker = this.element.data('timePicker');
                if(timePicker != undefined) {
                    return;
                }
                var self = this;
                var height = this.element.data('itemHeight') * 5;
                var pickerWidth = this.element.data('pickerWidth');
                var itemHeight = this.element.data('itemHeight') + "px";
                var indicatorHeight = this.element.data('indicatorHeight') + "px";
                var indicatorTranslateTop = this.element.data('indicatorTranslateTop');
                var indicatorTranslateDown = this.element.data('indicatorTranslateDown');
                var indicatorTranslateSelector = this.element.data('indicatorTranslateSelector');
                var indicatorTranslateContent = this.element.data('indicatorTranslateContent');
                var div = this._createDivElement(document.body, pickerWidth + "px");
                var divIndicator = this._createDivIndicatiorElement(div, itemHeight, "", indicatorTranslateSelector);
                var table = this._createTableElement(div, height + "px", "-", indicatorTranslateContent);
                var trTime = $("<tr/>").appendTo(table);
                // Hour
                var tdHour = $("<td/>").css({
                    "width": "33%"
                });
                var divHour = this._createPickerDivElement(tdHour, height);
                var divHourMask = this._createMaskElement(divHour, height);
                var pickerHourArray = {
                };
                for(var i = 1; i <= 12; i++) {
                    var text = this._getRollText(i, this.element.data('pickerTimeHourFormat'));
                    var itemDiv = this._createItemElement(i, divHourMask, itemHeight, text);
                    //itemDiv.mousedown(function (e, arg) {
                    //    self._hourMouseDown(e, arg);
                    //});
                    pickerHourArray[i - 1] = itemDiv;
                }
                //Minute
                var tdMinute = $("<td/>").css({
                    "width": "33%"
                });
                var divMinute = this._createPickerDivElement(tdMinute, height);
                var divMinuteMask = this._createMaskElement(divMinute, height);
                var pickerMinuteArray = {
                };
                for(var i = 0; i < 60; i++) {
                    var text = this._getRollText(i, this.element.data('pickerTimeMinuteFormat'));
                    var itemDiv = this._createItemElement(i, divMinuteMask, itemHeight, text);
                    //itemDiv.mousedown(function (e, arg) {
                    //    self._minuteMouseDown(e, arg);
                    //});
                    pickerMinuteArray[i] = itemDiv;
                }
                //AM
                var tdAM = $("<td/>").css({
                    "width": "34%"
                });
                var divAM = this._createPickerDivElement(tdAM, height);
                var divAMMask = this._createMaskElement(divAM, height);
                var pickerAMArray = {
                };
                for(var i = 0; i < 2; i++) {
                    var text = this._getRollText(i, this.element.data('pickerTimeAMFormat'));
                    var itemDiv = this._createItemElement(i, divAMMask, itemHeight, text);
                    //itemDiv.mousedown( function (e, arg) {
                    //    self._amMouseDown(e, arg);
                    //});
                    pickerAMArray[i] = itemDiv;
                }
                var pickerTimeFormat = this.element.data('pickerTimeFormat');
                var hourAdded = false, minuteAdded = false, amAdded = false;
                for(var i = 0; i < pickerTimeFormat.length; i++) {
                    if((pickerTimeFormat[i] == "h" || pickerTimeFormat[i] == "hh") && !hourAdded) {
                        tdHour.appendTo(trTime);
                        hourAdded = true;
                    }
                    if((pickerTimeFormat[i] == "m" || pickerTimeFormat[i] == "mm") && !minuteAdded) {
                        tdMinute.appendTo(trTime);
                        minuteAdded = true;
                    }
                    if((pickerTimeFormat[i] == "t" || pickerTimeFormat[i] == "tt") && !amAdded) {
                        tdAM.appendTo(trTime);
                        amAdded = true;
                    }
                }
                this.element.data('timePicker', div);
                this.element.data('divHour', divHour);
                this.element.data('divMinute', divMinute);
                this.element.data('divAM', divAM);
                this.element.data('divHourMask', divHourMask);
                this.element.data('divMinuteMask', divMinuteMask);
                this.element.data('divAMMask', divAMMask);
                this.element.data('pickerHourArray', pickerHourArray);
                this.element.data('pickerMinuteArray', pickerMinuteArray);
                this.element.data('pickerAMArray', pickerAMArray);
                if(!input.Utility.IsIE8OrBelow()) {
                    var divHourIndicatorTop = this._createIndicatiorElement(divHour, indicatorHeight, "-", indicatorTranslateTop);
                    var divHourIndicatorDown = this._createIndicatiorElement(divHour, indicatorHeight, "-", indicatorTranslateDown);
                    var divMinuteIndicatorTop = this._createIndicatiorElement(divMinute, indicatorHeight, "-", indicatorTranslateTop);
                    var divMinuteIndicatorDown = this._createIndicatiorElement(divMinute, indicatorHeight, "-", indicatorTranslateDown);
                    var divAMIndicatorTop = this._createIndicatiorElement(divAM, indicatorHeight, "-", indicatorTranslateTop);
                    var divAMIndicatorDown = this._createIndicatiorElement(divAM, indicatorHeight, "-", indicatorTranslateDown);
                    this.element.data('divHourIndicatorTop', divHourIndicatorTop);
                    this.element.data('divMinuteIndicatorTop', divMinuteIndicatorTop);
                    this.element.data('divAMIndicatorTop', divAMIndicatorTop);
                    this.element.data('divHourIndicatorDown', divHourIndicatorDown);
                    this.element.data('divMinuteIndicatorDown', divMinuteIndicatorDown);
                    this.element.data('divAMIndicatorDown', divAMIndicatorDown);
                }
                this._initTimePickerEvent();
                this._initTouchPickerEvent("Hour");
                this._initTouchPickerEvent("Minute");
                this._initTouchPickerEvent("AM");
            };
            wijinputdate.prototype._initTimePickerEvent = function () {
                var self = this;
                var divHour = this.element.data('divHour');
                var divMinute = this.element.data('divMinute');
                var divAM = this.element.data('divAM');
                divHour.mousewheel(function (e, arg) {
                    self._hourMouseWheel(e, arg);
                });
                divMinute.mousewheel(function (e, arg) {
                    self._minuteMouseWheel(e, arg);
                });
                divAM.mousewheel(function (e, arg) {
                    self._amMouseWheel(e, arg);
                });
            };
            wijinputdate.prototype._initDatePicker = function () {
                var datePicker = this.element.data('datePicker');
                if(datePicker != undefined) {
                    return;
                }
                var self = this;
                var minYear = this.element.data('pickerMinYear');
                var maxYear = this.element.data('pickerMaxYear');
                var height = this.element.data('itemHeight') * 5;
                var pickerWidth = this.element.data('pickerWidth');
                var itemHeight = this.element.data('itemHeight') + "px";
                var indicatorHeight = this.element.data('indicatorHeight') + "px";
                var indicatorTranslateTop = this.element.data('indicatorTranslateTop');
                var indicatorTranslateDown = this.element.data('indicatorTranslateDown');
                var indicatorTranslateSelector = this.element.data('indicatorTranslateSelector');
                var indicatorTranslateContent = this.element.data('indicatorTranslateContent');
                var div = this._createDivElement(document.body, pickerWidth + "px");
                var divIndicator = this._createDivIndicatiorElement(div, itemHeight, "", indicatorTranslateSelector);
                var table = this._createTableElement(div, height + "px", "-", indicatorTranslateContent);
                var trDate = $("<tr/>").appendTo(table);
                var tdYearWidth = "33%";
                var tdMonthWidth = "33%";
                var tdDayWidth = "33%";
                if(this.element.data('pickerDateMonthFormat') == "MMMM") {
                    tdYearWidth = "30%";
                    tdMonthWidth = "45%";
                    tdDayWidth = "25%";
                }
                // Year
                var tdYear = $("<td/>").css({
                    "width": tdYearWidth
                });
                var divYear = this._createPickerDivElement(tdYear, height);
                var divYearMask = this._createMaskElement(divYear, height);
                var pickerYearArray = new Array();
                for(var i = minYear; i <= maxYear; i++) {
                    var text = this._getRollText(i, this.element.data('pickerDateYearFormat'));
                    var itemDiv = this._createItemElement(i, divYearMask, itemHeight, text);
                    //itemDiv.mousedown(function (e, arg) {
                    //    self._yearMouseDown(e, arg);
                    //});
                    pickerYearArray[i - minYear] = itemDiv;
                }
                // Month
                var tdMonth = $("<td/>").css({
                    "width": tdMonthWidth
                });
                var divMonth = this._createPickerDivElement(tdMonth, height);
                var divMonthMask = this._createMaskElement(divMonth, height);
                var pickerMonthArray = {
                };
                for(var i = 1; i <= 12; i++) {
                    var text = this._getRollText(i, this.element.data('pickerDateMonthFormat'));
                    var itemDiv = this._createItemElement(i - 1, divMonthMask, itemHeight, text);
                    //itemDiv.mousedown(function (e, arg) {
                    //    self._monthMouseDown(e, arg);
                    //});
                    pickerMonthArray[i - 1] = itemDiv;
                }
                //Day
                var tdDay = $("<td/>").css({
                    "width": tdDayWidth
                });
                var divDay = this._createPickerDivElement(tdDay, height);
                var divDayMask = this._createMaskElement(divDay, height);
                var pickerDayArray = {
                };
                for(var i = 1; i <= 31; i++) {
                    var text = this._getRollText(i, this.element.data('pickerDateDayFormat'));
                    var itemDiv = this._createItemElement(i, divDayMask, itemHeight, text);
                    //itemDiv.mousedown(function (e, arg) {
                    //    self._dayMouseDown(e, arg);
                    //});
                    pickerDayArray[i - 1] = itemDiv;
                }
                var pickerDateFormat = this.element.data('pickerDateFormat');
                var yearAdded = false, monthAdded = false, dayAdded = false;
                for(var i = 0; i < pickerDateFormat.length; i++) {
                    if((pickerDateFormat[i] == "yyyy") && !yearAdded) {
                        tdYear.appendTo(trDate);
                        yearAdded = true;
                    }
                    if((pickerDateFormat[i] == "M" || pickerDateFormat[i] == "MM" || pickerDateFormat[i] == "MMM" || pickerDateFormat[i] == "MMMM") && !monthAdded) {
                        tdMonth.appendTo(trDate);
                        monthAdded = true;
                    }
                    if((pickerDateFormat[i] == "d" || pickerDateFormat[i] == "dd") && !dayAdded) {
                        tdDay.appendTo(trDate);
                        dayAdded = true;
                    }
                }
                this.element.data('datePicker', div);
                this.element.data('divYear', divYear);
                this.element.data('divMonth', divMonth);
                this.element.data('divDay', divDay);
                this.element.data('divYearMask', divYearMask);
                this.element.data('divMonthMask', divMonthMask);
                this.element.data('divDayMask', divDayMask);
                this.element.data('pickerYearArray', pickerYearArray);
                this.element.data('pickerMonthArray', pickerMonthArray);
                this.element.data('pickerDayArray', pickerDayArray);
                if(!input.Utility.IsIE8OrBelow()) {
                    var divYearIndicatorTop = this._createIndicatiorElement(divYear, indicatorHeight, "-", indicatorTranslateTop);
                    var divYearIndicatorDown = this._createIndicatiorElement(divYear, indicatorHeight, "-", indicatorTranslateDown);
                    var divMonthIndicatorTop = this._createIndicatiorElement(divMonth, indicatorHeight, "-", indicatorTranslateTop);
                    var divMonthIndicatorDown = this._createIndicatiorElement(divMonth, indicatorHeight, "-", indicatorTranslateDown);
                    var divDayIndicatorTop = this._createIndicatiorElement(divDay, indicatorHeight, "-", indicatorTranslateTop);
                    var divDayIndicatorDown = this._createIndicatiorElement(divDay, indicatorHeight, "-", indicatorTranslateDown);
                    this.element.data('divYearIndicatorTop', divYearIndicatorTop);
                    this.element.data('divMonthIndicatorTop', divMonthIndicatorTop);
                    this.element.data('divDayIndicatorTop', divDayIndicatorTop);
                    this.element.data('divYearIndicatorDown', divYearIndicatorDown);
                    this.element.data('divMonthIndicatorDown', divMonthIndicatorDown);
                    this.element.data('divDayIndicatorDown', divDayIndicatorDown);
                }
                this._initDatePickerEvent();
                this._initTouchPickerEvent("Year");
                this._initTouchPickerEvent("Month");
                this._initTouchPickerEvent("Day");
            };
            wijinputdate.prototype._initDatePickerEvent = function () {
                var self = this;
                var divYear = this.element.data('divYear');
                var divMonth = this.element.data('divMonth');
                var divDay = this.element.data('divDay');
                divYear.mousewheel(function (e, arg) {
                    self._yearMouseWheel(e, arg);
                });
                divMonth.mousewheel(function (e, arg) {
                    self._monthMouseWheel(e, arg);
                });
                divDay.mousewheel(function (e, arg) {
                    self._dayMouseWheel(e, arg);
                });
            };
            wijinputdate.prototype._initTouchPickerEvent = function (pickerType) {
                var div = this.element.data('div' + pickerType);
                var divMask = this.element.data('div' + pickerType + 'Mask');
                this._addPickerTouchEvent(divMask, pickerType);
                if(!input.Utility.IsIE8OrBelow()) {
                    var divIndicatorTop = this.element.data('div' + pickerType + 'IndicatorTop');
                    var divIndicatorDown = this.element.data('div' + pickerType + 'IndicatorDown');
                    this._addPickerTouchEvent(divIndicatorTop, pickerType);
                    this._addPickerTouchEvent(divIndicatorDown, pickerType);
                }
            };
            wijinputdate.prototype._addPickerTouchEvent = function (element, pickerType) {
                var self = this;
                element.bind("touchstart", function (evt) {
                    self._touchStart(evt, pickerType);
                    evt.preventDefault();
                }).bind("touchmove", function (evt) {
                    self._touchMove(evt, pickerType);
                    evt.preventDefault();
                }).bind("touchend", function (evt) {
                    self._touchEnd(evt, pickerType);
                    evt.preventDefault();
                });
            };
            wijinputdate.prototype._touchStart = function (evt, pickerType) {
                var touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];
                var clientY = touch.clientY;
                this.element.data("touch" + pickerType + "StartY", clientY);
                this.element.data("touch" + pickerType + "BaseY", this.element.data('picker' + pickerType + 'ScrollCurrent'));
                this.element.data("touch" + pickerType + "Started", true);
                this.element.data("touchStartTime", new Date());
                var pickerScrollCurrent = this.element.data('picker' + pickerType + 'ScrollCurrent');
                this.element.data('picker' + pickerType + 'ScrollTo', pickerScrollCurrent);
            };
            wijinputdate.prototype._touchMove = function (evt, pickerType) {
                if(!this._allowEdit()) {
                    return;
                }
                if(this.element.data("touch" + pickerType + "Started") != true) {
                    return;
                }
                var touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];
                var clientY = touch.clientY;
                var touchStartY = this.element.data("touch" + pickerType + "StartY");
                var touchBaseY = this.element.data("touch" + pickerType + "BaseY");
                var newY = touchBaseY + clientY - touchStartY;
                this._scrollTheViewByTouch(pickerType, newY);
            };
            wijinputdate.prototype._touchEnd = function (evt, pickerType) {
                var touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];
                var touchStartY = this.element.data("touch" + pickerType + "StartY");
                var touchBaseY = this.element.data("touch" + pickerType + "BaseY");
                var offset = touch.clientY - touchStartY;
                var newY = touchBaseY + offset;
                if(Math.abs(offset) < 10) {
                    var pickerScrollCurrent = this.element.data('picker' + pickerType + 'ScrollCurrent');
                    this.element.data('picker' + pickerType + 'ScrollTo', pickerScrollCurrent);
                    this._adjustTouchPosition(pickerType, pickerScrollCurrent);
                    return;
                }
                this.element.data("touch" + pickerType + "StartY", -1);
                this.element.data("touch" + pickerType + "BaseY", -1);
                this.element.data("touch" + pickerType + "Started", false);
                var now = new Date();
                var offsetTime = now - this.element.data("touchStartTime");
                if(offsetTime < 200) {
                    var itemHeight = this.element.data("itemHeight") * 5;
                    var negative = offset < 0 ? -1 : 1;
                    offset = offset * 4;
                    offset = Math.abs(offset) < itemHeight ? negative * itemHeight : offset;
                    newY += offset;
                    this.element.data("touchQuickScroll", true);
                    this.element.data('picker' + pickerType + 'ScrollRate', 3);
                }
                this._adjustTouchPosition(pickerType, newY);
            };
            wijinputdate.prototype._hourMouseWheel = function (e, arg) {
                if(!this._allowEdit()) {
                    return;
                }
                if(isNaN(arg)) {
                    return;
                }
                var oldHour = this.element.data("pickerHour");
                var hour = this.element.data("pickerHour");
                var lastHour = hour;
                hour -= arg;
                hour = hour < 1 ? 1 : hour;
                hour = hour > 12 ? 12 : hour;
                var am = this.element.data("pickerAM");
                if(hour == 12) {
                    if(am == 0) {
                        am = 1;
                        this._updateItemTransform("AM", am);
                        this._scrollTheView("AM", am, 0, false);
                        this.element.data("pickerAM", am);
                    }
                } else if(lastHour == 12) {
                    if(am == 1) {
                        am = 0;
                        this._updateItemTransform("AM", am);
                        this._scrollTheView("AM", am, 1, false);
                        this.element.data("pickerAM", am);
                    }
                }
                this._updateItemTransform("Hour", hour - 1);
                this._scrollTheView("Hour", hour - 1, oldHour - 1, false);
                this.element.data("pickerHour", hour);
                if(e.preventDefault) {
                    e.preventDefault();
                }
            };
            wijinputdate.prototype._minuteMouseWheel = function (e, arg) {
                if(!this._allowEdit()) {
                    return;
                }
                if(isNaN(arg)) {
                    return;
                }
                var oldMinute = this.element.data("pickerMinute");
                var minute = this.element.data("pickerMinute");
                minute -= arg;
                minute = minute < 0 ? 0 : minute;
                minute = minute > 59 ? 59 : minute;
                this._updateItemTransform("Minute", minute);
                this._scrollTheView("Minute", minute, oldMinute, false);
                this.element.data("pickerMinute", minute);
                if(e.preventDefault) {
                    e.preventDefault();
                }
            };
            wijinputdate.prototype._amMouseWheel = function (e, arg) {
                if(!this._allowEdit()) {
                    return;
                }
                if(isNaN(arg)) {
                    return;
                }
                var oldAM = $(e.currentTarget).data('pickerAM');
                var am = this.element.data("pickerAM");
                am -= arg;
                am = am < 0 ? 0 : am;
                am = am > 1 ? 1 : am;
                this._updateItemTransform("AM", am);
                this._scrollTheView("AM", am, oldAM, false);
                this.element.data("pickerAM", am);
                if(e.preventDefault) {
                    e.preventDefault();
                }
            };
            wijinputdate.prototype._yearMouseWheel = function (e, arg) {
                if(!this._allowEdit()) {
                    return;
                }
                if(isNaN(arg)) {
                    return;
                }
                var minYear = this.element.data("pickerMinYear");
                var maxYear = this.element.data("pickerMaxYear");
                var year = this.element.data("pickerYear");
                var oldYear = this.element.data("pickerYear");
                year -= arg;
                year = year < minYear ? minYear : year;
                year = year > maxYear ? maxYear : year;
                this._updateItemTransform("Year", year - minYear);
                this._scrollTheView("Year", year - minYear, oldYear - minYear, false);
                this.element.data("pickerYear", year);
                this._updateDayPickerMaxCount();
                if(e.preventDefault) {
                    e.preventDefault();
                }
            };
            wijinputdate.prototype._monthMouseWheel = function (e, arg) {
                if(!this._allowEdit()) {
                    return;
                }
                if(isNaN(arg)) {
                    return;
                }
                var month = this.element.data("pickerMonth");
                var oldMonth = this.element.data("pickerMonth");
                month -= arg;
                month = month < 1 ? 1 : month;
                month = month > 12 ? 12 : month;
                this._updateItemTransform("Month", month - 1);
                this._scrollTheView("Month", month - 1, oldMonth, false);
                this.element.data("pickerMonth", month);
                this._updateDayPickerMaxCount();
                if(e.preventDefault) {
                    e.preventDefault();
                }
            };
            wijinputdate.prototype._dayMouseWheel = function (e, arg) {
                if(!this._allowEdit()) {
                    return;
                }
                if(isNaN(arg)) {
                    return;
                }
                var maxDayCount = this.element.data('pickerDayMaxCount');
                var oldDay = this.element.data("pickerDay");
                var day = this.element.data("pickerDay");
                day -= arg;
                day = day < 1 ? 1 : day;
                day = day > maxDayCount ? maxDayCount : day;
                this._updateItemTransform("Day", day - 1);
                this._scrollTheView("Day", day - 1, oldDay - 1, false);
                this.element.data("pickerDay", day);
                if(e.preventDefault) {
                    e.preventDefault();
                }
            };
            wijinputdate.prototype._hourMouseDown = function (e, arg) {
                var oldHour = this.element.data("pickerHour");
                var hour = $(e.currentTarget).data('rollValue');
                this._scrollTheView("Hour", hour, oldHour, false);
                this.element.data("pickerHour", hour);
            };
            wijinputdate.prototype._minuteMouseDown = function (e, arg) {
                var oldMinute = this.element.data("pickerMinute");
                var minute = $(e.currentTarget).data('rollValue');
                this._scrollTheView("Minute", minute, oldMinute, false);
                this.element.data("pickerMinute", minute);
            };
            wijinputdate.prototype._amMouseDown = function (e, arg) {
                var oldAM = $(e.currentTarget).data('pickerAM');
                var am = $(e.currentTarget).data('rollValue');
                this._scrollTheView("AM", am, oldAM, false);
                this.element.data("pickerAM", am);
            };
            wijinputdate.prototype._yearMouseDown = function (e, arg) {
                var minYear = this.element.data("pickerMinYear");
                var year = $(e.currentTarget).data('rollValue');
                var oldYear = this.element.data("pickerYear");
                this._scrollTheView("Year", year - minYear, oldYear - minYear, false);
                this.element.data("pickerYear", year);
                this._updateDayPickerMaxCount();
            };
            wijinputdate.prototype._monthMouseDown = function (e, arg) {
                var oldMonth = this.element.data("pickerMonth");
                var month = $(e.currentTarget).data('rollValue');
                this._scrollTheView("Month", month, oldMonth, false);
                this.element.data("pickerMonth", month);
                this._updateDayPickerMaxCount();
            };
            wijinputdate.prototype._dayMouseDown = function (e, arg) {
                var oldDay = this.element.data("pickerDay");
                var day = $(e.currentTarget).data('rollValue');
                this._scrollTheView("Day", day - 1, oldDay - 1, false);
                this.element.data("pickerDay", day);
            };
            wijinputdate.prototype._updateCalendarPicker = function () {
                var calendar = this.element.data('calendar');
                var pickers = this.options.pickers;
                if(calendar == undefined || pickers == undefined) {
                    return;
                }
                if(pickers.calendar == undefined) {
                    return;
                }
                if(pickers.calendar.allowQuickPick != undefined) {
                    calendar.wijcalendar('option', 'allowQuickPick', pickers.calendar.allowQuickPick);
                }
                if(pickers.calendar.navButtons != undefined) {
                    calendar.wijcalendar('option', 'navButtons', pickers.calendar.navButtons);
                }
                if(pickers.calendar.nextTooltip != undefined) {
                    calendar.wijcalendar('option', 'nextTooltip', pickers.calendar.nextTooltip);
                }
                if(pickers.calendar.prevTooltip != undefined) {
                    calendar.wijcalendar('option', 'prevTooltip', pickers.calendar.prevTooltip);
                }
                if(pickers.calendar.showDayPadding != undefined) {
                    calendar.wijcalendar('option', 'showDayPadding', pickers.calendar.showDayPadding);
                }
                if(pickers.calendar.showOtherMonthDays != undefined) {
                    calendar.wijcalendar('option', 'showOtherMonthDays', pickers.calendar.showOtherMonthDays);
                }
                if(pickers.calendar.showTitle != undefined) {
                    calendar.wijcalendar('option', 'showTitle', pickers.calendar.showTitle);
                }
                if(pickers.calendar.showWeekDays != undefined) {
                    calendar.wijcalendar('option', 'showWeekDays', pickers.calendar.showWeekDays);
                }
                if(pickers.calendar.showWeekNumbers != undefined) {
                    calendar.wijcalendar('option', 'showWeekNumbers', pickers.calendar.showWeekNumbers);
                }
                if(pickers.calendar.titleFormat != undefined) {
                    calendar.wijcalendar('option', 'titleFormat', pickers.calendar.titleFormat);
                }
                if(pickers.calendar.toolTipFormat != undefined) {
                    calendar.wijcalendar('option', 'toolTipFormat', pickers.calendar.toolTipFormat);
                }
                if(pickers.calendar.weekDayFormat != undefined) {
                    calendar.wijcalendar('option', 'weekDayFormat', pickers.calendar.weekDayFormat);
                }
            };
            wijinputdate.prototype._updateTimePicker = function () {
                var hour = this.element.data("pickerHour") - 1;
                var minute = this.element.data("pickerMinute");
                var am = this.element.data("pickerAM");
                var divHourMask = this.element.data('divHourMask');
                var divMinuteMask = this.element.data('divMinuteMask');
                var divAMMask = this.element.data('divAMMask');
                this._updateItemTransform("Hour", hour);
                this._updateItemTransform("Minute", minute);
                this._updateItemTransform("AM", am);
                this._scrollTheView("Hour", hour, hour, true);
                this._scrollTheView("Minute", minute, minute, true);
                this._scrollTheView("AM", am, am, true);
                this.element.data('pickerHourScrollDelay', 5);
                this.element.data('pickerMinuteScrollDelay', 5);
                this.element.data('pickerAMScrollDelay', 5);
                this.element.data('pickerHourScrollRate', 1);
                this.element.data('pickerMinuteScrollRate', 1);
                this.element.data('pickerAMScrollRate', 1);
            };
            wijinputdate.prototype._updateDatePicker = function () {
                var minYear = this.element.data('pickerMinYear');
                var year = this.element.data("pickerYear");
                var month = this.element.data("pickerMonth");
                var day = this.element.data("pickerDay");
                var maxDayCount = input.DateTimeInfo.DaysInMonth(year, month);
                this._updateItemTransform("Year", year - minYear);
                this._updateItemTransform("Month", month - 1);
                this._updateItemTransform("Day", day - 1);
                this._scrollTheView("Year", year - minYear, year - minYear, true);
                this._scrollTheView("Month", month - 1, month - 1, true);
                this._scrollTheView("Day", day - 1, day - 1, true);
                this.element.data('pickerYearScrollDelay', 5);
                this.element.data('pickerMonthScrollDelay', 5);
                this.element.data('pickerDayScrollDelay', 5);
                this.element.data('pickerYearScrollRate', 1);
                this.element.data('pickerMonthScrollRate', 1);
                this.element.data('pickerDayScrollRate', 1);
                this._updateDayPickerMaxCount();
            };
            wijinputdate.prototype._updateDayPickerMaxCount = function () {
                var year = this.element.data("pickerYear");
                var month = this.element.data("pickerMonth");
                var day = this.element.data("pickerDay");
                var maxDayCount = input.DateTimeInfo.DaysInMonth(year, month);
                this.element.data('pickerDayMaxCount', maxDayCount);
                var pickerDayArray = this.element.data('pickerDayArray');
                for(var i = 29; i <= 31; i++) {
                    var display = i > maxDayCount ? "none" : "";
                    pickerDayArray[i - 1].css("display", display);
                }
                if(day > maxDayCount) {
                    var divDayMask = this.element.data('divDayMask');
                    day = maxDayCount;
                    this._updateItemTransform("Day", day - 1);
                    this._scrollTheView("Day", day - 1, null, false);
                    this.element.data("pickerDay", day);
                }
            };
            wijinputdate.prototype._updateItemTransform = function (pickerType, itemIndex) {
                if(input.Utility.IsIE8OrBelow()) {
                    return;
                }
                if(itemIndex < 0) {
                    return;
                }
                var itemArray = this.element.data("picker" + pickerType + "Array");
                var length = this._getItemLength(pickerType);
                var transform = "skew(0deg) scale(1.2, 1.2) translate(0px, 0px)";
                var transform1 = "skew(-5deg) scale(0.9, 0.9) translate(0px, 0px)";
                var transform2 = "skew(-10deg) scale(0.7, 0.7) translate(0px, 0px)";
                var transform3 = "skew(-15deg) scale(0.5, 0.5) translate(0px, 0px)";
                for(var i = 0; i < length; i++) {
                    if(i == itemIndex - 3) {
                        this._setCssTransform(itemArray[i], "", transform3, true);
                    } else if(i == itemIndex - 2) {
                        this._setCssTransform(itemArray[i], "", transform2, true);
                    } else if(i == itemIndex - 1) {
                        this._setCssTransform(itemArray[i], "", transform1, true);
                    } else if(i == itemIndex) {
                        this._setCssTransform(itemArray[i], "", transform, true);
                    } else if(i == itemIndex + 1) {
                        this._setCssTransform(itemArray[i], "", transform1, true);
                    } else if(i == itemIndex + 2) {
                        this._setCssTransform(itemArray[i], "", transform2, true);
                    } else if(i == itemIndex + 3) {
                        this._setCssTransform(itemArray[i], "", transform3, true);
                    } else {
                        this._setCssTransform(itemArray[i], "", "", true);
                    }
                }
            };
            wijinputdate.prototype._createDivElement = function (div, width) {
                var div = $("<div/>").appendTo(div).css({
                    "width": width + "px",
                    "display": "block",
                    "left": "",
                    "top": "",
                    "position": ""
                }).bind("touchstart", function (evt) {
                    evt.preventDefault();
                }).bind("touchmove", function (evt) {
                    evt.preventDefault();
                });
                return div;
            };
            wijinputdate.prototype._createTableElement = function (div, height, prefix, transform) {
                var table = $("<table/>").appendTo(div).css({
                    "width": "100%",
                    "height": height + "px"
                }).attr({
                    "cellspacing": "0px",
                    "cellpadding": "0px"
                });
                this._setCssTransform(table, prefix, transform, false);
                return table;
            };
            wijinputdate.prototype._createItemElement = function (index, div, height, text) {
                var item = $("<div/>").appendTo(div).css({
                    "height": height,
                    "lineHeight": height,
                    "cursor": "default"
                }).html(text).data("rollValue", index);
                return item;
            };
            wijinputdate.prototype._createPickerDivElement = function (div, height) {
                var pickerDiv = $("<div/>").appendTo(div).css({
                    "height": height,
                    "border": "0px",
                    "text-align": "center",
                    "overflow": "hidden",
                    "background": "transparent"
                });
                return pickerDiv;
            };
            wijinputdate.prototype._createMaskElement = function (div, height) {
                var mask = $("<div/>").appendTo(div).css({
                    "height": height
                });
                return mask;
            };
            wijinputdate.prototype._createDivIndicatiorElement = function (div, height, prefix, transform) {
                var indicator = $("<div/>").appendTo(div).css({
                    "height": height,
                    "opacity": "0.5",
                    "lineHeight": height,
                    "margin": "0px",
                    "cursor": "default"
                }).attr("class", "ui-state-active");
                this._setCssTransform(indicator, prefix, transform, false);
                return indicator;
            };
            wijinputdate.prototype._createIndicatiorElement = function (div, height, prefix, transform) {
                var indicator = $("<div/>").appendTo(div).css({
                    "height": height,
                    "opacity": "0.5",
                    "lineHeight": height,
                    "border-width": "0px",
                    "cursor": "default"
                }).attr("class", "ui-widget-content");
                this._setCssTransform(indicator, prefix, transform, false);
                return indicator;
            };
            wijinputdate.prototype._hideItemInIE7 = function (pickerType, pickerScrollCurrent) {
                if(!input.Utility.IsIE7()) {
                    return;
                }
                var lastItemIndex = this.element.data('picker' + pickerType + 'LastItemIndex');
                var itemIndex = this._getItemIndexByPosition(pickerType, pickerScrollCurrent);
                if(itemIndex == lastItemIndex) {
                    return;
                }
                var minItemIndex = itemIndex - 2;
                var maxItemIndex = itemIndex + 2;
                var itemArray = this.element.data("picker" + pickerType + "Array");
                var length = this._getItemLength(pickerType);
                for(var i = 0; i < length; i++) {
                    if(i >= minItemIndex && i <= maxItemIndex) {
                        itemArray[i].css("visibility", "");
                    } else {
                        itemArray[i].css("visibility", "hidden");
                    }
                }
                this.element.data('picker' + pickerType + 'LastItemIndex', itemIndex);
            };
            wijinputdate.prototype._okButtonMouseDown = function (e, arg) {
                var year = this.element.data("pickerYear");
                var month = this.element.data("pickerMonth") - 1;
                var day = this.element.data("pickerDay");
                var hour = this.element.data("pickerHour");
                var minute = this.element.data("pickerMinute");
                var am = this.element.data("pickerAM");
                if(hour == 12) {
                    hour = 0;
                }
                if(am == 1) {
                    hour += 12;
                }
                var date = this._getPickerValue();
                date.setFullYear(year);
                date.setMonth(month);
                date.setDate(day);
                date.setHours(hour);
                date.setMinutes(minute);
                _super.prototype._wasPopupShowing = false;
                var pickers = this.element.data('pickers');
                if(pickers != undefined) {
                    pickers.wijpopup('hide');
                }
                if(this._allowEdit()) {
                    this.option('date', date);
                    this.selectText();
                }
                this._trySetFocus();
            };
            wijinputdate.prototype._getCorrentPickerFormat = function (formats) {
                for(var i = 0; i < formats.length - 1; i++) {
                    for(var j = i + 1; j < formats.length; j++) {
                        if(formats[j].index < formats[i].index) {
                            var tmp = formats[i];
                            formats[i] = formats[j];
                            formats[j] = tmp;
                        }
                    }
                }
                var result = "";
                for(var i = 0; i < formats.length; i++) {
                    result += formats[i].value;
                    if(i < formats.length - 1) {
                        result += ",";
                    }
                }
                return result;
            };
            wijinputdate.prototype._getDefaultDatePickerFormat = function () {
                var culture = this._getCulture();
                if(culture == null) {
                    return "yyyy,M,d";
                }
                var cf = culture.calendars.standard;
                var pattern = cf.patterns.d;
                var y = {
                    "index": pattern.indexOf('y'),
                    "value": "yyyy"
                };
                var M = {
                    "index": pattern.indexOf('M'),
                    "value": "MM"
                };
                var d = {
                    "index": pattern.indexOf('d'),
                    "value": "dd"
                };
                if(y.index == -1 || M.index == -1 || d.index == -1) {
                    return "yyyy,M,d";
                }
                var formats = new Array();
                formats[0] = y;
                formats[1] = M;
                formats[2] = d;
                return this._getCorrentPickerFormat(formats);
            };
            wijinputdate.prototype._getDefaultTimePickerFormat = function () {
                if(this.options.culture.length >= 2) {
                    var subString = this.options.culture.substr(0, 2);
                    if(subString == 'ja' || subString == 'zh') {
                        return "tt,hh,mm";
                    }
                }
                return "hh,mm,tt";
            };
            wijinputdate.prototype._getListPickerWidth = function () {
                var comboWidth = this._getcomboWidth();
                var pickerWidth = this.element.data("pickerWidth");
                var width = comboWidth != undefined ? comboWidth : this.outerDiv.width();
                return pickerWidth > width ? pickerWidth + "px" : width + "px";
            };
            wijinputdate.prototype._getDatePickerMinYear = function () {
                var realMinDate = this._isEraFormatExist() ? this._getRealEraMinDate() : this._getRealMinDate();
                var minYear = realMinDate.getFullYear();
                var pickerValue = this._getPickerValue();
                var year = this._max(pickerValue.getFullYear() - 50, minYear);
                return year;
            };
            wijinputdate.prototype._getDatePickerMaxYear = function () {
                var realMaxDate = this._isEraFormatExist() ? this._getRealEraMaxDate() : this._getRealMaxDate();
                var maxYear = realMaxDate.getFullYear();
                var pickerValue = this._getPickerValue();
                var year = this._min(pickerValue.getFullYear() + 50, maxYear);
                return year;
            };
            wijinputdate.prototype._getPickerValue = function () {
                var pickerValue = this.options.date;
                pickerValue = pickerValue == null ? new Date() : pickerValue;
                return pickerValue;
            };
            wijinputdate.prototype._getRollFormat = function (pickerDateFormat, format) {
                for(var i = 0; i < pickerDateFormat.length; i++) {
                    if(pickerDateFormat[i].indexOf(format) != -1) {
                        return pickerDateFormat[i];
                    }
                }
                return "";
            };
            wijinputdate.prototype._getRollText = function (index, format) {
                var culture = this._getCulture();
                var text = "";
                switch(format) {
                    case "M":
                    case "h":
                        text = (index).toString();
                        break;
                    case "MM":
                    case "hh":
                        text = index < 10 ? "0" + (index).toString() : (index).toString();
                        break;
                    case "m":
                    case "d":
                    case "yyyy":
                        text = index.toString();
                        break;
                    case "mm":
                    case "dd":
                        text = index < 10 ? "0" + index.toString() : index.toString();
                        break;
                    case "t":
                        text = index == 0 ? this._getStandardAMPM("AM") : this._getStandardAMPM("PM");
                        text = text.substr(0, 1);
                        break;
                    case "tt":
                        text = index == 0 ? this._getStandardAMPM("AM") : this._getStandardAMPM("PM");
                        break;
                    case "MMM":
                        text = culture.calendars.standard.months.namesAbbr[index - 1];
                        break;
                    case "MMMM":
                        text = culture.calendars.standard.months.names[index - 1];
                        break;
                    default:
                }
                return text;
            };
            wijinputdate.prototype._getStandardAMPM = function (value) {
                var culture = this._getCulture();
                if(culture && culture.calendar) {
                    var tmp = culture.calendars.standard[value];
                    if(tmp) {
                        return tmp[0];
                    }
                }
                return value;
            };
            wijinputdate.prototype._getItemIndexByPosition = function (pickerType, newY) {
                var touchPositionArray = this._getTouchPositionArray(pickerType);
                var length = this._getItemLength(pickerType);
                if(pickerType == "Day") {
                    if(length > this.element.data('pickerDayMaxCount')) {
                        length = this.element.data('pickerDayMaxCount');
                    }
                }
                var index = -1;
                for(var i = 0; i < length; i++) {
                    if(i == 0) {
                        if(newY > touchPositionArray[i]) {
                            index = 0;
                            break;
                        }
                    } else {
                        if(newY <= touchPositionArray[i - 1] && newY >= touchPositionArray[i]) {
                            var offsetTop = touchPositionArray[i - 1] - newY;
                            var offsetBottom = newY - touchPositionArray[i];
                            index = offsetTop > offsetBottom ? i : i - 1;
                            break;
                        }
                    }
                    if(i == length - 1) {
                        if(newY < touchPositionArray[i]) {
                            index = i;
                            break;
                        }
                    }
                }
                return index;
            };
            wijinputdate.prototype._getItemLength = function (pickerType) {
                switch(pickerType) {
                    case "Hour":
                    case "Month":
                        return 12;
                    case "Year":
                        var minYear = this.element.data('pickerMinYear');
                        var maxYear = this.element.data('pickerMaxYear');
                        return maxYear - minYear + 1;
                    case "Day":
                        return 31;
                    case "Minute":
                        return 60;
                    case "AM":
                        return 2;
                }
                return -1;
            };
            wijinputdate.prototype._getTouchPositionArray = function (pickerType) {
                var positionArray = {
                };
                var itemHeight = this.element.data('itemHeight');
                var length = this._getItemLength(pickerType);
                for(var i = 0; i < length; i++) {
                    positionArray[i] = (2 - i) * itemHeight;
                }
                return positionArray;
            };
            wijinputdate.prototype._adjustTouchPosition = function (pickerType, newY) {
                var touchPositionArray = this._getTouchPositionArray(pickerType);
                var index = this._getItemIndexByPosition(pickerType, newY);
                var value = this._itemIndexToValue(pickerType, index);
                this.element.data("picker" + pickerType, value);
                this._scrollTheViewByTouch(pickerType, touchPositionArray[index]);
            };
            wijinputdate.prototype._itemIndexToValue = function (pickerType, index) {
                switch(pickerType) {
                    case "Minute":
                    case "AM":
                        return index;
                    case "Hour":
                    case "Month":
                    case "Day":
                        return index + 1;
                    case "Year":
                        var minYear = this.element.data('pickerMinYear');
                        return minYear + index;
                }
                return -1;
            };
            wijinputdate.prototype._scrollTheView = function (pickerType, newValue, oldValue, ignoreScroll) {
                var itemHeight = this.element.data('itemHeight');
                var newOffset = (2 - newValue) * itemHeight;
                this.element.data('picker' + pickerType + 'ScrollTo', newOffset);
                if(ignoreScroll == true) {
                    var divMask = this.element.data('div' + pickerType + 'Mask');
                    var pickerScrollCurrent = newOffset;
                    this._setCssTransform(divMask, "", pickerScrollCurrent, false);
                    this._hideItemInIE7(pickerType, pickerScrollCurrent);
                    this.element.data('picker' + pickerType + 'ScrollCurrent', pickerScrollCurrent);
                } else {
                    this._scrollPicker(pickerType);
                }
            };
            wijinputdate.prototype._scrollPicker = function (pickerType) {
                var divMask = this.element.data('div' + pickerType + 'Mask');
                var pickerScrollTo = this.element.data('picker' + pickerType + 'ScrollTo');
                var pickerScrollCurrent = this.element.data('picker' + pickerType + 'ScrollCurrent');
                var pickerScrollDelay = this.element.data('picker' + pickerType + 'ScrollDelay');
                if(pickerScrollCurrent == undefined) {
                    pickerScrollCurrent = pickerScrollTo;
                    this._setCssTransform(divMask, "", pickerScrollCurrent, false);
                    this.element.data('picker' + pickerType + 'ScrollCurrent', pickerScrollCurrent);
                }
                if(pickerScrollTo == pickerScrollCurrent || pickerScrollCurrent == undefined) {
                    return false;
                }
                pickerScrollCurrent += pickerScrollTo > pickerScrollCurrent ? 1 : -1;
                var transform = "translate(0," + pickerScrollCurrent + "px) ";
                this._setCssTransform(divMask, "", pickerScrollCurrent, false);
                this._hideItemInIE7(pickerType, pickerScrollCurrent);
                this.element.data('picker' + pickerType + 'ScrollCurrent', pickerScrollCurrent);
                var self = this;
                setTimeout(function () {
                    self._scrollPicker(pickerType);
                }, pickerScrollDelay);
                return true;
            };
            wijinputdate.prototype._scrollTheViewByTouch = function (pickerType, clientY) {
                var itemHeight = this.element.data('itemHeight');
                var pickerScrollCurrent = this.element.data('picker' + pickerType + 'ScrollCurrent');
                var pickerScrollTo = this.element.data('picker' + pickerType + 'ScrollTo');
                this.element.data('picker' + pickerType + 'ScrollTo', clientY);
                this._scrollPickerByTouch(pickerType);
            };
            wijinputdate.prototype._setCssTransform = function (element, prefix, transform, setDirect) {
                var newTransform = transform;
                if(!setDirect) {
                    newTransform = "translate(0, " + prefix + transform + "px)";
                }
                element.css("position", "");
                element.css("top", "");
                if(input.Utility.IsIE8OrBelow()) {
                    element.css("position", "relative");
                    element.css("top", prefix + transform + "px");
                } else if(input.Utility.IsIE9()) {
                    element.css("-ms-transform", newTransform);
                } else {
                    element.css("transform", newTransform);
                }
            };
            wijinputdate.prototype._scrollPickerByTouch = function (pickerType) {
                var divMask = this.element.data('div' + pickerType + 'Mask');
                var pickerScrollTo = this.element.data('picker' + pickerType + 'ScrollTo');
                var pickerScrollCurrent = this.element.data('picker' + pickerType + 'ScrollCurrent');
                if(pickerScrollCurrent == undefined) {
                    pickerScrollCurrent = pickerScrollTo;
                    this._setCssTransform(divMask, "", pickerScrollCurrent, false);
                    this.element.data('picker' + pickerType + 'ScrollCurrent', pickerScrollCurrent);
                }
                if(pickerScrollTo == pickerScrollCurrent) {
                    this.element.data('picker' + pickerType + 'ScrollRate', 1);
                    this.element.data('picker' + pickerType + 'ScrollDelay', 5);
                    this.element.data('touchQuickScroll', false);
                    if(pickerType == "Month" || pickerType == "Year") {
                        this._updateDayPickerMaxCount();
                    } else if(pickerType == "Hour") {
                        var itemIndex = this._getItemIndexByPosition(pickerType, pickerScrollCurrent);
                        var am = this.element.data("pickerAM");
                        if(itemIndex == 11) {
                            if(am == 0) {
                                am = 1;
                                this._updateItemTransform("AM", am);
                                this._scrollTheView("AM", am, 0, false);
                                this.element.data("pickerAM", am);
                            }
                        } else {
                            if(am == 1) {
                                am = 0;
                                this._updateItemTransform("AM", am);
                                this._scrollTheView("AM", am, 1, false);
                                this.element.data("pickerAM", am);
                            }
                        }
                    }
                    return false;
                }
                var itemHeight = this.element.data('itemHeight');
                var scrollDelay = this.element.data('picker' + pickerType + 'ScrollDelay');
                var scrollRate = this.element.data('picker' + pickerType + 'ScrollRate');
                var offset = Math.abs(pickerScrollTo - pickerScrollCurrent);
                var rate = offset > scrollRate ? scrollRate : offset;
                if(this.element.data('touchQuickScroll') == true) {
                    if(offset < itemHeight) {
                        scrollDelay = 80;
                    } else if(offset < itemHeight * 2) {
                        scrollDelay = 50;
                    } else if(offset < itemHeight * 5) {
                        scrollDelay = 30;
                    } else if(offset < itemHeight * 8) {
                        scrollDelay = 20;
                    } else if(offset < itemHeight * 10) {
                        scrollDelay = 10;
                    }
                    this.element.data('picker' + pickerType + 'ScrollDelay', scrollDelay);
                }
                pickerScrollCurrent += pickerScrollTo > pickerScrollCurrent ? rate : -1 * rate;
                this._setCssTransform(divMask, "", pickerScrollCurrent, false);
                this.element.data('picker' + pickerType + 'ScrollCurrent', pickerScrollCurrent);
                var itemIndex = this._getItemIndexByPosition(pickerType, pickerScrollCurrent);
                var lastItemIndex = this.element.data('picker' + pickerType + 'LastItemIndex');
                if(itemIndex != lastItemIndex) {
                    this._updateItemTransform(pickerType, itemIndex);
                }
                this.element.data('picker' + pickerType + 'LastItemIndex', lastItemIndex);
                var self = this;
                setTimeout(function () {
                    self._scrollPickerByTouch(pickerType);
                }, scrollDelay);
                return true;
            };
            wijinputdate.prototype._syncCalendar = function () {
                var calendar = this.element.data('calendar');
                if(!calendar) {
                    return;
                }
                var date = this._safeGetDate();
                if(date == null || this._isMinDate(date)) {
                    date = new Date();
                }
                calendar.wijcalendar('option', 'displayDate', date);
                if(this.options.minDate) {
                    calendar.wijcalendar('option', 'minDate', this.options.minDate);
                }
                if(this.options.maxDate) {
                    calendar.wijcalendar('option', 'maxDate', this.options.maxDate);
                }
                calendar.wijcalendar('unSelectAll');
                calendar.wijcalendar('selectDate', date);
                calendar.wijcalendar('refresh');
            };
            wijinputdate.prototype._showPopup = function () {
                if(this._isDatePickerNeedReInit()) {
                    this._reInitPicker();
                }
                var pickers = this.element.data('pickers');
                if(pickers == undefined) {
                    return false;
                }
                pickers.wijpopup('show', $.extend({
                }, this.options.popupPosition, {
                    of: this.outerDiv
                }));
                var pickerValue = this._getPickerValue();
                var hour = pickerValue.getHours();
                if(hour > 12) {
                    hour -= 12;
                } else if(hour == 0) {
                    hour = 12;
                }
                this.element.data("pickerValue", pickerValue);
                this.element.data("pickerYear", pickerValue.getFullYear());
                this.element.data("pickerMonth", pickerValue.getMonth() + 1);
                this.element.data("pickerDay", pickerValue.getDate());
                this.element.data("pickerHour", hour);
                this.element.data("pickerMinute", pickerValue.getMinutes());
                this.element.data("pickerAM", pickerValue.getHours() < 12 ? 0 : 1);
                this.element.data('divOK').css("visibility", "");
                if(this._isTimePickerShown()) {
                    this._updateTimePicker();
                    pickers.attr({
                        "class": "ui-widget-content ui-corner-all"
                    });
                }
                if(this._isDatePickerShown()) {
                    this._updateDatePicker();
                    pickers.css({
                        "font-size": "12px"
                    }).attr({
                        "class": "ui-widget-content ui-corner-all"
                    });
                }
                if(this._isListPickerShown()) {
                    if(this._getPickerCount() == 1) {
                        pickers.attr({
                            "class": ""
                        });
                        this._comboDiv.focus();
                    }
                    if(this.element.data("pickerCurrentTab") == "List") {
                        var listWidth = this._getListPickerWidth();
                        pickers.css({
                            "width": listWidth,
                            "height": ""
                        });
                        pickers.css({
                            "font-size": ""
                        });
                        var parentElement = this._comboDiv[0].parentElement;
                        this._comboDiv.wijlist("destroy");
                        this._comboDiv.remove();
                        delete this._comboDiv;
                        this._initListPicker();
                        this._comboDiv.appendTo(parentElement);
                        this._comboDiv.focus();
                    }
                }
                if(this._isCalendarPickerShown()) {
                    this._syncCalendar();
                    if(this.element.data("pickerCurrentTab") == "Calendar") {
                        if(this._getPickerCount() <= 1) {
                            pickers.css({
                                "width": ""
                            });
                        }
                        pickers.css({
                            "font-size": ""
                        });
                    }
                }
                return true;
            };
            wijinputdate.prototype._hidePopup = function () {
                var pickers = this.element.data('pickers');
                if(pickers != undefined) {
                    pickers.wijpopup('hide');
                }
                this.element.data('divOK').css("visibility", "hidden");
            };
            wijinputdate.prototype._popupVisible = function () {
                var pickers = this.element.data('pickers');
                if(pickers != undefined) {
                    return pickers.wijpopup('isVisible');
                }
                return false;
            };
            wijinputdate.prototype._isComboListVisible = function () {
                return this._popupVisible();
            };
            wijinputdate.prototype._isValidDate = function (date, chkBounds) {
                if(date === undefined) {
                    return false;
                }
                if(isNaN(date)) {
                    return false;
                }
                if(date.getFullYear() < 1 || date.getFullYear() > 9999) {
                    return false;
                }
                if(chkBounds) {
                    if(this.options.minDate) {
                        if(date < this.options.minDate) {
                            return false;
                        }
                    }
                    if(this.options.maxDate) {
                        if(date > this.options.maxDate) {
                            return false;
                        }
                    }
                }
                return true;
            };
            wijinputdate.prototype._isValidatePickerFormat = function (format) {
                switch(format) {
                    case "yyyy":
                    case "M":
                    case "MM":
                    case "MMM":
                    case "MMMM":
                    case "d":
                    case "dd":
                    case "h":
                    case "hh":
                    case "m":
                    case "mm":
                    case "t":
                    case "tt":
                        return true;
                }
                return false;
            };
            wijinputdate.prototype._isDatePickerNeedReInit = function () {
                if(!this._isDatePickerShown()) {
                    return false;
                }
                var pickerMinYear = this.element.data("pickerMinYear");
                var pickerMaxYear = this.element.data("pickerMaxYear");
                var year = this._getPickerValue().getFullYear();
                if(year < pickerMinYear || year > pickerMaxYear) {
                    return true;
                }
                var minYear = this._isEraFormatExist() ? this._getRealEraMinDate().getFullYear() : this._getRealMinDate().getFullYear();
                var maxYear = this._isEraFormatExist() ? this._getRealEraMaxDate().getFullYear() : this._getRealMaxDate().getFullYear();
                if(pickerMinYear < minYear || pickerMaxYear > maxYear) {
                    return true;
                }
                return false;
            };
            wijinputdate.prototype._isDropDownButtonShown = function () {
                return this.options.showDropDownButton;
            };
            wijinputdate.prototype._isCalendarPickerShown = function () {
                return (this.options.pickers.calendar != undefined && this.options.pickers.calendar.visible !== false) || this._getPickerCount() == 0;
            };
            wijinputdate.prototype._isListPickerShown = function () {
                var comboItems = this._getcomboItems();
                if(comboItems != undefined && comboItems.length != undefined) {
                    return comboItems.length > 0;
                }
                return false;
            };
            wijinputdate.prototype._isTimePickerShown = function () {
                return this.options.pickers.timePicker != undefined && this.options.pickers.timePicker.visible !== false;
            };
            wijinputdate.prototype._isDatePickerShown = function () {
                return this.options.pickers.datePicker != undefined && this.options.pickers.datePicker.visible !== false;
            };
            wijinputdate.prototype._getPickerCount = function () {
                var count = 0;
                var calendarVisible = this.options.pickers.calendar != undefined && this.options.pickers.calendar.visible !== false;
                count += calendarVisible ? 1 : 0;
                count += this._isListPickerShown() ? 1 : 0;
                count += this._isTimePickerShown() ? 1 : 0;
                count += this._isDatePickerShown() ? 1 : 0;
                return count;
            };
            wijinputdate.prototype._addPickerEditor = function (pickerDiv, picker, pickerName) {
                var div = $("<div/>").attr({
                    "id": pickerName,
                    "align": "center"
                }).css({
                    "padding": "0px"
                }).append(picker).appendTo(pickerDiv);
            };
            wijinputdate.prototype._addPickerTab = function (ul, tab, href) {
                var li = $("<li/>").appendTo(ul).css("line-height", "1px");
                var a = $("<a/>").attr("href", href).html(tab).appendTo(li);
            };
            wijinputdate.prototype._internalSetDate = function (date) {
                var self = this, o = this.options, inputElement = this.element, typing = !!inputElement.data('typing'), chkBounds;
                if(typing) {
                    o.date = date;
                    chkBounds = function () {
                        var now = new Date(), lastTime = inputElement.data('timeStamp');
                        if(lastTime) {
                            if((now.getTime() - lastTime.getTime()) > o.keyDelay) {
                                self._safeSetDate(o.date, true);
                                self._updateText();
                                self._highLightField();
                            } else {
                                window.setTimeout(chkBounds, o.keyDelay);
                            }
                        }
                    };
                    window.setTimeout(chkBounds, o.keyDelay);
                } else {
                    this._safeSetDate(date);
                }
            };
            wijinputdate.prototype.selectText = /** Selects a range of text in the widget.
            * @param {Number} start Start of the range.
            * @param {Number} end End of the range.
            * @example
            * // Select first two symbols in a wijinputdate
            * $(".selector").wijinputdate("selectText", 0, 2);
            */
            function (start, end) {
                if (typeof start === "undefined") { start = 0; }
                if (typeof end === "undefined") { end = this.getText().length; }
                if(this.isFocused()) {
                    _super.prototype.selectText.call(this, start, end);
                } else {
                    this.element.data('IsInSelectTextMethod', true);
                    this.focus();
                    var obj = this;
                    setTimeout(function () {
                        try  {
                            obj.selectText(start, end);
                        } catch (e) {
                        }
                    }, 0);
                    this.element.data('IsInSelectTextMethod', false);
                }
            };
            return wijinputdate;
        })(input.wijinputcore);
        input.wijinputdate = wijinputdate;        
        var wijinputdate_options = (function () {
            function wijinputdate_options() {
                this.wijCSS = {
                    wijinputdate: input.wijinputcore.prototype.options.wijCSS.wijinput + "-date"
                };
                /** Determines the initial date value shown for the wijdateinput widget.
                */
                this.date = undefined;
                /** Determines the earliest, or minimum, date that can be entered.
                */
                this.minDate = null;
                /** Determines the latest, or maximum date, that can be entered.
                */
                this.maxDate = null;
                /** The format pattern to display the date value when control got focus.
                *
                * @remarks
                * wijinputdate supports two types of formats:  <br />
                * Standard Format and Custom Format. <br />
                * <br />
                * A standard date and time format string uses a single format specifier  <br />
                * to define the text representation of a date and time value. <br />
                * <br />
                * Possible values for Standard Format are: <br />
                * "d": ShortDatePattern <br />
                * "D": LongDatePattern <br />
                * "f": Full date and time (long date and short time)  <br />
                * "F": FullDateTimePattern  <br />
                * "g": General (short date and short time)  <br />
                * "G": General (short date and long time)  <br />
                * "m": MonthDayPattern  <br />
                * "M": monthDayPattern  <br />
                * "r": RFC1123Pattern   <br />
                * "R": RFC1123Pattern   <br />
                * "s": SortableDateTimePattern   <br />
                * "t": shortTimePattern   <br />
                * "T": LongTimePattern   <br />
                * "u": UniversalSortableDateTimePattern  <br />
                * "U": Full date and time (long date and long time) using universal time  <br />
                * "y": YearMonthPattern   <br />
                * "Y": yearMonthPattern   <br />
                *
                * Any date and time format string that contains more than one character,  <br/>
                * including white space, is interpreted as a custom date and time format
                * string. For example:    <br/>
                * "mmm-dd-yyyy", "mmmm d, yyyy", "mm/dd/yyyy", "d-mmm-yyyy",
                * "ddd, mmmm dd, yyyy" etc.   <br/>
                *
                * Below are the custom date and time format specifiers:  <br/>
                *   <br/>
                * "d": The day of the month, from 1 through 31.   <br />
                * "dd": The day of the month, from 01 through 31.  <br />
                * "ddd": The abbreviated name of the day of the week.  <br />
                * "dddd": The full name of the day of the week.   <br />
                * "m": The minute, from 0 through 59.   <br />
                * "mm": The minute, from 00 through 59.  <br />
                * "M": The month, from 1 through 12.  <br />
                * "MM": The month, from 01 through 12.  <br />
                * "MMM": The abbreviated name of the month.  <br />
                * "MMMM": The full name of the month.  <br />
                * "y": The year, from 0 to 99.   <br />
                * "yy": The year, from 00 to 99   <br />
                * "yyy": The year, with a minimum of three digits.  <br />
                * "yyyy": The year as a four-digit number   <br />
                * "h": The hour, using a 12-hour clock from 1 to 12.   <br />
                * "hh": The hour, using a 12-hour clock from 01 to 12.   <br />
                * "H": The hour, using a 24-hour clock from 0 to 23.   <br />
                * "HH": The hour, using a 24-hour clock from 00 to 23.  <br />
                * "s": The second, from 0 through 59.   <br />
                * "ss": The second, from 00 through 59.   <br />
                * "t": The first character of the AM/PM designator.   <br />
                * "tt": The AM/PM designator.    <br />
                */
                this.dateFormat = 'd';
                /** The format pattern to display the date value when control lost focus.
                *
                * @remarks
                * wijinputdate supports two types of formats:   <br />
                * Standard Format and Custom Format.   <br />
                * <br />
                * A standard date and time format string uses a single format specifier <br />
                * to define the text representation of a date and time value.   <br />
                *
                * Possible values for Standard Format are:  <br />
                * "d": ShortDatePattern  <br />
                * "D": LongDatePattern  <br />
                * "f": Full date and time (long date and short time) <br />
                * "F": FullDateTimePattern  <br />
                * "g": General (short date and short time)  <br />
                * "G": General (short date and long time)  <br />
                * "m": MonthDayPattern   <br />
                * "M": monthDayPattern  <br />
                * "r": RFC1123Pattern   <br />
                * "R": RFC1123Pattern   <br />
                * "s": SortableDateTimePattern  <br />
                * "t": shortTimePattern  <br />
                * "T": LongTimePattern   <br />
                * "u": UniversalSortableDateTimePattern  <br />
                * "U": Full date and time (long date and long time) using universal time   <br />
                * "y": YearMonthPattern  <br />
                * "Y": yearMonthPattern  <br />
                *
                * Any date and time format string that contains more than one character, <br />
                * including white space, is interpreted as a custom date and time format   <br />
                * string. For example: <br />
                * "mmm-dd-yyyy", "mmmm d, yyyy", "mm/dd/yyyy", "d-mmm-yyyy",
                * "ddd, mmmm dd, yyyy" etc.  <br />
                *
                * Below are the custom date and time format specifiers:  <br />
                *
                * "d": The day of the month, from 1 through 31.   <br />
                * "dd": The day of the month, from 01 through 31.   <br />
                * "ddd": The abbreviated name of the day of the week.  <br />
                * "dddd": The full name of the day of the week.  <br />
                * "m": The minute, from 0 through 59.   <br />
                * "mm": The minute, from 00 through 59.  <br />
                * "M": The month, from 1 through 12.  <br />
                * "MM": The month, from 01 through 12.   <br />
                * "MMM": The abbreviated name of the month.  <br />
                * "MMMM": The full name of the month. <br />
                * "y": The year, from 0 to 99.  <br />
                * "yy": The year, from 00 to 99  <br />
                * "yyy": The year, with a minimum of three digits.  <br />
                * "yyyy": The year as a four-digit number  <br />
                * "h": The hour, using a 12-hour clock from 1 to 12.  <br />
                * "hh": The hour, using a 12-hour clock from 01 to 12.  <br />
                * "H": The hour, using a 24-hour clock from 0 to 23.   <br />
                * "HH": The hour, using a 24-hour clock from 00 to 23.  <br />
                * "s": The second, from 0 through 59.   <br />
                * "ss": The second, from 00 through 59.  <br />
                * "t": The first character of the AM/PM designator.  <br />
                * "tt": The AM/PM designator.    <br />
                * "E": Display the nengo year as a single digit number when possible (first year use Japanese name).  <br />
                */
                this.displayFormat = '';
                /** Determines string designator for hours that are "ante meridiem" (before noon).
                * @remarks
                * The Text set in the amDesignator option is displayed in the position occupied by the keywords "tt" and "t"
                * in the dateFormat or dipslayFormat.  <br />
                * If the custom pattern includes the format pattern "tt" and the time is before noon,
                * the value of amDesignator is displayed in place of the "tt" in the dateFormat or displayFormat pattern.   <br />
                * If the custom pattern includes the format pattern "t", only the first character of amDesignator is displayed.   <br />
                * If setting "tt" in format and not setting amDesignator/pmDesignator options,
                * it will show the string getting from the specified culture.    <br />
                * If not set, it will show ""/"" in Japanese culture and "AM"/"PM" in English culture.   <br />
                * If setting "t" in format and not setting amDesignator/pmDesignator options, it will show the string getting from current culture.  <br />
                * If not set, it will display "" in Japanese culture and "A"/"P" in English culture.  <br />
                */
                this.amDesignator = "";
                /** Determines the string designator for hours that are "post meridiem" (after noon).
                * @remarks
                * The Text set in the amDesignator option is displayed in the position occupied by the keywords "tt" and "t"
                * in the dateFormat or dipslayFormat.  <br />
                * If the custom pattern includes the format pattern "tt" and the time is after noon,
                * the value of pmDesignator is displayed in place of the "tt" in the dateFormat or displayFormat pattern.   <br />
                * If the custom pattern includes the format pattern "t", only the first character of pmDesignator is displayed.   <br />
                * If setting "tt" in format and not setting amDesignator/pmDesignator options,
                * it will show the string getting from the specified culture.    <br />
                * If not set, it will show ""/"" in Japanese culture and "AM"/"PM" in English culture.   <br />
                * If setting "t" in format and not setting amDesignator/pmDesignator options, it will show the string getting from current culture.  <br />
                * If not set, it will display "" in Japanese culture and "A"/"P" in English culture.  <br />
                */
                this.pmDesignator = "";
                /** A bool value determines whether to express midnight as 24:00.
                */
                this.midnightAs0 = true;
                /** A bool value determines the range of hours that can be entered in the control.
                * @remarks
                * If set this property to false,
                * the control sets the range for the hour field from 1 - 12.  If set to true
                * the range is set to 0 - 11.
                */
                this.hour12As0 = false;
                /** Determins whether or not the next control in the tab order receives
                * the focus as soon as the control is filled at the last character.
                */
                this.blurOnLastChar = false;
                /** Gets or set whether the focus automatically moves to the next or previous
                * tab ordering control when pressing the left, right arrow keys.
                */
                this.blurOnLeftRightKey = "none";
                /** Gets or sets whether the tab key moves the focus between controls or between
                * fields within the control, possible values is "field", "control".
                * @remarks
                * The caret moves to the next field when this property is "field".
                * If the caret is in the last field, the input focus leaves this control when pressing the TAB key.
                * If the value is "control", the behavior is similar to the standard control.
                */
                this.tabAction = "field";
                /** Determines how the control should interpret 2-digits year inputted in year field.
                * when the "smartInputMode" option is set to true.
                * @remarks
                * For example, if "startYear" is set to 1950 (the default value), and "smartInputMode" is true.   <br />
                * Enter 2-digit year value which is greater than 50 [e.g., 88]  <br />
                * 1988 displays in year part.  <br />
                * Enter 2-digit year value which is less than 50 [e.g., 12]  <br />
                * 2012 displays in year part.  <br />
                */
                this.startYear = 1950;
                /** Determines whether the control should interpret 2-digits year inputted in year field.
                * using the value provided in the "startYear" option.
                * @remarks
                * For example, when "smartInputMode" is false (the default value), and "startYear" is 1950. <br />
                * Enter 2-digit year value which is greater than 50 [e.g., 88]  <br />
                * 0088 displays in year part.    <br />
                * Enter 2-digit year value which is less than 50 [e.g., 12]  <br />
                * 0012 displays in year part.  <br />
                * Set "smartInputMode" to true.  <br />
                * Enter 2-digit year value which is greater than 50 [e.g., 88]  <br />
                * 1988 displays in year part when smartInputMode is true.   <br />
                * Enter 2-digit year value which is less than 50 [e.g., 12]  <br />
                * 2012 displays in year part. <br />
                */
                this.smartInputMode = false;
                /** Determines the active field index.
                */
                this.activeField = 0;
                /** Determines the time span, in milliseconds,
                * between two input intentions.
                * @remarks
                * when press a keyboard, and the widget will delay a time and then handle
                * the next keyboard press. Use this option to control the speed of the key press.
                */
                this.keyDelay = 800;
                /** Determines whether to automatically moves to the next field.
                * @remarks
                * For example, if user want input the '2012-9-20' in inputdate widget,
                * if this option's value is true, when user type '2012' in textbox,
                * it will auto focus in next field, user can type '9' in second field,
                * if this option's value is false, user want to type '9' in second field,
                * they should focus the second field by manual.
                */
                this.autoNextField = true;
                /** This option will supply an element to init the calendar widget
                * @ignore
                * @remarks
                * If the value is 'default', the widget will create a div and
                * append it to body element, and using this element to init calendar.
                * User can set this option value to an element,
                * and the widget will init the calendar using this element.
                */
                this.calendar = 'default';
                /** Detemines the popup position of a calendar.
                * See jQuery.ui.position for position options.
                * @example
                * // In the following example, the Y offset between the popup position and wijinputdate is 10 pixel.
                * $("#textbox1").wijinputdate({
                *     popupPosition: { offset: '0 10' },
                *     comboItems: [{ label: "first Day", value: new Date(2013, 1, 1) },
                *         { label: "second day", value: new Date(2013, 3, 3) },
                *         { label: "third day", value: new Date(2013, 4, 5) }]
                * });
                */
                this.popupPosition = {
                    offset: '0 4'
                };
                /** Gets or sets whether to highlight the control's Text on receiving input focus.
                * possible values is "field", "all" .
                * @example
                * $("#textbox1").wijinputdate({
                *     highlightText: "field"
                * });
                */
                this.highlightText = "field";
                /** Determines how much to increase/decrease the active field when performing spin on the the active field.
                * @example
                * $("#textbox1").wijinputdate({
                *     increment: 2
                * });
                */
                this.increment = 1;
                /** Determines the input method setting of widget.
                * Possible values are: 'auto', 'active', 'inactive', 'disabled'
                * @remarks
                * This property only take effect on IE and firefox browser.
                */
                this.imeMode = "auto";
                /** Determines whether dropdown button is displayed.
                */
                this.showDropDownButton = true;
                /** Determines whether dropdown button is displayed.
                */
                this.showTrigger = undefined;
                /** An object contains the settings for the dropdown list.
                * @example
                * //  The following code show the dropdown calendar, dropdown list,
                * //  and set the dorpdown window's width to 100px, height to 30px;
                * $(".selector").wijinputdate({
                *     pickers: {
                *         calendar: {},
                *         list: [{ label: 'item1', value: 1 }],
                *         width: 100,
                *         height: 30
                *     }
                * });
                *
                * // The following code show the dropdown date picker and dropdown time picker,
                * // also it sets the time picker's format ot "hh hh:mm".
                * $(".selector").wijinputdate({
                *     pickers: {
                *         datePicker: {},
                *         timePicker: { format: "tt hh:mm" }
                *     }
                * });
                *
                * // The following code shows the drpdown date picker and dropdown time picker.
                * // also it sets the date picker's format to "yyyy/MMMM/dd".
                * $(".selector").wijinputdate({
                *     pickers: {
                *         datePicker: { format: "yyyy/MMMM/dd" },
                *         timePicker: {}
                *     }
                * });
                */
                this.pickers = {
                    list: undefined,
                    width: undefined,
                    height: undefined,
                    calendar: undefined,
                    datePicker: undefined,
                    timePicker: undefined
                };
                /** The dateChanged event handler.
                * A function called when the date of the input is changed.
                * @event
                * @dataKey {Date} date The data with this event.
                */
                this.dateChanged = null;
                /** The spinUp event handler.
                * A function called when spin up event fired.
                * @event
                */
                this.spinUp = null;
                /** The spinDown event handler.
                * A function called when spin down event fired.
                * @event
                */
                this.spinDown = null;
                /** The valueBoundsExceeded event hander.
                * A function called when the valueBoundExceeded event fired.
                * @event
                */
                this.valueBoundsExceeded = null;
            }
            return wijinputdate_options;
        })();        
        wijinputdate.prototype.options = $.extend(true, {
        }, input.wijinputcore.prototype.options, new wijinputdate_options());
        $.wijmo.registerWidget("wijinputdate", wijinputdate.prototype);
        /** @ignore */
        var wijDateTextProvider = (function () {
            function wijDateTextProvider(inputWidget, format, displayFormat) {
                this.inputWidget = inputWidget;
                this._disableSmartInputMode = false;
                this.paddingZero = input.paddingZero;
                this.formatter = new input.wijDateTextFormatter(inputWidget, format, false);
                displayFormat = displayFormat == "" ? format : displayFormat;
                this.displayFormatter = new input.wijDateTextFormatter(inputWidget, displayFormat, true);
            }
            wijDateTextProvider.prototype.initialize = function () {
            };
            wijDateTextProvider.prototype.getFiledText = function (index) {
                var desc = this.formatter.fields[index];
                return desc.getText();
            };
            wijDateTextProvider.prototype.getFieldCount = function () {
                return this.formatter.fields.length;
            };
            wijDateTextProvider.prototype.getFieldRange = function (index) {
                if(index >= this.formatter.fields.length) {
                    index = this.formatter.fields.length - 1;
                }
                var desc = this.formatter.fields[index];
                return {
                    start: desc.startIndex,
                    end: desc.startIndex + desc.getText().length
                };
            };
            wijDateTextProvider.prototype.getAllRange = function () {
                return {
                    start: 0,
                    end: this.formatter.toString().length
                };
            };
            wijDateTextProvider.prototype.getCursorField = function (pos) {
                if(this.formatter.desPostions.length == 0) {
                    return 0;
                }
                pos = Math.min(pos, this.formatter.desPostions.length - 1);
                pos = Math.max(pos, 0);
                var desc = this.formatter.desPostions[pos].desc, i;
                if(desc.type === -1) {
                    i = $.inArray(desc, this.formatter.descriptors);
                    if(i > 0 && this.formatter.descriptors[i - 1].type !== -1) {
                        desc = this.formatter.descriptors[i - 1];
                    } else {
                        return -1;// liternal
                        
                    }
                }
                return $.inArray(desc, this.formatter.fields);
            };
            wijDateTextProvider.prototype.needToMove = function (index, pos, ch) {
                if(!this.inputWidget._isValidDate(this.inputWidget._safeGetDate(), true)) {
                    return false;
                }
                var desc = this.formatter.fields[index];
                switch(desc.type) {
                    case 72:
                    case 73:
                    case 74:
                        for(var i = 0; i < input.DateTimeInfo.GetEraCount(); i++) {
                            if((ch.toLowerCase() === input.DateTimeInfo.GetEraShortcuts()[i].toLowerCase()) || (ch.toLowerCase() === input.DateTimeInfo.GetEraShortNames()[i].toLowerCase()) || (ch.toLowerCase() === input.DateTimeInfo.GetEraAbbreviations()[i].toLowerCase()) || (ch.toLowerCase() === input.DateTimeInfo.GetEraNames()[i].toLowerCase())) {
                                return true;
                            }
                        }
                        return false;
                }
                var val = parseInt(ch, 10);
                if(pos === desc.maxLen) {
                    return true;
                }
                if(isNaN(val)) {
                    return false;
                }
                var lastInputChar = this.inputWidget.element.data("lastInputChar");
                switch(desc.type) {
                    case 10:
                        return (this._isSmartInputMode() && pos === 2);
                    case 20:
                    case 25:
                    case 45:
                    case 46: {
                        if(lastInputChar == "0" && val == 1) {
                            return true;
                        }
                        return val > 1;
                    }
                    case 47:
                    case 48: {
                        if(lastInputChar == "0" && val <= 2) {
                            return true;
                        }
                        return val > 2;
                    }
                    case 30:
                    case 31: {
                        if(lastInputChar == "0" && val <= 3) {
                            return true;
                        }
                        return val > 3;
                    }
                    case 50:
                    case 51:
                    case 60:
                    case 61: {
                        if(lastInputChar == "0" && val <= 6) {
                            return true;
                        }
                        return val > 6;
                    }
                    case 70:
                    case 71:
                        return false;
                }
                return false;
            };
            wijDateTextProvider.prototype._isEraFormatExist = function () {
                return this.formatter._isEraFormatExist();
            };
            wijDateTextProvider.prototype._getCulture = function () {
                return this.inputWidget._getCulture();
            };
            wijDateTextProvider.prototype._isDigitString = function (s) {
                s = $.trim(s);
                if(s.length === 0) {
                    return true;
                }
                var c = s.charAt(0), f, t;
                if(c === '+' || c === '-') {
                    s = s.substr(1);
                    s = $.trim(s);
                }
                if(s.length === 0) {
                    return true;
                }
                try  {
                    f = parseFloat(s);
                    t = f.toString();
                    return t === s;
                } catch (e) {
                    return false;
                }
            };
            wijDateTextProvider.prototype._setFormat = function (format) {
                return this.formatter._setFormat(format);
            };
            wijDateTextProvider.prototype._setDisplayFormat = function (displayFormat) {
                return this.displayFormatter._setFormat(displayFormat);
            };
            wijDateTextProvider.prototype._internalSetDate = function (date) {
                if(this.inputWidget) {
                    this.inputWidget._internalSetDate(date);
                }
            };
            wijDateTextProvider.prototype.toString = function () {
                if(this.inputWidget._isEraFormatExist()) {
                    if(this.inputWidget.options.date != null) {
                        var minDate = this.inputWidget._getRealEraMinDate();
                        var maxDate = this.inputWidget._getRealEraMaxDate();
                        if(this.inputWidget.options.date < minDate || this.inputWidget.options.date > maxDate) {
                            return "";
                        }
                    }
                }
                if(!this.inputWidget.isFocused()) {
                    if(this.inputWidget.isDateNull() && this.inputWidget._getInnerNullText() != null) {
                        return this.inputWidget._getInnerNullText();
                    } else {
                        return this.displayFormatter.toString();
                    }
                }
                return this.formatter.toString();
            };
            wijDateTextProvider.prototype.parseDate = function (str) {
                var date;
                //if (this.formatter.pattern === 'dddd' ||
                //    this.formatter.pattern === 'ddd' ||
                //    typeof str === 'object') {
                //    try {
                //        date = new Date(str);
                //        if (isNaN(date)) {
                //            date = new Date();
                //        }
                //    }
                //    catch (e) {
                //        date = new Date();
                //    }
                //} else {
                //    date = Globalize.parseDate(str, this.formatter.pattern, this._getCulture());
                //    if (!date) {
                //        date = this._tryParseDate(str, this.formatter.pattern);
                //    }
                //    if (!date) {
                //        date = null;
                //    }
                //}
                date = $.wijinputcore.parseDate(str, this.formatter.pattern, this._getCulture());
                return date;
            };
            wijDateTextProvider.prototype.setText = function (input) {
                var date = this.parseDate(input);
                if(date == null) {
                    this._internalSetDate(null);
                } else {
                    this._internalSetDate(new Date(date));
                }
                return true;
            };
            wijDateTextProvider.prototype.haveEnumParts = function () {
                return false;
            };
            wijDateTextProvider.prototype.removeLiterals = function (s) {
                s = '' + s + '';
                s = s.replace(new RegExp('[+]', 'g'), '');
                s = s.replace(new RegExp('[.]', 'g'), '');
                s = s.replace(new RegExp('[:]', 'g'), '');
                s = s.replace(new RegExp('[-]', 'g'), '');
                s = s.replace(new RegExp('[()=]', 'g'), '');
                return s;
            };
            wijDateTextProvider.prototype.getFirstDelimiterPos = function (aText, bText) {
                var i = 0, j = 0, ch1, ch2;
                while(i < bText.length && j < aText.length) {
                    ch1 = bText.charAt(i);
                    ch2 = aText.charAt(j);
                    if(ch1 === ch2) {
                        j++;
                    } else {
                        return j - 1;
                    }
                    i++;
                }
                return aText.length - 1;
            };
            wijDateTextProvider.prototype.isFieldSep = function (input, activeField) {
                var nextField = activeField++, desc;
                if(nextField < this.formatter.descriptors.length) {
                    desc = this.formatter.descriptors[nextField];
                    if(desc.type !== -1) {
                        return false;
                    }
                    return (input === desc.text);
                }
                return false;
            };
            wijDateTextProvider.prototype.getPositionType = function (pos) {
                var desPos = this.formatter.desPostions[pos];
                return desPos.desc.type;
            };
            wijDateTextProvider.prototype.addToField = function (input, activeField, pos) {
                var desc = this.formatter.fields[activeField], txt, resultObj, ret;
                txt = input;
                resultObj = {
                    val: input,
                    pos: 0,
                    offset: 0,
                    isreset: false
                };
                this.inputWidget.element.data('typing', true);
                ret = desc.setText(txt, ((input.length === 1) ? false : true), resultObj, this._isSmartInputMode());
                this.inputWidget.element.data('typing', false);
                return ret;
            };
            wijDateTextProvider.prototype.insertAt = function (strInput, position, rh) {
                if (typeof rh === "undefined") { rh = new input.wijInputResult(); }
                rh.testPosition = -1;
                var desPos, oldTxt, pos, txt, tryToExpandAtRight, result, tryToExpandAtLeft, curInsertTxt, resultObj, prevTextLength, posAdjustValue, altInsertText, newTextLength, diff, s, delimOrEndPos, delta;
                if(strInput.length === 1) {
                    desPos = this.formatter.desPostions[position];
                    if(desPos && desPos.desc.type === -1) {
                        if(desPos.text === strInput) {
                            rh.testPosition = position;
                            rh.hint = rh.characterEscaped;
                            return true;
                        }
                    }
                }
                oldTxt = strInput;
                pos = position;
                strInput = this.removeLiterals(strInput);
                txt = strInput;
                tryToExpandAtRight = false;
                tryToExpandAtLeft = false;
                if(pos > 0 && txt.length === 1) {
                    pos--;
                    position = pos;
                    desPos = this.formatter.desPostions[pos];
                    tryToExpandAtRight = true;
                    if(desPos && (desPos.desc.type === -1 || desPos.desc.getText().length !== 1)) {
                        position++;
                        pos++;
                        tryToExpandAtRight = false;
                    }
                }
                result = false;
                while(txt.length > 0 && pos < this.formatter.desPostions.length) {
                    desPos = this.formatter.desPostions[pos];
                    if(desPos.desc.type === -1) {
                        pos = pos + desPos.length;
                        continue;
                    }
                    if(desPos.desc.needAdjustInsertPos()) {
                        curInsertTxt = txt.substr(0, (desPos.length - desPos.pos));
                        curInsertTxt = desPos.text.slice(0, desPos.pos) + curInsertTxt + desPos.text.slice(desPos.pos + curInsertTxt.length, desPos.length);
                        if(tryToExpandAtRight) {
                            curInsertTxt = desPos.text + curInsertTxt;
                        }
                        if(tryToExpandAtLeft) {
                            curInsertTxt = curInsertTxt + desPos.text;
                        }
                        prevTextLength = desPos.desc.getText().length;
                        altInsertText = '';
                        try  {
                            if(strInput.length === 1) {
                                if(!desPos.pos) {
                                    altInsertText = strInput;
                                } else if(desPos.pos > 0) {
                                    altInsertText = curInsertTxt.substring(0, desPos.pos + 1);
                                }
                            }
                        } catch (e) {
                        }
                        if(prevTextLength === 1 && curInsertTxt.length > 1 && strInput.length === 1) {
                            if(desPos.desc.type === 31 || desPos.desc.type === 25) {
                                this._disableSmartInputMode = true;
                            }
                        }
                        resultObj = {
                            val: strInput,
                            pos: desPos.pos,
                            offset: 0,
                            isreset: false
                        };
                        result = desPos.desc.setText(curInsertTxt, ((strInput.length === 1) ? false : true), resultObj);
                        this._disableSmartInputMode = false;
                        if(!result && typeof (altInsertText) !== 'undefined' && altInsertText.length > 0 && (desPos.desc.type === 26 || desPos.desc.type === 27 || desPos.desc.type === 100 || desPos.desc.type === 101 || desPos.desc.type === 250 || desPos.desc.type === 251)) {
                            result = desPos.desc.setText(altInsertText, ((strInput.length === 1) ? false : true), resultObj);
                        }
                        if(result) {
                            rh.hint = rh.success;
                            rh.testPosition = pos + resultObj.offset;
                            if(strInput.length === 1) {
                                newTextLength = desPos.desc.getText().length;
                                posAdjustValue = desPos.pos;
                                if(desPos.pos > (newTextLength - 1)) {
                                    posAdjustValue = newTextLength;
                                }
                                diff = newTextLength - prevTextLength;
                                if(diff > 0 && desPos.pos === prevTextLength - 1) {
                                    posAdjustValue = newTextLength - 1;
                                }
                                s = this.toString();
                                rh.testPosition = desPos.desc.startIndex + posAdjustValue + resultObj.offset;
                            }
                            txt = txt.slice(desPos.length - desPos.pos, txt.length);
                        } else {
                            rh.hint = rh.invalidInput;
                            if(rh.testPosition !== -1) {
                                rh.testPosition = position;
                            }
                            if(desPos.desc.type !== -1 && strInput.length === 1) {
                                return false;
                            }
                        }
                        pos = pos + desPos.length;
                    } else {
                        delimOrEndPos = this.getFirstDelimiterPos(txt, oldTxt);
                        if(delimOrEndPos < 0) {
                            delimOrEndPos = 0;
                        }
                        curInsertTxt = txt.substring(0, delimOrEndPos + 1);
                        resultObj = {
                            val: strInput,
                            pos: desPos.pos,
                            offset: 0,
                            isreset: false
                        };
                        result = desPos.desc.setText(curInsertTxt, ((strInput.length === 1) ? false : true), resultObj);
                        if(result) {
                            rh.hint = rh.success;
                            rh.testPosition = pos + resultObj.offset;
                            txt = txt.slice(delimOrEndPos + 1, txt.length);
                        } else {
                            rh.hint = rh.invalidInput;
                            if(rh.testPosition !== -1) {
                                rh.testPosition = position;
                            }
                        }
                        if(delimOrEndPos < 0) {
                            delimOrEndPos = 0;
                        }
                        delta = delimOrEndPos + 1;
                        pos = pos + delta;
                    }
                }
                return result;
            };
            wijDateTextProvider.prototype.removeAt = function (start, end, rh, skipCheck) {
                try  {
                    var desPos = this.formatter.desPostions[start], curInsertTxt, pos, resultObj, result, widget = this.inputWidget, element = widget.element, dateLength = element.val().length;
                    if(dateLength === end + 1 && start === 0) {
                        widget.isDeleteAll = true;
                    }
                    if(desPos.desc.needAdjustInsertPos()) {
                        curInsertTxt = '0';
                        pos = start;
                        desPos.text = desPos.desc.getText();
                        curInsertTxt = desPos.text.slice(0, desPos.pos) + curInsertTxt + desPos.text.slice(desPos.pos + curInsertTxt.length, desPos.length);
                        if(desPos.desc.name === 'tt') {
                            curInsertTxt = "AM";
                        } else if(desPos.desc.name === 't') {
                            curInsertTxt = "A";
                        } else if(desPos.desc.formatString === 'ee') {
                            curInsertTxt = "01";
                        } else if(desPos.desc.formatString === 'e') {
                            curInsertTxt = "1";
                        }
                        resultObj = {
                            val: curInsertTxt,
                            pos: desPos.pos,
                            offset: 0,
                            isreset: true,
                            isfullreset: false
                        };
                        if((end - start + 1) >= desPos.length) {
                            resultObj.isfullreset = true;
                            start = start + desPos.length;
                            pos = start;
                        }
                        result = desPos.desc.setText(curInsertTxt, false, resultObj, this._isSmartInputMode());
                        if(result) {
                            rh.hint = rh.success;
                            rh.testPosition = pos;
                        } else {
                            rh.hint = rh.invalidInput;
                            if(rh.testPosition === -1) {
                                rh.testPosition = start;
                            }
                        }
                    }
                    if(start < end) {
                        this.removeAt(start + 1, end, rh);
                    }
                    return true;
                } catch (e) {
                    return false;
                }
            };
            wijDateTextProvider.prototype.incEnumPart = function () {
                var desc = this.formatter.fields[this.inputWidget.options.activeField];
                if(desc) {
                    desc.inc();
                }
                return true;
            };
            wijDateTextProvider.prototype.decEnumPart = function () {
                var desc = this.formatter.fields[this.inputWidget.options.activeField];
                if(desc) {
                    desc.dec();
                }
                return true;
            };
            wijDateTextProvider.prototype._isSmartInputMode = function () {
                if(this._disableSmartInputMode) {
                    return false;
                }
                if(this.inputWidget) {
                    return this.inputWidget.options.smartInputMode;
                }
                return true;
            };
            wijDateTextProvider.prototype._getInt = function (str, i, minlength, maxlength) {
                var x, token;
                for(x = maxlength; x >= minlength; x--) {
                    token = str.substring(i, i + x);
                    if(token.length < minlength) {
                        return null;
                    }
                    if($.wij.charValidator.isDigit(token)) {
                        return token;
                    }
                }
                return null;
            };
            wijDateTextProvider.prototype._tryParseDate = function (val, pattern) {
                var ci = this._getCulture().calendars, pattern2, sep, patterns, d;
                pattern = pattern || ci.standard.patterns.d;
                if(pattern) {
                    if(pattern.indexOf('MMM') === -1 && pattern.indexOf('MMMM') === -1) {
                        pattern = pattern.replace('MM', 'M');
                    }
                    pattern = pattern.replace('dd', 'd');
                    pattern = pattern.replace('tt', 'a');
                }
                pattern2 = pattern.replace('yyyy', 'yy');
                sep = ci.standard["/"];
                patterns = [
                    pattern, 
                    pattern2, 
                    pattern.replace(new RegExp(sep, 'g'), '-'), 
                    pattern2.replace(new RegExp(sep, 'g'), '-'), 
                    pattern.replace(new RegExp(sep, 'g'), '.'), 
                    pattern2.replace(new RegExp(sep, 'g'), '.')
                ];
                d = Globalize.parseDate(val, patterns, this._getCulture());
                if(d) {
                    return d;
                }
                // if the val is datetime string,
                // parse the string to datetime. added by dail 2012-6-25
                d = new Date(val);
                if(d.toString() !== "Invalid Date" && val && val !== "") {
                    return d;
                }
                return 0;
            };
            wijDateTextProvider.prototype._formatDate = function (date, format, culture) {
                var _this = this;
                if(!(date.valueOf())) {
                    return '&nbsp;';
                }
                var cf = this.inputWidget._getCulture().calendars.standard, sRes = format.replace(new RegExp('yyyy|MMMM|MMM|MM|M|mm|m|dddd|ddd|dd|d|hh|h|HH|H|ss|s|tt|t|a/p', 'gi'), function (match) {
                    var h;
                    switch(match) {
                        case 'yyyy':
                            return input.paddingZero(date.getFullYear(), 4);
                        case 'MMMM':
                            return culture.dateTimeFormat.monthNames[date.getMonth()];
                        case 'MMM':
                            return culture.dateTimeFormat.abbreviatedMonthNames[date.getMonth()];
                        case 'MM':
                            return _this.paddingZero((date.getMonth() + 1), 2);
                        case 'M':
                            return _this.paddingZero((date.getMonth() + 1), 1);
                        case 'mm':
                            return _this.paddingZero(date.getMinutes(), 2);
                        case 'm':
                            return _this.paddingZero(date.getMinutes(), 1);
                        case 'dddd':
                            return culture.dateTimeFormat.dayNames[date.getDay()];
                        case 'ddd':
                            return culture.dateTimeFormat.abbreviatedDayNames[date.getDay()];
                        case 'dd':
                            return _this.paddingZero(date.getDate(), 2);
                        case 'd':
                            return _this.paddingZero(date.getDate(), 1);
                        case 'hh':
                            h = date.getHours() % 12;
                            return _this.paddingZero(((h) ? h : 12), 2);
                        case 'h':
                            h = date.getHours() % 12;
                            return _this.paddingZero(((h) ? h : 12), 1);
                        case 'HH':
                            return _this.paddingZero(date.getHours(), 2);
                        case 'H':
                            return _this.paddingZero(date.getHours(), 1);
                        case 'ss':
                            return _this.paddingZero(date.getSeconds(), 2);
                        case 's':
                            return _this.paddingZero(date.getSeconds(), 1);
                        case 'tt':
                            return (date.getHours() < 12) ? cf.AM[0] : cf.PM[0];
                        case 't':
                            return (date.getHours() < 12) ? ((cf.AM[0].length > 0) ? cf.AM[0].charAt(0) : '') : ((cf.PM[0].length > 0) ? cf.PM[0].charAt(0) : '');
                        case 'a/p':
                            return (date.getHours() < 12) ? 'a' : 'p';
                    }
                    return 'N';
                });
                return sRes;
            };
            wijDateTextProvider.prototype.replaceWith = function (range, text) {
                var index = range.start;
                var result = new input.wijInputResult();
                if(range.start < range.end) {
                    this.removeAt(range.start, range.end - 1, result, true);
                    index = result.testPosition;
                }
                return this.insertAt(text, index, result) ? result : null;
            };
            return wijDateTextProvider;
        })();
        input.wijDateTextProvider = wijDateTextProvider;        
        ;
    })(wijmo.input || (wijmo.input = {}));
    var input = wijmo.input;
})(wijmo || (wijmo = {}));
